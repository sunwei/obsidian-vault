/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};

// node_modules/@mdfriday/foundry/dist/internal/domain/config/type.js
var require_type = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrInvalidConfigFormat = exports2.ErrConfigFileNotFound = exports2.ErrWorkspaceNotFound = exports2.ErrInvalidConfig = exports2.ErrConfigNotFound = exports2.ConfigError = void 0;
    var ConfigError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        this.name = "ConfigError";
      }
    };
    exports2.ConfigError = ConfigError;
    exports2.ErrConfigNotFound = new ConfigError("configuration not found", "CONFIG_NOT_FOUND");
    exports2.ErrInvalidConfig = new ConfigError("invalid configuration", "INVALID_CONFIG");
    exports2.ErrWorkspaceNotFound = new ConfigError("workspace not found", "WORKSPACE_NOT_FOUND");
    exports2.ErrConfigFileNotFound = new ConfigError("configuration file not found", "CONFIG_FILE_NOT_FOUND");
    exports2.ErrInvalidConfigFormat = new ConfigError("invalid configuration format", "INVALID_CONFIG_FORMAT");
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/config.js
var require_config = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Config = void 0;
    exports2.newConfig = newConfig;
    var Config = class {
      constructor(configSourceFs, provider, root, dir, module3, service, language, taxonomy) {
        this.configSourceFs = configSourceFs;
        this.provider = provider;
        this.root = root;
        this.dir = dir;
        this.module = module3;
        this.service = service;
        this.language = language;
        this.taxonomy = taxonomy;
      }
      fs() {
        return this.configSourceFs;
      }
      getProvider() {
        return this.provider;
      }
      theme() {
        return this.root.defaultTheme();
      }
      getDir() {
        return this.dir;
      }
      getRoot() {
        return this.root;
      }
      getModule() {
        return this.module;
      }
      getService() {
        return this.service;
      }
      getLanguage() {
        return this.language;
      }
      getTaxonomy() {
        return this.taxonomy;
      }
      setLanguage(language) {
        this.language = language;
      }
      setTaxonomy(taxonomy) {
        this.taxonomy = taxonomy;
      }
      validate() {
        let valid = true;
        if (this.language) {
          valid = valid && this.language.validate();
        }
        return valid;
      }
    };
    exports2.Config = Config;
    function newConfig(configSourceFs, provider, root, dir, module3, service, language, taxonomy) {
      return new Config(configSourceFs, provider, root, dir, module3, service, language, taxonomy);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/root.js
var require_root = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/root.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultRootConfig = void 0;
    exports2.decodeRootConfig = decodeRootConfig;
    exports2.DefaultRootConfig = {
      baseURL: "",
      title: "",
      theme: [],
      timeout: "30s",
      contentDir: "content",
      dataDir: "data",
      layoutDir: "layouts",
      staticDir: "static",
      archetypeDir: "archetypes",
      assetDir: "assets",
      publishDir: "public",
      buildDrafts: false,
      buildExpired: false,
      buildFuture: false,
      copyright: "",
      defaultContentLanguage: "en",
      defaultContentLanguageInSubdir: false,
      disableAliases: false,
      disablePathToLower: false,
      disableKinds: [],
      disableLanguages: [],
      renderSegments: [],
      disableHugoGeneratorInject: false,
      disableLiveReload: false,
      enableEmoji: false
    };
    function decodeRootConfig(data) {
      return {
        baseURL: data.baseURL || exports2.DefaultRootConfig.baseURL,
        title: data.title || exports2.DefaultRootConfig.title,
        theme: data.theme || exports2.DefaultRootConfig.theme,
        timeout: data.timeout || exports2.DefaultRootConfig.timeout,
        contentDir: data.contentDir || exports2.DefaultRootConfig.contentDir,
        dataDir: data.dataDir || exports2.DefaultRootConfig.dataDir,
        layoutDir: data.layoutDir || exports2.DefaultRootConfig.layoutDir,
        staticDir: data.staticDir || exports2.DefaultRootConfig.staticDir,
        archetypeDir: data.archetypeDir || exports2.DefaultRootConfig.archetypeDir,
        assetDir: data.assetDir || exports2.DefaultRootConfig.assetDir,
        publishDir: data.publishDir || exports2.DefaultRootConfig.publishDir,
        buildDrafts: data.buildDrafts !== void 0 ? data.buildDrafts : exports2.DefaultRootConfig.buildDrafts,
        buildExpired: data.buildExpired !== void 0 ? data.buildExpired : exports2.DefaultRootConfig.buildExpired,
        buildFuture: data.buildFuture !== void 0 ? data.buildFuture : exports2.DefaultRootConfig.buildFuture,
        copyright: data.copyright || exports2.DefaultRootConfig.copyright,
        defaultContentLanguage: data.defaultContentLanguage || exports2.DefaultRootConfig.defaultContentLanguage,
        defaultContentLanguageInSubdir: data.defaultContentLanguageInSubdir !== void 0 ? data.defaultContentLanguageInSubdir : exports2.DefaultRootConfig.defaultContentLanguageInSubdir,
        disableAliases: data.disableAliases !== void 0 ? data.disableAliases : exports2.DefaultRootConfig.disableAliases,
        disablePathToLower: data.disablePathToLower !== void 0 ? data.disablePathToLower : exports2.DefaultRootConfig.disablePathToLower,
        disableKinds: data.disableKinds || exports2.DefaultRootConfig.disableKinds,
        disableLanguages: data.disableLanguages || exports2.DefaultRootConfig.disableLanguages,
        renderSegments: data.renderSegments || exports2.DefaultRootConfig.renderSegments,
        disableHugoGeneratorInject: data.disableHugoGeneratorInject !== void 0 ? data.disableHugoGeneratorInject : exports2.DefaultRootConfig.disableHugoGeneratorInject,
        disableLiveReload: data.disableLiveReload !== void 0 ? data.disableLiveReload : exports2.DefaultRootConfig.disableLiveReload,
        enableEmoji: data.enableEmoji !== void 0 ? data.enableEmoji : exports2.DefaultRootConfig.enableEmoji
      };
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/root.js
var require_root2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/root.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Root = void 0;
    exports2.newRoot = newRoot;
    var root_1 = require_root();
    var Root = class {
      constructor(rootConfig, rootParams = {}) {
        this.rootConfig = rootConfig;
        this.rootParams = rootParams;
      }
      defaultTheme() {
        return this.rootConfig.theme.length > 0 ? this.rootConfig.theme[0] : "";
      }
      compiledTimeout() {
        const timeout = this.rootConfig.timeout;
        if (/^\d+$/.test(timeout)) {
          return parseInt(timeout, 10) * 1e3;
        }
        const match = timeout.match(/^(\d+)([smh])$/);
        if (match) {
          const value2 = parseInt(match[1], 10);
          const unit = match[2];
          switch (unit) {
            case "s":
              return value2 * 1e3;
            case "m":
              return value2 * 60 * 1e3;
            case "h":
              return value2 * 60 * 60 * 1e3;
          }
        }
        return 3e4;
      }
      baseUrl() {
        return this.rootConfig.baseURL;
      }
      configParams() {
        return this.rootParams;
      }
      siteTitle() {
        return this.rootConfig.title;
      }
      getRootConfig() {
        return this.rootConfig;
      }
      getThemes() {
        return this.rootConfig.theme;
      }
      getDefaultContentLanguage() {
        return this.rootConfig.defaultContentLanguage;
      }
      shouldBuildDrafts() {
        return this.rootConfig.buildDrafts;
      }
      shouldBuildFuture() {
        return this.rootConfig.buildFuture;
      }
      shouldBuildExpired() {
        return this.rootConfig.buildExpired;
      }
    };
    exports2.Root = Root;
    function newRoot(data, params = {}) {
      const rootConfig = (0, root_1.decodeRootConfig)(data);
      return new Root(rootConfig, params);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/module.js
var require_module = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyModuleConfig = void 0;
    exports2.decodeModuleConfig = decodeModuleConfig;
    exports2.isEmptyModuleConfig = isEmptyModuleConfig;
    exports2.EmptyModuleConfig = {
      mounts: [],
      imports: []
    };
    function decodeModuleConfig(data) {
      const config = {
        mounts: [],
        imports: []
      };
      if (data.mounts && Array.isArray(data.mounts)) {
        config.mounts = data.mounts.map((mount) => ({
          source: mount.source || "",
          target: mount.target || "",
          lang: mount.lang
        }));
      }
      if (data.imports && Array.isArray(data.imports)) {
        config.imports = data.imports.map((imp) => ({
          path: imp.path || "",
          url: imp.url,
          version: imp.version,
          mounts: imp.mounts || []
        }));
      }
      return config;
    }
    function isEmptyModuleConfig(config) {
      return config.mounts.length === 0 && config.imports.length === 0;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/module.js
var require_module2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Module = void 0;
    exports2.newModule = newModule;
    var module_1 = require_module();
    var Module = class {
      constructor(moduleConfig) {
        this.moduleConfig = moduleConfig;
      }
      importPaths() {
        return this.moduleConfig.imports.map((imp) => imp.path);
      }
      getModuleConfig() {
        return this.moduleConfig;
      }
      getImports() {
        return this.moduleConfig.imports;
      }
      getMounts() {
        return this.moduleConfig.mounts;
      }
      importCount() {
        return this.moduleConfig.imports.length;
      }
      mountCount() {
        return this.moduleConfig.mounts.length;
      }
      hasImports() {
        return this.moduleConfig.imports.length > 0;
      }
      hasMounts() {
        return this.moduleConfig.mounts.length > 0;
      }
      findImport(path6) {
        return this.moduleConfig.imports.find((imp) => imp.path === path6);
      }
      findMount(source) {
        return this.moduleConfig.mounts.find((mount) => mount.source === source);
      }
    };
    exports2.Module = Module;
    function newModule(data) {
      const moduleConfig = (0, module_1.decodeModuleConfig)(data);
      return new Module(moduleConfig);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/service.js
var require_service = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultServiceConfig = void 0;
    exports2.decodeServiceConfig = decodeServiceConfig;
    exports2.DefaultServiceConfig = {
      disqus: {
        disable: false,
        shortname: ""
      },
      googleAnalytics: {
        disable: false,
        respectDoNotTrack: false,
        id: ""
      },
      rss: {
        limit: 0
      },
      x: {
        respectDoNotTrack: false,
        disableInlineCSS: false
      }
    };
    function decodeServiceConfig(services) {
      const config = {
        disqus: { ...exports2.DefaultServiceConfig.disqus },
        googleAnalytics: { ...exports2.DefaultServiceConfig.googleAnalytics },
        rss: { ...exports2.DefaultServiceConfig.rss },
        x: { ...exports2.DefaultServiceConfig.x }
      };
      if (services) {
        if (services.disqus) {
          config.disqus.shortname = services.disqus.shortname || config.disqus.shortname;
        }
        if (services.googleAnalytics) {
          config.googleAnalytics.id = services.googleAnalytics.id || config.googleAnalytics.id;
        }
        if (services.rss) {
          config.rss.limit = services.rss.limit !== void 0 ? services.rss.limit : config.rss.limit;
        }
      }
      return config;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/service.js
var require_service2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Service = void 0;
    exports2.newService = newService;
    var service_1 = require_service();
    var Service = class {
      constructor(serviceConfig) {
        this.serviceConfig = serviceConfig;
      }
      isGoogleAnalyticsEnabled() {
        return !this.serviceConfig.googleAnalytics.disable;
      }
      googleAnalyticsID() {
        return this.serviceConfig.googleAnalytics.id;
      }
      isGoogleAnalyticsRespectDoNotTrack() {
        return this.serviceConfig.googleAnalytics.respectDoNotTrack;
      }
      isDisqusEnabled() {
        return !this.serviceConfig.disqus.disable;
      }
      disqusShortname() {
        return this.serviceConfig.disqus.shortname;
      }
      isXRespectDoNotTrack() {
        return this.serviceConfig.x.respectDoNotTrack;
      }
      isXDisableInlineCSS() {
        return this.serviceConfig.x.disableInlineCSS;
      }
      rssLimit() {
        return this.serviceConfig.rss.limit;
      }
      getServiceConfig() {
        return this.serviceConfig;
      }
      getGoogleAnalytics() {
        return this.serviceConfig.googleAnalytics;
      }
      getDisqus() {
        return this.serviceConfig.disqus;
      }
      getRSS() {
        return this.serviceConfig.rss;
      }
      hasEnabledServices() {
        return this.isGoogleAnalyticsEnabled() || this.isDisqusEnabled();
      }
    };
    exports2.Service = Service;
    function newService(data) {
      const serviceConfig = (0, service_1.decodeServiceConfig)(data);
      return new Service(serviceConfig);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/lang/data.js
var require_data = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/lang/data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CODE_NAME_MAP = exports2.LANGUAGE_MAP = exports2.ALL_LANGUAGES = exports2.RTL_LANGUAGES = exports2.LTR_LANGUAGES = void 0;
    exports2.LTR_LANGUAGES = [
      {
        code: "en",
        name: "English",
        direction: "ltr",
        englishName: "English"
      },
      {
        code: "zh",
        name: "\u4E2D\u6587",
        direction: "ltr",
        englishName: "Chinese"
      },
      {
        code: "ja",
        name: "\u65E5\u672C\u8A9E",
        direction: "ltr",
        englishName: "Japanese"
      },
      {
        code: "ko",
        name: "\uD55C\uAD6D\uC5B4",
        direction: "ltr",
        englishName: "Korean"
      },
      {
        code: "fr",
        name: "Fran\xE7ais",
        direction: "ltr",
        englishName: "French"
      },
      {
        code: "de",
        name: "Deutsch",
        direction: "ltr",
        englishName: "German"
      },
      {
        code: "es",
        name: "Espa\xF1ol",
        direction: "ltr",
        englishName: "Spanish"
      },
      {
        code: "pt",
        name: "Portugu\xEAs",
        direction: "ltr",
        englishName: "Portuguese"
      },
      {
        code: "ru",
        name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
        direction: "ltr",
        englishName: "Russian"
      },
      {
        code: "hi",
        name: "\u0939\u093F\u0902\u0926\u0940",
        direction: "ltr",
        englishName: "Hindi"
      },
      {
        code: "it",
        name: "Italiano",
        direction: "ltr",
        englishName: "Italian"
      },
      {
        code: "nl",
        name: "Nederlands",
        direction: "ltr",
        englishName: "Dutch"
      },
      {
        code: "tr",
        name: "T\xFCrk\xE7e",
        direction: "ltr",
        englishName: "Turkish"
      },
      {
        code: "vi",
        name: "Ti\u1EBFng Vi\u1EC7t",
        direction: "ltr",
        englishName: "Vietnamese"
      },
      {
        code: "th",
        name: "\u0E44\u0E17\u0E22",
        direction: "ltr",
        englishName: "Thai"
      }
    ];
    exports2.RTL_LANGUAGES = [];
    exports2.ALL_LANGUAGES = [
      ...exports2.LTR_LANGUAGES,
      ...exports2.RTL_LANGUAGES
    ];
    exports2.LANGUAGE_MAP = exports2.ALL_LANGUAGES.reduce((map, lang) => {
      map[lang.code] = lang;
      return map;
    }, {});
    exports2.CODE_NAME_MAP = exports2.ALL_LANGUAGES.reduce((map, lang) => {
      map[lang.code] = lang.name;
      return map;
    }, {});
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/lang/service.js
var require_service3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/lang/service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultLanguageService = void 0;
    exports2.getLanguageService = getLanguageService;
    exports2.createLanguageService = createLanguageService;
    var data_1 = require_data();
    var DefaultLanguageService = class {
      getAllCodes() {
        return data_1.ALL_LANGUAGES.map((lang) => lang.code);
      }
      getAllNames() {
        return data_1.ALL_LANGUAGES.map((lang) => lang.name);
      }
      getCodesByDirection(direction) {
        const languages = direction === "ltr" ? data_1.LTR_LANGUAGES : data_1.RTL_LANGUAGES;
        return languages.map((lang) => lang.code);
      }
      getNamesByDirection(direction) {
        const languages = direction === "ltr" ? data_1.LTR_LANGUAGES : data_1.RTL_LANGUAGES;
        return languages.map((lang) => lang.name);
      }
      getCodeNameMap() {
        return { ...data_1.CODE_NAME_MAP };
      }
      getCodeNameMapByDirection(direction) {
        const languages = direction === "ltr" ? data_1.LTR_LANGUAGES : data_1.RTL_LANGUAGES;
        return languages.reduce((map, lang) => {
          map[lang.code] = lang.name;
          return map;
        }, {});
      }
      getNameByCode(code) {
        return data_1.LANGUAGE_MAP[code]?.name;
      }
      getLanguageInfo(code) {
        const info = data_1.LANGUAGE_MAP[code];
        return info ? { ...info } : void 0;
      }
      isSupported(code) {
        return code in data_1.LANGUAGE_MAP;
      }
      getDirection(code) {
        return data_1.LANGUAGE_MAP[code]?.direction;
      }
      isLTR(code) {
        return data_1.LANGUAGE_MAP[code]?.direction === "ltr";
      }
      isRTL(code) {
        return data_1.LANGUAGE_MAP[code]?.direction === "rtl";
      }
    };
    exports2.DefaultLanguageService = DefaultLanguageService;
    var serviceInstance = null;
    function getLanguageService() {
      if (!serviceInstance) {
        serviceInstance = new DefaultLanguageService();
      }
      return serviceInstance;
    }
    function createLanguageService() {
      return new DefaultLanguageService();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/lang/index.js
var require_lang = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/lang/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.languages = exports2.lang = exports2.createLanguageService = exports2.getLanguageService = exports2.DefaultLanguageService = exports2.CODE_NAME_MAP = exports2.LANGUAGE_MAP = exports2.ALL_LANGUAGES = exports2.RTL_LANGUAGES = exports2.LTR_LANGUAGES = void 0;
    var data_1 = require_data();
    Object.defineProperty(exports2, "LTR_LANGUAGES", { enumerable: true, get: function() {
      return data_1.LTR_LANGUAGES;
    } });
    Object.defineProperty(exports2, "RTL_LANGUAGES", { enumerable: true, get: function() {
      return data_1.RTL_LANGUAGES;
    } });
    Object.defineProperty(exports2, "ALL_LANGUAGES", { enumerable: true, get: function() {
      return data_1.ALL_LANGUAGES;
    } });
    Object.defineProperty(exports2, "LANGUAGE_MAP", { enumerable: true, get: function() {
      return data_1.LANGUAGE_MAP;
    } });
    Object.defineProperty(exports2, "CODE_NAME_MAP", { enumerable: true, get: function() {
      return data_1.CODE_NAME_MAP;
    } });
    var service_1 = require_service3();
    Object.defineProperty(exports2, "DefaultLanguageService", { enumerable: true, get: function() {
      return service_1.DefaultLanguageService;
    } });
    Object.defineProperty(exports2, "getLanguageService", { enumerable: true, get: function() {
      return service_1.getLanguageService;
    } });
    Object.defineProperty(exports2, "createLanguageService", { enumerable: true, get: function() {
      return service_1.createLanguageService;
    } });
    var service_2 = require_service3();
    exports2.lang = (0, service_2.getLanguageService)();
    exports2.languages = {
      getAllCodes: () => exports2.lang.getAllCodes(),
      getAllNames: () => exports2.lang.getAllNames(),
      getCodesByDirection: (direction) => exports2.lang.getCodesByDirection(direction),
      getNamesByDirection: (direction) => exports2.lang.getNamesByDirection(direction),
      getCodeNameMap: () => exports2.lang.getCodeNameMap(),
      getCodeNameMapByDirection: (direction) => exports2.lang.getCodeNameMapByDirection(direction),
      getNameByCode: (code) => exports2.lang.getNameByCode(code),
      getLanguageInfo: (code) => exports2.lang.getLanguageInfo(code),
      isSupported: (code) => exports2.lang.isSupported(code),
      getDirection: (code) => exports2.lang.getDirection(code),
      isLTR: (code) => exports2.lang.isLTR(code),
      isRTL: (code) => exports2.lang.isRTL(code)
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/language.js
var require_language = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultLanguageConfig = void 0;
    exports2.decodeLanguageConfig = decodeLanguageConfig;
    exports2.validateLanguageConfig = validateLanguageConfig;
    var lang_1 = require_lang();
    exports2.DefaultLanguageConfig = {
      languageCode: "en",
      languageName: "English",
      title: "",
      weight: 0,
      contentDir: "content",
      disabled: false,
      params: {}
    };
    function decodeLanguageConfig(data) {
      const configs = {};
      if (!data || Object.keys(data).length === 0) {
        configs["en"] = {
          ...exports2.DefaultLanguageConfig,
          title: data?.title || exports2.DefaultLanguageConfig.title,
          params: data?.params || exports2.DefaultLanguageConfig.params
        };
        return configs;
      }
      for (const [langCode, langData] of Object.entries(data)) {
        const langConfig = langData;
        const languageName = lang_1.languages.getNameByCode(langCode) || langCode;
        configs[langCode] = {
          languageCode: langCode,
          languageName,
          title: langConfig.title || data.title || "",
          weight: langConfig.weight !== void 0 ? langConfig.weight : 0,
          contentDir: langConfig.contentDir || "content",
          disabled: langConfig.disabled !== void 0 ? langConfig.disabled : false,
          params: langConfig.params || data.params || {}
        };
      }
      return configs;
    }
    function validateLanguageConfig(configs, defaultLang) {
      return Object.prototype.hasOwnProperty.call(configs, defaultLang);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/language.js
var require_language2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Language = void 0;
    exports2.newLanguage = newLanguage;
    var language_1 = require_language();
    var Language = class {
      constructor(configs) {
        this.configs = configs;
        this.defaultLang = this.calculateDefaultLanguage();
        this.indices = [];
        this.setIndices();
      }
      calculateDefaultLanguage() {
        if (Object.keys(this.configs).length === 0) {
          return "en";
        }
        let defaultLang = "";
        let minWeight = Number.MAX_SAFE_INTEGER;
        for (const [langCode, config] of Object.entries(this.configs)) {
          if (config.weight < minWeight) {
            minWeight = config.weight;
            defaultLang = langCode;
          }
        }
        return defaultLang || Object.keys(this.configs)[0];
      }
      languages() {
        return Object.values(this.configs);
      }
      defaultLanguage() {
        return this.defaultLang;
      }
      isLanguageValid(lang) {
        return Object.prototype.hasOwnProperty.call(this.configs, lang);
      }
      otherLanguageKeys() {
        return Object.keys(this.configs).filter((lang) => lang !== this.defaultLang);
      }
      getRelDir(name, langKey) {
        const config = this.configs[langKey];
        if (!config) {
          throw new Error(`Language "${langKey}" not found`);
        }
        return config.contentDir || "content";
      }
      validate() {
        return (0, language_1.validateLanguageConfig)(this.configs, this.defaultLang);
      }
      setIndices() {
        const languages = [];
        if (this.configs[this.defaultLang]) {
          languages.push(this.defaultLang);
        }
        for (const lang of Object.keys(this.configs)) {
          if (lang !== this.defaultLang) {
            languages.push(lang);
          }
        }
        this.indices = languages;
      }
      languageKeys() {
        return [...this.indices];
      }
      languageIndexes() {
        return this.indices.map((_, index) => index);
      }
      getLanguageIndex(lang) {
        const index = this.indices.indexOf(lang);
        if (index === -1) {
          throw new Error("Language not found in indices");
        }
        return index;
      }
      getLanguageByIndex(idx) {
        if (idx < 0 || idx >= this.indices.length) {
          throw new Error("Language index out of range");
        }
        return this.indices[idx];
      }
      getLanguageName(lang) {
        const config = this.configs[lang];
        return config ? config.languageName : "";
      }
      getLanguageConfig(lang) {
        return this.configs[lang];
      }
      getConfigs() {
        return this.configs;
      }
    };
    exports2.Language = Language;
    function newLanguage(data) {
      const configs = (0, language_1.decodeLanguageConfig)(data);
      return new Language(configs);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/taxonomy.js
var require_taxonomy = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/vo/taxonomy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTaxonomies = void 0;
    exports2.cleanTreeKey = cleanTreeKey;
    exports2.setupTaxonomyViews = setupTaxonomyViews;
    exports2.decodeTaxonomyConfig = decodeTaxonomyConfig;
    exports2.DefaultTaxonomies = {
      tag: "tags",
      category: "categories"
    };
    function cleanTreeKey(...elems) {
      let s = "";
      if (elems.length > 0) {
        s = elems[0];
        if (elems.length > 1) {
          s = elems.join("/");
        }
      }
      s = s.replace(/^[.\s/]+|[.\s/]+$/g, "");
      s = s.toLowerCase();
      s = s.replace(/\\/g, "/");
      if (s === "" || s === "/") {
        return "";
      }
      if (!s.startsWith("/")) {
        s = "/" + s;
      }
      return s;
    }
    function setupTaxonomyViews(taxonomies) {
      const views = [];
      for (const [singular, plural] of Object.entries(taxonomies)) {
        views.push({
          singular,
          plural,
          pluralTreeKey: cleanTreeKey(plural)
        });
      }
      views.sort((a, b) => a.plural.localeCompare(b.plural));
      return views;
    }
    function decodeTaxonomyConfig(data) {
      if (data.taxonomies && typeof data.taxonomies === "object") {
        const taxonomies = {};
        for (const [key, value2] of Object.entries(data.taxonomies)) {
          if (typeof value2 === "string") {
            taxonomies[key] = value2;
          }
        }
        return taxonomies;
      }
      return { ...exports2.DefaultTaxonomies };
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/taxonomy.js
var require_taxonomy2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/taxonomy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Taxonomy = void 0;
    exports2.newTaxonomy = newTaxonomy;
    var taxonomy_1 = require_taxonomy();
    var Taxonomy = class {
      constructor(taxonomies) {
        this.taxonomies = taxonomies;
        this.views = [];
        this.viewsByTreeKey = {};
        this.setupViews();
      }
      getViews() {
        return [...this.views];
      }
      getTaxonomies() {
        return { ...this.taxonomies };
      }
      getViewByTreeKey(treeKey) {
        return this.viewsByTreeKey[treeKey];
      }
      hasTaxonomy(singular) {
        return Object.prototype.hasOwnProperty.call(this.taxonomies, singular);
      }
      getPluralForm(singular) {
        return this.taxonomies[singular];
      }
      getSingularForm(plural) {
        for (const [singular, pluralForm] of Object.entries(this.taxonomies)) {
          if (pluralForm === plural) {
            return singular;
          }
        }
        return void 0;
      }
      getSingularForms() {
        return Object.keys(this.taxonomies);
      }
      getPluralForms() {
        return Object.values(this.taxonomies);
      }
      setupViews() {
        this.views = (0, taxonomy_1.setupTaxonomyViews)(this.taxonomies);
        this.viewsByTreeKey = {};
        for (const view of this.views) {
          this.viewsByTreeKey[view.pluralTreeKey] = view;
        }
      }
      getViewCount() {
        return this.views.length;
      }
      isEmpty() {
        return Object.keys(this.taxonomies).length === 0;
      }
    };
    exports2.Taxonomy = Taxonomy;
    function newTaxonomy(data) {
      const taxonomies = (0, taxonomy_1.decodeTaxonomyConfig)(data);
      return new Taxonomy(taxonomies);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/dir.js
var require_dir = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/entity/dir.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dir = exports2.DEFAULT_PUBLISH_DIR = exports2.DEFAULT_THEMES_DIR = void 0;
    exports2.newDir = newDir;
    var path_1 = __importDefault(require("path"));
    exports2.DEFAULT_THEMES_DIR = "themes";
    exports2.DEFAULT_PUBLISH_DIR = "public";
    var Dir = class {
      constructor(workingDir, themesDir, publishDir = exports2.DEFAULT_PUBLISH_DIR) {
        this.workingDir = workingDir;
        this.themesDir = themesDir;
        this.publishDir = publishDir;
      }
      getWorkingDir() {
        return path_1.default.resolve(this.workingDir);
      }
      getThemesDir() {
        return path_1.default.resolve(this.themesDir);
      }
      getThemesCacheDir() {
        return path_1.default.resolve(this.themesDir, ".cache");
      }
      getPublishDir() {
        return path_1.default.resolve(this.publishDir);
      }
    };
    exports2.Dir = Dir;
    function newDir(workingDir, themesDir, publishDir) {
      return new Dir(workingDir, themesDir, publishDir);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/provider.js
var require_provider = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultConfigProvider = void 0;
    exports2.newFromParams = newFromParams;
    exports2.newDefaultProvider = newDefaultProvider;
    var DefaultConfigProvider = class {
      constructor(params = {}) {
        this.root = this.prepareParams(params);
        this.keyCache = /* @__PURE__ */ new Map();
      }
      prepareParams(params) {
        const prepared = {};
        for (const [key, value2] of Object.entries(params)) {
          prepared[key.toLowerCase()] = value2;
        }
        return prepared;
      }
      getNestedKeyAndMap(key, create) {
        let parts;
        if (this.keyCache.has(key)) {
          parts = this.keyCache.get(key);
        } else {
          parts = key.split(".");
          this.keyCache.set(key, parts);
        }
        let current = this.root;
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!(part in current)) {
            if (create) {
              current[part] = {};
            } else {
              return ["", null];
            }
          }
          const next = current[part];
          if (typeof next !== "object" || next === null) {
            return ["", null];
          }
          current = next;
        }
        return [parts[parts.length - 1], current];
      }
      getString(key) {
        const value2 = this.get(key);
        return String(value2 || "");
      }
      getInt(key) {
        const value2 = this.get(key);
        const num = Number(value2);
        return isNaN(num) ? 0 : Math.floor(num);
      }
      getBool(key) {
        const value2 = this.get(key);
        if (typeof value2 === "boolean")
          return value2;
        if (typeof value2 === "string") {
          return value2.toLowerCase() === "true";
        }
        return Boolean(value2);
      }
      getParams(key) {
        const value2 = this.get(key);
        if (value2 && typeof value2 === "object") {
          return value2;
        }
        return {};
      }
      getStringMap(key) {
        const value2 = this.get(key);
        if (value2 && typeof value2 === "object") {
          return value2;
        }
        return {};
      }
      getStringMapString(key) {
        const value2 = this.get(key);
        if (value2 && typeof value2 === "object") {
          const result = {};
          for (const [k, v] of Object.entries(value2)) {
            result[k] = String(v);
          }
          return result;
        }
        return {};
      }
      getStringSlice(key) {
        const value2 = this.get(key);
        if (Array.isArray(value2)) {
          return value2.map((v) => String(v));
        }
        return [];
      }
      get(key) {
        if (key === "") {
          return this.root;
        }
        const [finalKey, map] = this.getNestedKeyAndMap(key.toLowerCase(), false);
        if (map === null) {
          return void 0;
        }
        return map[finalKey];
      }
      set(key, value2) {
        const lowerKey = key.toLowerCase();
        if (lowerKey === "") {
          if (value2 && typeof value2 === "object") {
            Object.assign(this.root, this.prepareParams(value2));
          } else {
            this.root[lowerKey] = value2;
          }
          return;
        }
        const [finalKey, map] = this.getNestedKeyAndMap(lowerKey, true);
        if (map === null) {
          return;
        }
        if (finalKey in map && typeof map[finalKey] === "object" && typeof value2 === "object" && value2 !== null) {
          Object.assign(map[finalKey], value2);
        } else {
          map[finalKey] = value2;
        }
      }
      keys() {
        return Object.keys(this.root);
      }
      merge(key, value2) {
        const lowerKey = key.toLowerCase();
        if (lowerKey === "") {
          if (value2 && typeof value2 === "object") {
            Object.assign(this.root, this.prepareParams(value2));
          }
          return;
        }
        const [finalKey, map] = this.getNestedKeyAndMap(lowerKey, true);
        if (map === null) {
          return;
        }
        if (finalKey in map && typeof map[finalKey] === "object" && typeof value2 === "object" && value2 !== null) {
          Object.assign(map[finalKey], value2);
        } else {
          map[finalKey] = value2;
        }
      }
      setDefaults(params) {
        const prepared = this.prepareParams(params);
        for (const [key, value2] of Object.entries(prepared)) {
          if (!(key in this.root)) {
            this.root[key] = value2;
          }
        }
      }
      setDefaultMergeStrategy() {
      }
      walkParams(walkFn) {
        const walk = (obj) => {
          if (obj && typeof obj === "object" && !Array.isArray(obj)) {
            if (walkFn(obj)) {
              return true;
            }
            for (const value2 of Object.values(obj)) {
              if (walk(value2)) {
                return true;
              }
            }
          }
          return false;
        };
        walk(this.root);
      }
      isSet(key) {
        const [finalKey, map] = this.getNestedKeyAndMap(key.toLowerCase(), false);
        return map !== null && finalKey in map;
      }
    };
    exports2.DefaultConfigProvider = DefaultConfigProvider;
    function newFromParams(params) {
      return new DefaultConfigProvider(params);
    }
    function newDefaultProvider() {
      return new DefaultConfigProvider();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/loader.js
var require_loader = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/loader.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigLoader = void 0;
    var provider_1 = require_provider();
    var path6 = __importStar(require("path"));
    var NO_CONFIG_FILE_ERR_INFO = "Unable to locate config file or config directory.";
    var ConfigLoader = class {
      constructor(sourceDescriptor, baseDirs) {
        this.cfg = (0, provider_1.newDefaultProvider)();
        this.sourceDescriptor = sourceDescriptor;
        this.baseDirs = baseDirs;
      }
      async loadConfigByDefault() {
        const filename = this.sourceDescriptor.filename();
        await this.loadProvider(filename);
        this.applyDefaultConfig();
        this.cfg.setDefaultMergeStrategy();
        if (!this.cfg.isSet("languages")) {
          const lang = this.cfg.getString("defaultContentLanguage");
          this.cfg.set("languages", { [lang]: {} });
        }
        return this.cfg;
      }
      deleteMergeStrategies() {
        this.cfg.walkParams((params) => {
          return false;
        });
      }
      async loadProvider(configName) {
        const baseDir = this.baseDirs.workingDir;
        let baseFilename;
        if (path6.isAbsolute(configName)) {
          baseFilename = configName;
        } else {
          baseFilename = path6.join(baseDir, configName);
        }
        let filename = "";
        if (path6.extname(configName) !== "") {
          const exists = await this.fileExists(baseFilename);
          if (exists) {
            filename = baseFilename;
          }
        }
        if (filename === "") {
          throw new Error(NO_CONFIG_FILE_ERR_INFO);
        }
        const configData = await this.loadConfigFromFile(filename);
        this.cfg.set("", configData);
      }
      applyDefaultConfig() {
        const defaultSettings = {
          baseURL: "",
          cleanDestinationDir: false,
          watch: false,
          contentDir: "content",
          resourceDir: "resources",
          publishDir: "public",
          publishDirOrig: "public",
          themesDir: "themes",
          assetDir: "assets",
          layoutDir: "layouts",
          i18nDir: "i18n",
          dataDir: "data",
          archetypeDir: "archetypes",
          configDir: "config",
          staticDir: "static",
          buildDrafts: false,
          buildFuture: false,
          buildExpired: false,
          params: {},
          environment: "production",
          uglyURLs: false,
          verbose: false,
          ignoreCache: false,
          canonifyURLs: false,
          relativeURLs: false,
          removePathAccents: false,
          titleCaseStyle: "AP",
          taxonomies: { tag: "tags", category: "categories" },
          permalinks: {},
          sitemap: { priority: -1, filename: "sitemap.xml" },
          menus: {},
          disableLiveReload: false,
          pluralizeListTitles: true,
          capitalizeListTitles: true,
          forceSyncStatic: false,
          footnoteAnchorPrefix: "",
          footnoteReturnLinkContents: "",
          newContentEditor: "",
          paginate: 10,
          paginatePath: "page",
          summaryLength: 70,
          rssLimit: -1,
          sectionPagesMenu: "",
          disablePathToLower: false,
          hasCJKLanguage: false,
          enableEmoji: false,
          defaultContentLanguage: "en",
          defaultContentLanguageInSubdir: false,
          enableMissingTranslationPlaceholders: false,
          enableGitInfo: false,
          ignoreFiles: [],
          disableAliases: false,
          debug: false,
          disableFastRender: false,
          timeout: "30s",
          timeZone: "",
          enableInlineShortcodes: false
        };
        this.cfg.setDefaults(defaultSettings);
      }
      async fileExists(filename) {
        try {
          const fs5 = this.sourceDescriptor.fs();
          const stat = await fs5.stat(filename);
          return !stat.isDir();
        } catch {
          return false;
        }
      }
      async loadConfigFromFile(filename) {
        const fs5 = this.sourceDescriptor.fs();
        const file = await fs5.open(filename);
        try {
          const buffer = new Uint8Array(1024 * 1024);
          const { bytesRead } = await file.read(buffer);
          const content = new TextDecoder().decode(buffer.slice(0, bytesRead));
          try {
            return JSON.parse(content);
          } catch {
            return {};
          }
        } finally {
          await file.close();
        }
      }
    };
    exports2.ConfigLoader = ConfigLoader;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/sourcedescriptor.js
var require_sourcedescriptor = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/sourcedescriptor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newSourceDescriptor = newSourceDescriptor;
    var ConfigSourceDescriptor = class {
      constructor(fs5, filename) {
        this.fileSystem = fs5;
        this.configFilename = filename;
      }
      fs() {
        return this.fileSystem;
      }
      filename() {
        return this.configFilename;
      }
    };
    function newSourceDescriptor(fs5, filename) {
      return new ConfigSourceDescriptor(fs5, filename);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/config.js
var require_config2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/factory/config.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadConfigWithParams = loadConfigWithParams;
    var config_1 = require_config();
    var dir_1 = require_dir();
    var root_1 = require_root2();
    var module_1 = require_module2();
    var service_1 = require_service2();
    var language_1 = require_language2();
    var taxonomy_1 = require_taxonomy2();
    var loader_1 = require_loader();
    var sourcedescriptor_1 = require_sourcedescriptor();
    var path6 = __importStar(require("path"));
    async function loadConfigWithParams(fs5, configFilename, workingDir, modulesDir, params = {}) {
      const cleanWorkingDir = path6.resolve(workingDir);
      const cleanModulesDir = path6.resolve(modulesDir);
      const cleanPublishDir = path6.resolve(dir_1.DEFAULT_PUBLISH_DIR);
      const baseDirs = {
        workingDir: cleanWorkingDir,
        modulesDir: cleanModulesDir,
        publishDir: cleanPublishDir,
        cacheDir: ""
      };
      baseDirs.cacheDir = await getCacheDir(fs5, baseDirs.cacheDir);
      const loader = new loader_1.ConfigLoader((0, sourcedescriptor_1.newSourceDescriptor)(fs5, configFilename), baseDirs);
      try {
        const provider = await loader.loadConfigByDefault();
        for (const [key, value2] of Object.entries(params)) {
          provider.set(key, value2);
        }
        const absPublishDir = path6.resolve(provider.get("publishDir") || dir_1.DEFAULT_PUBLISH_DIR);
        await fs5.mkdirAll(absPublishDir, 511);
        return (0, config_1.newConfig)(fs5, provider, (0, root_1.newRoot)(provider.get(""), provider.getParams("params")), (0, dir_1.newDir)(baseDirs.workingDir, baseDirs.modulesDir, absPublishDir), (0, module_1.newModule)(provider.get("module") || {}), (0, service_1.newService)(provider.get("services")), (0, language_1.newLanguage)(provider.get("languages")), provider.isSet("taxonomies") ? (0, taxonomy_1.newTaxonomy)(provider.get("taxonomies")) : (0, taxonomy_1.newTaxonomy)(provider.get("")));
      } finally {
        loader.deleteMergeStrategies();
      }
    }
    async function getCacheDir(fs5, cacheDir) {
      if (cacheDir !== "") {
        return cacheDir;
      }
      const homeDir = process.env.HOME || process.env.USERPROFILE || "";
      const defaultCacheDir = path6.join(homeDir, ".cache", "mdf");
      try {
        await fs5.mkdirAll(defaultCacheDir, 493);
        return defaultCacheDir;
      } catch {
        return path6.join("/tmp", "hugo-cache");
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/config/index.js
var require_config3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/config/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadConfigWithParams = exports2.newTaxonomy = exports2.Taxonomy = exports2.newLanguage = exports2.Language = exports2.newService = exports2.Service = exports2.newModule = exports2.Module = exports2.newRoot = exports2.Root = exports2.newConfig = exports2.Config = void 0;
    __exportStar(require_type(), exports2);
    var config_1 = require_config();
    Object.defineProperty(exports2, "Config", { enumerable: true, get: function() {
      return config_1.Config;
    } });
    Object.defineProperty(exports2, "newConfig", { enumerable: true, get: function() {
      return config_1.newConfig;
    } });
    var root_1 = require_root2();
    Object.defineProperty(exports2, "Root", { enumerable: true, get: function() {
      return root_1.Root;
    } });
    Object.defineProperty(exports2, "newRoot", { enumerable: true, get: function() {
      return root_1.newRoot;
    } });
    var module_1 = require_module2();
    Object.defineProperty(exports2, "Module", { enumerable: true, get: function() {
      return module_1.Module;
    } });
    Object.defineProperty(exports2, "newModule", { enumerable: true, get: function() {
      return module_1.newModule;
    } });
    var service_1 = require_service2();
    Object.defineProperty(exports2, "Service", { enumerable: true, get: function() {
      return service_1.Service;
    } });
    Object.defineProperty(exports2, "newService", { enumerable: true, get: function() {
      return service_1.newService;
    } });
    var language_1 = require_language2();
    Object.defineProperty(exports2, "Language", { enumerable: true, get: function() {
      return language_1.Language;
    } });
    Object.defineProperty(exports2, "newLanguage", { enumerable: true, get: function() {
      return language_1.newLanguage;
    } });
    var taxonomy_1 = require_taxonomy2();
    Object.defineProperty(exports2, "Taxonomy", { enumerable: true, get: function() {
      return taxonomy_1.Taxonomy;
    } });
    Object.defineProperty(exports2, "newTaxonomy", { enumerable: true, get: function() {
      return taxonomy_1.newTaxonomy;
    } });
    __exportStar(require_root(), exports2);
    __exportStar(require_module(), exports2);
    __exportStar(require_service(), exports2);
    __exportStar(require_language(), exports2);
    __exportStar(require_taxonomy(), exports2);
    var config_2 = require_config2();
    Object.defineProperty(exports2, "loadConfigWithParams", { enumerable: true, get: function() {
      return config_2.loadConfigWithParams;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/type.js
var require_type2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrMountFailed = exports2.ErrInvalidZipFile = exports2.ErrDownloadFailed = exports2.ErrModuleNotFound = exports2.ModuleError = exports2.DownloadStatus = exports2.ComponentFolders = exports2.ComponentFolderI18n = exports2.ComponentFolderAssets = exports2.ComponentFolderStatic = exports2.ComponentFolderLayouts = exports2.ComponentFolderContent = exports2.ComponentFolderPrompts = exports2.ComponentFolderWorkflows = exports2.PACKAGE_JSON_FILENAME = void 0;
    exports2.PACKAGE_JSON_FILENAME = "package.json";
    exports2.ComponentFolderWorkflows = "workflows";
    exports2.ComponentFolderPrompts = "prompts";
    exports2.ComponentFolderContent = "content";
    exports2.ComponentFolderLayouts = "layouts";
    exports2.ComponentFolderStatic = "static";
    exports2.ComponentFolderAssets = "assets";
    exports2.ComponentFolderI18n = "i18n";
    exports2.ComponentFolders = [
      exports2.ComponentFolderWorkflows,
      exports2.ComponentFolderPrompts,
      exports2.ComponentFolderContent,
      exports2.ComponentFolderLayouts,
      exports2.ComponentFolderStatic,
      exports2.ComponentFolderAssets,
      exports2.ComponentFolderI18n
    ];
    var DownloadStatus;
    (function(DownloadStatus2) {
      DownloadStatus2["PENDING"] = "pending";
      DownloadStatus2["DOWNLOADING"] = "downloading";
      DownloadStatus2["COMPLETED"] = "completed";
      DownloadStatus2["FAILED"] = "failed";
    })(DownloadStatus || (exports2.DownloadStatus = DownloadStatus = {}));
    var ModuleError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        this.name = "ModuleError";
      }
    };
    exports2.ModuleError = ModuleError;
    exports2.ErrModuleNotFound = new ModuleError("module not found", "MODULE_NOT_FOUND");
    exports2.ErrDownloadFailed = new ModuleError("download failed", "DOWNLOAD_FAILED");
    exports2.ErrInvalidZipFile = new ModuleError("invalid zip file", "INVALID_ZIP");
    exports2.ErrMountFailed = new ModuleError("mount failed", "MOUNT_FAILED");
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/mount.js
var require_mount = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/mount.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Mount = void 0;
    exports2.newMount = newMount;
    exports2.newMountFromConfig = newMountFromConfig;
    exports2.createDefaultMounts = createDefaultMounts;
    var path6 = __importStar(require("path"));
    var Mount = class {
      constructor(sourcePath, targetPath, language = "") {
        this.sourcePath = sourcePath;
        this.targetPath = targetPath;
        this.language = language;
      }
      source() {
        return this.sourcePath;
      }
      target() {
        return this.targetPath;
      }
      lang() {
        return this.language;
      }
      setLanguage(lang) {
        this.language = lang;
      }
      component() {
        const parts = this.targetPath.split(path6.sep);
        return parts[0] || "";
      }
      componentAndName() {
        const parts = this.targetPath.split(path6.sep);
        const component = parts[0] || "";
        const name = parts.slice(1).join(path6.sep);
        return { component, name };
      }
      copy() {
        return new Mount(this.sourcePath, this.targetPath, this.language);
      }
      equals(other) {
        return this.sourcePath === other.sourcePath && this.targetPath === other.targetPath && this.language === other.language;
      }
      toConfig() {
        const config = {
          sourcePath: this.sourcePath,
          targetPath: this.targetPath
        };
        if (this.language) {
          config.language = this.language;
        }
        return config;
      }
      toString() {
        return `${this.sourcePath} -> ${this.targetPath} (${this.language})`;
      }
    };
    exports2.Mount = Mount;
    function newMount(sourcePath, targetPath) {
      return new Mount(sourcePath, targetPath);
    }
    function newMountFromConfig(config) {
      return new Mount(config.sourcePath, config.targetPath, config.language || "");
    }
    function createDefaultMounts(componentFolders) {
      return componentFolders.map((folder) => new Mount(folder, folder));
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/log/types.js
var require_types = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/log/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogLevel = void 0;
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "debug";
      LogLevel2["INFO"] = "info";
      LogLevel2["WARN"] = "warn";
      LogLevel2["ERROR"] = "error";
      LogLevel2["FATAL"] = "fatal";
    })(LogLevel || (exports2.LogLevel = LogLevel = {}));
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/log/logger.js
var require_logger = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/log/logger.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Logger = void 0;
    exports2.New = New2;
    exports2.NewWithConfig = NewWithConfig;
    var util = __importStar(require("util"));
    var types_1 = require_types();
    var Logger = class {
      constructor(config) {
        this.config = {
          enableCaller: true,
          jsonFormat: true,
          ...config
        };
        this.fields = {};
      }
      shouldLog(level) {
        const levels = [types_1.LogLevel.DEBUG, types_1.LogLevel.INFO, types_1.LogLevel.WARN, types_1.LogLevel.ERROR, types_1.LogLevel.FATAL];
        const configLevelIndex = levels.indexOf(this.config.level);
        const msgLevelIndex = levels.indexOf(level);
        return msgLevelIndex >= configLevelIndex;
      }
      getCaller() {
        if (!this.config.enableCaller) {
          return void 0;
        }
        const stack = new Error().stack;
        if (!stack)
          return void 0;
        const lines = stack.split("\n");
        const callerLine = lines[4];
        if (!callerLine)
          return void 0;
        const match = callerLine.match(/at .* \((.+):(\d+):(\d+)\)/);
        if (match) {
          const [, file, line] = match;
          const filename = file.split("/").pop();
          return `${filename}:${line}`;
        }
        const simpleMatch = callerLine.match(/at (.+):(\d+):(\d+)/);
        if (simpleMatch) {
          const [, file, line] = simpleMatch;
          const filename = file.split("/").pop();
          return `${filename}:${line}`;
        }
        return void 0;
      }
      formatMessage(template, args) {
        if (args.length === 0) {
          return template;
        }
        return util.format(template, ...args);
      }
      writeLog(level, message) {
        if (!this.shouldLog(level)) {
          return;
        }
        const entry = {
          level,
          timestamp: new Date().toISOString(),
          message,
          ...this.fields
        };
        const caller = this.getCaller();
        if (caller) {
          entry.caller = caller;
        }
        const output = this.config.jsonFormat ? JSON.stringify(entry) : this.formatPlainText(entry);
        if (level === types_1.LogLevel.ERROR || level === types_1.LogLevel.FATAL) {
          process.stderr.write(output + "\n");
        } else {
          process.stdout.write(output + "\n");
        }
        if (level === types_1.LogLevel.FATAL) {
          process.exit(1);
        }
      }
      formatPlainText(entry) {
        const parts = [entry.timestamp, entry.level.toUpperCase()];
        if (entry.caller) {
          parts.push(`[${entry.caller}]`);
        }
        parts.push(entry.message);
        const extraFields = Object.keys(entry).filter((key) => !["level", "timestamp", "message", "caller"].includes(key)).map((key) => `${key}=${JSON.stringify(entry[key])}`).join(" ");
        if (extraFields) {
          parts.push(extraFields);
        }
        return parts.join(" ");
      }
      debug(message, ...args) {
        this.writeLog(types_1.LogLevel.DEBUG, this.formatMessage(message, args));
      }
      info(message, ...args) {
        this.writeLog(types_1.LogLevel.INFO, this.formatMessage(message, args));
      }
      warn(message, ...args) {
        this.writeLog(types_1.LogLevel.WARN, this.formatMessage(message, args));
      }
      error(message, ...args) {
        this.writeLog(types_1.LogLevel.ERROR, this.formatMessage(message, args));
      }
      fatal(message, ...args) {
        this.writeLog(types_1.LogLevel.FATAL, this.formatMessage(message, args));
      }
      debugf(template, ...args) {
        this.writeLog(types_1.LogLevel.DEBUG, this.formatMessage(template, args));
      }
      infof(template, ...args) {
        this.writeLog(types_1.LogLevel.INFO, this.formatMessage(template, args));
      }
      warnf(template, ...args) {
        this.writeLog(types_1.LogLevel.WARN, this.formatMessage(template, args));
      }
      errorf(template, ...args) {
        this.writeLog(types_1.LogLevel.ERROR, this.formatMessage(template, args));
      }
      fatalf(template, ...args) {
        this.writeLog(types_1.LogLevel.FATAL, this.formatMessage(template, args));
      }
      with(fields) {
        const newLogger = new Logger(this.config);
        newLogger.fields = { ...this.fields, ...fields };
        return newLogger;
      }
    };
    exports2.Logger = Logger;
    function New2(level = types_1.LogLevel.INFO) {
      return new Logger({ level });
    }
    function NewWithConfig(config) {
      return new Logger(config);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/log/http.js
var require_http = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/log/http.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTTPErrorLogger = void 0;
    exports2.NewHTTPErrorLogger = NewHTTPErrorLogger;
    var HTTPErrorLogger = class {
      constructor(logger) {
        this.logger = logger;
      }
      write(message) {
        const trimmedMessage = message.trim();
        if (trimmedMessage.includes("http: URL query contains semicolon")) {
          this.logger.debug(trimmedMessage);
        } else {
          this.logger.error(trimmedMessage);
        }
      }
      getWriteFunction() {
        return (message) => this.write(message);
      }
      createWritableStream() {
        const self2 = this;
        const { Writable } = require("stream");
        return new Writable({
          write(chunk, encoding, callback) {
            try {
              const message = chunk.toString();
              self2.write(message);
              callback();
            } catch (error) {
              callback(error);
            }
          }
        });
      }
    };
    exports2.HTTPErrorLogger = HTTPErrorLogger;
    function NewHTTPErrorLogger(logger) {
      return new HTTPErrorLogger(logger);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/log/manager.js
var require_manager = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/log/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalLoggerManager = exports2.LoggerManager = void 0;
    exports2.initLogger = initLogger;
    exports2.getDomainLogger = getDomainLogger;
    exports2.getComponentLogger = getComponentLogger;
    exports2.setGlobalLogLevel = setGlobalLogLevel;
    exports2.setGlobalCallerEnabled = setGlobalCallerEnabled;
    exports2.setGlobalJsonFormat = setGlobalJsonFormat;
    var logger_1 = require_logger();
    var types_1 = require_types();
    var LoggerManager = class {
      constructor() {
        this.globalConfig = {
          level: types_1.LogLevel.ERROR,
          enableCaller: true,
          jsonFormat: true
        };
        this.loggers = /* @__PURE__ */ new Map();
      }
      static getInstance() {
        if (!LoggerManager.instance) {
          LoggerManager.instance = new LoggerManager();
        }
        return LoggerManager.instance;
      }
      setGlobalConfig(config) {
        this.globalConfig = { ...this.globalConfig, ...config };
        this.loggers.clear();
      }
      getGlobalConfig() {
        return { ...this.globalConfig };
      }
      getLogger(domain, additionalFields) {
        const cacheKey = domain + (additionalFields ? JSON.stringify(additionalFields) : "");
        if (!this.loggers.has(cacheKey)) {
          const logger = (0, logger_1.NewWithConfig)(this.globalConfig);
          const fields = {
            domain,
            ...additionalFields
          };
          const domainLogger = logger.with(fields);
          this.loggers.set(cacheKey, domainLogger);
        }
        return this.loggers.get(cacheKey);
      }
      getComponentLogger(domain, component, additionalFields) {
        const fields = {
          component,
          ...additionalFields
        };
        return this.getLogger(domain, fields);
      }
      clearCache() {
        this.loggers.clear();
      }
      getCachedDomains() {
        return Array.from(this.loggers.keys());
      }
      setLogLevel(level) {
        this.setGlobalConfig({ level });
      }
      setCallerEnabled(enabled) {
        this.setGlobalConfig({ enableCaller: enabled });
      }
      setJsonFormat(enabled) {
        this.setGlobalConfig({ jsonFormat: enabled });
      }
    };
    exports2.LoggerManager = LoggerManager;
    var globalLoggerManager = LoggerManager.getInstance();
    exports2.globalLoggerManager = globalLoggerManager;
    function initLogger(config) {
      globalLoggerManager.setGlobalConfig(config);
    }
    function getDomainLogger(domain, additionalFields) {
      return globalLoggerManager.getLogger(domain, additionalFields);
    }
    function getComponentLogger(domain, component, additionalFields) {
      return globalLoggerManager.getComponentLogger(domain, component, additionalFields);
    }
    function setGlobalLogLevel(level) {
      globalLoggerManager.setLogLevel(level);
    }
    function setGlobalCallerEnabled(enabled) {
      globalLoggerManager.setCallerEnabled(enabled);
    }
    function setGlobalJsonFormat(enabled) {
      globalLoggerManager.setJsonFormat(enabled);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/log/index.js
var require_log = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/log/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.with_ = exports2.fatalf = exports2.errorf = exports2.warnf = exports2.infof = exports2.debugf = exports2.fatal = exports2.error = exports2.warn = exports2.info = exports2.debug = exports2.defaultLogger = exports2.globalLoggerManager = exports2.setGlobalJsonFormat = exports2.setGlobalCallerEnabled = exports2.setGlobalLogLevel = exports2.getComponentLogger = exports2.getDomainLogger = exports2.initLogger = exports2.LoggerManager = exports2.NewHTTPErrorLogger = exports2.HTTPErrorLogger = exports2.NewWithConfig = exports2.New = exports2.Logger = exports2.LogLevel = void 0;
    var types_1 = require_types();
    Object.defineProperty(exports2, "LogLevel", { enumerable: true, get: function() {
      return types_1.LogLevel;
    } });
    var logger_1 = require_logger();
    Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    Object.defineProperty(exports2, "New", { enumerable: true, get: function() {
      return logger_1.New;
    } });
    Object.defineProperty(exports2, "NewWithConfig", { enumerable: true, get: function() {
      return logger_1.NewWithConfig;
    } });
    var http_1 = require_http();
    Object.defineProperty(exports2, "HTTPErrorLogger", { enumerable: true, get: function() {
      return http_1.HTTPErrorLogger;
    } });
    Object.defineProperty(exports2, "NewHTTPErrorLogger", { enumerable: true, get: function() {
      return http_1.NewHTTPErrorLogger;
    } });
    var manager_1 = require_manager();
    Object.defineProperty(exports2, "LoggerManager", { enumerable: true, get: function() {
      return manager_1.LoggerManager;
    } });
    Object.defineProperty(exports2, "initLogger", { enumerable: true, get: function() {
      return manager_1.initLogger;
    } });
    Object.defineProperty(exports2, "getDomainLogger", { enumerable: true, get: function() {
      return manager_1.getDomainLogger;
    } });
    Object.defineProperty(exports2, "getComponentLogger", { enumerable: true, get: function() {
      return manager_1.getComponentLogger;
    } });
    Object.defineProperty(exports2, "setGlobalLogLevel", { enumerable: true, get: function() {
      return manager_1.setGlobalLogLevel;
    } });
    Object.defineProperty(exports2, "setGlobalCallerEnabled", { enumerable: true, get: function() {
      return manager_1.setGlobalCallerEnabled;
    } });
    Object.defineProperty(exports2, "setGlobalJsonFormat", { enumerable: true, get: function() {
      return manager_1.setGlobalJsonFormat;
    } });
    Object.defineProperty(exports2, "globalLoggerManager", { enumerable: true, get: function() {
      return manager_1.globalLoggerManager;
    } });
    var logger_2 = require_logger();
    var types_2 = require_types();
    exports2.defaultLogger = (0, logger_2.New)(types_2.LogLevel.INFO);
    var debug = (message, ...args) => exports2.defaultLogger.debug(message, ...args);
    exports2.debug = debug;
    var info = (message, ...args) => exports2.defaultLogger.info(message, ...args);
    exports2.info = info;
    var warn = (message, ...args) => exports2.defaultLogger.warn(message, ...args);
    exports2.warn = warn;
    var error = (message, ...args) => exports2.defaultLogger.error(message, ...args);
    exports2.error = error;
    var fatal = (message, ...args) => exports2.defaultLogger.fatal(message, ...args);
    exports2.fatal = fatal;
    var debugf = (template, ...args) => exports2.defaultLogger.debugf(template, ...args);
    exports2.debugf = debugf;
    var infof = (template, ...args) => exports2.defaultLogger.infof(template, ...args);
    exports2.infof = infof;
    var warnf = (template, ...args) => exports2.defaultLogger.warnf(template, ...args);
    exports2.warnf = warnf;
    var errorf = (template, ...args) => exports2.defaultLogger.errorf(template, ...args);
    exports2.errorf = errorf;
    var fatalf = (template, ...args) => exports2.defaultLogger.fatalf(template, ...args);
    exports2.fatalf = fatalf;
    var with_ = (fields) => exports2.defaultLogger.with(fields);
    exports2.with_ = with_;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/httpclient.js
var require_httpclient = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/httpclient.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchHttpClient = exports2.NodeHttpClient = void 0;
    exports2.newHttpClient = newHttpClient;
    var type_1 = require_type2();
    var path6 = __importStar(require("path"));
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("module", { component: "httpclient" });
    var NodeHttpClient = class {
      constructor(fs5, timeout = 3e4, headers = {}) {
        this.fs = fs5;
        this.timeout = timeout;
        this.headers = headers;
        this.defaultTimeout = 3e4;
        this.defaultHeaders = {
          "User-Agent": "MDFriday-CLI/1.0.0"
        };
      }
      async download(downloadUrl, targetPath, options) {
        return new Promise((resolve, reject) => {
          try {
            const parsedUrl = new URL(downloadUrl);
            const isHttps = parsedUrl.protocol === "https:";
            const httpModule = isHttps ? https : http;
            const requestHeaders = {
              ...this.defaultHeaders,
              ...this.headers,
              ...options?.headers
            };
            const requestOptions = {
              hostname: parsedUrl.hostname,
              port: parsedUrl.port || (isHttps ? 443 : 80),
              path: parsedUrl.pathname + parsedUrl.search,
              method: "GET",
              headers: requestHeaders,
              timeout: options?.timeout || this.timeout
            };
            const request = httpModule.request(requestOptions, async (response) => {
              if (!response.statusCode || response.statusCode < 200 || response.statusCode >= 300) {
                reject(new type_1.ModuleError(`HTTP ${response.statusCode}: ${response.statusMessage}`, "HTTP_ERROR"));
                return;
              }
              const total = parseInt(response.headers["content-length"] || "0", 10);
              let loaded = 0;
              let lastProgressTime = Date.now();
              let lastLoggedPercentage = -1;
              try {
                const targetDir = path6.dirname(targetPath);
                await this.fs.mkdirAll(targetDir, 493);
                const file = await this.fs.create(targetPath);
                const chunks = [];
                response.on("data", (chunk) => {
                  chunks.push(chunk);
                  loaded += chunk.length;
                  if (options?.onProgress && total > 0) {
                    const now = Date.now();
                    const percentage = Math.round(loaded / total * 100);
                    const timePassed = now - lastProgressTime >= 100;
                    const significantChange = percentage - lastLoggedPercentage >= 5;
                    if (timePassed && percentage !== lastLoggedPercentage || significantChange) {
                      const progress = {
                        loaded,
                        total,
                        percentage
                      };
                      try {
                        options.onProgress(progress);
                        lastLoggedPercentage = percentage;
                      } catch (progressError) {
                        log.error(`Progress callback error: ${progressError}`);
                      }
                      lastProgressTime = now;
                    }
                  }
                });
                response.on("end", async () => {
                  try {
                    const buffer = Buffer.concat(chunks);
                    const uint8Array = new Uint8Array(buffer);
                    await file.write(uint8Array);
                    await file.sync();
                    await file.close();
                    if (options?.onProgress && total > 0) {
                      const progress = {
                        loaded: total,
                        total,
                        percentage: 100
                      };
                      try {
                        options.onProgress(progress);
                      } catch (progressError) {
                        log.warn(`Progress callback error: ${progressError}`);
                      }
                    }
                    resolve();
                  } catch (error) {
                    const message = error instanceof Error ? error.message : String(error);
                    reject(new type_1.ModuleError(`File write failed: ${message}`, "WRITE_FAILED"));
                  }
                });
                response.on("error", (error) => {
                  log.error(`Response error: ${error.message}`);
                  reject(new type_1.ModuleError(`Download failed: ${error.message}`, "DOWNLOAD_FAILED"));
                });
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                reject(new type_1.ModuleError(`File system error: ${message}`, "FS_ERROR"));
              }
            });
            request.on("error", (error) => {
              log.error(`Request error:`, error);
              reject(new type_1.ModuleError(`Request failed: ${error.message}`, "REQUEST_FAILED"));
            });
            request.on("timeout", () => {
              request.destroy();
              log.error(`Request timeout for ${downloadUrl}`);
              reject(new type_1.ModuleError("Request timeout", "TIMEOUT"));
            });
            request.end();
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            reject(new type_1.ModuleError(`Download failed: ${message}`, "DOWNLOAD_FAILED"));
          }
        });
      }
      async get(requestUrl5, options) {
        return new Promise((resolve, reject) => {
          try {
            const parsedUrl = new URL(requestUrl5);
            const isHttps = parsedUrl.protocol === "https:";
            const httpModule = isHttps ? https : http;
            const requestHeaders = {
              ...this.defaultHeaders,
              ...this.headers,
              ...options?.headers
            };
            const requestOptions = {
              hostname: parsedUrl.hostname,
              port: parsedUrl.port || (isHttps ? 443 : 80),
              path: parsedUrl.pathname + parsedUrl.search,
              method: "GET",
              headers: requestHeaders,
              timeout: options?.timeout || this.timeout
            };
            const request = httpModule.request(requestOptions, (response) => {
              const chunks = [];
              const responseHeaders = {};
              Object.entries(response.headers).forEach(([key, value2]) => {
                responseHeaders[key] = Array.isArray(value2) ? value2.join(", ") : value2 || "";
              });
              response.on("data", (chunk) => {
                chunks.push(chunk);
              });
              response.on("end", () => {
                const buffer = Buffer.concat(chunks);
                const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
                resolve({
                  data: arrayBuffer,
                  headers: responseHeaders,
                  status: response.statusCode || 0
                });
              });
              response.on("error", (error) => {
                reject(new type_1.ModuleError(`Response error: ${error.message}`, "RESPONSE_ERROR"));
              });
            });
            request.on("error", (error) => {
              reject(new type_1.ModuleError(`GET request failed: ${error.message}`, "REQUEST_FAILED"));
            });
            request.on("timeout", () => {
              request.destroy();
              reject(new type_1.ModuleError("GET request timeout", "TIMEOUT"));
            });
            request.end();
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            reject(new type_1.ModuleError(`GET request failed: ${message}`, "REQUEST_FAILED"));
          }
        });
      }
    };
    exports2.NodeHttpClient = NodeHttpClient;
    var FetchHttpClient = class {
      constructor(fs5, timeout = 3e4, headers = {}) {
        this.fs = fs5;
        this.timeout = timeout;
        this.headers = headers;
        this.defaultTimeout = 3e4;
        this.defaultHeaders = {
          "User-Agent": "AuPro-CLI/1.0.0"
        };
      }
      async download(url, targetPath, options) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
          }, options?.timeout || this.timeout);
          const headers = {
            ...this.defaultHeaders,
            ...this.headers,
            ...options?.headers
          };
          const response = await fetch(url, {
            headers,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new type_1.ModuleError(`HTTP ${response.status}: ${response.statusText}`, "HTTP_ERROR");
          }
          const total = parseInt(response.headers.get("content-length") || "0", 10);
          const reader = response.body?.getReader();
          if (!reader) {
            throw new type_1.ModuleError("Unable to read response body", "RESPONSE_ERROR");
          }
          const targetDir = path6.dirname(targetPath);
          await this.fs.mkdirAll(targetDir, 493);
          const file = await this.fs.create(targetPath);
          try {
            let loaded = 0;
            const chunks = [];
            while (true) {
              const { done, value: value2 } = await reader.read();
              if (done)
                break;
              chunks.push(value2);
              loaded += value2.length;
              if (options?.onProgress && total > 0) {
                const percentage = Math.round(loaded / total * 100);
                const progress = {
                  loaded,
                  total,
                  percentage
                };
                try {
                  options.onProgress(progress);
                } catch (progressError) {
                  log.warn(`Progress callback error: ${progressError}`);
                }
              }
            }
            const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const buffer = new Uint8Array(totalSize);
            let offset = 0;
            for (const chunk of chunks) {
              buffer.set(chunk, offset);
              offset += chunk.length;
            }
            await file.write(buffer);
            await file.sync();
          } finally {
            await file.close();
          }
        } catch (error) {
          if (error instanceof type_1.ModuleError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Download failed: ${message}`, "DOWNLOAD_FAILED");
        }
      }
      async get(url, options) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
          }, options?.timeout || this.timeout);
          const headers = {
            ...this.defaultHeaders,
            ...this.headers,
            ...options?.headers
          };
          const response = await fetch(url, {
            headers,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          const data = await response.arrayBuffer();
          const responseHeaders = {};
          response.headers.forEach((value2, key) => {
            responseHeaders[key] = value2;
          });
          return {
            data,
            headers: responseHeaders,
            status: response.status
          };
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`GET request failed: ${message}`, "REQUEST_FAILED");
        }
      }
      setHeaders(headers) {
        this.headers = { ...this.headers, ...headers };
      }
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    exports2.FetchHttpClient = FetchHttpClient;
    function newHttpClient(fs5, timeout, headers) {
      return new NodeHttpClient(fs5, timeout, headers);
    }
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports2, module2) {
    !function(e) {
      if (typeof exports2 == "object" && typeof module2 != "undefined")
        module2.exports = e();
      else if (typeof define == "function" && define.amd)
        define([], e);
      else {
        (typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = typeof require == "function" && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n2 = new Error("Cannot find module '" + r + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = typeof require == "function" && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n2, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = d.getTypeOf(e2) !== "string"; u < e2.length; )
            f = l - u, n2 = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n2 >> 6 : 64, o = 2 < f ? 63 & n2 : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n2, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n2 = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, s !== 64 && (l[h++] = r2), a !== 64 && (l[h++] = n2);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n2 = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n3, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n3, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n2 = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n2 = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n3 = 0; n3 < 8; n3++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return e2 !== void 0 && e2.length ? n2.getTypeOf(e2) !== "string" ? function(e3, t3, r2, n3) {
            var i = o, s = n3 + r2;
            e3 ^= -1;
            for (var a = n3; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n3) {
            var i = o, s = n3 + r2;
            e3 ^= -1;
            for (var a = n3; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n2 = null;
        n2 = typeof Promise != "undefined" ? Promise : e("lie"), t.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n2 ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n3 = "";
          for (r2 = 0; r2 < t2; r2++)
            n3 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n3;
        }
        function n2(e2, t2, r2, n3, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), i2 === "UNIX" ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n3, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n3) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n3, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n3 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n2(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n2(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n3 = function(e3, t3, r3, n4, i2) {
            var s2 = I.transformTo("string", i2(n4));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n2 = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n2(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n4 = u[r3];
                if (!n4)
                  throw new Error(r3 + " is not a valid compression method !");
                return n4;
              }(t3.options.compression, a.compression), n3 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n3).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n2() {
          if (!(this instanceof n2))
            return new n2();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n2();
            for (var t2 in this)
              typeof this[t2] != "function" && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n2.prototype = e("./object")).loadAsync = e("./load"), n2.support = e("./support"), n2.defaults = e("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e2, t2) {
          return new n2().loadAsync(e2, t2);
        }, n2.external = e("./external"), t.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n2 = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n3) {
          return new i.Promise(function(e2, t2) {
            var r2 = n3.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n3.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n3 = 0; n3 < r2.length; n3++)
                t2.push(f(r2[n3]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n3 = 0; n3 < r2.length; n3++) {
              var i2 = r2[n3], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n2.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n2(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n3 = this;
          e2.on("data", function(e3, t3) {
            n3.push(e3) || n3._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n3.emit("error", e3);
          }).on("end", function() {
            n3.push(null);
          });
        }
        e("../utils").inherits(n2, i), n2.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if (typeof e2 == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && typeof e2.on == "function" && typeof e2.pause == "function" && typeof e2.resume == "function";
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n3, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n3 = _(e2)) && b.call(this, n3, true);
          var a2 = i2 === "string" && s2.binary === false && s2.base64 === false;
          r2 && r2.binary !== void 0 || (s2.binary = !a2), (t2 instanceof c && t2.uncompressedSize === 0 || s2.dir || !t2 || t2.length === 0) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          e2.slice(-1) === "/" && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return e2.slice(-1) !== "/" && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = t2 !== void 0 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return Object.prototype.toString.call(e2) === "[object RegExp]";
        }
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n3;
          for (t2 in this.files)
            n3 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n3);
        }, filter: function(r2) {
          var n3 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n3.push(t2);
          }), n3;
        }, file: function(e2, t2, r2) {
          if (arguments.length !== 1)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n3 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n3.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n3 = this.clone();
          return n3.root = t2.name, n3;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || (r2.slice(-1) !== "/" && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n3 = 0; n3 < t2.length; n3++)
              delete this.files[t2[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
            var n3 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n3);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n2 = e("./DataReader");
        function i(e2) {
          n2.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n2), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n3 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n3 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n3 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n3 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), e2 === 0)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n2.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n2 = e("./Uint8ArrayReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n2 = e("./DataReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n2 = e("./ArrayReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), e2 === 0)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n2.getTypeOf(e2);
          return n2.checkSupport(t2), t2 !== "string" || i.uint8array ? t2 === "nodebuffer" ? new o(e2) : i.uint8array ? new h(n2.transformTo("uint8array", e2)) : new s(n2.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n2 = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n2.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n2), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n2 = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n2), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n2.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n2.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n2.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n2(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n2.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n2;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n2 = e("../support"), a = e("../external"), o = null;
        if (n2.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n3 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n3.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n3 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n4 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n4), n4 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n3), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n3 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n3 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t2, this._mimeType = r2, h.checkSupport(n3), this._worker = e2.pipe(new i(n3)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return e2 === "data" ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: this._outputType !== "nodebuffer" }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
          r.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r.blob = new Blob([n2], { type: "application/zip" }).size === 0;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n2), r.blob = i.getBlob("application/zip").size === 0;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n2 = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n2.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n3, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n3, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n3 = e3[t2++]) < 128)
                a2[r2++] = n3;
              else if (4 < (i2 = u[n3]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n3 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n3 = n3 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n3 < 65536 ? a2[r2++] = n3 : (n3 -= 65536, a2[r2++] = 55296 | n3 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n3);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n2), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n3 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && (192 & e3[r3]) == 128; )
              r3--;
            return r3 < 0 ? t3 : r3 === 0 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n3 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n3), this.leftOver = t2.subarray(n3, t2.length)) : (i2 = t2.slice(0, n3), this.leftOver = t2.slice(n3, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n2), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n2(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t2), n3.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n3 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            t2 === "array" || t2 === "nodebuffer" ? n3.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n3.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n3.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n3 = true;
          if (r2 === "uint8array" ? n3 = i.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (n3 = i.applyCanBeUsed.nodebuffer), n3)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n2, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n2, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n2, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n2, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n2 }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n3 = 0; n3 < t2.length; n3++) {
            var i2 = t2[n3];
            i2 === "." || i2 === "" && n3 !== 0 && n3 !== t2.length - 1 || (i2 === ".." ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return typeof e2 == "string" ? "string" : Object.prototype.toString.call(e2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n3 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n3 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n3;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && r2[t2] === void 0 && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n3, i2, s2) {
          return u.Promise.resolve(e2).then(function(n4) {
            return o.blob && (n4 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? (t2 === "arraybuffer" ? e3 = a.transformTo("uint8array", e3) : t2 === "string" && (s2 ? e3 = h.decode(e3) : n3 && i2 !== true && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n2 = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n3 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n3 = t2 - r2;
          if (0 < n3)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n2(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n2 = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)) === null)
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), e2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n2(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n3, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n3 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n3 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (t2 !== null)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (n3 !== null)
              this.fileCommentStr = n3;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n2(e2.value);
            return t2.readInt(1) !== 1 ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n2(e2.value);
            return t2.readInt(1) !== 1 ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n2(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n3 = (r2 = e2.toLowerCase()) === "string" || r2 === "text";
            r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n3 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n3 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n2.prototype[u[f]] = l;
        t.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n2, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || t2.MessageChannel === void 0)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n2 = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n2 = false;
          }
          l.exports = function(e3) {
            h.push(e3) !== 1 || n2 || r();
          };
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n2 = ["PENDING"];
        function o(e2) {
          if (typeof e2 != "function")
            throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, typeof t2 == "function" && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n3) {
          i(function() {
            var e2;
            try {
              e2 = r2(n3);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && (typeof e2 == "object" || typeof e2 == "function") && typeof t2 == "function")
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n3(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n3);
          });
          s2.status === "error" && n3(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if (typeof t2 != "function")
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if (typeof e2 != "function" && this.state === a || typeof t2 != "function" && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n2 ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if (r2.status === "error")
            return l.reject(e2, r2.value);
          var n3 = r2.value;
          if (n3)
            d(e2, n3);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n3 = e2.queue.length; ++r2 < n3; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if (Object.prototype.toString.call(e2) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var n3 = e2.length, i2 = false;
          if (!n3)
            return this.resolve([]);
          var s2 = new Array(n3), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n3; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n3 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if (Object.prototype.toString.call(e2) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n3 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n3 || (n3 = true, l.resolve(s2, e3));
            }, function(e3) {
              n3 || (n3 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n2 = {};
        (0, e("./lib/utils/common").assign)(n2, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n3;
            if (n3 = typeof t2.dictionary == "string" ? h.string2buf(t2.dictionary) : u.call(t2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n3)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n2(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n3, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n3 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? i2.input = h.string2buf(e2) : u.call(e2) === "[object ArrayBuffer]" ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (i2.avail_out === 0 && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), (r2 = a.deflate(i2, n3)) !== 1 && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            i2.avail_out !== 0 && (i2.avail_in !== 0 || n3 !== 4 && n3 !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1);
          return n3 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : n3 !== 2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n2, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n2(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n2(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n2 = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, t2.windowBits === 0 && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && (15 & t2.windowBits) == 0 && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n2[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n2[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n3 = t2 === ~~t2 ? t2 : t2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof e2 == "string" ? h.input = p.binstring2buf(e2) : _.call(e2) === "[object ArrayBuffer]" ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (h.avail_out === 0 && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (h.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h.avail_in !== 0 || n3 !== m.Z_FINISH && n3 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), h.avail_in === 0 && h.avail_out === 0 && (f = true);
          } while ((0 < h.avail_in || h.avail_out === 0) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n3 = m.Z_FINISH), n3 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n3 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if (typeof r2 != "object")
                throw new TypeError(r2 + "must be non-object");
              for (var n3 in r2)
                r2.hasOwnProperty(n3) && (e2[n3] = r2[n3]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n3, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n3), i2);
          else
            for (var s2 = 0; s2 < n3; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n3, i2, s2, a;
          for (t2 = n3 = 0, r2 = e2.length; t2 < r2; t2++)
            n3 += e2[t2].length;
          for (a = new Uint8Array(n3), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n3, i2) {
          for (var s2 = 0; s2 < n3; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n2);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n2 = 0; n2 < 256; n2++)
          u[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n3 = 0; n3 < t2; n3++)
            r2 += String.fromCharCode(e2[n3]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n3, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n3 = t2.length; r2 < n3; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n3, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n3 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n3++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n3++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n3++] = 65533 : i2 < 65536 ? o[n3++] = i2 : (i2 -= 65536, o[n3++] = 55296 | i2 >> 10 & 1023, o[n3++] = 56320 | 1023 & i2);
            }
          return l(o, n3);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && (192 & e2[r2]) == 128; )
            r2--;
          return r2 < 0 ? t2 : r2 === 0 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n2) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n2++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n2) {
          var i = o, s = n2 + r2;
          e2 ^= -1;
          for (var a = n2; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n2 = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n2[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, t2.pending === 0 && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n3, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n3 = S - (c2 - s2), s2 = c2 - S, a2 < n3) {
                if (e2.match_start = t2, o2 <= (a2 = n3))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && --i2 != 0);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n3, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n3 = e2.head[--t2], e2.head[t2] = f2 <= n3 ? n3 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n3 = e2.prev[--t2], e2.prev[t2] = f2 <= n3 ? n3 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (e2.strm.avail_in === 0)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), a2.state.wrap === 1 ? a2.adler = d(a2.adler, o2, l2, h2) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && e2.strm.avail_in !== 0);
        }
        function Z(e2, t2) {
          for (var r2, n3; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n3 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, --e2.match_length != 0; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n3 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n3 && (N(e2, false), e2.strm.avail_out === 0))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n3, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n3 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), --e2.prev_length != 0; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n3 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            } else if (e2.match_available) {
              if ((n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
        }
        function M(e2, t2, r2, n3, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n3, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n3, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n3 < 0 ? (a2 = 0, n3 = -n3) : 15 < n3 && (a2 = 2, n3 -= 16), i2 < 1 || y < i2 || r2 !== v || n3 < 8 || 15 < n3 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          n3 === 8 && (n3 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), e2.lookahead === 0 && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n3 = e2.block_start + r2;
            if ((e2.strstart === 0 || e2.strstart >= n3) && (e2.lookahead = e2.strstart - n3, e2.strstart = n3, N(e2, false), e2.strm.avail_out === 0))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), e2.strm.avail_out === 0))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? e2.state.wrap !== 2 ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n3, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n3 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || n3.status === 666 && t2 !== f)
            return R(e2, e2.avail_out === 0 ? -5 : _);
          if (n3.strm = e2, r2 = n3.last_flush, n3.last_flush = t2, n3.status === C)
            if (n3.wrap === 2)
              e2.adler = 0, U(n3, 31), U(n3, 139), U(n3, 8), n3.gzhead ? (U(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U(n3, 255 & n3.gzhead.time), U(n3, n3.gzhead.time >> 8 & 255), U(n3, n3.gzhead.time >> 16 & 255), U(n3, n3.gzhead.time >> 24 & 255), U(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U(n3, 255 & n3.gzhead.extra.length), U(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 3), n3.status = E);
            else {
              var a2 = v + (n3.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : n3.level === 6 ? 2 : 3) << 6, n3.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, n3.status = E, P(n3, a2), n3.strstart !== 0 && (P(n3, e2.adler >>> 16), P(n3, 65535 & e2.adler)), e2.adler = 1;
            }
          if (n3.status === 69)
            if (n3.gzhead.extra) {
              for (i2 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending !== n3.pending_buf_size)); )
                U(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
            } else
              n3.status = 73;
          if (n3.status === 73)
            if (n3.gzhead.name) {
              i2 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U(n3, s2);
              } while (s2 !== 0);
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), s2 === 0 && (n3.gzindex = 0, n3.status = 91);
            } else
              n3.status = 91;
          if (n3.status === 91)
            if (n3.gzhead.comment) {
              i2 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U(n3, s2);
              } while (s2 !== 0);
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), s2 === 0 && (n3.status = 103);
            } else
              n3.status = 103;
          if (n3.status === 103 && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F(e2), n3.pending + 2 <= n3.pending_buf_size && (U(n3, 255 & e2.adler), U(n3, e2.adler >> 8 & 255), e2.adler = 0, n3.status = E)) : n3.status = E), n3.pending !== 0) {
            if (F(e2), e2.avail_out === 0)
              return n3.last_flush = -1, m;
          } else if (e2.avail_in === 0 && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (n3.status === 666 && e2.avail_in !== 0)
            return R(e2, -5);
          if (e2.avail_in !== 0 || n3.lookahead !== 0 || t2 !== l && n3.status !== 666) {
            var o2 = n3.strategy === 2 ? function(e3, t3) {
              for (var r3; ; ) {
                if (e3.lookahead === 0 && (j(e3), e3.lookahead === 0)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), e3.strm.avail_out === 0))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
            }(n3, t2) : n3.strategy === 3 ? function(e3, t3) {
              for (var r3, n4, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (e3.lookahead === 0)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n4 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), e3.strm.avail_out === 0))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
            }(n3, t2) : h[n3.level].func(n3, t2);
            if (o2 !== O && o2 !== B || (n3.status = 666), o2 === A || o2 === O)
              return e2.avail_out === 0 && (n3.last_flush = -1), m;
            if (o2 === I && (t2 === 1 ? u._tr_align(n3) : t2 !== 5 && (u._tr_stored_block(n3, 0, 0, false), t2 === 3 && (D(n3.head), n3.lookahead === 0 && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F(e2), e2.avail_out === 0))
              return n3.last_flush = -1, m;
          }
          return t2 !== f ? m : n3.wrap <= 0 ? 1 : (n3.wrap === 2 ? (U(n3, 255 & e2.adler), U(n3, e2.adler >> 8 & 255), U(n3, e2.adler >> 16 & 255), U(n3, e2.adler >> 24 & 255), U(n3, 255 & e2.total_in), U(n3, e2.total_in >> 8 & 255), U(n3, e2.total_in >> 16 & 255), U(n3, e2.total_in >> 24 & 255)) : (P(n3, e2.adler >>> 16), P(n3, 65535 & e2.adler)), F(e2), 0 < n3.wrap && (n3.wrap = -n3.wrap), n3.pending !== 0 ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && t2 !== 69 && t2 !== 73 && t2 !== 91 && t2 !== 103 && t2 !== E && t2 !== 666 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if ((s2 = (r2 = e2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
            return _;
          for (s2 === 1 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n3 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n3 + x - 1]) & r2.hash_mask, r2.prev[n3 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n3, n3++, --i2; )
              ;
            r2.strstart = n3, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n2, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n2 = e2.next_in, z = e2.input, i = n2 + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n2++] << p, p += 8, d += z[n2++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, (y = v >>> 16 & 255) === 0)
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if ((64 & y) == 0) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n2++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n2++] << p, p += 8, d += z[n2++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if ((64 & y) == 0) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n2++] << p, (p += 8) < y && (d += z[n2++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n2 < i && s < o);
          n2 -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n2, e2.next_out = s, e2.avail_in = n2 < i ? i - n2 + 5 : 5 - (n2 - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n2 = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n2), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n3;
          return e2 && e2.state ? (n3 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (n3.window !== null && n3.wbits !== t2 && (n3.window = null), n3.wrap = r2, n3.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n3;
          return e2 ? (n3 = new s(), (e2.state = n3).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n3) {
          var i2, s2 = e2.state;
          return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n3 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n3 < (i2 = s2.wsize - s2.wnext) && (i2 = n3), I.arraySet(s2.window, t2, r2 - n3, i2, s2.wnext), (n3 -= i2) ? (I.arraySet(s2.window, t2, r2 - n3, n3, 0), s2.wnext = n3, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
            return U;
          (r2 = e2.state).mode === 12 && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n3 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (r2.wrap === 0) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && u2 === 35615) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if ((15 & u2) != 8) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, (255 & r2.flags) != 8) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n3, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (o2 === 0)
                      break e;
                    for (d = 0; k = n3[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (o2 === 0)
                      break e;
                    for (d = 0; k = n3[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (r2.havedict === 0)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (t2 === 5 || t2 === 6)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, t2 !== 6)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, t2 === 6)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), d === 0)
                      break e;
                    I.arraySet(i2, n3, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (b === 16) {
                        for (z = _ + 2; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, r2.have === 0) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (b === 17) {
                        for (z = _ + 3; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (r2.mode === 30)
                    break;
                  if (r2.lens[256] === 0) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, t2 === 6)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n3 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (g && (240 & g) == 0) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, g === 0) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if ((240 & g) == 0) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (h2 === 0)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  r2.length === 0 && (r2.mode = 21);
                  break;
                case 26:
                  if (h2 === 0)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 |= n3[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t2 !== 4)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && c2 === 0 || t2 === 4) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? (2 & (r2 = e2.state).wrap) == 0 ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n3 = t2.length;
          return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, t2, n3, 0) !== r2.check ? -3 : Z(e2, t2, n3, n3) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n2, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n2; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && O[w] === 0; w--)
            ;
          if (w < k && (k = w), w === 0)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && O[y] === 0; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (e2 === 0 || w !== 1))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n2; v++)
            t2[r2 + v] !== 0 && (a[B[t2[r2 + v]]++] = v);
          if (d = e2 === 0 ? (A = R = a, 19) : e2 === 1 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, u !== 0; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (h !== 0 ? (E &= h - 1, E += h) : E = 0, v++, --O[b] == 0) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (S === 0 && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return E !== 0 && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n2(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n2(z);
        var C = new Array(2 * f);
        n2(C);
        var E = new Array(512);
        n2(E);
        var A = new Array(256);
        n2(A);
        var I = new Array(a);
        n2(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n3, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n3, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n3, i2, s2 = new Array(g + 1), a2 = 0;
          for (n3 = 1; n3 <= g; n3++)
            s2[n3] = a2 = a2 + r2[n3 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            o2 !== 0 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n3) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n3[t2] <= n3[r2];
        }
        function G(e2, t2, r2) {
          for (var n3 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n3, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n3;
        }
        function K(e2, t2, r2) {
          var n3, i2, s2, a2, o2 = 0;
          if (e2.last_lit !== 0)
            for (; n3 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, n3 === 0 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), (a2 = w[s2]) !== 0 && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n3), r2), (a2 = k[s2]) !== 0 && P(e2, n3 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n3, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            s2[2 * r2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n3 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n3, s2[2 * i2] = s2[2 * r2] + s2[2 * n3], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n3] ? e2.depth[r2] : e2.depth[n3]) + 1, s2[2 * r2 + 1] = s2[2 * n3 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n4, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n4 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n4 + 1] = s3, u3 < n4 || (e3.bl_count[s3]++, a3 = 0, d2 <= n4 && (a3 = c2[n4 - d2]), o3 = h3[2 * n4], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n4 + 1] + a3)));
            if (m2 !== 0) {
              do {
                for (s3 = p2 - 1; e3.bl_count[s3] === 0; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; s3 !== 0; s3--)
                for (n4 = e3.bl_count[s3]; n4 !== 0; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n4--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n3, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (a2 === 0 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n3 = 0; n3 <= r2; n3++)
            i2 = a2, a2 = t2[2 * (n3 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : i2 !== 0 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n3, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (a2 === 0 && (h2 = 138, u2 = 3), n3 = 0; n3 <= r2; n3++)
            if (i2 = a2, a2 = t2[2 * (n3 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), --o2 != 0; )
                  ;
              else
                i2 !== 0 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n2(T);
        var q = false;
        function J(e2, t2, r2, n3) {
          P(e2, (s << 1) + (n3 ? 1 : 0), 3), function(e3, t3, r3, n4) {
            M(e3), n4 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n3, i2, s2 = new Array(g + 1);
            for (n3 = r2 = 0; n3 < a - 1; n3++)
              for (I[n3] = r2, e3 = 0; e3 < 1 << w[n3]; e3++)
                A[r2++] = n3;
            for (A[r2 - 1] = n3, n3 = i2 = 0; n3 < 16; n3++)
              for (T[n3] = i2, e3 = 0; e3 < 1 << k[n3]; e3++)
                E[i2++] = n3;
            for (i2 >>= 7; n3 < f; n3++)
              for (T[n3] = i2 << 7, e3 = 0; e3 < 1 << k[n3] - 7; e3++)
                E[256 + i2++] = n3;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n3) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && e3.dyn_ltree[2 * t3] !== 0)
                return o;
            if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (e3.dyn_ltree[2 * t3] !== 0)
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && e3.bl_tree[2 * S[t3] + 1] === 0; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && t2 !== -1 ? J(e2, t2, r2, n3) : e2.strategy === 4 || s2 === i2 ? (P(e2, 2 + (n3 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n3 ? 1 : 0), 3), function(e3, t3, r3, n4) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n4 - 4, 4), i3 = 0; i3 < n4; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n3 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            e3.bi_valid === 16 ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n2) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = {}.toString.call(r2.process) === "[object process]" ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                typeof e4 != "function" && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n3 = { callback: e4, args: t3 };
                return h[o] = n3, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n2, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && typeof e4.data == "string" && e4.data.indexOf(a) === 0 && c(+e4.data.slice(a.length));
            }
          }(typeof self == "undefined" ? e2 === void 0 ? this : e2 : self);
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/zipextractor.js
var require_zipextractor = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/zipextractor.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MockZipExtractor = exports2.WebZipExtractor = exports2.JsZipExtractor = void 0;
    exports2.newZipExtractor = newZipExtractor;
    exports2.newMockZipExtractor = newMockZipExtractor;
    var type_1 = require_type2();
    var log_1 = require_log();
    var jszip_1 = __importDefault(require_jszip_min());
    var path6 = __importStar(require("path"));
    var log = (0, log_1.getDomainLogger)("module", { component: "zipextractor" });
    var JsZipExtractor = class {
      constructor(fs5) {
        this.fs = fs5;
      }
      async extract(zipPath, targetDir) {
        try {
          const zipFile = await this.fs.open(zipPath);
          const fileInfo = await zipFile.stat();
          const zipSize = fileInfo.size();
          const buffer = new Uint8Array(zipSize);
          const result = await zipFile.read(buffer);
          await zipFile.close();
          await this.extractZipData(result.buffer, targetDir);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`ZIP extraction failed for ${zipPath}: ${message}`);
          throw new type_1.ModuleError(`ZIP extraction failed: ${message}`, "EXTRACTION_FAILED");
        }
      }
      async list(zipPath) {
        try {
          const zipFile = await this.fs.open(zipPath);
          const fileInfo = await zipFile.stat();
          const buffer = new Uint8Array(fileInfo.size());
          const result = await zipFile.read(buffer);
          await zipFile.close();
          return await this.listZipContents(result.buffer);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`ZIP listing failed: ${message}`, "LIST_FAILED");
        }
      }
      async extractZipData(zipData, targetDir) {
        try {
          await this.fs.mkdirAll(targetDir, 493);
          const zip = new jszip_1.default();
          const zipContent = await zip.loadAsync(zipData);
          const allFiles = [];
          zipContent.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
              allFiles.push(relativePath);
            }
          });
          const promises5 = [];
          let extractedCount = 0;
          zipContent.forEach((relativePath, zipEntry) => {
            promises5.push(this.extractSingleEntry(relativePath, zipEntry, targetDir).then(() => {
              extractedCount++;
            }));
          });
          await Promise.all(promises5);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`Failed to extract ZIP data: ${message}`);
          throw new type_1.ModuleError(`Failed to extract ZIP data: ${message}`, "EXTRACTION_FAILED");
        }
      }
      async extractSingleEntry(relativePath, zipEntry, targetDir) {
        const fullPath = path6.join(targetDir, relativePath);
        if (zipEntry.dir) {
          await this.fs.mkdirAll(fullPath, 493);
        } else {
          const dir = path6.dirname(fullPath);
          if (dir !== targetDir) {
            await this.fs.mkdirAll(dir, 493);
          }
          const content = await zipEntry.async("uint8array");
          const file = await this.fs.create(fullPath);
          await file.write(content);
          await file.close();
        }
      }
      async listZipContents(zipData) {
        try {
          const zip = new jszip_1.default();
          const zipContent = await zip.loadAsync(zipData);
          const paths = [];
          zipContent.forEach((relativePath) => {
            paths.push(relativePath);
          });
          return paths;
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Failed to list ZIP contents: ${message}`, "LIST_FAILED");
        }
      }
    };
    exports2.JsZipExtractor = JsZipExtractor;
    var WebZipExtractor = class {
      constructor(fs5) {
        this.fs = fs5;
      }
      async extract(zipPath, targetDir) {
        try {
          throw new type_1.ModuleError("Web ZIP extraction not implemented", "NOT_IMPLEMENTED");
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Web ZIP extraction failed: ${message}`, "WEB_EXTRACTION_FAILED");
        }
      }
      async list(zipPath) {
        try {
          throw new type_1.ModuleError("Web ZIP listing not implemented", "NOT_IMPLEMENTED");
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Web ZIP listing failed: ${message}`, "WEB_LIST_FAILED");
        }
      }
    };
    exports2.WebZipExtractor = WebZipExtractor;
    var MockZipExtractor = class {
      constructor() {
        this.mockContents = /* @__PURE__ */ new Map();
      }
      setMockContents(zipPath, contents) {
        this.mockContents.set(zipPath, contents);
      }
      async extract(zipPath, targetDir) {
        const contents = this.mockContents.get(zipPath) || this.mockContents.get("/any/path");
        if (!contents) {
          return;
        }
      }
      async list(zipPath) {
        const contents = this.mockContents.get(zipPath) || this.mockContents.get("/any/path");
        if (!contents) {
          return [];
        }
        return [...contents];
      }
    };
    exports2.MockZipExtractor = MockZipExtractor;
    function newZipExtractor(fs5, environment = "node") {
      switch (environment) {
        case "node":
          return new JsZipExtractor(fs5);
        case "browser":
          return new WebZipExtractor(fs5);
        default:
          throw new Error(`Unsupported environment: ${environment}`);
      }
    }
    function newMockZipExtractor() {
      return new MockZipExtractor();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/cache.js
var require_cache = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/cache.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MemoryModuleCache = exports2.FsModuleCache = void 0;
    exports2.newModuleCache = newModuleCache;
    exports2.newMemoryModuleCache = newMemoryModuleCache;
    var type_1 = require_type2();
    var log_1 = require_log();
    var path6 = __importStar(require("path"));
    var log = (0, log_1.getDomainLogger)("module", { component: "cache" });
    var FsModuleCache = class {
      constructor(fs5, cacheDir = "./module/cache") {
        this.fs = fs5;
        this.cacheDir = cacheDir;
      }
      async get(modulePath) {
        try {
          const cacheFile = this.getCacheFilePath(modulePath);
          const file = await this.fs.open(cacheFile);
          const fileInfo = await file.stat();
          const buffer = new Uint8Array(fileInfo.size());
          await file.read(buffer);
          await file.close();
          const content = new TextDecoder().decode(buffer);
          return JSON.parse(content);
        } catch (error) {
          if (error.message?.includes("ENOENT") || error.message?.includes("no such file")) {
            log.error(`Cache miss: ${modulePath}`, error);
            return null;
          }
          const message = error instanceof Error ? error.message : String(error);
          log.error(`Cache read error for ${modulePath}: ${message}`);
          throw new type_1.ModuleError(`Failed to read cache: ${message}`, "CACHE_READ_FAILED");
        }
      }
      async set(modulePath, metadata) {
        try {
          await this.fs.mkdirAll(this.cacheDir, 493);
          const cacheFile = this.getCacheFilePath(modulePath);
          const content = JSON.stringify(metadata, null, 2);
          const buffer = new TextEncoder().encode(content);
          const file = await this.fs.create(cacheFile);
          await file.write(buffer);
          await file.sync();
          await file.close();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`Cache write error for ${modulePath}: ${message}`);
          throw new type_1.ModuleError(`Failed to write cache: ${message}`, "CACHE_WRITE_FAILED");
        }
      }
      async has(modulePath) {
        try {
          const cacheFile = this.getCacheFilePath(modulePath);
          await this.fs.stat(cacheFile);
          return true;
        } catch (error) {
          return false;
        }
      }
      async delete(modulePath) {
        try {
          const cacheFile = this.getCacheFilePath(modulePath);
          await this.fs.remove(cacheFile);
        } catch (error) {
          if (!error.message?.includes("ENOENT") && !error.message?.includes("no such file")) {
            const message = error instanceof Error ? error.message : String(error);
            log.error(`Cache delete error for ${modulePath}: ${message}`);
            throw new type_1.ModuleError(`Failed to delete cache: ${message}`, "CACHE_DELETE_FAILED");
          }
        }
      }
      async clear() {
        try {
          await this.fs.removeAll(this.cacheDir);
        } catch (error) {
          if (!error.message?.includes("ENOENT") && !error.message?.includes("no such file")) {
            const message = error instanceof Error ? error.message : String(error);
            log.error(`Cache clear error: ${message}`);
            throw new type_1.ModuleError(`Failed to clear cache: ${message}`, "CACHE_CLEAR_FAILED");
          }
        }
      }
      getCacheFilePath(modulePath) {
        const safeFileName = modulePath.replace(/[/\\:*?"<>|]/g, "_").replace(/^_+|_+$/g, "") + ".json";
        return path6.join(this.cacheDir, safeFileName);
      }
      getCacheDir() {
        return this.cacheDir;
      }
      async getStats() {
        try {
          const files = await this.listCacheFiles();
          let totalSize = 0;
          for (const file of files) {
            try {
              const filePath = path6.join(this.cacheDir, file);
              const fileInfo = await this.fs.stat(filePath);
              totalSize += fileInfo.size();
            } catch (error) {
            }
          }
          return {
            totalEntries: files.length,
            totalSize
          };
        } catch (error) {
          return {
            totalEntries: 0,
            totalSize: 0
          };
        }
      }
      async listCached() {
        try {
          const files = await this.listCacheFiles();
          return files.map((file) => path6.basename(file, ".json").replace(/_/g, "/"));
        } catch (error) {
          return [];
        }
      }
      async listCacheFiles() {
        try {
          const dir = await this.fs.open(this.cacheDir);
          const files = await dir.readdirnames(-1);
          await dir.close();
          return files.filter((file) => file.endsWith(".json"));
        } catch (error) {
          return [];
        }
      }
    };
    exports2.FsModuleCache = FsModuleCache;
    var MemoryModuleCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      async get(modulePath) {
        const metadata = this.cache.get(modulePath);
        return metadata ? { ...metadata } : null;
      }
      async set(modulePath, metadata) {
        this.cache.set(modulePath, { ...metadata });
      }
      async has(modulePath) {
        return this.cache.has(modulePath);
      }
      async delete(modulePath) {
        this.cache.delete(modulePath);
      }
      async clear() {
        this.cache.clear();
      }
      size() {
        return this.cache.size;
      }
      keys() {
        return Array.from(this.cache.keys());
      }
    };
    exports2.MemoryModuleCache = MemoryModuleCache;
    function newModuleCache(fs5, cacheDir) {
      return new FsModuleCache(fs5, cacheDir);
    }
    function newMemoryModuleCache() {
      return new MemoryModuleCache();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/module.js
var require_module3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/module.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectModule = exports2.Module = void 0;
    exports2.newModule = newModule;
    exports2.newProjectModule = newProjectModule;
    var type_1 = require_type2();
    var mount_1 = require_mount();
    var path6 = __importStar(require("path"));
    var Module = class {
      constructor(fs5, absoluteDir, modulePath, parent = null, isProject = false) {
        this.fs = fs5;
        this.isProject = false;
        this.absoluteDir = absoluteDir;
        this.modulePath = modulePath;
        this.parentModule = parent;
        this.mountDirs = [];
        this.metadata = null;
        this.isProject = isProject;
      }
      isProjectModule() {
        return this.isProject;
      }
      owner() {
        return this.parentModule;
      }
      mounts() {
        return this.mountDirs.map((mount) => mount);
      }
      dir() {
        return this.absoluteDir;
      }
      path() {
        return this.modulePath;
      }
      setMetadata(metadata) {
        this.metadata = metadata;
      }
      getMetadata() {
        return this.metadata;
      }
      async applyMounts(moduleImport) {
        try {
          let mounts = moduleImport.mounts || [];
          if (mounts.length === 0) {
            for (const componentFolder of type_1.ComponentFolders) {
              const sourceDir = path6.join(this.absoluteDir, componentFolder);
              try {
                const stat = await this.fs.stat(sourceDir);
                if (stat.isDir()) {
                  mounts.push({
                    sourcePath: componentFolder,
                    targetPath: componentFolder
                  });
                }
              } catch (error) {
              }
            }
          }
          this.mountDirs = mounts.map((mountConfig) => (0, mount_1.newMount)(mountConfig.sourcePath, mountConfig.targetPath));
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Failed to apply mounts: ${message}`, "MOUNT_FAILED");
        }
      }
      appendMount(mount) {
        this.mountDirs.push(mount);
      }
      removeMount(mount) {
        const index = this.mountDirs.findIndex((m) => m.equals(mount));
        if (index >= 0) {
          this.mountDirs.splice(index, 1);
          return true;
        }
        return false;
      }
      getMountByTarget(targetPath) {
        return this.mountDirs.find((mount) => mount.target() === targetPath) || null;
      }
      getMountsByComponent(component) {
        return this.mountDirs.filter((mount) => mount.component() === component);
      }
      isDownloaded() {
        return this.metadata?.downloadStatus === type_1.DownloadStatus.COMPLETED;
      }
      isDownloading() {
        return this.metadata?.downloadStatus === type_1.DownloadStatus.DOWNLOADING;
      }
      isDownloadFailed() {
        return this.metadata?.downloadStatus === type_1.DownloadStatus.FAILED;
      }
      async exists() {
        try {
          const stat = await this.fs.stat(this.absoluteDir);
          return stat.isDir();
        } catch (error) {
          return false;
        }
      }
      copy() {
        const copy = new Module(this.fs, this.absoluteDir, this.modulePath, this.parentModule, this.isProject);
        copy.mountDirs = this.mountDirs.map((mount) => mount.copy());
        copy.metadata = this.metadata ? { ...this.metadata } : null;
        return copy;
      }
      toString() {
        return `Module{path: ${this.modulePath}, dir: ${this.absoluteDir}, mounts: ${this.mountDirs.length}}`;
      }
    };
    exports2.Module = Module;
    var ProjectModule = class {
      constructor(module3) {
        this.module = module3;
      }
      getModule() {
        return this.module;
      }
      appendMount(mount) {
        this.module.appendMount(mount);
      }
      setDefaultLanguage(lang) {
        const mounts = this.module.mounts();
        for (const mount of mounts) {
          if (mount instanceof mount_1.Mount) {
            mount.setLanguage(lang);
          }
        }
      }
      applyDefaultMounts() {
        const defaultMounts = (0, mount_1.createDefaultMounts)(type_1.ComponentFolders);
        for (const mount of defaultMounts) {
          this.module.appendMount(mount);
        }
      }
      owner() {
        return this.module.owner();
      }
      mounts() {
        return this.module.mounts();
      }
      dir() {
        return this.module.dir();
      }
      path() {
        return this.module.path();
      }
    };
    exports2.ProjectModule = ProjectModule;
    function newModule(fs5, absoluteDir, modulePath, parent) {
      return new Module(fs5, absoluteDir, modulePath, parent || null, false);
    }
    function newProjectModule(info) {
      const fs5 = info.osFs();
      const absoluteDir = info.projDir();
      const modulePath = "project-root";
      const defaultLanguage = info.defaultLanguageKey();
      const module3 = new Module(fs5, absoluteDir, modulePath, null, true);
      const projectModule = new ProjectModule(module3);
      projectModule.applyDefaultMounts();
      if (defaultLanguage) {
        projectModule.setDefaultLanguage(defaultLanguage);
      }
      const otherLanguageKeys = info.otherLanguageKeys();
      for (const langKey of otherLanguageKeys) {
        try {
          const dir = info.getRelDir(type_1.ComponentFolderContent, langKey);
          if (dir && dir !== "") {
            const mount = new mount_1.Mount(dir, type_1.ComponentFolderContent, langKey);
            projectModule.appendMount(mount);
          }
        } catch (error) {
          console.warn(`Failed to get relative directory for language ${langKey}:`, error);
        }
      }
      return projectModule;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/entity/lang.js
var require_lang2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/entity/lang.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lang = void 0;
    exports2.newLang = newLang;
    var path_1 = __importDefault(require("path"));
    var Lang = class {
      constructor(modules) {
        this.sourceLangMap = /* @__PURE__ */ new Map();
        for (const module3 of modules) {
          for (const mount of module3.mounts()) {
            this.sourceLangMap.set(mount.source(), mount.lang());
          }
        }
      }
      getSourceLang(source) {
        const lang = this.sourceLangMap.get(path_1.default.basename(source));
        if (lang !== void 0) {
          return [lang, true];
        }
        return ["", false];
      }
    };
    exports2.Lang = Lang;
    function newLang(modules) {
      return new Lang(modules);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/themes.js
var require_themes = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/vo/themes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Themes = void 0;
    var Themes = class {
      constructor(themes) {
        this.themes = themes;
      }
      static fromJson(json) {
        return new Themes(json);
      }
      findThemeByUrl(targetUrl) {
        const baseUrl = this.extractBaseUrl(targetUrl);
        for (const theme of this.themes) {
          const themeBaseUrl = this.extractBaseUrl(theme.download_url);
          if (baseUrl === themeBaseUrl) {
            return theme;
          }
        }
        return null;
      }
      resolveLatestVersion(importPath) {
        const theme = this.findThemeByUrl(importPath);
        if (theme) {
          return theme.download_url;
        }
        return importPath;
      }
      extractBaseUrl(url) {
        try {
          const urlObj = new URL(url);
          urlObj.searchParams.delete("version");
          return urlObj.toString();
        } catch (error) {
          const questionMarkIndex = url.indexOf("?");
          if (questionMarkIndex === -1) {
            return url;
          }
          const baseUrl = url.substring(0, questionMarkIndex);
          const searchParams = new URLSearchParams(url.substring(questionMarkIndex + 1));
          searchParams.delete("version");
          const remainingParams = searchParams.toString();
          return remainingParams ? `${baseUrl}?${remainingParams}` : baseUrl;
        }
      }
      getAllThemes() {
        return [...this.themes];
      }
      getThemeByName(name) {
        return this.themes.find((theme) => theme.name.toLowerCase() === name.toLowerCase()) || null;
      }
      getThemesByTag(tag) {
        return this.themes.filter((theme) => theme.tags.some((t) => t.toLowerCase() === tag.toLowerCase()));
      }
    };
    exports2.Themes = Themes;
  }
});

// node_modules/smol-toml/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/smol-toml/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      TomlDate: () => TomlDate,
      TomlError: () => TomlError,
      default: () => index_default,
      parse: () => parse2,
      stringify: () => stringify
    });
    module2.exports = __toCommonJS2(index_exports);
    function getLineColFromPtr(string, ptr) {
      let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
      return [lines.length, lines.pop().length + 1];
    }
    function makeCodeBlock(string, line, column) {
      let lines = string.split(/\r\n|\n|\r/g);
      let codeblock = "";
      let numberLen = (Math.log10(line + 1) | 0) + 1;
      for (let i = line - 1; i <= line + 1; i++) {
        let l = lines[i - 1];
        if (!l)
          continue;
        codeblock += i.toString().padEnd(numberLen, " ");
        codeblock += ":  ";
        codeblock += l;
        codeblock += "\n";
        if (i === line) {
          codeblock += " ".repeat(numberLen + column + 2);
          codeblock += "^\n";
        }
      }
      return codeblock;
    }
    var TomlError = class extends Error {
      constructor(message, options) {
        const [line, column] = getLineColFromPtr(options.toml, options.ptr);
        const codeblock = makeCodeBlock(options.toml, line, column);
        super(`Invalid TOML document: ${message}

${codeblock}`, options);
        __publicField(this, "line");
        __publicField(this, "column");
        __publicField(this, "codeblock");
        this.line = line;
        this.column = column;
        this.codeblock = codeblock;
      }
    };
    function indexOfNewline(str, start = 0, end = str.length) {
      let idx = str.indexOf("\n", start);
      if (str[idx - 1] === "\r")
        idx--;
      return idx <= end ? idx : -1;
    }
    function skipComment(str, ptr) {
      for (let i = ptr; i < str.length; i++) {
        let c = str[i];
        if (c === "\n")
          return i;
        if (c === "\r" && str[i + 1] === "\n")
          return i + 1;
        if (c < " " && c !== "	" || c === "\x7F") {
          throw new TomlError("control characters are not allowed in comments", {
            toml: str,
            ptr
          });
        }
      }
      return str.length;
    }
    function skipVoid(str, ptr, banNewLines, banComments) {
      let c;
      while ((c = str[ptr]) === " " || c === "	" || !banNewLines && (c === "\n" || c === "\r" && str[ptr + 1] === "\n"))
        ptr++;
      return banComments || c !== "#" ? ptr : skipVoid(str, skipComment(str, ptr), banNewLines);
    }
    function skipUntil(str, ptr, sep2, end, banNewLines = false) {
      if (!end) {
        ptr = indexOfNewline(str, ptr);
        return ptr < 0 ? str.length : ptr;
      }
      for (let i = ptr; i < str.length; i++) {
        let c = str[i];
        if (c === "#") {
          i = indexOfNewline(str, i);
        } else if (c === sep2) {
          return i + 1;
        } else if (c === end || banNewLines && (c === "\n" || c === "\r" && str[i + 1] === "\n")) {
          return i;
        }
      }
      throw new TomlError("cannot find end of structure", {
        toml: str,
        ptr
      });
    }
    function getStringEnd(str, seek) {
      let first = str[seek];
      let target = first === str[seek + 1] && str[seek + 1] === str[seek + 2] ? str.slice(seek, seek + 3) : first;
      seek += target.length - 1;
      do
        seek = str.indexOf(target, ++seek);
      while (seek > -1 && first !== "'" && str[seek - 1] === "\\" && (str[seek - 2] !== "\\" || str[seek - 3] === "\\"));
      if (seek > -1) {
        seek += target.length;
        if (target.length > 1) {
          if (str[seek] === first)
            seek++;
          if (str[seek] === first)
            seek++;
        }
      }
      return seek;
    }
    var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
    var _hasDate, _hasTime, _offset, _a;
    var TomlDate = (_a = class extends Date {
      constructor(date) {
        let hasDate = true;
        let hasTime = true;
        let offset = "Z";
        if (typeof date === "string") {
          let match = date.match(DATE_TIME_RE);
          if (match) {
            if (!match[1]) {
              hasDate = false;
              date = `0000-01-01T${date}`;
            }
            hasTime = !!match[2];
            hasTime && date[10] === " " && (date = date.replace(" ", "T"));
            if (match[2] && +match[2] > 23) {
              date = "";
            } else {
              offset = match[3] || null;
              date = date.toUpperCase();
              if (!offset && hasTime)
                date += "Z";
            }
          } else {
            date = "";
          }
        }
        super(date);
        __privateAdd(this, _hasDate, false);
        __privateAdd(this, _hasTime, false);
        __privateAdd(this, _offset, null);
        if (!isNaN(this.getTime())) {
          __privateSet(this, _hasDate, hasDate);
          __privateSet(this, _hasTime, hasTime);
          __privateSet(this, _offset, offset);
        }
      }
      isDateTime() {
        return __privateGet(this, _hasDate) && __privateGet(this, _hasTime);
      }
      isLocal() {
        return !__privateGet(this, _hasDate) || !__privateGet(this, _hasTime) || !__privateGet(this, _offset);
      }
      isDate() {
        return __privateGet(this, _hasDate) && !__privateGet(this, _hasTime);
      }
      isTime() {
        return __privateGet(this, _hasTime) && !__privateGet(this, _hasDate);
      }
      isValid() {
        return __privateGet(this, _hasDate) || __privateGet(this, _hasTime);
      }
      toISOString() {
        let iso = super.toISOString();
        if (this.isDate())
          return iso.slice(0, 10);
        if (this.isTime())
          return iso.slice(11, 23);
        if (__privateGet(this, _offset) === null)
          return iso.slice(0, -1);
        if (__privateGet(this, _offset) === "Z")
          return iso;
        let offset = +__privateGet(this, _offset).slice(1, 3) * 60 + +__privateGet(this, _offset).slice(4, 6);
        offset = __privateGet(this, _offset)[0] === "-" ? offset : -offset;
        let offsetDate = new Date(this.getTime() - offset * 6e4);
        return offsetDate.toISOString().slice(0, -1) + __privateGet(this, _offset);
      }
      static wrapAsOffsetDateTime(jsDate, offset = "Z") {
        let date = new _a(jsDate);
        __privateSet(date, _offset, offset);
        return date;
      }
      static wrapAsLocalDateTime(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _offset, null);
        return date;
      }
      static wrapAsLocalDate(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _hasTime, false);
        __privateSet(date, _offset, null);
        return date;
      }
      static wrapAsLocalTime(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _hasDate, false);
        __privateSet(date, _offset, null);
        return date;
      }
    }, _hasDate = new WeakMap(), _hasTime = new WeakMap(), _offset = new WeakMap(), _a);
    var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
    var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
    var LEADING_ZERO = /^[+-]?0[0-9_]/;
    var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
    var ESC_MAP = {
      b: "\b",
      t: "	",
      n: "\n",
      f: "\f",
      r: "\r",
      '"': '"',
      "\\": "\\"
    };
    function parseString(str, ptr = 0, endPtr = str.length) {
      let isLiteral = str[ptr] === "'";
      let isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];
      if (isMultiline) {
        endPtr -= 2;
        if (str[ptr += 2] === "\r")
          ptr++;
        if (str[ptr] === "\n")
          ptr++;
      }
      let tmp = 0;
      let isEscape;
      let parsed = "";
      let sliceStart = ptr;
      while (ptr < endPtr - 1) {
        let c = str[ptr++];
        if (c === "\n" || c === "\r" && str[ptr] === "\n") {
          if (!isMultiline) {
            throw new TomlError("newlines are not allowed in strings", {
              toml: str,
              ptr: ptr - 1
            });
          }
        } else if (c < " " && c !== "	" || c === "\x7F") {
          throw new TomlError("control characters are not allowed in strings", {
            toml: str,
            ptr: ptr - 1
          });
        }
        if (isEscape) {
          isEscape = false;
          if (c === "u" || c === "U") {
            let code = str.slice(ptr, ptr += c === "u" ? 4 : 8);
            if (!ESCAPE_REGEX.test(code)) {
              throw new TomlError("invalid unicode escape", {
                toml: str,
                ptr: tmp
              });
            }
            try {
              parsed += String.fromCodePoint(parseInt(code, 16));
            } catch {
              throw new TomlError("invalid unicode escape", {
                toml: str,
                ptr: tmp
              });
            }
          } else if (isMultiline && (c === "\n" || c === " " || c === "	" || c === "\r")) {
            ptr = skipVoid(str, ptr - 1, true);
            if (str[ptr] !== "\n" && str[ptr] !== "\r") {
              throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
                toml: str,
                ptr: tmp
              });
            }
            ptr = skipVoid(str, ptr);
          } else if (c in ESC_MAP) {
            parsed += ESC_MAP[c];
          } else {
            throw new TomlError("unrecognized escape sequence", {
              toml: str,
              ptr: tmp
            });
          }
          sliceStart = ptr;
        } else if (!isLiteral && c === "\\") {
          tmp = ptr - 1;
          isEscape = true;
          parsed += str.slice(sliceStart, tmp);
        }
      }
      return parsed + str.slice(sliceStart, endPtr - 1);
    }
    function parseValue(value2, toml, ptr, integersAsBigInt) {
      if (value2 === "true")
        return true;
      if (value2 === "false")
        return false;
      if (value2 === "-inf")
        return -Infinity;
      if (value2 === "inf" || value2 === "+inf")
        return Infinity;
      if (value2 === "nan" || value2 === "+nan" || value2 === "-nan")
        return NaN;
      if (value2 === "-0")
        return integersAsBigInt ? 0n : 0;
      let isInt2 = INT_REGEX.test(value2);
      if (isInt2 || FLOAT_REGEX.test(value2)) {
        if (LEADING_ZERO.test(value2)) {
          throw new TomlError("leading zeroes are not allowed", {
            toml,
            ptr
          });
        }
        value2 = value2.replace(/_/g, "");
        let numeric = +value2;
        if (isNaN(numeric)) {
          throw new TomlError("invalid number", {
            toml,
            ptr
          });
        }
        if (isInt2) {
          if ((isInt2 = !Number.isSafeInteger(numeric)) && !integersAsBigInt) {
            throw new TomlError("integer value cannot be represented losslessly", {
              toml,
              ptr
            });
          }
          if (isInt2 || integersAsBigInt === true)
            numeric = BigInt(value2);
        }
        return numeric;
      }
      const date = new TomlDate(value2);
      if (!date.isValid()) {
        throw new TomlError("invalid value", {
          toml,
          ptr
        });
      }
      return date;
    }
    function sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {
      let value2 = str.slice(startPtr, endPtr);
      let commentIdx = value2.indexOf("#");
      if (commentIdx > -1) {
        skipComment(str, commentIdx);
        value2 = value2.slice(0, commentIdx);
      }
      let trimmed = value2.trimEnd();
      if (!allowNewLines) {
        let newlineIdx = value2.indexOf("\n", trimmed.length);
        if (newlineIdx > -1) {
          throw new TomlError("newlines are not allowed in inline tables", {
            toml: str,
            ptr: startPtr + newlineIdx
          });
        }
      }
      return [trimmed, commentIdx];
    }
    function extractValue(str, ptr, end, depth, integersAsBigInt) {
      if (depth === 0) {
        throw new TomlError("document contains excessively nested structures. aborting.", {
          toml: str,
          ptr
        });
      }
      let c = str[ptr];
      if (c === "[" || c === "{") {
        let [value2, endPtr2] = c === "[" ? parseArray(str, ptr, depth, integersAsBigInt) : parseInlineTable(str, ptr, depth, integersAsBigInt);
        let newPtr = end ? skipUntil(str, endPtr2, ",", end) : endPtr2;
        if (endPtr2 - newPtr && end === "}") {
          let nextNewLine = indexOfNewline(str, endPtr2, newPtr);
          if (nextNewLine > -1) {
            throw new TomlError("newlines are not allowed in inline tables", {
              toml: str,
              ptr: nextNewLine
            });
          }
        }
        return [value2, newPtr];
      }
      let endPtr;
      if (c === '"' || c === "'") {
        endPtr = getStringEnd(str, ptr);
        let parsed = parseString(str, ptr, endPtr);
        if (end) {
          endPtr = skipVoid(str, endPtr, end !== "]");
          if (str[endPtr] && str[endPtr] !== "," && str[endPtr] !== end && str[endPtr] !== "\n" && str[endPtr] !== "\r") {
            throw new TomlError("unexpected character encountered", {
              toml: str,
              ptr: endPtr
            });
          }
          endPtr += +(str[endPtr] === ",");
        }
        return [parsed, endPtr];
      }
      endPtr = skipUntil(str, ptr, ",", end);
      let slice = sliceAndTrimEndOf(str, ptr, endPtr - +(str[endPtr - 1] === ","), end === "]");
      if (!slice[0]) {
        throw new TomlError("incomplete key-value declaration: no value specified", {
          toml: str,
          ptr
        });
      }
      if (end && slice[1] > -1) {
        endPtr = skipVoid(str, ptr + slice[1]);
        endPtr += +(str[endPtr] === ",");
      }
      return [
        parseValue(slice[0], str, ptr, integersAsBigInt),
        endPtr
      ];
    }
    var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
    function parseKey(str, ptr, end = "=") {
      let dot = ptr - 1;
      let parsed = [];
      let endPtr = str.indexOf(end, ptr);
      if (endPtr < 0) {
        throw new TomlError("incomplete key-value: cannot find end of key", {
          toml: str,
          ptr
        });
      }
      do {
        let c = str[ptr = ++dot];
        if (c !== " " && c !== "	") {
          if (c === '"' || c === "'") {
            if (c === str[ptr + 1] && c === str[ptr + 2]) {
              throw new TomlError("multiline strings are not allowed in keys", {
                toml: str,
                ptr
              });
            }
            let eos = getStringEnd(str, ptr);
            if (eos < 0) {
              throw new TomlError("unfinished string encountered", {
                toml: str,
                ptr
              });
            }
            dot = str.indexOf(".", eos);
            let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);
            let newLine = indexOfNewline(strEnd);
            if (newLine > -1) {
              throw new TomlError("newlines are not allowed in keys", {
                toml: str,
                ptr: ptr + dot + newLine
              });
            }
            if (strEnd.trimStart()) {
              throw new TomlError("found extra tokens after the string part", {
                toml: str,
                ptr: eos
              });
            }
            if (endPtr < eos) {
              endPtr = str.indexOf(end, eos);
              if (endPtr < 0) {
                throw new TomlError("incomplete key-value: cannot find end of key", {
                  toml: str,
                  ptr
                });
              }
            }
            parsed.push(parseString(str, ptr, eos));
          } else {
            dot = str.indexOf(".", ptr);
            let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
            if (!KEY_PART_RE.test(part)) {
              throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
                toml: str,
                ptr
              });
            }
            parsed.push(part.trimEnd());
          }
        }
      } while (dot + 1 && dot < endPtr);
      return [parsed, skipVoid(str, endPtr + 1, true, true)];
    }
    function parseInlineTable(str, ptr, depth, integersAsBigInt) {
      let res = {};
      let seen = /* @__PURE__ */ new Set();
      let c;
      let comma = 0;
      ptr++;
      while ((c = str[ptr++]) !== "}" && c) {
        let err = { toml: str, ptr: ptr - 1 };
        if (c === "\n") {
          throw new TomlError("newlines are not allowed in inline tables", err);
        } else if (c === "#") {
          throw new TomlError("inline tables cannot contain comments", err);
        } else if (c === ",") {
          throw new TomlError("expected key-value, found comma", err);
        } else if (c !== " " && c !== "	") {
          let k;
          let t = res;
          let hasOwn = false;
          let [key, keyEndPtr] = parseKey(str, ptr - 1);
          for (let i = 0; i < key.length; i++) {
            if (i)
              t = hasOwn ? t[k] : t[k] = {};
            k = key[i];
            if ((hasOwn = Object.hasOwn(t, k)) && (typeof t[k] !== "object" || seen.has(t[k]))) {
              throw new TomlError("trying to redefine an already defined value", {
                toml: str,
                ptr
              });
            }
            if (!hasOwn && k === "__proto__") {
              Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
            }
          }
          if (hasOwn) {
            throw new TomlError("trying to redefine an already defined value", {
              toml: str,
              ptr
            });
          }
          let [value2, valueEndPtr] = extractValue(str, keyEndPtr, "}", depth - 1, integersAsBigInt);
          seen.add(value2);
          t[k] = value2;
          ptr = valueEndPtr;
          comma = str[ptr - 1] === "," ? ptr - 1 : 0;
        }
      }
      if (comma) {
        throw new TomlError("trailing commas are not allowed in inline tables", {
          toml: str,
          ptr: comma
        });
      }
      if (!c) {
        throw new TomlError("unfinished table encountered", {
          toml: str,
          ptr
        });
      }
      return [res, ptr];
    }
    function parseArray(str, ptr, depth, integersAsBigInt) {
      let res = [];
      let c;
      ptr++;
      while ((c = str[ptr++]) !== "]" && c) {
        if (c === ",") {
          throw new TomlError("expected value, found comma", {
            toml: str,
            ptr: ptr - 1
          });
        } else if (c === "#")
          ptr = skipComment(str, ptr);
        else if (c !== " " && c !== "	" && c !== "\n" && c !== "\r") {
          let e = extractValue(str, ptr - 1, "]", depth - 1, integersAsBigInt);
          res.push(e[0]);
          ptr = e[1];
        }
      }
      if (!c) {
        throw new TomlError("unfinished array encountered", {
          toml: str,
          ptr
        });
      }
      return [res, ptr];
    }
    function peekTable(key, table, meta, type) {
      let t = table;
      let m = meta;
      let k;
      let hasOwn = false;
      let state;
      for (let i = 0; i < key.length; i++) {
        if (i) {
          t = hasOwn ? t[k] : t[k] = {};
          m = (state = m[k]).c;
          if (type === 0 && (state.t === 1 || state.t === 2)) {
            return null;
          }
          if (state.t === 2) {
            let l = t.length - 1;
            t = t[l];
            m = m[l].c;
          }
        }
        k = key[i];
        if ((hasOwn = Object.hasOwn(t, k)) && m[k]?.t === 0 && m[k]?.d) {
          return null;
        }
        if (!hasOwn) {
          if (k === "__proto__") {
            Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
            Object.defineProperty(m, k, { enumerable: true, configurable: true, writable: true });
          }
          m[k] = {
            t: i < key.length - 1 && type === 2 ? 3 : type,
            d: false,
            i: 0,
            c: {}
          };
        }
      }
      state = m[k];
      if (state.t !== type && !(type === 1 && state.t === 3)) {
        return null;
      }
      if (type === 2) {
        if (!state.d) {
          state.d = true;
          t[k] = [];
        }
        t[k].push(t = {});
        state.c[state.i++] = state = { t: 1, d: false, i: 0, c: {} };
      }
      if (state.d) {
        return null;
      }
      state.d = true;
      if (type === 1) {
        t = hasOwn ? t[k] : t[k] = {};
      } else if (type === 0 && hasOwn) {
        return null;
      }
      return [k, t, state.c];
    }
    function parse2(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
      let res = {};
      let meta = {};
      let tbl = res;
      let m = meta;
      for (let ptr = skipVoid(toml, 0); ptr < toml.length; ) {
        if (toml[ptr] === "[") {
          let isTableArray = toml[++ptr] === "[";
          let k = parseKey(toml, ptr += +isTableArray, "]");
          if (isTableArray) {
            if (toml[k[1] - 1] !== "]") {
              throw new TomlError("expected end of table declaration", {
                toml,
                ptr: k[1] - 1
              });
            }
            k[1]++;
          }
          let p = peekTable(k[0], res, meta, isTableArray ? 2 : 1);
          if (!p) {
            throw new TomlError("trying to redefine an already defined table or value", {
              toml,
              ptr
            });
          }
          m = p[2];
          tbl = p[1];
          ptr = k[1];
        } else {
          let k = parseKey(toml, ptr);
          let p = peekTable(k[0], tbl, m, 0);
          if (!p) {
            throw new TomlError("trying to redefine an already defined table or value", {
              toml,
              ptr
            });
          }
          let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
          p[1][p[0]] = v[0];
          ptr = v[1];
        }
        ptr = skipVoid(toml, ptr, true);
        if (toml[ptr] && toml[ptr] !== "\n" && toml[ptr] !== "\r") {
          throw new TomlError("each key-value declaration must be followed by an end-of-line", {
            toml,
            ptr
          });
        }
        ptr = skipVoid(toml, ptr);
      }
      return res;
    }
    var BARE_KEY = /^[a-z0-9-_]+$/i;
    function extendedTypeOf(obj) {
      let type = typeof obj;
      if (type === "object") {
        if (Array.isArray(obj))
          return "array";
        if (obj instanceof Date)
          return "date";
      }
      return type;
    }
    function isArrayOfTables(obj) {
      for (let i = 0; i < obj.length; i++) {
        if (extendedTypeOf(obj[i]) !== "object")
          return false;
      }
      return obj.length != 0;
    }
    function formatString(s) {
      return JSON.stringify(s).replace(/\x7f/g, "\\u007f");
    }
    function stringifyValue(val, type, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      if (type === "number") {
        if (isNaN(val))
          return "nan";
        if (val === Infinity)
          return "inf";
        if (val === -Infinity)
          return "-inf";
        if (numberAsFloat && Number.isInteger(val))
          return val.toFixed(1);
        return val.toString();
      }
      if (type === "bigint" || type === "boolean") {
        return val.toString();
      }
      if (type === "string") {
        return formatString(val);
      }
      if (type === "date") {
        if (isNaN(val.getTime())) {
          throw new TypeError("cannot serialize invalid date");
        }
        return val.toISOString();
      }
      if (type === "object") {
        return stringifyInlineTable(val, depth, numberAsFloat);
      }
      if (type === "array") {
        return stringifyArray(val, depth, numberAsFloat);
      }
    }
    function stringifyInlineTable(obj, depth, numberAsFloat) {
      let keys = Object.keys(obj);
      if (keys.length === 0)
        return "{}";
      let res = "{ ";
      for (let i = 0; i < keys.length; i++) {
        let k = keys[i];
        if (i)
          res += ", ";
        res += BARE_KEY.test(k) ? k : formatString(k);
        res += " = ";
        res += stringifyValue(obj[k], extendedTypeOf(obj[k]), depth - 1, numberAsFloat);
      }
      return res + " }";
    }
    function stringifyArray(array, depth, numberAsFloat) {
      if (array.length === 0)
        return "[]";
      let res = "[ ";
      for (let i = 0; i < array.length; i++) {
        if (i)
          res += ", ";
        if (array[i] === null || array[i] === void 0) {
          throw new TypeError("arrays cannot contain null or undefined values");
        }
        res += stringifyValue(array[i], extendedTypeOf(array[i]), depth - 1, numberAsFloat);
      }
      return res + " ]";
    }
    function stringifyArrayTable(array, key, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      let res = "";
      for (let i = 0; i < array.length; i++) {
        res += `[[${key}]]
`;
        res += stringifyTable(array[i], key, depth, numberAsFloat);
        res += "\n\n";
      }
      return res;
    }
    function stringifyTable(obj, prefix, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      let preamble = "";
      let tables = "";
      let keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        let k = keys[i];
        if (obj[k] !== null && obj[k] !== void 0) {
          let type = extendedTypeOf(obj[k]);
          if (type === "symbol" || type === "function") {
            throw new TypeError(`cannot serialize values of type '${type}'`);
          }
          let key = BARE_KEY.test(k) ? k : formatString(k);
          if (type === "array" && isArrayOfTables(obj[k])) {
            tables += stringifyArrayTable(obj[k], prefix ? `${prefix}.${key}` : key, depth - 1, numberAsFloat);
          } else if (type === "object") {
            let tblKey = prefix ? `${prefix}.${key}` : key;
            tables += `[${tblKey}]
`;
            tables += stringifyTable(obj[k], tblKey, depth - 1, numberAsFloat);
            tables += "\n\n";
          } else {
            preamble += key;
            preamble += " = ";
            preamble += stringifyValue(obj[k], type, depth, numberAsFloat);
            preamble += "\n";
          }
        }
      }
      return `${preamble}
${tables}`.trim();
    }
    function stringify(obj, { maxDepth = 1e3, numbersAsFloat = false } = {}) {
      if (extendedTypeOf(obj) !== "object") {
        throw new TypeError("stringify can only be called with an object");
      }
      return stringifyTable(obj, "", maxDepth, numbersAsFloat);
    }
    var index_default = { parse: parse2, stringify, TomlDate, TomlError };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/entity/module.js
var require_module4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/entity/module.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Modules = void 0;
    exports2.newModules = newModules;
    var type_1 = require_type2();
    var module_1 = require_module3();
    var lang_1 = require_lang2();
    var themes_1 = require_themes();
    var log_1 = require_log();
    var smol_toml_1 = require_dist();
    var path6 = __importStar(require("path"));
    var log = (0, log_1.getDomainLogger)("module", { component: "modules" });
    var Modules = class {
      constructor(info, httpClient, zipExtractor, moduleCache) {
        this.info = info;
        this.httpClient = httpClient;
        this.zipExtractor = zipExtractor;
        this.moduleCache = moduleCache;
        this.modules = [];
        this.downloadedModules = /* @__PURE__ */ new Set();
        this.themes = null;
        this.projectModule = (0, module_1.newProjectModule)(this.info);
        this.lang = (0, lang_1.newLang)(this.all());
      }
      proj() {
        return this.projectModule.getModule();
      }
      all() {
        const modules = [this.projectModule.getModule()];
        modules.push(...this.modules);
        return modules;
      }
      isProjMod(mod) {
        return mod === this.projectModule.getModule();
      }
      async load(onProgress) {
        const importPaths = this.info.importPaths();
        if (importPaths.length === 0) {
          log.warn("No import paths configured - no modules will be downloaded");
          return;
        }
        for (let i = 0; i < importPaths.length; i++) {
          const originalImportPath = importPaths[i];
          const { cleanUrl, version } = this.parseVersionFromImportPath(originalImportPath);
          let resolvedImportPath = originalImportPath;
          if (version === "latest") {
            resolvedImportPath = await this.resolveLatestVersion(originalImportPath);
          }
          if (!this.downloadedModules.has(resolvedImportPath)) {
            await this.addModule(this.projectModule.getModule(), resolvedImportPath, (downloadProgress) => {
              onProgress?.({
                modulePath: resolvedImportPath,
                downloadPercentage: downloadProgress.percentage
              });
            });
          } else {
            log.info(`Module already downloaded: ${resolvedImportPath}`);
          }
        }
      }
      parseVersionFromImportPath(importPath) {
        try {
          const url = new URL(importPath);
          const version = url.searchParams.get("version") || "latest";
          url.searchParams.delete("version");
          const cleanUrl = url.toString();
          return { cleanUrl, version };
        } catch (error) {
          log.warn(`Failed to parse import path ${importPath}:`, error);
          return { cleanUrl: importPath, version: "latest" };
        }
      }
      async resolveLatestVersion(importPath) {
        const { version } = this.parseVersionFromImportPath(importPath);
        if (version !== "latest") {
          return importPath;
        }
        try {
          log.info("Fetching latest theme versions from themes.json...");
          if (!this.themes) {
            const response = await this.httpClient.get("https://gohugo.net/themes.json");
            const responseText = new TextDecoder().decode(response.data);
            const themesData = JSON.parse(responseText);
            this.themes = themes_1.Themes.fromJson(themesData);
          }
          const resolvedPath = this.themes.resolveLatestVersion(importPath);
          if (resolvedPath !== importPath) {
            log.info(`Resolved latest version: ${importPath} -> ${resolvedPath}`);
          } else {
            log.warn(`Could not resolve latest version for ${importPath}, using original path`);
          }
          return resolvedPath;
        } catch (error) {
          log.error(`Failed to resolve latest version for ${importPath}:`, error);
          return importPath;
        }
      }
      async downloadModule(moduleImport, onProgress) {
        try {
          const cachedMetadata = await this.moduleCache.get(moduleImport.path);
          if (cachedMetadata && cachedMetadata.downloadStatus === type_1.DownloadStatus.COMPLETED && this.isCacheValidForVersion(cachedMetadata.version, moduleImport.version)) {
            const module3 = await this.createModuleFromCache(moduleImport, cachedMetadata);
            if (await module3.exists()) {
              log.info(`Using cached module ${moduleImport.path} version ${cachedMetadata.version}`);
              return module3;
            }
          }
          if (cachedMetadata && cachedMetadata.downloadStatus === type_1.DownloadStatus.COMPLETED && !this.isCacheValidForVersion(cachedMetadata.version, moduleImport.version)) {
            log.info(`Cache version mismatch for ${moduleImport.path}: cached=${cachedMetadata.version}, requested=${moduleImport.version || "latest"}`);
          }
          const moduleDir = this.getModuleDir(moduleImport.path);
          const zipPath = path6.join(moduleDir, "module.zip");
          const metadata = {
            path: moduleImport.path,
            version: moduleImport.version || "latest",
            url: moduleImport.url,
            dir: moduleDir,
            downloadStatus: type_1.DownloadStatus.DOWNLOADING,
            downloadedAt: new Date()
          };
          await this.moduleCache.set(moduleImport.path, metadata);
          try {
            const urlWithTimestamp = this.addTimestampToUrl(moduleImport.url);
            await this.httpClient.download(urlWithTimestamp, zipPath, {
              onProgress: (progress) => {
                onProgress?.({ percentage: progress.percentage });
              }
            });
            await this.zipExtractor.extract(zipPath, moduleDir);
            metadata.downloadStatus = type_1.DownloadStatus.COMPLETED;
            metadata.downloadedAt = new Date();
            try {
              const zipStat = await this.info.osFs().stat(zipPath);
              metadata.size = zipStat.size();
            } catch (error) {
            }
            try {
              await this.info.osFs().remove(zipPath);
            } catch (error) {
            }
            await this.moduleCache.set(moduleImport.path, metadata);
            const module3 = (0, module_1.newModule)(this.info.osFs(), moduleDir, moduleImport.path);
            module3.setMetadata(metadata);
            await module3.applyMounts(moduleImport);
            return module3;
          } catch (error) {
            metadata.downloadStatus = type_1.DownloadStatus.FAILED;
            await this.moduleCache.set(moduleImport.path, metadata);
            const message = error instanceof Error ? error.message : String(error);
            throw new type_1.ModuleError(`Failed to download module ${moduleImport.path}: ${message}`, "DOWNLOAD_FAILED");
          }
        } catch (error) {
          if (error instanceof type_1.ModuleError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Module download failed: ${message}`, "DOWNLOAD_FAILED");
        }
      }
      async addModule(owner, importPath, onProgress) {
        try {
          if (this.downloadedModules.has(importPath)) {
            return;
          }
          const { cleanUrl, version } = this.parseVersionFromImportPath(importPath);
          const moduleImport = {
            path: importPath,
            url: this.getDownloadUrl(cleanUrl),
            ...version && { version }
          };
          const module3 = await this.downloadModule(moduleImport, onProgress);
          this.modules.push(module3);
          this.downloadedModules.add(importPath);
          try {
            const themeImportPaths = await this.parseThemeToml(module3);
            for (const themeImportPath of themeImportPaths) {
              if (this.downloadedModules.has(themeImportPath)) {
                log.info(`Module ${themeImportPath} already downloaded, skipping`);
                continue;
              }
              log.info(`Recursively downloading module dependency: ${themeImportPath}`);
              const originalImportPath = themeImportPath;
              const { cleanUrl: cleanUrl2, version: version2 } = this.parseVersionFromImportPath(originalImportPath);
              let resolvedImportPath = originalImportPath;
              if (version2 === "latest") {
                resolvedImportPath = await this.resolveLatestVersion(originalImportPath);
              }
              await this.addModule(module3, resolvedImportPath, (childProgress) => {
                onProgress?.({ percentage: childProgress.percentage * 0.5 });
              });
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            log.warn(`Failed to process recursive imports for module ${importPath}: ${message}`);
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Failed to add module ${importPath}: ${message}`, "ADD_MODULE_FAILED");
        }
      }
      async createModuleFromCache(moduleImport, metadata) {
        const module3 = (0, module_1.newModule)(this.info.osFs(), metadata.dir, moduleImport.path);
        module3.setMetadata(metadata);
        await module3.applyMounts(moduleImport);
        return module3;
      }
      getModuleDir(modulePath) {
        const safeName = modulePath.replace(/[/\\:*?"<>|]/g, "_").replace(/^_+|_+$/g, "");
        return path6.join(this.info.moduleDir(), safeName);
      }
      getDownloadUrl(modulePath) {
        return modulePath;
      }
      isCacheValidForVersion(cachedVersion, requestedVersion) {
        if (!requestedVersion)
          return true;
        if (requestedVersion === "latest")
          return true;
        return cachedVersion === requestedVersion;
      }
      addTimestampToUrl(url) {
        try {
          const parsedUrl = new URL(url);
          const timestamp = Date.now().toString();
          parsedUrl.searchParams.set("_t", timestamp);
          return parsedUrl.toString();
        } catch (error) {
          const separator = url.includes("?") ? "&" : "?";
          return `${url}${separator}_t=${Date.now()}`;
        }
      }
      getModuleByPath(modulePath) {
        return this.modules.find((m) => m.path() === modulePath) || null;
      }
      isModuleDownloaded(modulePath) {
        return this.downloadedModules.has(modulePath);
      }
      async getModuleStatus(modulePath) {
        const metadata = await this.moduleCache.get(modulePath);
        return metadata?.downloadStatus || type_1.DownloadStatus.PENDING;
      }
      async removeModule(modulePath) {
        try {
          const index = this.modules.findIndex((m) => m.path() === modulePath);
          if (index >= 0) {
            const module3 = this.modules[index];
            try {
              await this.info.osFs().removeAll(module3.dir());
            } catch (error) {
            }
            this.modules.splice(index, 1);
            this.downloadedModules.delete(modulePath);
            await this.moduleCache.delete(modulePath);
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Failed to remove module ${modulePath}: ${message}`, "REMOVE_MODULE_FAILED");
        }
      }
      async clearAll() {
        try {
          for (const module3 of this.modules) {
            try {
              await this.info.osFs().removeAll(module3.dir());
            } catch (error) {
            }
          }
          this.modules = [];
          this.downloadedModules.clear();
          await this.moduleCache.clear();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.ModuleError(`Failed to clear modules: ${message}`, "CLEAR_MODULES_FAILED");
        }
      }
      getSourceLang(source) {
        return this.lang.getSourceLang(source);
      }
      async parseThemeToml(module3) {
        try {
          const themeTomlPath = path6.join(module3.dir(), "theme.toml");
          try {
            const stat = await this.info.osFs().stat(themeTomlPath);
            if (stat.isDir()) {
              return [];
            }
          } catch (error) {
            return [];
          }
          let tomlContent;
          try {
            const file = await this.info.osFs().open(themeTomlPath);
            try {
              const chunks = [];
              const buffer = new Uint8Array(4096);
              while (true) {
                const result = await file.read(buffer);
                if (result.bytesRead === 0)
                  break;
                chunks.push(buffer.slice(0, result.bytesRead));
              }
              const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
              const combined = new Uint8Array(totalLength);
              let offset = 0;
              for (const chunk of chunks) {
                combined.set(chunk, offset);
                offset += chunk.length;
              }
              tomlContent = new TextDecoder("utf-8").decode(combined);
            } finally {
              await file.close();
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            log.warn(`Failed to read theme.toml for module ${module3.path()}: ${message}`);
            return [];
          }
          const tomlData = (0, smol_toml_1.parse)(tomlContent);
          if (tomlData.module?.imports) {
            log.info(`Found ${tomlData.module.imports.length} module imports in ${module3.path()}/theme.toml`);
            return tomlData.module.imports.map((imp) => imp.path);
          }
          return [];
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.warn(`Failed to parse theme.toml for module ${module3.path()}: ${message}`);
          return [];
        }
      }
    };
    exports2.Modules = Modules;
    function newModules(info, httpClient, zipExtractor, moduleCache) {
      return new Modules(info, httpClient, zipExtractor, moduleCache);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/factory/module.js
var require_module5 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/factory/module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModules = createModules;
    exports2.createModulesWithProgress = createModulesWithProgress;
    var module_1 = require_module4();
    var type_1 = require_type2();
    var httpclient_1 = require_httpclient();
    var zipextractor_1 = require_zipextractor();
    var cache_1 = require_cache();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("module", { component: "factory" });
    async function createModules(info) {
      try {
        const httpClient = (0, httpclient_1.newHttpClient)(info.osFs());
        const zipExtractor = (0, zipextractor_1.newZipExtractor)(info.osFs());
        const moduleCache = (0, cache_1.newModuleCache)(info.osFs(), info.moduleCacheDir());
        const modules = (0, module_1.newModules)(info, httpClient, zipExtractor, moduleCache);
        await modules.load();
        return modules;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`Failed to create modules: ${message}`);
        throw new type_1.ModuleError(`Failed to create modules: ${message}`, "FACTORY_FAILED");
      }
    }
    async function createModulesWithProgress(info, onProgress) {
      try {
        const httpClient = (0, httpclient_1.newHttpClient)(info.osFs());
        const zipExtractor = (0, zipextractor_1.newZipExtractor)(info.osFs());
        const moduleCache = (0, cache_1.newModuleCache)(info.osFs(), info.moduleCacheDir());
        const modules = (0, module_1.newModules)(info, httpClient, zipExtractor, moduleCache);
        await modules.load(onProgress);
        return modules;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`Failed to create modules: ${message}`);
        throw new type_1.ModuleError(`Failed to create modules: ${message}`, "FACTORY_FAILED");
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/module/index.js
var require_module6 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/module/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newModules = exports2.EModules = exports2.newProjectModule = exports2.newModule = exports2.ProjectModule = exports2.VoModule = exports2.newMemoryModuleCache = exports2.newModuleCache = exports2.MemoryModuleCache = exports2.FsModuleCache = exports2.newMockZipExtractor = exports2.newZipExtractor = exports2.MockZipExtractor = exports2.WebZipExtractor = exports2.JsZipExtractor = exports2.newHttpClient = exports2.FetchHttpClient = exports2.createDefaultMounts = exports2.newMountFromConfig = exports2.newMount = exports2.Mount = exports2.PACKAGE_JSON_FILENAME = exports2.ComponentFolders = exports2.ComponentFolderPrompts = exports2.ComponentFolderWorkflows = exports2.DownloadStatus = exports2.ErrMountFailed = exports2.ErrInvalidZipFile = exports2.ErrDownloadFailed = exports2.ErrModuleNotFound = exports2.ModuleError = void 0;
    __exportStar(require_type2(), exports2);
    var type_1 = require_type2();
    Object.defineProperty(exports2, "ModuleError", { enumerable: true, get: function() {
      return type_1.ModuleError;
    } });
    Object.defineProperty(exports2, "ErrModuleNotFound", { enumerable: true, get: function() {
      return type_1.ErrModuleNotFound;
    } });
    Object.defineProperty(exports2, "ErrDownloadFailed", { enumerable: true, get: function() {
      return type_1.ErrDownloadFailed;
    } });
    Object.defineProperty(exports2, "ErrInvalidZipFile", { enumerable: true, get: function() {
      return type_1.ErrInvalidZipFile;
    } });
    Object.defineProperty(exports2, "ErrMountFailed", { enumerable: true, get: function() {
      return type_1.ErrMountFailed;
    } });
    Object.defineProperty(exports2, "DownloadStatus", { enumerable: true, get: function() {
      return type_1.DownloadStatus;
    } });
    Object.defineProperty(exports2, "ComponentFolderWorkflows", { enumerable: true, get: function() {
      return type_1.ComponentFolderWorkflows;
    } });
    Object.defineProperty(exports2, "ComponentFolderPrompts", { enumerable: true, get: function() {
      return type_1.ComponentFolderPrompts;
    } });
    Object.defineProperty(exports2, "ComponentFolders", { enumerable: true, get: function() {
      return type_1.ComponentFolders;
    } });
    Object.defineProperty(exports2, "PACKAGE_JSON_FILENAME", { enumerable: true, get: function() {
      return type_1.PACKAGE_JSON_FILENAME;
    } });
    var mount_1 = require_mount();
    Object.defineProperty(exports2, "Mount", { enumerable: true, get: function() {
      return mount_1.Mount;
    } });
    Object.defineProperty(exports2, "newMount", { enumerable: true, get: function() {
      return mount_1.newMount;
    } });
    Object.defineProperty(exports2, "newMountFromConfig", { enumerable: true, get: function() {
      return mount_1.newMountFromConfig;
    } });
    Object.defineProperty(exports2, "createDefaultMounts", { enumerable: true, get: function() {
      return mount_1.createDefaultMounts;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports2, "FetchHttpClient", { enumerable: true, get: function() {
      return httpclient_1.FetchHttpClient;
    } });
    Object.defineProperty(exports2, "newHttpClient", { enumerable: true, get: function() {
      return httpclient_1.newHttpClient;
    } });
    var zipextractor_1 = require_zipextractor();
    Object.defineProperty(exports2, "JsZipExtractor", { enumerable: true, get: function() {
      return zipextractor_1.JsZipExtractor;
    } });
    Object.defineProperty(exports2, "WebZipExtractor", { enumerable: true, get: function() {
      return zipextractor_1.WebZipExtractor;
    } });
    Object.defineProperty(exports2, "MockZipExtractor", { enumerable: true, get: function() {
      return zipextractor_1.MockZipExtractor;
    } });
    Object.defineProperty(exports2, "newZipExtractor", { enumerable: true, get: function() {
      return zipextractor_1.newZipExtractor;
    } });
    Object.defineProperty(exports2, "newMockZipExtractor", { enumerable: true, get: function() {
      return zipextractor_1.newMockZipExtractor;
    } });
    var cache_1 = require_cache();
    Object.defineProperty(exports2, "FsModuleCache", { enumerable: true, get: function() {
      return cache_1.FsModuleCache;
    } });
    Object.defineProperty(exports2, "MemoryModuleCache", { enumerable: true, get: function() {
      return cache_1.MemoryModuleCache;
    } });
    Object.defineProperty(exports2, "newModuleCache", { enumerable: true, get: function() {
      return cache_1.newModuleCache;
    } });
    Object.defineProperty(exports2, "newMemoryModuleCache", { enumerable: true, get: function() {
      return cache_1.newMemoryModuleCache;
    } });
    var module_1 = require_module3();
    Object.defineProperty(exports2, "VoModule", { enumerable: true, get: function() {
      return module_1.Module;
    } });
    Object.defineProperty(exports2, "ProjectModule", { enumerable: true, get: function() {
      return module_1.ProjectModule;
    } });
    Object.defineProperty(exports2, "newModule", { enumerable: true, get: function() {
      return module_1.newModule;
    } });
    Object.defineProperty(exports2, "newProjectModule", { enumerable: true, get: function() {
      return module_1.newProjectModule;
    } });
    var module_2 = require_module4();
    Object.defineProperty(exports2, "EModules", { enumerable: true, get: function() {
      return module_2.Modules;
    } });
    Object.defineProperty(exports2, "newModules", { enumerable: true, get: function() {
      return module_2.newModules;
    } });
    __exportStar(require_module5(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/type.js
var require_type3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrOperationNotSupported = exports2.ErrNoFilesystems = exports2.OverlayFsError = exports2.ErrWalkAlreadyWalked = exports2.ErrSkipDir = exports2.OpenFlags = exports2.ErrDestinationExists = exports2.ErrFileExists = exports2.ErrFileNotFound = exports2.ErrTooLarge = exports2.ErrOutOfRange = exports2.ErrFileClosed = exports2.FsError = void 0;
    var FsError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        this.name = "FsError";
      }
    };
    exports2.FsError = FsError;
    exports2.ErrFileClosed = new FsError("File is closed", "FILE_CLOSED");
    exports2.ErrOutOfRange = new FsError("out of range", "OUT_OF_RANGE");
    exports2.ErrTooLarge = new FsError("too large", "TOO_LARGE");
    exports2.ErrFileNotFound = new FsError("file not found", "FILE_NOT_FOUND");
    exports2.ErrFileExists = new FsError("file exists", "FILE_EXISTS");
    exports2.ErrDestinationExists = new FsError("destination exists", "DESTINATION_EXISTS");
    var OpenFlags;
    (function(OpenFlags2) {
      OpenFlags2[OpenFlags2["O_RDONLY"] = 0] = "O_RDONLY";
      OpenFlags2[OpenFlags2["O_WRONLY"] = 1] = "O_WRONLY";
      OpenFlags2[OpenFlags2["O_RDWR"] = 2] = "O_RDWR";
      OpenFlags2[OpenFlags2["O_APPEND"] = 8] = "O_APPEND";
      OpenFlags2[OpenFlags2["O_CREATE"] = 64] = "O_CREATE";
      OpenFlags2[OpenFlags2["O_EXCL"] = 128] = "O_EXCL";
      OpenFlags2[OpenFlags2["O_SYNC"] = 256] = "O_SYNC";
      OpenFlags2[OpenFlags2["O_TRUNC"] = 512] = "O_TRUNC";
    })(OpenFlags || (exports2.OpenFlags = OpenFlags = {}));
    exports2.ErrSkipDir = new Error("skip directory");
    exports2.ErrWalkAlreadyWalked = new FsError("walkway already walked", "ALREADY_WALKED");
    var OverlayFsError = class extends FsError {
      constructor(message, code) {
        super(message, code);
        this.name = "OverlayFsError";
      }
    };
    exports2.OverlayFsError = OverlayFsError;
    exports2.ErrNoFilesystems = new OverlayFsError("no filesystems to write to", "NO_FILESYSTEMS");
    exports2.ErrOperationNotSupported = new OverlayFsError("operation not supported", "OPERATION_NOT_SUPPORTED");
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/originfs.js
var require_originfs = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/originfs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OriginFs = void 0;
    var OriginFs = class {
      constructor(source, origin, publishDir) {
        this.source = source;
        this.origin = origin;
        this.publishDir = publishDir;
      }
      getSource() {
        return this.source;
      }
      getOrigin() {
        return this.origin;
      }
      publish() {
        return this.publishDir;
      }
    };
    exports2.OriginFs = OriginFs;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/type.js
var require_type4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PATH_CONSTANTS = exports2.PathValidationError = exports2.PathParseError = exports2.PathError = exports2.PathType = void 0;
    var PathType;
    (function(PathType2) {
      PathType2[PathType2["File"] = 0] = "File";
      PathType2[PathType2["ContentResource"] = 1] = "ContentResource";
      PathType2[PathType2["ContentSingle"] = 2] = "ContentSingle";
      PathType2[PathType2["Leaf"] = 3] = "Leaf";
      PathType2[PathType2["Branch"] = 4] = "Branch";
    })(PathType || (exports2.PathType = PathType = {}));
    var PathError = class extends Error {
      constructor(message, path6) {
        super(message);
        this.path = path6;
        this.name = "PathError";
      }
    };
    exports2.PathError = PathError;
    var PathParseError = class extends PathError {
      constructor(message, path6) {
        super(message, path6);
        this.name = "PathParseError";
      }
    };
    exports2.PathParseError = PathParseError;
    var PathValidationError = class extends PathError {
      constructor(message, path6, validationErrors) {
        super(message, path6);
        this.validationErrors = validationErrors;
        this.name = "PathValidationError";
      }
    };
    exports2.PathValidationError = PathValidationError;
    exports2.PATH_CONSTANTS = {
      CONTENT_EXTENSIONS: [".md", ".markdown", ".mdown", ".mkd", ".mkdn", ".html", ".htm", ".xml"],
      HTML_EXTENSIONS: [".html", ".htm"],
      INDEX_NAMES: ["index", "_index"],
      PATH_SEPARATOR: "/",
      EXTENSION_SEPARATOR: ".",
      LANGUAGE_SEPARATOR: ".",
      SYSTEM_PATH_SEPARATOR: (() => {
        try {
          return require("path").sep;
        } catch {
          return "/";
        }
      })(),
      COMPONENT_FOLDER_CONTENT: "content",
      COMPONENT_FOLDER_STATIC: "static",
      COMPONENT_FOLDER_LAYOUTS: "layouts",
      COMPONENT_FOLDER_ARCHETYPES: "archetypes",
      COMPONENT_FOLDER_DATA: "data",
      COMPONENT_FOLDER_ASSETS: "assets",
      COMPONENT_FOLDER_I18N: "i18n",
      normalizePath: (path6) => {
        return path6.replace(/\\/g, "/");
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/vo/pathcomponents.js
var require_pathcomponents = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/vo/pathcomponents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathComponentsUtils = exports2.PathComponentsFactory = exports2.LowHighImpl = exports2.PathPositionsImpl = exports2.PathComponentsImpl = void 0;
    var type_1 = require_type4();
    var PathComponentsImpl = class {
      constructor(original, normalized, positions, identifiers, bundleType, disabled = false, component) {
        this.original = original;
        this.normalized = normalized;
        this.positions = positions;
        this.identifiers = identifiers;
        this.bundleType = bundleType;
        this.disabled = disabled;
        this.component = component;
      }
      withBundleType(bundleType) {
        return new PathComponentsImpl(this.original, this.normalized, this.positions, this.identifiers, bundleType, this.disabled);
      }
      withDisabled(disabled) {
        return new PathComponentsImpl(this.original, this.normalized, this.positions, this.identifiers, this.bundleType, disabled);
      }
      hasIdentifiers() {
        return this.identifiers.length > 0;
      }
      firstIdentifier() {
        return this.identifiers.length > 0 ? this.identifiers[0] : null;
      }
      lastIdentifier() {
        return this.identifiers.length > 0 ? this.identifiers[this.identifiers.length - 1] : null;
      }
      getIdentifier(index) {
        return index >= 0 && index < this.identifiers.length ? this.identifiers[index] : null;
      }
      isContentComponent(component) {
        return component === "content" || component === "archetypes";
      }
      clone() {
        return new PathComponentsImpl(this.original, this.normalized, { ...this.positions }, [...this.identifiers], this.bundleType, this.disabled, this.component);
      }
      toString() {
        return `PathComponents{original="${this.original}", normalized="${this.normalized}", bundleType=${type_1.PathType[this.bundleType]}, identifiers=${this.identifiers.length}}`;
      }
    };
    exports2.PathComponentsImpl = PathComponentsImpl;
    var PathPositionsImpl = class {
      constructor(containerLow = -1, containerHigh = -1, sectionHigh = -1, identifierLanguage = -1) {
        this.containerLow = containerLow;
        this.containerHigh = containerHigh;
        this.sectionHigh = sectionHigh;
        this.identifierLanguage = identifierLanguage;
      }
      reset() {
        this.containerLow = -1;
        this.containerHigh = -1;
        this.sectionHigh = -1;
        this.identifierLanguage = -1;
      }
      hasContainer() {
        return this.containerLow !== -1 && this.containerHigh !== -1;
      }
      hasSection() {
        return this.sectionHigh > 0;
      }
      hasLanguageIdentifier() {
        return this.identifierLanguage !== -1;
      }
      clone() {
        return new PathPositionsImpl(this.containerLow, this.containerHigh, this.sectionHigh, this.identifierLanguage);
      }
    };
    exports2.PathPositionsImpl = PathPositionsImpl;
    var LowHighImpl = class {
      constructor(low, high) {
        this.low = low;
        this.high = high;
        if (low > high) {
          throw new Error(`Invalid range: low (${low}) must be <= high (${high})`);
        }
      }
      length() {
        return this.high - this.low;
      }
      isEmpty() {
        return this.low === this.high;
      }
      contains(position) {
        return position >= this.low && position < this.high;
      }
      substring(str) {
        return str.substring(this.low, this.high);
      }
      toString() {
        return `[${this.low}, ${this.high})`;
      }
    };
    exports2.LowHighImpl = LowHighImpl;
    var PathComponentsFactory = class {
      static createEmpty(original = "", bundleType = type_1.PathType.File) {
        return new PathComponentsImpl(original, original, new PathPositionsImpl(), [], bundleType, false);
      }
      static create(original, normalized, bundleType = type_1.PathType.File) {
        return new PathComponentsImpl(original, normalized || original, new PathPositionsImpl(), [], bundleType, false);
      }
      static createFull(original, normalized, positions, identifiers, bundleType, disabled = false) {
        return new PathComponentsImpl(original, normalized, positions, identifiers, bundleType, disabled);
      }
    };
    exports2.PathComponentsFactory = PathComponentsFactory;
    var PathComponentsUtils = class {
      static extractString(str, range) {
        return str.substring(range.low, range.high);
      }
      static extractStrings(str, ranges) {
        return ranges.map((range) => str.substring(range.low, range.high));
      }
      static findIdentifierIndex(identifiers, position) {
        for (let i = 0; i < identifiers.length; i++) {
          const range = identifiers[i];
          if (position >= range.low && position < range.high) {
            return i;
          }
        }
        return -1;
      }
      static merge(base, override) {
        return new PathComponentsImpl(override.original ?? base.original, override.normalized ?? base.normalized, override.positions ?? base.positions, override.identifiers ?? base.identifiers, override.bundleType ?? base.bundleType, override.disabled ?? base.disabled);
      }
    };
    exports2.PathComponentsUtils = PathComponentsUtils;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/entity/path.js
var require_path = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/entity/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathUtils = exports2.Path = void 0;
    var type_1 = require_type4();
    var pathcomponents_1 = require_pathcomponents();
    var Path = class {
      constructor(components) {
        this.components = components;
        this.shouldTrimLeadingSlash = false;
      }
      component() {
        if (this.components.component) {
          return this.components.component;
        }
        const path6 = this.components.normalized;
        const parts = path6.split("/").filter((p) => p.length > 0);
        if (parts.length === 0) {
          return "content";
        }
        const firstPart = parts[0];
        const componentMap = {
          "static": "static",
          "layouts": "layouts",
          "themes": "themes",
          "archetypes": "archetypes",
          "data": "data",
          "i18n": "i18n",
          "assets": "assets"
        };
        return componentMap[firstPart] || "content";
      }
      path() {
        return this.norm(this.components.normalized);
      }
      name() {
        if (this.components.positions.containerHigh > 0) {
          return this.components.normalized.substring(this.components.positions.containerHigh);
        }
        return this.components.normalized;
      }
      nameNoExt() {
        const firstId = this.components.firstIdentifier();
        if (firstId) {
          return this.components.normalized.substring(this.components.positions.containerHigh, firstId.low - 1);
        }
        return this.components.normalized.substring(this.components.positions.containerHigh);
      }
      nameNoLang() {
        if (this.components.identifiers.length >= 2) {
          const lastId = this.components.identifiers[this.components.identifiers.length - 1];
          const secondToLastId = this.components.identifiers[this.components.identifiers.length - 2];
          const langStr = this.components.normalized.substring(secondToLastId.low, secondToLastId.high);
          const knownLangCodes = ["en", "fr", "es", "de", "zh", "ja", "ko", "pt", "it", "ru", "ar"];
          if (knownLangCodes.includes(langStr)) {
            const nameStart = this.components.positions.containerHigh;
            const beforeLang = this.components.normalized.substring(nameStart, secondToLastId.low - 1);
            const afterLang = this.components.normalized.substring(lastId.low - 1);
            return beforeLang + afterLang;
          }
        }
        return this.name();
      }
      dir() {
        let d = "";
        if (this.components.positions.containerHigh > 0) {
          d = this.components.normalized.substring(0, this.components.positions.containerHigh - 1);
        }
        if (d === "") {
          d = "/";
        }
        return this.norm(d);
      }
      ext() {
        if (this.components.identifiers.length === 0) {
          return "";
        }
        const lastIdentifier = this.components.identifiers[this.components.identifiers.length - 1];
        const extStr = this.components.normalized.substring(lastIdentifier.low, lastIdentifier.high);
        return extStr ? "." + extStr : "";
      }
      lang() {
        if (this.components.identifiers.length >= 2) {
          const secondToLastId = this.components.identifiers[this.components.identifiers.length - 2];
          const langStr = this.components.normalized.substring(secondToLastId.low, secondToLastId.high);
          const knownLangCodes = ["en", "fr", "es", "de", "zh", "ja", "ko", "pt", "it", "ru", "ar"];
          if (knownLangCodes.includes(langStr)) {
            return "." + langStr;
          }
        }
        return "";
      }
      section() {
        if (this.components.positions.sectionHigh <= 0) {
          return "";
        }
        const sectionPath = this.components.normalized.substring(1, this.components.positions.sectionHigh);
        if (sectionPath === "_index.md" || sectionPath === "index.md" || sectionPath.endsWith("/_index.md") || sectionPath.endsWith("/index.md")) {
          return "";
        }
        return this.norm(sectionPath);
      }
      sections() {
        const dirPath = this.dir();
        if (dirPath === "/" || dirPath === "") {
          return [];
        }
        const cleanPath = dirPath.startsWith("/") ? dirPath.substring(1) : dirPath;
        const sections = [];
        const pathParts = cleanPath.split("/").filter((part) => part.length > 0);
        let currentPath = "";
        for (const part of pathParts) {
          if (currentPath === "") {
            currentPath = part;
          } else {
            currentPath += "/" + part;
          }
          sections.push(this.norm(currentPath));
        }
        return sections;
      }
      container() {
        if (this.components.positions.containerLow === -1) {
          return "";
        }
        return this.norm(this.components.normalized.substring(this.components.positions.containerLow, this.components.positions.containerHigh - 1));
      }
      containerDir() {
        if (this.isLeafBundle()) {
          return this.dir();
        } else if (this.isBranchBundle()) {
          return this.dir();
        } else {
          return this.dir();
        }
      }
      base() {
        if (this.isBranchBundle() && this.components.normalized === "/_index.md") {
          return "/";
        } else if (this.isLeafBundle()) {
          return this.baseInternal(false, true);
        } else if (this.isContent() && !this.isBundle()) {
          return this.pathNoIdentifier();
        } else if (!this.isContent()) {
          return this.path();
        } else if (this.isBundle()) {
          return this.baseInternal(false, true);
        }
        return this.baseInternal(!this.isContentPage(), this.isBundle());
      }
      baseNoLeadingSlash() {
        return this.base().substring(1);
      }
      baseNameNoIdentifier() {
        if (this.isBundle()) {
          return this.container();
        }
        return this.nameNoIdentifier();
      }
      nameNoIdentifier() {
        if (this.components.identifiers.length === 0) {
          return this.name();
        }
        const firstIdentifier = this.components.identifiers[0];
        const nameStart = this.components.positions.containerHigh;
        return this.components.normalized.substring(nameStart, firstIdentifier.low - 1);
      }
      pathNoLang() {
        return this.baseInternal(true, false);
      }
      pathNoIdentifier() {
        if (this.components.identifiers.length === 0) {
          return this.path();
        }
        const firstIdentifier = this.components.identifiers[0];
        const pathBeforeIdentifiers = this.components.normalized.substring(0, firstIdentifier.low - 1);
        return this.norm(pathBeforeIdentifiers);
      }
      pathRel(owner) {
        let ob = owner.base();
        if (!ob.endsWith("/")) {
          ob += "/";
        }
        return this.path().replace(new RegExp("^" + this.escapeRegExp(ob)), "");
      }
      baseRel(owner) {
        let ob = owner.base();
        if (ob === "/") {
          ob = "";
        }
        return this.base().substring(ob.length + 1);
      }
      trimLeadingSlash() {
        const clonedComponents = this.components.clone();
        const newPath = new Path(clonedComponents);
        newPath.setShouldTrimLeadingSlash(true);
        return newPath;
      }
      identifier(index) {
        const totalIdentifiers = this.components.identifiers.length;
        if (totalIdentifiers === 0 || index < 0 || index >= totalIdentifiers) {
          return "";
        }
        let actualIndex;
        if (totalIdentifiers === 1) {
          actualIndex = 0;
        } else {
          if (index === 0) {
            actualIndex = totalIdentifiers - 1;
          } else {
            actualIndex = totalIdentifiers - 1 - index;
          }
        }
        const identifierStr = this.identifierAsString(actualIndex);
        return identifierStr ? "." + identifierStr : "";
      }
      identifiers() {
        const result = [];
        const totalIdentifiers = this.components.identifiers.length;
        for (let i = 0; i < totalIdentifiers; i++) {
          const identifier = this.identifier(i);
          if (identifier) {
            result.push(identifier);
          }
        }
        return result;
      }
      bundleType() {
        return this.components.bundleType;
      }
      isContent() {
        return this.bundleType() >= type_1.PathType.ContentResource;
      }
      isBundle() {
        return this.bundleType() > type_1.PathType.Leaf;
      }
      isBranchBundle() {
        return this.bundleType() === type_1.PathType.Branch;
      }
      isLeafBundle() {
        return this.bundleType() === type_1.PathType.Leaf;
      }
      isHTML() {
        const ext = this.ext().toLowerCase();
        return type_1.PATH_CONSTANTS.HTML_EXTENSIONS.some((htmlExt) => htmlExt === ext);
      }
      disabled() {
        return this.components.disabled;
      }
      forBundleType(type) {
        const newComponents = this.components.withBundleType(type);
        return new Path(newComponents);
      }
      unnormalized() {
        if (!this._unnormalized) {
          if (this.components.original === this.components.normalized) {
            this._unnormalized = this;
          } else {
            const unnormalizedComponents = new pathcomponents_1.PathComponentsImpl(this.components.original, this.components.original, this.components.positions, this.components.identifiers, this.components.bundleType, this.components.disabled);
            this._unnormalized = new Path(unnormalizedComponents);
          }
        }
        return this._unnormalized;
      }
      setShouldTrimLeadingSlash(value2) {
        this.shouldTrimLeadingSlash = value2;
      }
      norm(s) {
        if (this.shouldTrimLeadingSlash) {
          return s.startsWith("/") ? s.substring(1) : s;
        }
        return s;
      }
      isContentPage() {
        return this.bundleType() >= type_1.PathType.ContentSingle;
      }
      baseInternal(preserveExt, isBundle) {
        if (this.components.identifiers.length === 0) {
          return this.norm(this.components.normalized);
        }
        if (preserveExt && this.components.identifiers.length === 1) {
          return this.norm(this.components.normalized);
        }
        const lastId = this.components.identifiers[this.components.identifiers.length - 1];
        let high = lastId.low - 1;
        if (isBundle) {
          high = this.components.positions.containerHigh - 1;
        }
        if (high === 0) {
          high++;
        }
        if (!preserveExt) {
          return this.norm(this.components.normalized.substring(0, high));
        }
        const firstId = this.components.identifiers[0];
        return this.norm(this.components.normalized.substring(0, high) + this.components.normalized.substring(firstId.low - 1, firstId.high));
      }
      identifierAsString(i) {
        const index = this.identifierIndex(i);
        if (index === -1) {
          return "";
        }
        const id = this.components.identifiers[index];
        return this.components.normalized.substring(id.low, id.high);
      }
      identifierIndex(i) {
        if (i < 0 || i >= this.components.identifiers.length) {
          return -1;
        }
        return i;
      }
      escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      toString() {
        return `Path{path="${this.path()}", component="${this.component()}", bundleType=${type_1.PathType[this.bundleType()]}}`;
      }
      equals(other) {
        return this.path() === other.path() && this.component() === other.component() && this.bundleType() === other.bundleType();
      }
      hashCode() {
        return `${this.component()}:${this.path()}:${this.bundleType()}`;
      }
    };
    exports2.Path = Path;
    var PathUtils = class {
      static fromString(component, path6) {
        const components = new pathcomponents_1.PathComponentsImpl(path6, path6, { containerLow: -1, containerHigh: -1, sectionHigh: -1, identifierLanguage: -1 }, [], type_1.PathType.File, false);
        return new Path(components);
      }
      static hasExtension(path6, extension) {
        const pathExt = path6.ext();
        const targetExt = extension.startsWith(".") ? extension : "." + extension;
        return pathExt.toLowerCase() === targetExt.toLowerCase();
      }
      static isUnder(child, parent) {
        const childPath = child.path();
        let parentPath;
        if (parent.isBranchBundle()) {
          parentPath = parent.dir();
        } else {
          parentPath = parent.path();
        }
        const normalizedParent = parentPath === "/" ? "/" : parentPath + "/";
        return childPath !== parentPath && childPath.startsWith(normalizedParent);
      }
      static relativeTo(from, to) {
        return to.pathRel(from);
      }
      static compare(a, b) {
        const pathCmp = a.path().localeCompare(b.path());
        if (pathCmp !== 0)
          return pathCmp;
        const componentCmp = a.component().localeCompare(b.component());
        if (componentCmp !== 0)
          return componentCmp;
        return a.bundleType() - b.bundleType();
      }
    };
    exports2.PathUtils = PathUtils;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/vo/pathparser.js
var require_pathparser = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/vo/pathparser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathParserUtils = exports2.ConfigurablePathNormalizer = exports2.DefaultFileExtensionChecker = exports2.BasicPathNormalizer = exports2.PathParsingNormalizer = exports2.PathProcessorImpl = void 0;
    var type_1 = require_type4();
    var pathcomponents_1 = require_pathcomponents();
    var path_1 = require_path();
    var PathProcessorImpl = class {
      constructor(normalizer, extChecker) {
        this.normalizer = normalizer || new PathParsingNormalizer();
        this.extChecker = extChecker || new DefaultFileExtensionChecker();
      }
      parse(component, path6) {
        let normalizedPath = path6;
        if (!normalizedPath || normalizedPath === "") {
          normalizedPath = "/";
        }
        const normalized = this.normalizer.normalize(normalizedPath);
        const pathComponents = this.createPathComponents(component, normalized, path6);
        return new path_1.Path(pathComponents);
      }
      parseIdentity(component, path6) {
        const parsed = this.parse(component, path6);
        return {
          identifierBase: () => parsed.base()
        };
      }
      parseBaseAndBaseNameNoIdentifier(component, path6) {
        const parsed = this.parse(component, path6);
        return [parsed.base(), parsed.baseNameNoIdentifier()];
      }
      createPathComponents(component, normalizedPath, originalPath) {
        let actualComponent = component;
        let actualPath = normalizedPath;
        if (normalizedPath.startsWith("/")) {
          const parts = normalizedPath.split("/").filter((p) => p.length > 0);
          if (parts.length > 0) {
            const firstPart = parts[0];
            const knownComponents = ["static", "layouts", "themes", "archetypes", "data", "i18n", "assets"];
            if (knownComponents.includes(firstPart) && component === "content") {
              actualComponent = firstPart;
            }
            const staticDirs = ["images", "assets", "static", "css", "js", "fonts"];
            if (staticDirs.includes(firstPart) && component === "content") {
              actualComponent = "static";
            }
          }
        }
        const lastSlash = actualPath.lastIndexOf("/");
        const filename = lastSlash >= 0 ? actualPath.substring(lastSlash + 1) : actualPath;
        const directory = lastSlash >= 0 ? actualPath.substring(0, lastSlash) : "";
        let bundleType = this.detectBundleType(filename, actualComponent);
        const positions = this.calculatePathPositions(actualPath);
        const identifiers = this.extractIdentifiers(actualPath, filename);
        return new pathcomponents_1.PathComponentsImpl(originalPath, actualPath, positions, identifiers, bundleType, false, actualComponent);
      }
      detectBundleType(filename, component) {
        if (component !== "content" && component !== "archetypes") {
          return type_1.PathType.File;
        }
        const parts = filename.split(".");
        let baseName = parts[0];
        if (baseName === "index" && this.isContentFile(filename)) {
          return type_1.PathType.Leaf;
        } else if (baseName === "_index" && this.isContentFile(filename)) {
          return type_1.PathType.Branch;
        } else if (this.isContentFile(filename)) {
          return type_1.PathType.ContentSingle;
        } else {
          return type_1.PathType.File;
        }
      }
      isContentFile(filename) {
        const ext = this.getFileExtension(filename);
        return ["md", "html", "markdown", "mdown", "mkd", "mkdn", "htm"].includes(ext.toLowerCase());
      }
      getFileExtension(filename) {
        const lastDot = filename.lastIndexOf(".");
        if (lastDot > 0 && lastDot < filename.length - 1) {
          return filename.substring(lastDot + 1);
        }
        return "";
      }
      calculatePathPositions(normalizedPath) {
        let sectionHigh = -1;
        let containerLow = -1;
        let containerHigh = -1;
        let slashCount = 0;
        for (let i = normalizedPath.length - 1; i >= 0; i--) {
          const c = normalizedPath[i];
          if (c === "/") {
            slashCount++;
            if (containerHigh === -1) {
              containerHigh = i + 1;
            } else if (containerLow === -1) {
              containerLow = i + 1;
            }
            if (i > 0) {
              sectionHigh = i;
            }
          }
        }
        return new pathcomponents_1.PathPositionsImpl(containerLow, containerHigh, sectionHigh, -1);
      }
      extractIdentifiers(normalizedPath, filename) {
        const identifiers = [];
        const basePath = normalizedPath.substring(0, normalizedPath.length - filename.length);
        const basePathLength = basePath.length;
        const parts = filename.split(".");
        if (parts.length <= 1) {
          return identifiers;
        }
        let currentPos = basePathLength + parts[0].length;
        for (let i = 1; i < parts.length; i++) {
          const part = parts[i];
          const dotPos = currentPos;
          const partStart = dotPos + 1;
          const partEnd = partStart + part.length;
          identifiers.push(new pathcomponents_1.LowHighImpl(partStart, partEnd));
          currentPos = partEnd;
        }
        return identifiers;
      }
    };
    exports2.PathProcessorImpl = PathProcessorImpl;
    var PathParsingNormalizer = class {
      constructor(toLowerCase = true, replaceSpaces = true) {
        this.toLowerCase = toLowerCase;
        this.replaceSpaces = replaceSpaces;
      }
      normalize(path6) {
        let result = path6;
        result = result.replace(/\\/g, "/");
        if (this.toLowerCase) {
          result = result.toLowerCase();
        }
        if (this.replaceSpaces) {
          result = result.replace(/\s/g, "-");
        }
        return result;
      }
    };
    exports2.PathParsingNormalizer = PathParsingNormalizer;
    var BasicPathNormalizer = class {
      constructor(toLowerCase = true, replaceSpaces = true) {
        this.toLowerCase = toLowerCase;
        this.replaceSpaces = replaceSpaces;
      }
      normalize(path6) {
        let result = path6;
        result = result.replace(/\\/g, "/");
        if (this.toLowerCase) {
          result = result.toLowerCase();
        }
        if (this.replaceSpaces) {
          result = result.replace(/\s+/g, "-");
        }
        return result;
      }
    };
    exports2.BasicPathNormalizer = BasicPathNormalizer;
    var DefaultFileExtensionChecker = class {
      isContentExt(ext) {
        const contentExts = type_1.PATH_CONSTANTS.CONTENT_EXTENSIONS;
        return contentExts.includes(ext.toLowerCase());
      }
      isHTML(ext) {
        const htmlExts = type_1.PATH_CONSTANTS.HTML_EXTENSIONS;
        return htmlExts.includes(ext.toLowerCase());
      }
      hasExt(path6) {
        for (let i = path6.length - 1; i >= 0; i--) {
          if (path6[i] === ".") {
            return true;
          }
          if (path6[i] === "/") {
            return false;
          }
        }
        return false;
      }
    };
    exports2.DefaultFileExtensionChecker = DefaultFileExtensionChecker;
    var ConfigurablePathNormalizer = class {
      constructor(config) {
        this.rules = [];
        if (config?.normalizer) {
          this.rules.push(config.normalizer);
        } else {
          if (config?.normalize !== false) {
            this.rules.push((path6) => path6.toLowerCase());
          }
          if (config?.replaceSpaces !== false) {
            this.rules.push((path6) => path6.replace(/\s+/g, "-"));
          }
        }
      }
      normalize(path6) {
        return this.rules.reduce((result, rule) => rule(result), path6);
      }
      addRule(rule) {
        this.rules.push(rule);
      }
      clearRules() {
        this.rules = [];
      }
    };
    exports2.ConfigurablePathNormalizer = ConfigurablePathNormalizer;
    var PathParserUtils = class {
      static parseBasic(path6) {
        const lastSlash = path6.lastIndexOf("/");
        const dir = lastSlash >= 0 ? path6.substring(0, lastSlash) : "";
        const name = lastSlash >= 0 ? path6.substring(lastSlash + 1) : path6;
        const lastDot = name.lastIndexOf(".");
        const ext = lastDot >= 0 ? name.substring(lastDot) : "";
        const nameWithoutExt = lastDot >= 0 ? name.substring(0, lastDot) : name;
        return { dir, name, ext, nameWithoutExt };
      }
      static join(...segments) {
        return segments.filter((segment) => segment.length > 0).map((segment) => segment.replace(/^\/+|\/+$/g, "")).join("/").replace(/\/+/g, "/");
      }
      static normalizeBasic(path6) {
        const normalizer = new BasicPathNormalizer();
        return normalizer.normalize(path6);
      }
      static isBundle(path6) {
        const basic = PathParserUtils.parseBasic(path6);
        const indexNames = type_1.PATH_CONSTANTS.INDEX_NAMES;
        return indexNames.includes(basic.nameWithoutExt);
      }
      static extractSection(path6) {
        const normalized = path6.startsWith("/") ? path6.substring(1) : path6;
        const firstSlash = normalized.indexOf("/");
        return firstSlash >= 0 ? normalized.substring(0, firstSlash) : normalized;
      }
      static removeExtension(path6) {
        const lastDot = path6.lastIndexOf(".");
        const lastSlash = path6.lastIndexOf("/");
        if (lastDot > lastSlash) {
          return path6.substring(0, lastDot);
        }
        return path6;
      }
      static hasExtension(path6) {
        const checker = new DefaultFileExtensionChecker();
        return checker.hasExt(path6);
      }
    };
    exports2.PathParserUtils = PathParserUtils;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/factory/pathfactory.js
var require_pathfactory = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/factory/pathfactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathFactoryUtils = exports2.PathBuilder = exports2.SimplePathPool = exports2.DefaultPathFactory = exports2.PathFactoryImpl = void 0;
    var pathparser_1 = require_pathparser();
    var pathcomponents_1 = require_pathcomponents();
    var path_1 = require_path();
    var PathFactoryImpl = class {
      constructor(config, pool) {
        const normalizer = config?.normalizer ? { normalize: config.normalizer } : new pathparser_1.BasicPathNormalizer(config?.normalize !== false, config?.replaceSpaces !== false);
        const extChecker = new pathparser_1.DefaultFileExtensionChecker();
        this.processor = new pathparser_1.PathProcessorImpl(normalizer, extChecker);
        if (pool) {
          this.pool = pool;
        }
      }
      create(component, path6, config) {
        if (this.pool) {
          const pooledPath = this.pool.get();
        }
        return this.processor.parse(component, path6);
      }
      createFromComponents(components) {
        return new path_1.Path(components);
      }
      createMany(component, paths, config) {
        return paths.map((path6) => this.create(component, path6, config));
      }
      createWithConfig(component, path6, normalizeConfig) {
        const config = {};
        if (normalizeConfig?.toLowerCase !== void 0) {
          config.normalize = normalizeConfig.toLowerCase;
        }
        if (normalizeConfig?.replaceSpaces !== void 0) {
          config.replaceSpaces = normalizeConfig.replaceSpaces;
        }
        if (normalizeConfig?.customNormalizer !== void 0) {
          config.normalizer = normalizeConfig.customNormalizer;
        }
        return this.create(component, path6, config);
      }
    };
    exports2.PathFactoryImpl = PathFactoryImpl;
    var DefaultPathFactory = class extends PathFactoryImpl {
      constructor() {
        super({
          normalize: true,
          replaceSpaces: true
        });
      }
    };
    exports2.DefaultPathFactory = DefaultPathFactory;
    var SimplePathPool = class {
      constructor(maxSize = 100) {
        this.pool = [];
        this.maxSize = maxSize;
      }
      get() {
        if (this.pool.length > 0) {
          return this.pool.pop();
        }
        const components = pathcomponents_1.PathComponentsFactory.createEmpty();
        return new path_1.Path(components);
      }
      put(path6) {
        if (this.pool.length < this.maxSize) {
          this.pool.push(path6);
        }
      }
      clear() {
        this.pool = [];
      }
      size() {
        return this.pool.length;
      }
    };
    exports2.SimplePathPool = SimplePathPool;
    var PathBuilder = class {
      constructor(factory) {
        this.component = "";
        this.path = "";
        this.config = {};
        this.factory = factory || new DefaultPathFactory();
      }
      withComponent(component) {
        this.component = component;
        return this;
      }
      withPath(path6) {
        this.path = path6;
        return this;
      }
      withNormalization(normalize2) {
        this.config.normalize = normalize2;
        return this;
      }
      withSpaceReplacement(replaceSpaces) {
        this.config.replaceSpaces = replaceSpaces;
        return this;
      }
      withNormalizer(normalizer) {
        this.config.normalizer = normalizer;
        return this;
      }
      build() {
        if (!this.component || !this.path) {
          throw new Error("Component and path must be set");
        }
        return this.factory.create(this.component, this.path, this.config);
      }
      reset() {
        this.component = "";
        this.path = "";
        this.config = {};
        return this;
      }
    };
    exports2.PathBuilder = PathBuilder;
    var PathFactoryUtils = class {
      static createContentPath(path6) {
        return PathFactoryUtils.defaultFactory.create("content", path6);
      }
      static createStaticPath(path6) {
        return PathFactoryUtils.defaultFactory.create("static", path6);
      }
      static createLayoutPath(path6) {
        return PathFactoryUtils.defaultFactory.create("layouts", path6);
      }
      static createArchetypePath(path6) {
        return PathFactoryUtils.defaultFactory.create("archetypes", path6);
      }
      static createDataPath(path6) {
        return PathFactoryUtils.defaultFactory.create("data", path6);
      }
      static createThemePath(path6) {
        return PathFactoryUtils.defaultFactory.create("themes", path6);
      }
      static createFromConfig(config) {
        const factoryConfig = {};
        if (config.normalize !== void 0) {
          factoryConfig.normalize = config.normalize;
        }
        if (config.replaceSpaces !== void 0) {
          factoryConfig.replaceSpaces = config.replaceSpaces;
        }
        const factory = new PathFactoryImpl(factoryConfig);
        return config.paths.map((path6) => factory.create(config.component, path6));
      }
      static builder() {
        return new PathBuilder();
      }
      static createWithPool(component, path6, pool) {
        const factory = new PathFactoryImpl(void 0, pool);
        return factory.create(component, path6);
      }
    };
    exports2.PathFactoryUtils = PathFactoryUtils;
    PathFactoryUtils.defaultFactory = new DefaultPathFactory();
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/paths/index.js
var require_paths = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/paths/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathDomain = exports2.PathValidationError = exports2.PathParseError = exports2.PathError = exports2.PATH_CONSTANTS = exports2.PathType = exports2.PathFactoryUtils = exports2.PathBuilder = exports2.SimplePathPool = exports2.DefaultPathFactory = exports2.PathFactoryImpl = exports2.PathUtils = exports2.Path = exports2.PathParserUtils = exports2.ConfigurablePathNormalizer = exports2.DefaultFileExtensionChecker = exports2.PathParsingNormalizer = exports2.BasicPathNormalizer = exports2.PathProcessorImpl = exports2.PathComponentsUtils = exports2.PathComponentsFactory = exports2.LowHighImpl = exports2.PathPositionsImpl = exports2.PathComponentsImpl = void 0;
    __exportStar(require_type4(), exports2);
    var pathcomponents_1 = require_pathcomponents();
    Object.defineProperty(exports2, "PathComponentsImpl", { enumerable: true, get: function() {
      return pathcomponents_1.PathComponentsImpl;
    } });
    Object.defineProperty(exports2, "PathPositionsImpl", { enumerable: true, get: function() {
      return pathcomponents_1.PathPositionsImpl;
    } });
    Object.defineProperty(exports2, "LowHighImpl", { enumerable: true, get: function() {
      return pathcomponents_1.LowHighImpl;
    } });
    Object.defineProperty(exports2, "PathComponentsFactory", { enumerable: true, get: function() {
      return pathcomponents_1.PathComponentsFactory;
    } });
    Object.defineProperty(exports2, "PathComponentsUtils", { enumerable: true, get: function() {
      return pathcomponents_1.PathComponentsUtils;
    } });
    var pathparser_1 = require_pathparser();
    Object.defineProperty(exports2, "PathProcessorImpl", { enumerable: true, get: function() {
      return pathparser_1.PathProcessorImpl;
    } });
    Object.defineProperty(exports2, "BasicPathNormalizer", { enumerable: true, get: function() {
      return pathparser_1.BasicPathNormalizer;
    } });
    Object.defineProperty(exports2, "PathParsingNormalizer", { enumerable: true, get: function() {
      return pathparser_1.PathParsingNormalizer;
    } });
    Object.defineProperty(exports2, "DefaultFileExtensionChecker", { enumerable: true, get: function() {
      return pathparser_1.DefaultFileExtensionChecker;
    } });
    Object.defineProperty(exports2, "ConfigurablePathNormalizer", { enumerable: true, get: function() {
      return pathparser_1.ConfigurablePathNormalizer;
    } });
    Object.defineProperty(exports2, "PathParserUtils", { enumerable: true, get: function() {
      return pathparser_1.PathParserUtils;
    } });
    var path_1 = require_path();
    Object.defineProperty(exports2, "Path", { enumerable: true, get: function() {
      return path_1.Path;
    } });
    Object.defineProperty(exports2, "PathUtils", { enumerable: true, get: function() {
      return path_1.PathUtils;
    } });
    var pathfactory_1 = require_pathfactory();
    Object.defineProperty(exports2, "PathFactoryImpl", { enumerable: true, get: function() {
      return pathfactory_1.PathFactoryImpl;
    } });
    Object.defineProperty(exports2, "DefaultPathFactory", { enumerable: true, get: function() {
      return pathfactory_1.DefaultPathFactory;
    } });
    Object.defineProperty(exports2, "SimplePathPool", { enumerable: true, get: function() {
      return pathfactory_1.SimplePathPool;
    } });
    Object.defineProperty(exports2, "PathBuilder", { enumerable: true, get: function() {
      return pathfactory_1.PathBuilder;
    } });
    Object.defineProperty(exports2, "PathFactoryUtils", { enumerable: true, get: function() {
      return pathfactory_1.PathFactoryUtils;
    } });
    var type_1 = require_type4();
    Object.defineProperty(exports2, "PathType", { enumerable: true, get: function() {
      return type_1.PathType;
    } });
    var type_2 = require_type4();
    Object.defineProperty(exports2, "PATH_CONSTANTS", { enumerable: true, get: function() {
      return type_2.PATH_CONSTANTS;
    } });
    var type_3 = require_type4();
    Object.defineProperty(exports2, "PathError", { enumerable: true, get: function() {
      return type_3.PathError;
    } });
    Object.defineProperty(exports2, "PathParseError", { enumerable: true, get: function() {
      return type_3.PathParseError;
    } });
    Object.defineProperty(exports2, "PathValidationError", { enumerable: true, get: function() {
      return type_3.PathValidationError;
    } });
    var pathfactory_2 = require_pathfactory();
    var pathparser_2 = require_pathparser();
    var path_2 = require_path();
    var pathparser_3 = require_pathparser();
    var pathfactory_3 = require_pathfactory();
    var pathfactory_4 = require_pathfactory();
    var pathparser_4 = require_pathparser();
    exports2.PathDomain = {
      createContentPath: pathfactory_2.PathFactoryUtils.createContentPath,
      createStaticPath: pathfactory_2.PathFactoryUtils.createStaticPath,
      createLayoutPath: pathfactory_2.PathFactoryUtils.createLayoutPath,
      createArchetypePath: pathfactory_2.PathFactoryUtils.createArchetypePath,
      createDataPath: pathfactory_2.PathFactoryUtils.createDataPath,
      createThemePath: pathfactory_2.PathFactoryUtils.createThemePath,
      builder: pathfactory_2.PathFactoryUtils.builder,
      parseBasic: pathparser_2.PathParserUtils.parseBasic,
      join: pathparser_2.PathParserUtils.join,
      normalizeBasic: pathparser_2.PathParserUtils.normalizeBasic,
      isBundle: pathparser_2.PathParserUtils.isBundle,
      extractSection: pathparser_2.PathParserUtils.extractSection,
      removeExtension: pathparser_2.PathParserUtils.removeExtension,
      checkExtension: pathparser_2.PathParserUtils.hasExtension,
      hasSpecificExtension: path_2.PathUtils.hasExtension,
      isUnder: path_2.PathUtils.isUnder,
      relativeTo: path_2.PathUtils.relativeTo,
      compare: path_2.PathUtils.compare,
      createProcessor: () => new pathparser_3.PathProcessorImpl(),
      createFactory: () => new pathfactory_3.DefaultPathFactory(),
      createPool: (maxSize) => new pathfactory_4.SimplePathPool(maxSize),
      createNormalizer: (config) => new pathparser_4.BasicPathNormalizer(config?.toLowerCase, config?.replaceSpaces)
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filemeta.js
var require_filemeta = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filemeta.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileMeta = void 0;
    exports2.newFileMeta = newFileMeta;
    var paths_1 = require_paths();
    var FileMeta = class {
      constructor(filename = "", openFunc = null) {
        this.filename = filename;
        this.componentRoot = "";
        this.componentDir = "";
        this.openFunc = openFunc;
      }
      fileName() {
        return this.filename;
      }
      relativeFilename() {
        if (this.componentRoot === "") {
          return this.filename;
        }
        const rootIndex = this.filename.indexOf(this.componentRoot);
        if (rootIndex === -1) {
          throw new Error(`filename ${this.filename} has no root ${this.componentRoot}`);
        }
        let relativePath = this.filename.substring(rootIndex + this.componentRoot.length);
        if (!relativePath.startsWith(paths_1.PATH_CONSTANTS.SYSTEM_PATH_SEPARATOR)) {
          relativePath = paths_1.PATH_CONSTANTS.SYSTEM_PATH_SEPARATOR + relativePath;
        }
        return relativePath;
      }
      component() {
        return this.componentDir;
      }
      root() {
        return this.componentRoot;
      }
      async open() {
        if (this.openFunc === null) {
          throw new Error("OpenFunc not set");
        }
        return await this.openFunc();
      }
      setFileName(filename) {
        this.filename = filename;
      }
      setComponentRoot(root) {
        this.componentRoot = root;
      }
      setComponentDir(dir) {
        this.componentDir = dir;
      }
      setOpenFunc(openFunc) {
        this.openFunc = openFunc;
      }
      merge(from) {
        if (!from)
          return;
        if (from.filename && !this.filename) {
          this.filename = from.filename;
        }
        if (from.componentRoot && !this.componentRoot) {
          this.componentRoot = from.componentRoot;
        }
        if (from.componentDir && !this.componentDir) {
          this.componentDir = from.componentDir;
        }
        if (from.openFunc && !this.openFunc) {
          this.openFunc = from.openFunc;
        }
      }
    };
    exports2.FileMeta = FileMeta;
    function newFileMeta(filename, openFunc) {
      return new FileMeta(filename, openFunc);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/fileinfo.js
var require_fileinfo = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/fileinfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileInfo = void 0;
    exports2.newFileInfo = newFileInfo;
    exports2.newFileInfoWithMeta = newFileInfoWithMeta;
    var filemeta_1 = require_filemeta();
    var FileInfo = class {
      constructor(fileInfo, fileMeta) {
        this.fileInfo = fileInfo;
        this._fileMeta = fileMeta;
      }
      meta() {
        return this._fileMeta;
      }
      type() {
        return this.fileInfo.mode();
      }
      info() {
        return this.fileInfo;
      }
      setMeta(meta) {
        this._fileMeta = meta;
      }
      name() {
        return this.fileInfo.name();
      }
      size() {
        return this.fileInfo.size();
      }
      mode() {
        return this.fileInfo.mode();
      }
      modTime() {
        return this.fileInfo.modTime();
      }
      isDir() {
        return this.fileInfo.isDir();
      }
      sys() {
        return this.fileInfo.sys();
      }
      fileName() {
        return this._fileMeta.fileName();
      }
      relativeFilename() {
        return this._fileMeta.relativeFilename();
      }
      component() {
        return this._fileMeta.component();
      }
      root() {
        return this._fileMeta.root();
      }
      async open() {
        return await this._fileMeta.open();
      }
    };
    exports2.FileInfo = FileInfo;
    function newFileInfo(fi, filename) {
      const meta = (0, filemeta_1.newFileMeta)(filename);
      const info = new FileInfo(fi, meta);
      if (isMetaProvider(fi)) {
        info.meta().merge(fi.meta());
      }
      return info;
    }
    function newFileInfoWithMeta(fi, meta) {
      const info = new FileInfo(fi, meta);
      if (isMetaProvider(fi)) {
        info.meta().merge(fi.meta());
      }
      return info;
    }
    function isMetaProvider(obj) {
      return obj && typeof obj.meta === "function";
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/file.js
var require_file = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/file.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.File = void 0;
    exports2.newFile = newFile;
    exports2.newFileWithMeta = newFileWithMeta;
    exports2.newDirFileWithMeta = newDirFileWithMeta;
    exports2.newDirFile = newDirFile;
    var filemeta_1 = require_filemeta();
    var fileinfo_1 = require_fileinfo();
    var path6 = __importStar(require("path"));
    var File = class {
      constructor(file, fileMeta, fs5, isDir = false) {
        this.file = file;
        this.fileMeta = fileMeta;
        this.fs = fs5;
        this._isDir = isDir;
      }
      isNop() {
        return this.file === null;
      }
      async close() {
        if (this.file === null) {
          return;
        }
        return await this.file.close();
      }
      async readDir(count) {
        const result = [];
        if (this._isDir && this.file) {
          const fis = await this.file.readdir(count);
          for (const fi of fis) {
            const filename = this.joinPath(this.fileMeta.fileName(), fi.name());
            const meta = (0, filemeta_1.newFileMeta)(filename, async () => {
              return await this.fs.open(filename);
            });
            meta.merge(this.fileMeta);
            const fim = (0, fileinfo_1.newFileInfo)(fi, filename);
            fim.setMeta(meta);
            result.push(fim);
          }
        }
        return result;
      }
      meta() {
        return this.fileMeta;
      }
      joinPath(dir, name) {
        if (dir.endsWith("/")) {
          return dir + name;
        }
        return dir + "/" + name;
      }
      async read(buffer) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.read(buffer);
      }
      async readAt(buffer, offset) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.readAt(buffer, offset);
      }
      async seek(offset, whence) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.seek(offset, whence);
      }
      async write(buffer) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.write(buffer);
      }
      async writeAt(buffer, offset) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.writeAt(buffer, offset);
      }
      name() {
        return path6.basename(this.fileMeta.fileName());
      }
      async readdir(count) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.readDir(count);
      }
      async readdirnames(n2) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.readdirnames(n2);
      }
      async stat() {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.stat();
      }
      async sync() {
        if (this.file === null) {
          return;
        }
        return await this.file.sync();
      }
      async truncate(size) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.truncate(size);
      }
      async writeString(s) {
        if (this.file === null) {
          throw new Error("File is null");
        }
        return await this.file.writeString(s);
      }
    };
    exports2.File = File;
    function newFile(file, filename, fs5) {
      const meta = (0, filemeta_1.newFileMeta)(filename);
      return new File(file, meta, fs5);
    }
    function newFileWithMeta(file, meta, fs5) {
      return new File(file, meta, fs5);
    }
    function newDirFileWithMeta(file, meta, fs5) {
      return new File(file, meta, fs5, true);
    }
    function newDirFile(file, filename, fs5) {
      const meta = (0, filemeta_1.newFileMeta)(filename);
      return new File(file, meta, fs5, true);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/dir.js
var require_dir2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/dir.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirFile = void 0;
    exports2.newDirFileWithVirtualOpener = newDirFileWithVirtualOpener;
    exports2.newDirFile = newDirFile;
    exports2.newDirFileWithFilter = newDirFileWithFilter;
    exports2.newDirFileWithOpenerAndFilter = newDirFileWithOpenerAndFilter;
    var file_1 = require_file();
    var DirFile = class extends file_1.File {
      constructor(file, virtualOpener = null, filter = null) {
        super(file.isNop() ? null : file, file.meta(), file.fs, true);
        this.virtualOpener = virtualOpener;
        this.filter = filter;
      }
      async readDir(count) {
        if (!this.isNop()) {
          let fis = await super.readDir(count);
          if (this.filter !== null) {
            fis = await this.filter(fis);
          }
          return fis;
        }
        return await this.readVirtualDir();
      }
      async readVirtualDir() {
        if (this.virtualOpener !== null) {
          return await this.virtualOpener();
        }
        throw new Error("virtual dir opener not found");
      }
      setFilter(filter) {
        this.filter = filter;
      }
      setVirtualOpener(opener) {
        this.virtualOpener = opener;
      }
      getFilter() {
        return this.filter;
      }
      getVirtualOpener() {
        return this.virtualOpener;
      }
    };
    exports2.DirFile = DirFile;
    function newDirFileWithVirtualOpener(file, opener) {
      return new DirFile(file, opener);
    }
    function newDirFile(file, meta, fs5) {
      const baseFile = new file_1.File(file, meta, fs5, true);
      return new DirFile(baseFile);
    }
    function newDirFileWithFilter(file, filter) {
      return new DirFile(file, null, filter);
    }
    function newDirFileWithOpenerAndFilter(file, opener, filter) {
      return new DirFile(file, opener, filter);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/basefs.js
var require_basefs = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/basefs.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseFs = void 0;
    exports2.newBaseFs = newBaseFs;
    var filemeta_1 = require_filemeta();
    var fileinfo_1 = require_fileinfo();
    var file_1 = require_file();
    var dir_1 = require_dir2();
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "basefs" });
    var BaseFs = class {
      constructor(fs5, roots) {
        this.fs = fs5;
        this.roots = roots;
      }
      toAbsolutePath(name) {
        if (this.roots.length === 0) {
          return name;
        }
        const root = this.roots[0];
        if (name === "") {
          return root;
        }
        if (path6.isAbsolute(name)) {
          if (name.startsWith(root)) {
            return name;
          }
          return path6.join(root, name.substring(1));
        }
        return path6.join(root, name);
      }
      async stat(name) {
        const absPath = this.toAbsolutePath(name);
        try {
          const fi = await this.fs.stat(absPath);
          if (fi.isDir()) {
            const fileInfo2 = (0, fileinfo_1.newFileInfo)(fi, absPath);
            fileInfo2.meta().setOpenFunc(async () => {
              return await this.openDir(name);
            });
            return fileInfo2;
          }
          const fileInfo = (0, fileinfo_1.newFileInfo)(fi, absPath);
          const root = this.getRoot(absPath);
          fileInfo.meta().setComponentRoot(root);
          fileInfo.meta().setOpenFunc(async () => {
            return await this.openInternal(name);
          });
          return fileInfo;
        } catch (error) {
          throw error;
        }
      }
      async open(name) {
        const absPath = this.toAbsolutePath(name);
        const fi = await this.fs.stat(absPath);
        if (fi.isDir()) {
          return await this.openDir(name);
        }
        return await this.openInternal(name);
      }
      async openInternal(name, isDir = false) {
        const absPath = this.toAbsolutePath(name);
        const f = await this.fs.open(absPath);
        const root = this.getRoot(absPath);
        const meta = (0, filemeta_1.newFileMeta)(absPath);
        meta.setComponentRoot(root);
        if (isDir) {
          return (0, file_1.newDirFileWithMeta)(f, meta, this.fs);
        }
        return (0, file_1.newFileWithMeta)(f, meta, this.fs);
      }
      getRoot(name) {
        for (const root of this.roots) {
          if (name.startsWith(root)) {
            return root;
          }
        }
        return "";
      }
      async openDir(name) {
        const f = await this.openInternal(name, true);
        const absPath = this.toAbsolutePath(name);
        const root = this.getRoot(absPath);
        const meta = (0, filemeta_1.newFileMeta)(absPath);
        meta.setComponentRoot(root);
        return (0, dir_1.newDirFile)(f, meta, this.fs);
      }
      async create(name) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.create(absPath);
      }
      async mkdir(name, perm) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.mkdir(absPath, perm);
      }
      async mkdirAll(path7, perm) {
        const absPath = this.toAbsolutePath(path7);
        return await this.fs.mkdirAll(absPath, perm);
      }
      async openFile(name, flag, perm) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.openFile(absPath, flag, perm);
      }
      async remove(name) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.remove(absPath);
      }
      async removeAll(path7) {
        const absPath = this.toAbsolutePath(path7);
        return await this.fs.removeAll(absPath);
      }
      async rename(oldname, newname) {
        const oldAbsPath = this.toAbsolutePath(oldname);
        const newAbsPath = this.toAbsolutePath(newname);
        return await this.fs.rename(oldAbsPath, newAbsPath);
      }
      name() {
        return `BaseFs(${this.fs.name()})`;
      }
      async chmod(name, mode) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.chmod(absPath, mode);
      }
      async chown(name, uid, gid) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.chown(absPath, uid, gid);
      }
      async chtimes(name, atime, mtime) {
        const absPath = this.toAbsolutePath(name);
        return await this.fs.chtimes(absPath, atime, mtime);
      }
    };
    exports2.BaseFs = BaseFs;
    function newBaseFs(fs5, roots) {
      return new BaseFs(fs5, roots);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/walkway.js
var require_walkway = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/walkway.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Walkway = void 0;
    exports2.newWalkway = newWalkway;
    var path6 = __importStar(require("path"));
    var type_1 = require_type3();
    var fileinfo_1 = require_fileinfo();
    var filemeta_1 = require_filemeta();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "walkway" });
    var Walkway = class {
      constructor(fs5, cb) {
        this.walked = false;
        if (!fs5) {
          throw new Error("fs must be set");
        }
        if (!cb.walkFn) {
          throw new Error("walkFn must be set");
        }
        this.fs = fs5;
        this.cb = cb;
        this.root = "";
        this.cfg = {};
      }
      async walkWith(root, cfg) {
        this.cfg = cfg;
        this.root = root;
        return await this.walk();
      }
      async walk() {
        if (this.walked) {
          throw new Error("this walkway is already walked");
        }
        this.walked = true;
        return await this.walkRecursive(this.root, this.cfg.info, this.cfg.dirEntries);
      }
      checkErr(filename, err) {
        if (this.isNotExistError(err) && !this.cfg.failOnNotExist) {
          log.warn(`File "${filename}" not found, skipping.`);
          return true;
        }
        return false;
      }
      isNotExistError(err) {
        return err.message.includes("ENOENT") || err.message.includes("no such file") || err.code === "ENOENT";
      }
      async walkRecursive(filePath, info, dirEntries) {
        if (!info) {
          try {
            const fi = await this.fs.stat(filePath);
            const meta = (0, filemeta_1.newFileMeta)(filePath);
            meta.setOpenFunc(async () => await this.fs.open(filePath));
            info = (0, fileinfo_1.newFileInfoWithMeta)(fi, meta);
          } catch (err) {
            if (filePath === this.root && this.isNotExistError(err)) {
              if (this.cfg.failOnNotExist) {
                throw new type_1.FsError(`walk: root not found: ${err.message}`, "WALK_ROOT_NOT_FOUND");
              }
              return;
            }
            if (this.checkErr(filePath, err)) {
              return;
            }
            throw new type_1.FsError(`walk: stat: ${err.message}`, "WALK_STAT_FAILED");
          }
        }
        try {
          const result = await this.cb.walkFn(filePath, info);
          if (result instanceof Error) {
            throw result;
          }
        } catch (err) {
          if (info.isDir() && err === type_1.ErrSkipDir) {
            return;
          }
          throw err;
        }
        if (!info.isDir()) {
          return;
        }
        if (!dirEntries) {
          try {
            const file = await this.fs.open(filePath);
            const entries = await file.readdir(-1);
            await file.close();
            dirEntries = entries.map((entry) => {
              return entry;
            });
            if (this.cfg.sortDirEntries) {
              dirEntries.sort((a, b) => a.name().localeCompare(b.name()));
            }
          } catch (err) {
            if (this.checkErr(filePath, err)) {
              return;
            }
            throw new type_1.FsError(`walk: readdir: ${err.message}`, "WALK_READDIR_FAILED");
          }
        }
        if (this.cfg.ignoreFile) {
          dirEntries = dirEntries.filter((entry) => !this.cfg.ignoreFile(entry.fileName()));
        }
        if (this.cb.hookPre) {
          try {
            dirEntries = await this.cb.hookPre(info, filePath, dirEntries);
          } catch (err) {
            if (err === type_1.ErrSkipDir) {
              return;
            }
            throw err;
          }
        }
        for (const entry of dirEntries) {
          const nextPath = path6.join(filePath, entry.name());
          try {
            await this.walkRecursive(nextPath, entry);
          } catch (err) {
            if (!entry.isDir() || err !== type_1.ErrSkipDir) {
              throw err;
            }
          }
        }
        if (this.cb.hookPost) {
          try {
            await this.cb.hookPost(info, filePath, dirEntries);
          } catch (err) {
            if (err === type_1.ErrSkipDir) {
              return;
            }
            throw err;
          }
        }
      }
    };
    exports2.Walkway = Walkway;
    function newWalkway(fs5, cb) {
      return new Walkway(fs5, cb);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/static-copier.js
var require_static_copier = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/static-copier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StaticCopier = void 0;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "static-copier" });
    var StaticCopier = class {
      constructor(froms, to) {
        this.fromFss = froms;
        this.toFs = to;
      }
      async copy() {
        if (!this.fromFss || this.fromFss.length === 0) {
          log.error("No static filesystems found");
          return;
        }
        if (!this.toFs) {
          log.error("No publish filesystem found");
          return;
        }
        await this.doWithPublishDirs(this.toFs, async (publishDir) => {
          for (const sf of this.fromFss) {
            await this.copyStaticTo(sf, publishDir);
          }
        });
      }
      async doWithPublishDirs(publishFs, fn) {
        try {
          await fn("/");
        } catch (error) {
          log.error("Error in doWithPublishDirs:", error);
          throw error;
        }
      }
      async copyStaticTo(sourceFs, targetDir) {
        try {
          return await this.walkSourceFiles(sourceFs, targetDir);
        } catch (error) {
          log.error(`Error copying static files to ${targetDir}:`, error);
          throw error;
        }
      }
      async walkSourceFiles(sourceFs, targetDir) {
        let fileCount = 0;
        try {
          await this.walkFileSystem(sourceFs, "/", async (path6, isDir) => {
            if (!isDir) {
              await this.copyFile(sourceFs, path6, this.toFs, targetDir);
              fileCount++;
            }
          });
        } catch (error) {
          log.error("Error walking source files:", error);
          throw error;
        }
        return fileCount;
      }
      async walkFileSystem(fs5, basePath, callback) {
        try {
          const file = await fs5.open(basePath);
          const fileInfo = await file.stat();
          if (!fileInfo.isDir()) {
            await file.close();
            await callback(basePath, false);
            return;
          }
          const entries = await file.readdir(-1);
          await file.close();
          for (const entry of entries) {
            const fullPath = this.joinPath(basePath, entry.name());
            if (entry.isDir()) {
              await callback(fullPath, true);
              await this.walkFileSystem(fs5, fullPath, callback);
            } else {
              await callback(fullPath, false);
            }
          }
        } catch (error) {
          log.error(`Could not read directory ${basePath}:`, error);
        }
      }
      async copyFile(sourceFs, sourcePath, targetFs, targetDir) {
        let sourceFile = null;
        let targetFile = null;
        try {
          const cleanSourcePath = sourcePath.startsWith("/") ? sourcePath.slice(1) : sourcePath;
          const targetPath = this.joinPath(targetDir, cleanSourcePath);
          const targetDirPath = this.dirname(targetPath);
          if (targetDirPath !== "/") {
            await targetFs.mkdirAll(targetDirPath, 493);
          }
          sourceFile = await sourceFs.open(sourcePath);
          const sourceInfo = await sourceFile.stat();
          const buffer = new Uint8Array(sourceInfo.size());
          await sourceFile.read(buffer);
          targetFile = await targetFs.create(targetPath);
          await targetFile.write(buffer);
        } catch (error) {
          log.warn(`Failed to copy static file ${sourcePath}:`, error);
        } finally {
          if (targetFile) {
            try {
              await targetFile.close();
            } catch (closeError) {
              log.warn(`Failed to close target file: ${closeError}`);
            }
          }
          if (sourceFile) {
            try {
              await sourceFile.close();
            } catch (closeError) {
              log.warn(`Failed to close source file: ${closeError}`);
            }
          }
        }
      }
      joinPath(...parts) {
        return parts.map((part) => part.replace(/^\/+|\/+$/g, "")).filter((part) => part.length > 0).join("/").replace(/^/, "/");
      }
      dirname(path6) {
        const parts = path6.split("/").filter((part) => part.length > 0);
        if (parts.length <= 1)
          return "/";
        return "/" + parts.slice(0, -1).join("/");
      }
    };
    exports2.StaticCopier = StaticCopier;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/incremental-file-collector.js
var require_incremental_file_collector = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/incremental-file-collector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectFileMetaInfos = collectFileMetaInfos;
    var fileinfo_1 = require_fileinfo();
    var filemeta_1 = require_filemeta();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "incremental-file-collector" });
    async function collectFileMetaInfos(paths, fss) {
      const result = /* @__PURE__ */ new Map();
      for (const path6 of paths) {
        try {
          for (const fs5 of fss) {
            const fileMetaInfo = await createFileMetaInfo(path6, fs5);
            result.set(path6, fileMetaInfo);
          }
        } catch (error) {
          log.error(`Failed to create FileMetaInfo for ${path6}:`, error);
        }
      }
      return result;
    }
    async function createFileMetaInfo(filePath, fs5) {
      try {
        const fi = await fs5.stat(filePath);
        const meta = (0, filemeta_1.newFileMeta)(filePath);
        meta.setOpenFunc(async () => await fs5.open(filePath));
        return (0, fileinfo_1.newFileInfoWithMeta)(fi, meta);
      } catch (error) {
        throw new Error(`Failed to stat file ${filePath}: ${error.message}`);
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/fs.js
var require_fs = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fs = void 0;
    var basefs_1 = require_basefs();
    var walkway_1 = require_walkway();
    var static_copier_1 = require_static_copier();
    var incremental_file_collector_1 = require_incremental_file_collector();
    var fs_1 = require_fs3();
    var Fs = class {
      constructor(originFs, prompts, workflows, content, layouts, statics, assets, i18n, work) {
        this.originFs = originFs;
        this.prompts = prompts;
        this.workflows = workflows;
        this.content = content;
        this.layouts = layouts;
        this.statics = statics;
        this.assets = assets;
        this.i18n = i18n;
        this.work = work;
        this.service = (0, fs_1.newService)();
      }
      os() {
        return this.originFs.getOrigin();
      }
      workFs() {
        return this.work;
      }
      workflowFs() {
        return this.workflows;
      }
      promptFs() {
        return this.prompts;
      }
      contentFs() {
        return this.content;
      }
      layoutsFs() {
        return this.layouts;
      }
      staticFs() {
        return this.statics;
      }
      assetsFs() {
        return this.assets;
      }
      publishFs() {
        return this.originFs.publish();
      }
      copyStatic(froms, to) {
        const sc = new static_copier_1.StaticCopier(froms, to);
        return sc.copy();
      }
      newFileMetaInfo(filename) {
        return this.service.newFileMetaInfo(filename);
      }
      newFileMetaInfoWithContent(content) {
        return this.service.newFileMetaInfoWithContent(content);
      }
      async getFileMetaInfos(paths) {
        return (0, incremental_file_collector_1.collectFileMetaInfos)(paths, this.content);
      }
      newBasePathFs(source, path6) {
        return (0, basefs_1.newBaseFs)(source, [path6]);
      }
      async walkPrompts(start, cb, conf) {
        return await this.walk(this.prompts, start, cb, conf);
      }
      async walkWorkflows(start, cb, conf) {
        return await this.walk(this.workflows, start, cb, conf);
      }
      async walkLayouts(start, cb, conf) {
        return await this.walk(this.layouts, start, cb, conf);
      }
      async walkContent(fs5, start, cb, conf) {
        await this.walk(fs5, start, cb, conf);
      }
      async walkStatics(start, cb, conf) {
        return await this.walk(this.statics, start, cb, conf);
      }
      async walkI18n(start, cb, conf) {
        return await this.walk(this.i18n, start, cb, conf);
      }
      async walk(fs5, start, cb, conf) {
        const w = (0, walkway_1.newWalkway)(fs5, cb);
        if (start === "") {
          start = "/";
        }
        return await w.walkWith(start, conf);
      }
    };
    exports2.Fs = Fs;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlayoptions.js
var require_overlayoptions = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlayoptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OverlayOptions = exports2.defaultDirMerger = void 0;
    exports2.newOverlayOptions = newOverlayOptions;
    exports2.createDefaultOverlayOptions = createDefaultOverlayOptions;
    exports2.createWritableOverlayOptions = createWritableOverlayOptions;
    var defaultDirMerger = (lofi, bofi) => {
      const result = [...lofi];
      for (const boFile of bofi) {
        let found = false;
        for (const loFile of lofi) {
          if (boFile.name() === loFile.name()) {
            found = true;
            break;
          }
        }
        if (!found) {
          result.push(boFile);
        }
      }
      return result;
    };
    exports2.defaultDirMerger = defaultDirMerger;
    var OverlayOptions = class {
      constructor(options) {
        this.fss = [...options.fss];
        this.firstWritable = options.firstWritable ?? false;
        this.dirsMerger = options.dirsMerger ?? exports2.defaultDirMerger;
      }
      withFilesystems(...additionalFss) {
        return new OverlayOptions({
          fss: [...this.fss, ...additionalFss],
          firstWritable: this.firstWritable,
          dirsMerger: this.dirsMerger
        });
      }
      withFirstWritable(writable2) {
        return new OverlayOptions({
          fss: this.fss,
          firstWritable: writable2,
          dirsMerger: this.dirsMerger
        });
      }
      withDirsMerger(merger) {
        return new OverlayOptions({
          fss: this.fss,
          firstWritable: this.firstWritable,
          dirsMerger: merger
        });
      }
      getWritableFs() {
        if (!this.firstWritable || this.fss.length === 0) {
          return null;
        }
        return this.fss[0];
      }
      isValid() {
        return this.dirsMerger !== void 0;
      }
      getFilesystemCount() {
        return this.fss.length;
      }
      getFilesystem(index) {
        if (index < 0 || index >= this.fss.length) {
          return null;
        }
        return this.fss[index];
      }
      hasFilesystem(fs5) {
        return this.fss.includes(fs5);
      }
      getFilesystems() {
        return this.fss;
      }
    };
    exports2.OverlayOptions = OverlayOptions;
    function newOverlayOptions(fss, firstWritable = false, dirsMerger) {
      const options = {
        fss,
        firstWritable
      };
      if (dirsMerger !== void 0) {
        options.dirsMerger = dirsMerger;
      }
      return new OverlayOptions(options);
    }
    function createDefaultOverlayOptions(fss) {
      return newOverlayOptions(fss, false, exports2.defaultDirMerger);
    }
    function createWritableOverlayOptions(fss, dirsMerger) {
      return newOverlayOptions(fss, true, dirsMerger);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/overlaydir.js
var require_overlaydir = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/overlaydir.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OverlayDir = void 0;
    exports2.getDir = getDir;
    exports2.releaseDir = releaseDir;
    exports2.openDir = openDir;
    exports2.newOverlayDir = newOverlayDir;
    var type_1 = require_type3();
    var overlayoptions_1 = require_overlayoptions();
    var OverlayDir = class {
      constructor(options = {}) {
        this._name = options.name || "";
        this.fss = options.fss ? [...options.fss] : [];
        this.dirOpeners = options.dirOpeners ? [...options.dirOpeners] : [];
        if (options.info !== void 0) {
          this.info = options.info;
        }
        this.merge = options.merge || overlayoptions_1.defaultDirMerger;
        this.offset = 0;
        this.fis = [];
        this.closed = false;
      }
      name() {
        return this._name;
      }
      isClosed() {
        return this.closed || this.fss.length === 0 && this.dirOpeners.length === 0;
      }
      async readdir(count) {
        if (this.isClosed()) {
          throw type_1.ErrFileClosed;
        }
        if (this.err) {
          throw this.err;
        }
        if (this.offset === 0) {
          await this.loadDirectoryEntries();
        }
        const remainingEntries = this.fis.slice(this.offset);
        if (count <= 0) {
          this.err = new Error("EOF");
          if (this.offset > 0 && remainingEntries.length === 0) {
            throw this.err;
          }
          return [...remainingEntries];
        }
        if (remainingEntries.length === 0) {
          this.err = new Error("EOF");
          throw this.err;
        }
        const result = remainingEntries.slice(0, count);
        this.offset += result.length;
        return result;
      }
      async readdirnames(n2) {
        if (this.isClosed()) {
          throw type_1.ErrFileClosed;
        }
        const entries = await this.readdir(n2);
        return entries.map((entry) => entry.name());
      }
      async loadDirectoryEntries() {
        for (let i = 0; i < this.fss.length; i++) {
          const fs5 = this.fss[i];
          await this.readFromFilesystem(fs5, null);
        }
        for (let i = 0; i < this.dirOpeners.length; i++) {
          const file = await this.dirOpeners[i]();
          await this.readFromFilesystem(null, file);
        }
      }
      async readFromFilesystem(fs5, file) {
        let f = file;
        try {
          if (!f && fs5) {
            const fsPath = this._name === "/" ? "" : this._name;
            f = await fs5.open(fsPath);
          }
          if (!f) {
            return;
          }
          const entries = await f.readdir(-1);
          this.fis = this.merge(this.fis, entries);
        } catch (error) {
        } finally {
          if (f && !file) {
            await f.close();
          }
        }
      }
      async stat() {
        if (this.isClosed()) {
          throw type_1.ErrFileClosed;
        }
        if (this.info) {
          return await this.info();
        }
        if (this.fss.length > 0) {
          return await this.fss[0].stat(this._name);
        }
        throw new type_1.OverlayFsError("no filesystem available for stat", "NO_FILESYSTEM");
      }
      async close() {
        this.closed = true;
        this.fss = [];
        this.dirOpeners = [];
        this.fis = [];
        delete this.info;
        this.offset = 0;
        delete this.err;
      }
      notSupported(operation) {
        throw new type_1.OverlayFsError(`operation ${operation} not supported on directory "${this._name}"`, "OPERATION_NOT_SUPPORTED");
      }
      async read(buffer) {
        this.notSupported("read");
      }
      async readAt(buffer, offset) {
        this.notSupported("readAt");
      }
      async seek(offset, whence) {
        this.notSupported("seek");
      }
      async write(buffer) {
        this.notSupported("write");
      }
      async writeAt(buffer, offset) {
        this.notSupported("writeAt");
      }
      async sync() {
        this.notSupported("sync");
      }
      async truncate(size) {
        this.notSupported("truncate");
      }
      async writeString(s) {
        this.notSupported("writeString");
      }
    };
    exports2.OverlayDir = OverlayDir;
    var DirPool = class {
      constructor() {
        this.pool = [];
      }
      get() {
        if (this.pool.length > 0) {
          return this.pool.pop();
        }
        return new OverlayDir();
      }
      release(dir) {
        dir["fss"] = [];
        dir["dirOpeners"] = [];
        dir["fis"] = [];
        delete dir["info"];
        dir["offset"] = 0;
        dir["_name"] = "";
        delete dir["err"];
        dir["closed"] = false;
        this.pool.push(dir);
      }
    };
    var dirPool = new DirPool();
    function getDir() {
      return dirPool.get();
    }
    function releaseDir(dir) {
      dirPool.release(dir);
    }
    async function openDir(name, merge, info, fss) {
      if (!info) {
        throw new type_1.OverlayFsError("info function must not be null", "INFO_REQUIRED");
      }
      const dir = getDir();
      const options = {
        name,
        fss: [...fss],
        info,
        merge: merge || overlayoptions_1.defaultDirMerger
      };
      Object.assign(dir, new OverlayDir(options));
      return dir;
    }
    function newOverlayDir(options = {}) {
      return new OverlayDir(options);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/overlayfs.js
var require_overlayfs = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/overlayfs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OverlayFs = void 0;
    exports2.newOverlayFs = newOverlayFs;
    exports2.createOverlayFs = createOverlayFs;
    var type_1 = require_type3();
    var overlayoptions_1 = require_overlayoptions();
    var overlaydir_1 = require_overlaydir();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "overlayfs" });
    var OverlayFs = class {
      constructor(options) {
        this.fss = [...options.fss];
        this.mergeDirs = options.dirsMerger;
        this.firstWritable = options.firstWritable;
      }
      name() {
        return "overlayfs";
      }
      filesystem(i) {
        if (i < 0 || i >= this.fss.length) {
          return null;
        }
        return this.fss[i];
      }
      numFilesystems() {
        return this.fss.length;
      }
      append(...fss) {
        const newOptions = new overlayoptions_1.OverlayOptions({
          fss: [...this.fss, ...fss],
          firstWritable: this.firstWritable,
          dirsMerger: this.mergeDirs
        });
        return new OverlayFs(newOptions);
      }
      withDirsMerger(merger) {
        const newOptions = new overlayoptions_1.OverlayOptions({
          fss: this.fss,
          firstWritable: this.firstWritable,
          dirsMerger: merger
        });
        return new OverlayFs(newOptions);
      }
      writeFs() {
        if (this.fss.length === 0) {
          throw type_1.ErrNoFilesystems;
        }
        return this.fss[0];
      }
      async collectDirs(name, withFs) {
        for (const fs5 of this.fss) {
          await this.collectDirsRecursive(fs5, name, withFs);
        }
      }
      async collectDirsRecursive(fs5, name, withFs) {
        try {
          const fi = await fs5.stat(name);
          if (fi.isDir()) {
            withFs(fs5);
          }
        } catch (error) {
        }
        const fsi = fs5;
        if (fsi.filesystem && fsi.numFilesystems) {
          for (let i = 0; i < fsi.numFilesystems(); i++) {
            const subFs = fsi.filesystem(i);
            if (subFs) {
              await this.collectDirsRecursive(subFs, name, withFs);
            }
          }
        }
      }
      async statInternal(name, lstatIfPossible) {
        for (let i = 0; i < this.fss.length; i++) {
          const fs5 = this.fss[i];
          const [fs22, fi, ok, err] = await this.statRecursive(fs5, name, lstatIfPossible);
          if (err === null || !this.isNotExistError(err)) {
            return [fs22, fi, ok, err];
          }
        }
        return [null, null, false, type_1.ErrFileNotFound];
      }
      async statRecursive(fs5, name, lstatIfPossible) {
        try {
          const fi = await fs5.stat(name);
          return [fs5, fi, false, null];
        } catch (error) {
          if (!this.isNotExistError(error)) {
            return [fs5, null, false, error];
          }
        }
        const fsi = fs5;
        if (fsi.filesystem && fsi.numFilesystems) {
          for (let i = 0; i < fsi.numFilesystems(); i++) {
            const subFs = fsi.filesystem(i);
            if (subFs) {
              const [fs22, fi, ok, err] = await this.statRecursive(subFs, name, lstatIfPossible);
              if (err === null || !this.isNotExistError(err)) {
                return [fs22, fi, ok, err];
              }
            }
          }
        }
        return [null, null, false, type_1.ErrFileNotFound];
      }
      isNotExistError(error) {
        return error.message.includes("ENOENT") || error.message.includes("no such file") || error === type_1.ErrFileNotFound;
      }
      async create(name) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().create(name);
      }
      async mkdir(name, perm) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().mkdir(name, perm);
      }
      async mkdirAll(path6, perm) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().mkdirAll(path6, perm);
      }
      async open(name) {
        if (this.fss.length === 0) {
          throw type_1.ErrFileNotFound;
        }
        const [fs5, fi, , err] = await this.statInternal(name, false);
        if (err) {
          throw err;
        }
        if (fi.isDir()) {
          const dirFss = [];
          await this.collectDirs(name, (fs6) => {
            dirFss.push(fs6);
          });
          if (dirFss.length === 0) {
            throw type_1.ErrFileNotFound;
          }
          if (dirFss.length === 1) {
            return await dirFss[0].open(name);
          }
          return await (0, overlaydir_1.openDir)(name, this.mergeDirs, async () => fi, dirFss);
        }
        return await fs5.open(name);
      }
      async openFile(name, flag, perm) {
        const isWrite = (flag & type_1.OpenFlags.O_WRONLY) !== 0 || (flag & type_1.OpenFlags.O_RDWR) !== 0;
        if (isWrite && !this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        if (isWrite) {
          return await this.writeFs().openFile(name, flag, perm);
        }
        return await this.open(name);
      }
      async remove(name) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().remove(name);
      }
      async removeAll(path6) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().removeAll(path6);
      }
      async rename(oldname, newname) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().rename(oldname, newname);
      }
      async stat(name) {
        const fsPath = name === "/" ? "" : name;
        const [, fi, , err] = await this.statInternal(fsPath, false);
        if (err) {
          throw err;
        }
        return fi;
      }
      async chmod(name, mode) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().chmod(name, mode);
      }
      async chown(name, uid, gid) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().chown(name, uid, gid);
      }
      async chtimes(name, atime, mtime) {
        if (!this.firstWritable) {
          throw new type_1.OverlayFsError("filesystem is read-only", "READ_ONLY");
        }
        return await this.writeFs().chtimes(name, atime, mtime);
      }
    };
    exports2.OverlayFs = OverlayFs;
    function newOverlayFs(options) {
      return new OverlayFs(options);
    }
    function createOverlayFs(opts) {
      const options = new overlayoptions_1.OverlayOptions(opts);
      return new OverlayFs(options);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filevitural.js
var require_filevitural = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filevitural.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newFileInfoWithName = newFileInfoWithName;
    exports2.newFileInfoWithContent = newFileInfoWithContent;
    var fs_1 = require_fs3();
    var fileinfo_1 = require_fileinfo();
    var VirtualFileInfo = class {
      constructor(name, content = "This is a virtual file.") {
        this._name = name;
        this._content = content;
        this._modTime = new Date();
      }
      name() {
        return this._name;
      }
      size() {
        return Buffer.byteLength(this._content, "utf8");
      }
      mode() {
        return 420;
      }
      modTime() {
        return this._modTime;
      }
      isDir() {
        return false;
      }
      sys() {
        return null;
      }
      getContent() {
        return this._content;
      }
    };
    var VirtualFile = class {
      constructor(fileName, fileContent) {
        this._fileInfo = null;
        this._fileName = fileName;
        this._fileContent = fileContent;
      }
      fullName() {
        return this._fileName;
      }
      async open() {
        return {
          name: () => this._fileName,
          close: async () => {
          },
          read: async (buffer) => {
            const data = Buffer.from(this._fileContent, "utf8");
            const bytesToCopy = Math.min(buffer.length, data.length);
            data.copy(buffer, 0, 0, bytesToCopy);
            return { bytesRead: bytesToCopy, buffer };
          },
          readAt: async (buffer, offset) => {
            const data = Buffer.from(this._fileContent, "utf8");
            const start = Math.min(offset, data.length);
            const bytesToCopy = Math.min(buffer.length, data.length - start);
            if (bytesToCopy > 0) {
              data.copy(buffer, 0, start, start + bytesToCopy);
            }
            return { bytesRead: bytesToCopy, buffer };
          },
          seek: async (offset, whence) => offset,
          write: async (buffer) => ({ bytesWritten: buffer.length, buffer }),
          writeAt: async (buffer, offset) => ({ bytesWritten: buffer.length, buffer }),
          readdir: async (count) => [],
          readdirnames: async (n2) => [],
          stat: async () => this.getFileInfo(),
          sync: async () => {
          },
          truncate: async (size) => {
          },
          writeString: async (s) => ({ bytesWritten: Buffer.byteLength(s, "utf8") })
        };
      }
      getFileInfo() {
        if (!this._fileInfo) {
          this._fileInfo = new VirtualFileInfo(this._fileName, this._fileContent);
        }
        return this._fileInfo;
      }
    };
    var globalVirtualFile = null;
    function getVirtualFileInfo() {
      if (!globalVirtualFile) {
        globalVirtualFile = new VirtualFile("/content/file.txt", "This is a virtual file.");
      }
      return globalVirtualFile.getFileInfo();
    }
    function getVirtualFileInfoWithContent(content) {
      const randomSuffix = Math.floor(Math.random() * 1e6).toString().padStart(6, "0");
      const fileName = `/content/file_${randomSuffix}.md`;
      return new VirtualFile(fileName, content);
    }
    function newFileInfoWithName(filename) {
      const vf = getVirtualFileInfo();
      const meta = (0, fs_1.newFileMeta)(filename);
      return new fileinfo_1.FileInfo(vf, meta);
    }
    function newFileInfoWithContent(content) {
      const vf = getVirtualFileInfoWithContent(content);
      const info = vf.getFileInfo();
      const opener = () => vf.open();
      const meta = (0, fs_1.newFileMeta)(vf.fullName(), opener);
      meta.setComponentRoot("content");
      meta.setComponentDir("content");
      return new fileinfo_1.FileInfo(info, meta);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/service.js
var require_service4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/entity/service.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Service = void 0;
    exports2.newService = newService;
    var filevitural_1 = require_filevitural();
    var Service = class {
      newFileMetaInfo(filename) {
        return (0, filevitural_1.newFileInfoWithName)(filename);
      }
      newFileMetaInfoWithContent(content) {
        return (0, filevitural_1.newFileInfoWithContent)(content);
      }
    };
    exports2.Service = Service;
    function newService() {
      return new Service();
    }
    exports2.default = Service;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlayfs-factory.js
var require_overlayfs_factory = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlayfs-factory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Factory = void 0;
    exports2.newOverlayFsFactory = newOverlayFsFactory;
    exports2.createOverlayFileSystem = createOverlayFileSystem;
    exports2.createReadOnlyOverlayFs = createReadOnlyOverlayFs;
    exports2.createWritableOverlayFs = createWritableOverlayFs;
    exports2.appendToOverlayFs = appendToOverlayFs;
    exports2.createOverlayFromPairs = createOverlayFromPairs;
    exports2.createMultilayerOverlayFs = createMultilayerOverlayFs;
    var overlayoptions_1 = require_overlayoptions();
    var overlayfs_1 = require_overlayfs();
    var Factory = class {
      create(fss) {
        const options = (0, overlayoptions_1.createDefaultOverlayOptions)(fss);
        return (0, overlayfs_1.newOverlayFs)(options);
      }
      createWithOptions(options) {
        return (0, overlayfs_1.createOverlayFs)(options);
      }
      createReadOnly(fss) {
        const options = (0, overlayoptions_1.createDefaultOverlayOptions)(fss);
        return (0, overlayfs_1.newOverlayFs)(options);
      }
      createWritable(fss) {
        const options = (0, overlayoptions_1.createWritableOverlayOptions)(fss);
        return (0, overlayfs_1.newOverlayFs)(options);
      }
      createWithMerger(fss, merger) {
        const options = (0, overlayoptions_1.createDefaultOverlayOptions)(fss).withDirsMerger(merger);
        return (0, overlayfs_1.newOverlayFs)(options);
      }
    };
    exports2.Factory = Factory;
    function newOverlayFsFactory() {
      return new Factory();
    }
    function createOverlayFileSystem(fss, options) {
      const factory = newOverlayFsFactory();
      if (!options) {
        return factory.create(fss);
      }
      const overlayOptions = { fss };
      if (options.firstWritable !== void 0) {
        overlayOptions.firstWritable = options.firstWritable;
      }
      if (options.dirsMerger !== void 0) {
        overlayOptions.dirsMerger = options.dirsMerger;
      }
      return factory.createWithOptions(overlayOptions);
    }
    function createReadOnlyOverlayFs(fss) {
      const factory = newOverlayFsFactory();
      return factory.createReadOnly(fss);
    }
    function createWritableOverlayFs(fss, dirsMerger) {
      const factory = newOverlayFsFactory();
      const overlayFs = factory.createWritable(fss);
      if (dirsMerger) {
        return overlayFs.withDirsMerger(dirsMerger);
      }
      return overlayFs;
    }
    function appendToOverlayFs(overlayFs, ...fss) {
      return overlayFs.append(...fss);
    }
    function createOverlayFromPairs(pairs) {
      const sortedPairs = pairs.sort((a, b) => a.priority - b.priority);
      const fss = sortedPairs.map((pair) => pair.fs);
      const factory = newOverlayFsFactory();
      return factory.create(fss);
    }
    function createMultilayerOverlayFs(readOnlyLayers, writableLayer, dirsMerger) {
      const fss = writableLayer ? [writableLayer, ...readOnlyLayers] : readOnlyLayers;
      const options = {
        fss,
        firstWritable: !!writableLayer
      };
      if (dirsMerger !== void 0) {
        options.dirsMerger = dirsMerger;
      }
      const factory = newOverlayFsFactory();
      return factory.createWithOptions(options);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filesystemscollector.js
var require_filesystemscollector = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/filesystemscollector.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilesystemsCollector = exports2.RootMapping = void 0;
    exports2.newFilesystemsCollector = newFilesystemsCollector;
    var overlayfs_factory_1 = require_overlayfs_factory();
    var basefs_1 = require_basefs();
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "filesystemscollector" });
    var RootMapping = class {
      constructor(from, to, toBase = "") {
        this.from = from;
        this.to = to;
        this.toBase = toBase;
      }
      fs(sourceProject) {
        return (0, basefs_1.newBaseFs)(sourceProject, [this.to]);
      }
    };
    exports2.RootMapping = RootMapping;
    var FilesystemsCollector = class {
      constructor(sourceProject) {
        this.sourceProject = sourceProject;
        this.overlayMountsPrompt = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
        this.overlayMountsWorkflow = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
        this.overlayMountsContent = [];
        this.overlayMountsLayouts = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
        this.overlayMountsStatics = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
        this.overlayMountsAssets = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
        this.overlayMountsI18n = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
      }
      async collect(mods) {
        const allModules = mods.all();
        for (const md of allModules) {
          const fromToWorkflow = [];
          const fromToPrompt = [];
          const fromToContent = [];
          const fromToLayouts = [];
          const fromToStatics = [];
          const fromToAssets = [];
          const fromToI18n = [];
          const absPathify = (inputPath) => {
            if (path6.isAbsolute(inputPath)) {
              return ["", inputPath];
            }
            return [md.dir(), this.absPathify(md.dir(), inputPath)];
          };
          const mounts = md.mounts();
          for (const mount of mounts) {
            const [base, absFilename] = absPathify(mount.source());
            const rm = new RootMapping(mount.target(), absFilename, base);
            const fs5 = rm.fs(this.sourceProject);
            if (this.isPrompts(mount.target())) {
              fromToPrompt.push(fs5);
            } else if (this.isWorkflows(mount.target())) {
              fromToWorkflow.push(fs5);
            } else if (this.isContent(mount.target())) {
              fromToContent.push(fs5);
            } else if (this.isLayouts(mount.target())) {
              fromToLayouts.push(fs5);
            } else if (this.isStatics(mount.target())) {
              fromToStatics.push(fs5);
            } else if (this.isAssets(mount.target())) {
              fromToAssets.push(fs5);
            } else if (this.isI18n(mount.target())) {
              fromToI18n.push(fs5);
            }
          }
          if (fromToWorkflow.length > 0) {
            this.overlayMountsWorkflow = this.overlayMountsWorkflow.append(...fromToWorkflow);
          }
          if (fromToPrompt.length > 0) {
            this.overlayMountsPrompt = this.overlayMountsPrompt.append(...fromToPrompt);
          }
          if (md.isProjectModule()) {
            for (const fs5 of fromToContent) {
              let ofs = (0, overlayfs_factory_1.createReadOnlyOverlayFs)([]);
              ofs = ofs.append(...[fs5]);
              this.overlayMountsContent.push(ofs);
            }
          }
          if (fromToLayouts.length > 0) {
            this.overlayMountsLayouts = this.overlayMountsLayouts.append(...fromToLayouts);
          }
          if (fromToStatics.length > 0) {
            this.overlayMountsStatics = this.overlayMountsStatics.append(...fromToStatics);
          }
          if (fromToAssets.length > 0) {
            this.overlayMountsAssets = this.overlayMountsAssets.append(...fromToAssets);
          }
          if (fromToI18n.length > 0) {
            this.overlayMountsI18n = this.overlayMountsI18n.append(...fromToI18n);
          }
        }
      }
      isPrompts(target) {
        return target === "prompts" || target.startsWith("prompts/") || target.startsWith("/prompts/");
      }
      isWorkflows(target) {
        return target === "workflows" || target.startsWith("workflows/") || target.startsWith("/workflows/");
      }
      isContent(target) {
        return target === "content" || target.startsWith("content/") || target.startsWith("/content/");
      }
      isLayouts(target) {
        return target === "layouts" || target.startsWith("layouts/") || target.startsWith("/layouts/");
      }
      isStatics(target) {
        return target === "static" || target.startsWith("static/") || target.startsWith("/static/");
      }
      isAssets(target) {
        return target === "assets" || target.startsWith("assets/") || target.startsWith("/assets/");
      }
      isI18n(target) {
        return target === "i18n" || target.startsWith("i18n/") || target.startsWith("/i18n/");
      }
      absPathify(baseDir, relativePath) {
        return path6.resolve(baseDir, relativePath);
      }
    };
    exports2.FilesystemsCollector = FilesystemsCollector;
    function newFilesystemsCollector(sourceProject) {
      return new FilesystemsCollector(sourceProject);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/osfs.js
var require_osfs = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/osfs.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OsFs = exports2.OsFile = exports2.OsFileInfo = void 0;
    exports2.newOsFs = newOsFs;
    var fs5 = __importStar(require("fs/promises"));
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("fs", { component: "osfs" });
    var OsFileInfo = class {
      constructor(stats, _name) {
        this.stats = stats;
        this._name = _name;
      }
      name() {
        return this._name;
      }
      size() {
        return this.stats.size;
      }
      mode() {
        return this.stats.mode;
      }
      modTime() {
        return this.stats.mtime;
      }
      isDir() {
        return this.stats.isDirectory();
      }
      sys() {
        return this.stats;
      }
    };
    exports2.OsFileInfo = OsFileInfo;
    var OsFile = class {
      constructor(filePath, flags = "r") {
        this.filePath = filePath;
        this.flags = flags;
        this.handle = null;
        this.closed = false;
        this.position = 0;
      }
      async ensureOpen() {
        if (!this.handle && !this.closed) {
          this.handle = await fs5.open(this.filePath, this.flags);
        }
      }
      async close() {
        if (this.handle) {
          try {
            await this.handle.close();
          } catch (error) {
            log.error(`\u274C Error closing file handle for ${this.filePath}:`, error);
            throw error;
          }
          this.handle = null;
        }
        this.closed = true;
      }
      async read(buffer) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (!this.handle)
          throw new Error("Failed to open file");
        const result = await this.handle.read(buffer, 0, buffer.length, this.position);
        this.position += result.bytesRead;
        return { bytesRead: result.bytesRead, buffer };
      }
      async readAt(buffer, offset) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (!this.handle)
          throw new Error("Failed to open file");
        const result = await this.handle.read(buffer, 0, buffer.length, offset);
        return { bytesRead: result.bytesRead, buffer };
      }
      async seek(offset, whence) {
        if (this.closed)
          throw new Error("File is closed");
        switch (whence) {
          case 0:
            this.position = offset;
            break;
          case 1:
            this.position += offset;
            break;
          case 2:
            await this.ensureOpen();
            if (this.handle) {
              const stats = await this.handle.stat();
              this.position = stats.size + offset;
            }
            break;
          default:
            this.position = offset;
        }
        return this.position;
      }
      async write(buffer) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (!this.handle)
          throw new Error("Failed to open file");
        const result = await this.handle.write(buffer, 0, buffer.length, this.position);
        this.position += result.bytesWritten;
        return { bytesWritten: result.bytesWritten, buffer };
      }
      async writeAt(buffer, offset) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (!this.handle)
          throw new Error("Failed to open file");
        const result = await this.handle.write(buffer, 0, buffer.length, offset);
        return { bytesWritten: result.bytesWritten, buffer };
      }
      name() {
        return this.filePath;
      }
      async readdir(count) {
        if (this.closed)
          throw new Error("File is closed");
        const entries = await fs5.readdir(this.filePath, { withFileTypes: true });
        const result = [];
        const limit = count > 0 ? Math.min(count, entries.length) : entries.length;
        for (let i = 0; i < limit; i++) {
          const entry = entries[i];
          const entryPath = path6.join(this.filePath, entry.name);
          const stats = await fs5.stat(entryPath);
          result.push(new OsFileInfo(stats, entry.name));
        }
        return result;
      }
      async readdirnames(n2) {
        if (this.closed)
          throw new Error("File is closed");
        const entries = await fs5.readdir(this.filePath);
        return n2 > 0 ? entries.slice(0, n2) : entries;
      }
      async stat() {
        if (this.closed)
          throw new Error("File is closed");
        const stats = await fs5.stat(this.filePath);
        return new OsFileInfo(stats, path6.basename(this.filePath));
      }
      async sync() {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (this.handle) {
          await this.handle.sync();
        }
      }
      async truncate(size) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen();
        if (this.handle) {
          await this.handle.truncate(size);
          if (this.position > size) {
            this.position = size;
          }
        }
      }
      async writeString(s) {
        const buffer = Buffer.from(s, "utf8");
        const result = await this.write(buffer);
        return { bytesWritten: result.bytesWritten };
      }
    };
    exports2.OsFile = OsFile;
    var OsFs = class {
      async create(name) {
        await fs5.writeFile(name, "");
        return new OsFile(name, "w+");
      }
      async mkdir(name, perm) {
        await fs5.mkdir(name, { mode: perm });
      }
      async mkdirAll(dirPath, perm) {
        await fs5.mkdir(dirPath, { mode: perm, recursive: true });
      }
      async open(name) {
        await fs5.access(name);
        const stats = await fs5.stat(name);
        if (stats.isDirectory()) {
          return new OsFile(name, "r");
        } else {
          return new OsFile(name, "r");
        }
      }
      async openFile(name, flag, perm) {
        let flags = "r";
        if (flag & 1)
          flags = "w";
        if (flag & 2)
          flags = "r+";
        if (flag & 64)
          flags = "w";
        if (flag & 512)
          flags = "w";
        if (flag & 1024)
          flags = "a";
        return new OsFile(name, flags);
      }
      async remove(name) {
        const stats = await fs5.stat(name);
        if (stats.isDirectory()) {
          await fs5.rmdir(name);
        } else {
          await fs5.unlink(name);
        }
      }
      async removeAll(dirPath) {
        await fs5.rm(dirPath, { recursive: true, force: true });
      }
      async rename(oldname, newname) {
        await fs5.rename(oldname, newname);
      }
      async stat(name) {
        const stats = await fs5.stat(name);
        return new OsFileInfo(stats, path6.basename(name));
      }
      name() {
        return "OsFs";
      }
      async chmod(name, mode) {
        await fs5.chmod(name, mode);
      }
      async chown(name, uid, gid) {
        await fs5.chown(name, uid, gid);
      }
      async chtimes(name, atime, mtime) {
        await fs5.utimes(name, atime, mtime);
      }
    };
    exports2.OsFs = OsFs;
    function newOsFs() {
      return new OsFs();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlay-factory.js
var require_overlay_factory = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/vo/overlay-factory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMainOverlayFs = createMainOverlayFs;
    exports2.createOriginFs = createOriginFs;
    var originfs_1 = require_originfs();
    var fs_1 = require_fs3();
    var basefs_1 = require_basefs();
    async function createMainOverlayFs(ofs, mods) {
      const collector = (0, fs_1.newFilesystemsCollector)(ofs.getSource());
      await collector.collect(mods);
      return collector;
    }
    function createOriginFs(workspace, mods) {
      const source = workspace.osFs;
      const origin = workspace.osFs;
      const publishDir = (0, basefs_1.newBaseFs)(workspace.osFs, [workspace.publish]);
      return new originfs_1.OriginFs(source, origin, publishDir);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/factory/fs.js
var require_fs2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/factory/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFs = createFs;
    var fs_1 = require_fs();
    var overlay_factory_1 = require_overlay_factory();
    var basefs_1 = require_basefs();
    async function createFs(workspace, mods) {
      const originFs = (0, overlay_factory_1.createOriginFs)(workspace, mods);
      const collector = await (0, overlay_factory_1.createMainOverlayFs)(originFs, mods);
      const work = (0, basefs_1.newBaseFs)(workspace.osFs, [workspace.path]);
      return new fs_1.Fs(originFs, collector.overlayMountsPrompt, collector.overlayMountsWorkflow, collector.overlayMountsContent, collector.overlayMountsLayouts, collector.overlayMountsStatics, collector.overlayMountsAssets, collector.overlayMountsI18n, work);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/fs/index.js
var require_fs3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/fs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMainOverlayFs = exports2.createOriginFs = exports2.newFilesystemsCollector = exports2.RootMapping = exports2.FilesystemsCollector = exports2.newWalkway = exports2.Walkway = exports2.newDirFileWithOpenerAndFilter = exports2.newDirFileWithFilter = exports2.newDirFileWithVirtualOpener = exports2.newDirFile = exports2.DirFile = exports2.newFile = exports2.VoFile = exports2.newFileInfoWithContent = exports2.newFileInfoWithName = exports2.newFileInfoWithMeta = exports2.newFileInfo = exports2.VoFileInfo = exports2.newFileMeta = exports2.FileMeta = exports2.newService = exports2.Service = exports2.releaseDir = exports2.getDir = exports2.openDir = exports2.newOverlayDir = exports2.OverlayDir = exports2.createOverlayFs = exports2.newOverlayFs = exports2.OverlayFsEntity = exports2.newBaseFs = exports2.BaseFs = exports2.FsEntity = exports2.OriginFs = exports2.OpenFlags = exports2.ErrFileExists = exports2.ErrFileNotFound = exports2.ErrFileClosed = exports2.FsError = void 0;
    __exportStar(require_type3(), exports2);
    var type_1 = require_type3();
    Object.defineProperty(exports2, "FsError", { enumerable: true, get: function() {
      return type_1.FsError;
    } });
    Object.defineProperty(exports2, "ErrFileClosed", { enumerable: true, get: function() {
      return type_1.ErrFileClosed;
    } });
    Object.defineProperty(exports2, "ErrFileNotFound", { enumerable: true, get: function() {
      return type_1.ErrFileNotFound;
    } });
    Object.defineProperty(exports2, "ErrFileExists", { enumerable: true, get: function() {
      return type_1.ErrFileExists;
    } });
    Object.defineProperty(exports2, "OpenFlags", { enumerable: true, get: function() {
      return type_1.OpenFlags;
    } });
    var originfs_1 = require_originfs();
    Object.defineProperty(exports2, "OriginFs", { enumerable: true, get: function() {
      return originfs_1.OriginFs;
    } });
    var fs_1 = require_fs();
    Object.defineProperty(exports2, "FsEntity", { enumerable: true, get: function() {
      return fs_1.Fs;
    } });
    var basefs_1 = require_basefs();
    Object.defineProperty(exports2, "BaseFs", { enumerable: true, get: function() {
      return basefs_1.BaseFs;
    } });
    Object.defineProperty(exports2, "newBaseFs", { enumerable: true, get: function() {
      return basefs_1.newBaseFs;
    } });
    var overlayfs_1 = require_overlayfs();
    Object.defineProperty(exports2, "OverlayFsEntity", { enumerable: true, get: function() {
      return overlayfs_1.OverlayFs;
    } });
    Object.defineProperty(exports2, "newOverlayFs", { enumerable: true, get: function() {
      return overlayfs_1.newOverlayFs;
    } });
    Object.defineProperty(exports2, "createOverlayFs", { enumerable: true, get: function() {
      return overlayfs_1.createOverlayFs;
    } });
    var overlaydir_1 = require_overlaydir();
    Object.defineProperty(exports2, "OverlayDir", { enumerable: true, get: function() {
      return overlaydir_1.OverlayDir;
    } });
    Object.defineProperty(exports2, "newOverlayDir", { enumerable: true, get: function() {
      return overlaydir_1.newOverlayDir;
    } });
    Object.defineProperty(exports2, "openDir", { enumerable: true, get: function() {
      return overlaydir_1.openDir;
    } });
    Object.defineProperty(exports2, "getDir", { enumerable: true, get: function() {
      return overlaydir_1.getDir;
    } });
    Object.defineProperty(exports2, "releaseDir", { enumerable: true, get: function() {
      return overlaydir_1.releaseDir;
    } });
    var service_1 = require_service4();
    Object.defineProperty(exports2, "Service", { enumerable: true, get: function() {
      return service_1.Service;
    } });
    Object.defineProperty(exports2, "newService", { enumerable: true, get: function() {
      return service_1.newService;
    } });
    var filemeta_1 = require_filemeta();
    Object.defineProperty(exports2, "FileMeta", { enumerable: true, get: function() {
      return filemeta_1.FileMeta;
    } });
    Object.defineProperty(exports2, "newFileMeta", { enumerable: true, get: function() {
      return filemeta_1.newFileMeta;
    } });
    var fileinfo_1 = require_fileinfo();
    Object.defineProperty(exports2, "VoFileInfo", { enumerable: true, get: function() {
      return fileinfo_1.FileInfo;
    } });
    Object.defineProperty(exports2, "newFileInfo", { enumerable: true, get: function() {
      return fileinfo_1.newFileInfo;
    } });
    Object.defineProperty(exports2, "newFileInfoWithMeta", { enumerable: true, get: function() {
      return fileinfo_1.newFileInfoWithMeta;
    } });
    var filevitural_1 = require_filevitural();
    Object.defineProperty(exports2, "newFileInfoWithName", { enumerable: true, get: function() {
      return filevitural_1.newFileInfoWithName;
    } });
    Object.defineProperty(exports2, "newFileInfoWithContent", { enumerable: true, get: function() {
      return filevitural_1.newFileInfoWithContent;
    } });
    var file_1 = require_file();
    Object.defineProperty(exports2, "VoFile", { enumerable: true, get: function() {
      return file_1.File;
    } });
    Object.defineProperty(exports2, "newFile", { enumerable: true, get: function() {
      return file_1.newFile;
    } });
    var dir_1 = require_dir2();
    Object.defineProperty(exports2, "DirFile", { enumerable: true, get: function() {
      return dir_1.DirFile;
    } });
    Object.defineProperty(exports2, "newDirFile", { enumerable: true, get: function() {
      return dir_1.newDirFile;
    } });
    Object.defineProperty(exports2, "newDirFileWithVirtualOpener", { enumerable: true, get: function() {
      return dir_1.newDirFileWithVirtualOpener;
    } });
    Object.defineProperty(exports2, "newDirFileWithFilter", { enumerable: true, get: function() {
      return dir_1.newDirFileWithFilter;
    } });
    Object.defineProperty(exports2, "newDirFileWithOpenerAndFilter", { enumerable: true, get: function() {
      return dir_1.newDirFileWithOpenerAndFilter;
    } });
    var walkway_1 = require_walkway();
    Object.defineProperty(exports2, "Walkway", { enumerable: true, get: function() {
      return walkway_1.Walkway;
    } });
    Object.defineProperty(exports2, "newWalkway", { enumerable: true, get: function() {
      return walkway_1.newWalkway;
    } });
    var filesystemscollector_1 = require_filesystemscollector();
    Object.defineProperty(exports2, "FilesystemsCollector", { enumerable: true, get: function() {
      return filesystemscollector_1.FilesystemsCollector;
    } });
    Object.defineProperty(exports2, "RootMapping", { enumerable: true, get: function() {
      return filesystemscollector_1.RootMapping;
    } });
    Object.defineProperty(exports2, "newFilesystemsCollector", { enumerable: true, get: function() {
      return filesystemscollector_1.newFilesystemsCollector;
    } });
    __exportStar(require_static_copier(), exports2);
    __exportStar(require_overlayoptions(), exports2);
    __exportStar(require_overlayfs_factory(), exports2);
    __exportStar(require_osfs(), exports2);
    __exportStar(require_fs2(), exports2);
    var overlay_factory_1 = require_overlay_factory();
    Object.defineProperty(exports2, "createOriginFs", { enumerable: true, get: function() {
      return overlay_factory_1.createOriginFs;
    } });
    Object.defineProperty(exports2, "createMainOverlayFs", { enumerable: true, get: function() {
      return overlay_factory_1.createMainOverlayFs;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/type.js
var require_type5 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageKind = void 0;
    exports2.PageKind = {
      PAGE: "page",
      HOME: "home",
      SECTION: "section",
      TAXONOMY: "taxonomy",
      TERM: "term",
      RSS: "rss",
      SITEMAP: "sitemap",
      SITEMAP_INDEX: "sitemapindex",
      ROBOTS_TXT: "robotstxt",
      STATUS_404: "404"
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/type.js
var require_type6 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultRendererFunc = exports2.RendererType = void 0;
    var RendererType;
    (function(RendererType2) {
      RendererType2[RendererType2["LinkRendererType"] = 1] = "LinkRendererType";
      RendererType2[RendererType2["ImageRendererType"] = 2] = "ImageRendererType";
      RendererType2[RendererType2["HeadingRendererType"] = 3] = "HeadingRendererType";
      RendererType2[RendererType2["CodeBlockRendererType"] = 4] = "CodeBlockRendererType";
    })(RendererType || (exports2.RendererType = RendererType = {}));
    var DefaultRendererFunc = (t, id) => null;
    exports2.DefaultRendererFunc = DefaultRendererFunc;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/config.js
var require_config4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultMarkdownConfig = exports2.DefaultHighlightConfig = exports2.AutoHeadingIDType = void 0;
    exports2.AutoHeadingIDType = {
      GitHub: "github",
      GitHubAscii: "github-ascii",
      Blackfriday: "blackfriday"
    };
    exports2.DefaultHighlightConfig = {
      style: "github",
      lineNos: false,
      lineNoStart: 1,
      anchorLineNos: false,
      lineAnchors: "",
      lineNumbersInTable: true,
      noClasses: true,
      codeFences: true,
      guessSyntax: false,
      tabWidth: 4
    };
    exports2.DefaultMarkdownConfig = {
      extensions: {
        typographer: {
          disable: true,
          leftSingleQuote: "&lsquo;",
          rightSingleQuote: "&rsquo;",
          leftDoubleQuote: "&ldquo;",
          rightDoubleQuote: "&rdquo;",
          enDash: "&ndash;",
          emDash: "&mdash;",
          ellipsis: "&hellip;",
          leftAngleQuote: "&laquo;",
          rightAngleQuote: "&raquo;",
          apostrophe: "&rsquo;"
        },
        footnote: true,
        definitionList: true,
        table: true,
        strikethrough: true,
        linkify: true,
        linkifyProtocol: "https",
        taskList: true,
        cjk: {
          enable: false,
          eastAsianLineBreaks: false,
          eastAsianLineBreaksStyle: "simple",
          escapedSpace: false
        },
        passthrough: {
          enable: false,
          delimiters: {
            inline: [],
            block: []
          }
        },
        highlight: exports2.DefaultHighlightConfig
      },
      renderer: {
        unsafe: true
      },
      parser: {
        autoHeadingID: true,
        autoHeadingIDType: exports2.AutoHeadingIDType.GitHub,
        wrapStandAloneImageWithinParagraph: true,
        attribute: {
          title: true,
          block: false
        }
      },
      duplicateResourceFiles: false,
      renderHooks: {
        image: {
          enableDefault: true
        },
        link: {
          enableDefault: true
        }
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/context.js
var require_context = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Context = exports2.RenderContextDataHolder = exports2.BufWriter = void 0;
    var BufWriter = class {
      constructor(initialCapacity = 1024) {
        this.capacity = initialCapacity;
        this.buffer = new Uint8Array(this.capacity);
        this.position = 0;
      }
      async write(data) {
        this.ensureCapacity(data.length);
        this.buffer.set(data, this.position);
        this.position += data.length;
      }
      async writeString(str) {
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        await this.write(data);
      }
      async writeByte(b) {
        this.ensureCapacity(1);
        this.buffer[this.position] = b;
        this.position++;
      }
      bytes() {
        return this.buffer.slice(0, this.position);
      }
      length() {
        return this.position;
      }
      truncate(size) {
        if (size < 0 || size > this.position) {
          throw new Error("Invalid truncate size");
        }
        this.position = size;
      }
      ensureCapacity(additional) {
        const needed = this.position + additional;
        if (needed <= this.capacity) {
          return;
        }
        const newCapacity = Math.max(this.capacity * 2, needed);
        const newBuffer = new Uint8Array(newCapacity);
        newBuffer.set(this.buffer);
        this.buffer = newBuffer;
        this.capacity = newCapacity;
      }
    };
    exports2.BufWriter = BufWriter;
    var RenderContextDataHolder = class {
      constructor(rctx, dctx) {
        this.rctx = rctx;
        this.dctx = dctx;
      }
      renderContext() {
        return this.rctx;
      }
      documentContext() {
        return this.dctx;
      }
    };
    exports2.RenderContextDataHolder = RenderContextDataHolder;
    var Context = class {
      constructor(bufWriter, contextData) {
        this.bufWriter = bufWriter;
        this.contextData = contextData;
        this.posStack = [];
      }
      async write(data) {
        return this.bufWriter.write(data);
      }
      async writeString(str) {
        return this.bufWriter.writeString(str);
      }
      async writeByte(b) {
        return this.bufWriter.writeByte(b);
      }
      renderContext() {
        return this.contextData.renderContext();
      }
      documentContext() {
        return this.contextData.documentContext();
      }
      get buffer() {
        return this.bufWriter;
      }
      pushPos(pos2) {
        this.posStack.push(pos2);
      }
      popPos() {
        const pos2 = this.posStack.pop();
        if (pos2 === void 0) {
          throw new Error("Position stack is empty");
        }
        return pos2;
      }
    };
    exports2.Context = Context;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/tableofcontents.js
var require_tableofcontents = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/tableofcontents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoIDGenerator = exports2.TOCBuilder = exports2.ParagraphImpl = exports2.LinkImpl = exports2.HeaderImpl = exports2.TableOfContentsImpl = void 0;
    var TableOfContentsImpl = class {
      constructor(fragments = []) {
        this.fragments = fragments;
      }
      toHTML(startLevel, stopLevel, ordered) {
        if (this.fragments.length === 0) {
          return "";
        }
        const filtered = this.filterByLevel(this.fragments, startLevel, stopLevel);
        if (filtered.length === 0) {
          return "";
        }
        const tag = ordered ? "ol" : "ul";
        return `<${tag}>
${this.renderFragments(filtered, ordered)}</${tag}>
`;
      }
      filterByLevel(fragments, startLevel, stopLevel) {
        return fragments.filter((f) => f.level >= startLevel && f.level <= stopLevel).map((f) => {
          const filtered = {
            id: f.id,
            text: f.text,
            level: f.level
          };
          if (f.children) {
            filtered.children = this.filterByLevel(f.children, startLevel, stopLevel);
          }
          return filtered;
        });
      }
      renderFragments(fragments, ordered) {
        const tag = ordered ? "ol" : "ul";
        return fragments.map((f) => {
          let html = `  <li><a href="#${f.id}">${this.escapeHTML(f.text)}</a>`;
          if (f.children && f.children.length > 0) {
            html += `
    <${tag}>
${this.renderFragments(f.children, ordered)}    </${tag}>`;
          }
          html += "</li>";
          return html;
        }).join("\n");
      }
      escapeHTML(text3) {
        return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      addFragment(fragment) {
        this.fragments.push(fragment);
      }
      getFragments() {
        return [...this.fragments];
      }
    };
    exports2.TableOfContentsImpl = TableOfContentsImpl;
    var HeaderImpl = class {
      constructor(_name, _level, _links = [], _paragraphs = [], _listParagraphs = []) {
        this._name = _name;
        this._level = _level;
        this._links = _links;
        this._paragraphs = _paragraphs;
        this._listParagraphs = _listParagraphs;
      }
      name() {
        return this._name;
      }
      level() {
        return this._level;
      }
      links() {
        return [...this._links];
      }
      paragraphs() {
        return [...this._paragraphs];
      }
      listParagraphs() {
        return [...this._listParagraphs];
      }
      addLink(link) {
        this._links.push(link);
      }
      addParagraph(paragraph) {
        this._paragraphs.push(paragraph);
      }
      addListParagraph(paragraph) {
        this._listParagraphs.push(paragraph);
      }
    };
    exports2.HeaderImpl = HeaderImpl;
    var LinkImpl = class {
      constructor(_text, _url) {
        this._text = _text;
        this._url = _url;
      }
      text() {
        return this._text;
      }
      url() {
        return this._url;
      }
    };
    exports2.LinkImpl = LinkImpl;
    var ParagraphImpl = class {
      constructor(_text) {
        this._text = _text;
      }
      text() {
        return this._text;
      }
    };
    exports2.ParagraphImpl = ParagraphImpl;
    var TOCBuilder = class {
      constructor() {
        this.fragments = [];
        this.stack = [];
      }
      addHeading(text3, level, id) {
        while (this.stack.length > 0 && this.stack[this.stack.length - 1].level >= level) {
          this.stack.pop();
        }
        const fragment = {
          id,
          text: text3,
          level,
          children: []
        };
        if (this.stack.length === 0) {
          this.fragments.push(fragment);
        } else {
          const parent = this.stack[this.stack.length - 1];
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(fragment);
        }
        this.stack.push(fragment);
      }
      build() {
        return new TableOfContentsImpl(this.fragments);
      }
      reset() {
        this.fragments = [];
        this.stack = [];
      }
    };
    exports2.TOCBuilder = TOCBuilder;
    var AutoIDGenerator2 = class {
      constructor() {
        this.usedIds = /* @__PURE__ */ new Set();
      }
      generateID(text3, type = "github") {
        let id;
        switch (type) {
          case "github":
            id = this.githubStyle(text3);
            break;
          case "github-ascii":
            id = this.githubAsciiStyle(text3);
            break;
          case "blackfriday":
            id = this.blackfridayStyle(text3);
            break;
          default:
            id = this.githubStyle(text3);
        }
        if (this.usedIds.has(id)) {
          let counter = 1;
          let uniqueId = `${id}-${counter}`;
          while (this.usedIds.has(uniqueId)) {
            counter++;
            uniqueId = `${id}-${counter}`;
          }
          id = uniqueId;
        }
        this.usedIds.add(id);
        return id;
      }
      githubStyle(text3) {
        return text3.toLowerCase().replace(/[^\w\u4e00-\u9fff\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      githubAsciiStyle(text3) {
        return text3.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      blackfridayStyle(text3) {
        return text3.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      reset() {
        this.usedIds.clear();
      }
    };
    exports2.AutoIDGenerator = AutoIDGenerator2;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/highlight.js
var require_highlight = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/highlight.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExternalHighlighter = exports2.DefaultHighlighter = exports2.HighlightResultImpl = void 0;
    exports2.createDefaultHighlighter = createDefaultHighlighter;
    exports2.createExternalHighlighter = createExternalHighlighter;
    var HighlightResultImpl = class {
      constructor(wrappedContent, innerContent) {
        this.wrappedContent = wrappedContent;
        this.innerContent = innerContent;
      }
      wrapped() {
        return this.wrappedContent;
      }
      inner() {
        return this.innerContent;
      }
    };
    exports2.HighlightResultImpl = HighlightResultImpl;
    var DefaultHighlighter = class {
      constructor(config) {
        this.config = config;
      }
      async highlight(code, lang, opts) {
        if (!lang || lang === "text" || lang === "plain") {
          return this.escapeHTML(code);
        }
        const escapedCode = this.escapeHTML(code);
        const className = `language-${lang}`;
        if (this.config.lineNos) {
          return this.addLineNumbers(escapedCode, className);
        }
        return `<code class="${className}">${escapedCode}</code>`;
      }
      async highlightCodeBlock(ctx, opts) {
        const lang = ctx.type();
        const code = ctx.inner();
        const highlighted = await this.highlight(code, lang, opts);
        const wrapped = `<pre>${highlighted}</pre>`;
        return new HighlightResultImpl(wrapped, highlighted);
      }
      async renderCodeblock(cctx, w, ctx) {
        const result = await this.highlightCodeBlock(ctx);
        await w.writeString(result.wrapped());
      }
      isDefaultCodeBlockRenderer() {
        return true;
      }
      escapeHTML(text3) {
        return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      addLineNumbers(code, className) {
        const lines = code.split("\n");
        const numberedLines = lines.map((line, index) => {
          const lineNumber = index + this.config.lineNoStart;
          if (this.config.lineNumbersInTable) {
            return `<tr><td class="line-number">${lineNumber}</td><td class="line-code"><code class="${className}">${line}</code></td></tr>`;
          } else {
            return `<span class="line-number">${lineNumber}</span><code class="${className}">${line}</code>`;
          }
        });
        if (this.config.lineNumbersInTable) {
          return `<table class="code-table"><tbody>${numberedLines.join("")}</tbody></table>`;
        } else {
          return numberedLines.join("\n");
        }
      }
    };
    exports2.DefaultHighlighter = DefaultHighlighter;
    var ExternalHighlighter = class {
      constructor(highlightFn, config = {
        style: "github",
        lineNos: false,
        lineNoStart: 1,
        anchorLineNos: false,
        lineAnchors: "",
        lineNumbersInTable: true,
        noClasses: true,
        codeFences: true,
        guessSyntax: false,
        tabWidth: 4
      }) {
        this.highlightFn = highlightFn;
        this.config = config;
      }
      async highlight(code, lang, opts) {
        return this.highlightFn(code, lang);
      }
      async highlightCodeBlock(ctx, opts) {
        const lang = ctx.type();
        const code = ctx.inner();
        const highlighted = await this.highlight(code, lang, opts);
        const wrapped = `<pre>${highlighted}</pre>`;
        return new HighlightResultImpl(wrapped, highlighted);
      }
      async renderCodeblock(cctx, w, ctx) {
        const result = await this.highlightCodeBlock(ctx);
        await w.writeString(result.wrapped());
      }
      isDefaultCodeBlockRenderer() {
        return false;
      }
    };
    exports2.ExternalHighlighter = ExternalHighlighter;
    function createDefaultHighlighter(config) {
      const defaultConfig = {
        style: "github",
        lineNos: false,
        lineNoStart: 1,
        anchorLineNos: false,
        lineAnchors: "",
        lineNumbersInTable: true,
        noClasses: true,
        codeFences: true,
        guessSyntax: false,
        tabWidth: 4
      };
      return new DefaultHighlighter({ ...defaultConfig, ...config });
    }
    function createExternalHighlighter(highlightFn, config) {
      const defaultConfig = {
        style: "github",
        lineNos: false,
        lineNoStart: 1,
        anchorLineNos: false,
        lineAnchors: "",
        lineNumbersInTable: true,
        noClasses: true,
        codeFences: true,
        guessSyntax: false,
        tabWidth: 4
      };
      return new ExternalHighlighter(highlightFn, { ...defaultConfig, ...config });
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/md/parser/item.js
var require_item = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/md/parser/item.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemType = exports2.Item = void 0;
    exports2.itemTypeToString = itemTypeToString;
    var Item = class {
      constructor() {
        this.Type = ItemType.tError;
        this.Err = null;
        this.low = 0;
        this.high = 0;
        this.segments = [];
        this.firstByte = 0;
        this.isString = false;
        this.content = "";
        this.bytes = [];
      }
      Pos() {
        if (this.segments.length > 0) {
          return this.segments[0].Low;
        }
        return this.low;
      }
      Val(source) {
        if (this.segments.length === 0) {
          return source.slice(this.low, this.high);
        }
        if (this.segments.length === 1) {
          return source.slice(this.segments[0].Low, this.segments[0].High);
        }
        const chunks = [];
        for (const s of this.segments) {
          chunks.push(source.slice(s.Low, s.High));
        }
        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        return result;
      }
      ValStr(source) {
        return new TextDecoder().decode(this.Val(source));
      }
      ValTyped(source) {
        const str = this.ValStr(source);
        if (this.isString) {
          return str;
        }
        if (boolRe.test(str)) {
          return str === "true";
        }
        if (intRe.test(str)) {
          const num = parseInt(str, 10);
          if (!isNaN(num)) {
            return num;
          }
          return str;
        }
        if (floatRe.test(str)) {
          const num = parseFloat(str);
          if (!isNaN(num)) {
            return num;
          }
          return str;
        }
        return str;
      }
      IsText() {
        return this.Type === ItemType.tText || this.Type === ItemType.tIndentation;
      }
      IsIndentation() {
        return this.Type === ItemType.tIndentation;
      }
      IsNonWhitespace(source) {
        return this.ValStr(source).trim().length > 0;
      }
      IsShortcodeName() {
        return this.Type === ItemType.tScName;
      }
      IsInlineShortcodeName() {
        return this.Type === ItemType.tScNameInline;
      }
      IsLeftShortcodeDelim() {
        return this.Type === ItemType.tLeftDelimScWithMarkup || this.Type === ItemType.tLeftDelimScNoMarkup;
      }
      IsRightShortcodeDelim() {
        return this.Type === ItemType.tRightDelimScWithMarkup || this.Type === ItemType.tRightDelimScNoMarkup;
      }
      IsShortcodeClose() {
        return this.Type === ItemType.tScClose;
      }
      IsShortcodeParam() {
        return this.Type === ItemType.tScParam;
      }
      IsShortcodeParamVal() {
        return this.Type === ItemType.tScParamVal;
      }
      IsShortcodeMarkupDelimiter() {
        return this.Type === ItemType.tLeftDelimScWithMarkup || this.Type === ItemType.tRightDelimScWithMarkup;
      }
      IsFrontMatter() {
        return this.Type >= ItemType.TypeFrontMatterYAML && this.Type <= ItemType.TypeFrontMatterORG;
      }
      IsDone() {
        return this.Type === ItemType.tError || this.Type === ItemType.tEOF;
      }
      IsEOF() {
        return this.Type === ItemType.tEOF;
      }
      IsError() {
        return this.Type === ItemType.tError;
      }
      ToString(source) {
        const val = this.Val(source);
        const valStr = this.ValStr(source);
        const typeStr = itemTypeToString(this.Type);
        switch (true) {
          case this.Type === ItemType.tEOF:
            return "EOF";
          case this.Type === ItemType.tError:
            return valStr;
          case this.Type === ItemType.tIndentation:
            return `${typeStr}:[${visualizeSpaces(valStr)}]`;
          case this.Type > ItemType.tKeywordMarker:
            return `<${valStr}>`;
          case val.length > 50:
            return `${typeStr}:${valStr.substring(0, 20)}...`;
          default:
            return `${typeStr}:[${valStr}]`;
        }
      }
    };
    exports2.Item = Item;
    var ItemType;
    (function(ItemType2) {
      ItemType2[ItemType2["tError"] = 0] = "tError";
      ItemType2[ItemType2["tEOF"] = 1] = "tEOF";
      ItemType2[ItemType2["TypeLeadSummaryDivider"] = 2] = "TypeLeadSummaryDivider";
      ItemType2[ItemType2["TypeFrontMatterYAML"] = 3] = "TypeFrontMatterYAML";
      ItemType2[ItemType2["TypeFrontMatterTOML"] = 4] = "TypeFrontMatterTOML";
      ItemType2[ItemType2["TypeFrontMatterJSON"] = 5] = "TypeFrontMatterJSON";
      ItemType2[ItemType2["TypeFrontMatterORG"] = 6] = "TypeFrontMatterORG";
      ItemType2[ItemType2["TypeIgnore"] = 7] = "TypeIgnore";
      ItemType2[ItemType2["tLeftDelimScNoMarkup"] = 8] = "tLeftDelimScNoMarkup";
      ItemType2[ItemType2["tRightDelimScNoMarkup"] = 9] = "tRightDelimScNoMarkup";
      ItemType2[ItemType2["tLeftDelimScWithMarkup"] = 10] = "tLeftDelimScWithMarkup";
      ItemType2[ItemType2["tRightDelimScWithMarkup"] = 11] = "tRightDelimScWithMarkup";
      ItemType2[ItemType2["tScClose"] = 12] = "tScClose";
      ItemType2[ItemType2["tScName"] = 13] = "tScName";
      ItemType2[ItemType2["tScNameInline"] = 14] = "tScNameInline";
      ItemType2[ItemType2["tScParam"] = 15] = "tScParam";
      ItemType2[ItemType2["tScParamVal"] = 16] = "tScParamVal";
      ItemType2[ItemType2["tIndentation"] = 17] = "tIndentation";
      ItemType2[ItemType2["tText"] = 18] = "tText";
      ItemType2[ItemType2["tKeywordMarker"] = 19] = "tKeywordMarker";
    })(ItemType || (exports2.ItemType = ItemType = {}));
    var boolRe = /^(true|false)$/;
    var intRe = /^[-+]?\d+$/;
    var floatRe = /^[-+]?\d*\.\d+$/;
    function visualizeSpaces(str) {
      return str.replace(/ /g, "\u2423").replace(/\t/g, "\u2192");
    }
    var _ItemType_name = "tErrortEOFTypeLeadSummaryDividerTypeFrontMatterYAMLTypeFrontMatterTOMLTypeFrontMatterJSONTypeFrontMatterORGTypeIgnoretLeftDelimScNoMarkuptRightDelimScNoMarkuptLeftDelimScWithMarkuptRightDelimScWithMarkuptScClosetScNametScNameInlinetScParamtScParamValtIndentationtTexttKeywordMarker";
    var _ItemType_index = [0, 6, 10, 32, 51, 70, 89, 107, 117, 137, 158, 180, 203, 211, 218, 231, 239, 250, 262, 267, 281];
    function itemTypeToString(itemType) {
      const i = itemType;
      if (i < 0 || i >= _ItemType_index.length - 1) {
        return `ItemType(${i})`;
      }
      return _ItemType_name.slice(_ItemType_index[i], _ItemType_index[i + 1]);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/md/parser/pagelexer.js
var require_pagelexer = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/md/parser/pagelexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pageLexer = exports2.Iterator = void 0;
    exports2.NewIterator = NewIterator;
    exports2.ParseBytes = ParseBytes;
    exports2.ParseBytesMain = ParseBytesMain;
    exports2.HasShortcode = HasShortcode;
    exports2.newPageLexer = newPageLexer;
    exports2.lexIntroSection = lexIntroSection;
    exports2.lexMainSection = lexMainSection;
    var item_1 = require_item();
    var eof = -1;
    var ParamState;
    (function(ParamState2) {
      ParamState2[ParamState2["none"] = 0] = "none";
      ParamState2[ParamState2["named"] = 1] = "named";
      ParamState2[ParamState2["positional"] = 2] = "positional";
    })(ParamState || (ParamState = {}));
    var byteOrderMark = 65279;
    var byteOrderMarkUTF8 = new Uint8Array([239, 187, 191]);
    var summaryDivider = new TextEncoder().encode("<!--more-->");
    var summaryDividerOrg = new TextEncoder().encode("# more");
    var delimTOML = new TextEncoder().encode("+++");
    var delimYAML = new TextEncoder().encode("---");
    var delimOrg = new TextEncoder().encode("#+");
    var leftDelimSc = new TextEncoder().encode("{{");
    var leftDelimScNoMarkup = new TextEncoder().encode("{{<");
    var rightDelimScNoMarkup = new TextEncoder().encode(">}}");
    var leftDelimScWithMarkup = new TextEncoder().encode("{{%");
    var rightDelimScWithMarkup = new TextEncoder().encode("%}}");
    var leftComment = new TextEncoder().encode("/*");
    var rightComment = new TextEncoder().encode("*/");
    var inlineIdentifier = new TextEncoder().encode("inline ");
    var sectionHandlers = class {
      constructor(l) {
        this.l = l;
        this.skipAll = false;
        this.handlers = [];
        this.skipIndexes = [];
      }
      skip() {
        if (this.skipAll) {
          return -1;
        }
        this.skipIndexes = [];
        let shouldSkip = false;
        for (const handler of this.handlers) {
          if (handler.skipAll) {
            continue;
          }
          const idx = handler.skip();
          if (idx !== -1) {
            shouldSkip = true;
            this.skipIndexes.push(idx);
          }
        }
        if (!shouldSkip) {
          this.skipAll = true;
          return -1;
        }
        return minIndex(...this.skipIndexes);
      }
      lex(origin) {
        if (this.skipAll) {
          return null;
        }
        if (this.l.pos > this.l.start) {
          this.l.emit(item_1.ItemType.tText);
        }
        for (const handler of this.handlers) {
          if (handler.skipAll) {
            continue;
          }
          const [next, handled] = handler.lexFunc(origin, handler.l);
          if (next === null || handled) {
            return next;
          }
        }
        this.l.pos++;
        return origin;
      }
    };
    var sectionHandler = class {
      constructor(l, skipFunc, lexFunc) {
        this.l = l;
        this.skipAll = false;
        this.skipFunc = skipFunc;
        this.lexFunc = lexFunc;
      }
      skip() {
        if (this.skipAll) {
          return -1;
        }
        const idx = this.skipFunc(this.l);
        if (idx === -1) {
          this.skipAll = true;
        }
        return idx;
      }
    };
    function createSectionHandlers(l) {
      const handlers = new sectionHandlers(l);
      const shortCodeHandler = new sectionHandler(l, (l2) => l2.index(leftDelimSc), (origin, l2) => {
        if (!l2.isShortCodeStart()) {
          return [origin, false];
        }
        if (l2.lexerShortcodeState.isInline) {
          const b = l2.input.slice(l2.pos + 3);
          const end = indexNonWhiteSpace(b, 47);
          if (end !== l2.input.length - 1) {
            const bTrimmed = new TextDecoder().decode(b.slice(end + 1)).trim();
            if (end === -1 || !bTrimmed.startsWith(l2.lexerShortcodeState.currShortcodeName + " ")) {
              return [l2.errorf("inline shortcodes do not support nesting"), true];
            }
          }
        }
        if (l2.hasPrefix(leftDelimScWithMarkup)) {
          l2.lexerShortcodeState.currLeftDelimItem = item_1.ItemType.tLeftDelimScWithMarkup;
          l2.lexerShortcodeState.currRightDelimItem = item_1.ItemType.tRightDelimScWithMarkup;
        } else {
          l2.lexerShortcodeState.currLeftDelimItem = item_1.ItemType.tLeftDelimScNoMarkup;
          l2.lexerShortcodeState.currRightDelimItem = item_1.ItemType.tRightDelimScNoMarkup;
        }
        return [l2.lexShortcodeLeftDelim, true];
      });
      const summaryDividerHandler = new sectionHandler(l, (l2) => {
        if (l2.summaryDividerChecked || !l2.summaryDivider) {
          return -1;
        }
        return l2.index(l2.summaryDivider);
      }, (origin, l2) => {
        if (!l2.summaryDivider || !l2.hasPrefix(l2.summaryDivider)) {
          return [origin, false];
        }
        l2.summaryDividerChecked = true;
        l2.pos += l2.summaryDivider.length;
        l2.consumeSpace();
        l2.emit(item_1.ItemType.TypeLeadSummaryDivider);
        return [origin, true];
      });
      handlers.handlers = [shortCodeHandler, summaryDividerHandler];
      handlers.skipIndexes = new Array(handlers.handlers.length);
      return handlers;
    }
    function isSpace(r) {
      return r === 32 || r === 9;
    }
    function isAlphaNumericOrHyphen(r) {
      return isAlphaNumeric(r) || r === 45;
    }
    function isEndOfLine(r) {
      return r === 13 || r === 10;
    }
    function isAlphaNumeric(r) {
      return r === 95 || r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57;
    }
    function minIndex(...indices) {
      let min = -1;
      for (const j of indices) {
        if (j < 0) {
          continue;
        }
        if (min === -1) {
          min = j;
        } else if (j < min) {
          min = j;
        }
      }
      return min;
    }
    function indexNonWhiteSpace(s, char2) {
      for (let i = 0; i < s.length; i++) {
        if (!isSpace(s[i])) {
          if (s[i] === char2) {
            return i;
          }
          break;
        }
      }
      return -1;
    }
    var Iterator = class {
      constructor(items) {
        this.items = items;
        this.lastPos = -1;
      }
      Next() {
        this.lastPos++;
        return this.Current();
      }
      Current() {
        if (this.lastPos >= this.items.length) {
          const errorItem = new item_1.Item();
          errorItem.Type = item_1.ItemType.tError;
          errorItem.Err = new Error("no more tokens");
          return errorItem;
        }
        return this.items[this.lastPos];
      }
      Backup() {
        if (this.lastPos < 0) {
          throw new Error("need to go forward before going back");
        }
        this.lastPos--;
      }
      Pos() {
        return this.lastPos;
      }
      IsValueNext() {
        const i = this.Peek();
        return i.Type !== item_1.ItemType.tError && i.Type !== item_1.ItemType.tEOF;
      }
      Peek() {
        return this.items[this.lastPos + 1];
      }
      PeekWalk(walkFn) {
        for (let i = this.lastPos + 1; i < this.items.length; i++) {
          const item = this.items[i];
          if (!walkFn(item)) {
            break;
          }
        }
      }
      Consume(cnt) {
        for (let i = 0; i < cnt; i++) {
          const token = this.Next();
          if (token.Type === item_1.ItemType.tError || token.Type === item_1.ItemType.tEOF) {
            this.Backup();
            break;
          }
        }
      }
      LineNumber(source) {
        const lf = new Uint8Array([10]);
        const slice = source.slice(0, this.Current().low);
        let count = 0;
        for (let i = 0; i < slice.length; i++) {
          if (slice[i] === lf[0]) {
            count++;
          }
        }
        return count + 1;
      }
    };
    exports2.Iterator = Iterator;
    function NewIterator(items) {
      return new Iterator(items);
    }
    var pageLexer = class {
      constructor(input, stateStart, cfg) {
        this.input = input;
        this.stateStart = stateStart;
        this.state = null;
        this.pos = 0;
        this.start = 0;
        this.width = 0;
        this.cfg = cfg;
        this.summaryDivider = null;
        this.summaryDividerChecked = false;
        this.err = null;
        this.items = [];
        this.inFrontMatter = false;
        this.parenDepth = 0;
        this.lexerShortcodeState = {
          currLeftDelimItem: item_1.ItemType.tLeftDelimScNoMarkup,
          currRightDelimItem: item_1.ItemType.tRightDelimScNoMarkup,
          isInline: false,
          currShortcodeName: "",
          closingState: 0,
          elementStepNum: 0,
          paramElements: 0,
          paramState: ParamState.none,
          openShortcodes: {}
        };
        this.lexSummaryDivider = this.lexSummaryDivider.bind(this);
        this.lexMainSection = this.lexMainSection.bind(this);
        this.lexIdentifierInShortcode = this.lexIdentifierInShortcode.bind(this);
        this.lexEndOfShortcode = this.lexEndOfShortcode.bind(this);
        this.lexShortcodeLeftDelim = this.lexShortcodeLeftDelim.bind(this);
        this.lexShortcodeRightDelim = this.lexShortcodeRightDelim.bind(this);
        this.lexShortcodeParam = this.lexShortcodeParam.bind(this);
        this.lexShortcodeValue = this.lexShortcodeValue.bind(this);
        this.lexShortcodeValueQuoted = this.lexShortcodeValueQuoted.bind(this);
        this.lexShortcodeValueUnquoted = this.lexShortcodeValueUnquoted.bind(this);
        this.lexInsideShortcode = this.lexInsideShortcode.bind(this);
        this.lexDone = this.lexDone.bind(this);
        this.sectionHandlers = createSectionHandlers(this);
      }
      Iterator() {
        return NewIterator(this.items);
      }
      Input() {
        return this.input;
      }
      run() {
        for (this.state = this.stateStart; this.state !== null; ) {
          this.state = this.state(this);
        }
        return this;
      }
      next() {
        if (this.pos >= this.input.length) {
          this.width = 0;
          return eof;
        }
        const r = this.input[this.pos];
        this.width = 1;
        this.pos += this.width;
        return r;
      }
      peek() {
        const r = this.next();
        this.backup();
        return r;
      }
      backup() {
        this.pos -= this.width;
      }
      append(item) {
        if (item.Pos() < this.input.length) {
          if (item.Type === item_1.ItemType.TypeIgnore && this.input[item.Pos()] === 239) {
            item.firstByte = 239;
          } else {
            item.firstByte = this.input[item.Pos()];
          }
        }
        this.items.push(item);
      }
      emit(t) {
        const defer = () => {
          this.start = this.pos;
        };
        if (t === item_1.ItemType.tText) {
          for (let i = this.pos - 1; i >= this.start; i--) {
            const b = this.input[i];
            if (b !== 32 && b !== 9 && b !== 13 && b !== 10) {
              break;
            }
            if (i === this.start && b !== 10) {
              const item2 = new item_1.Item();
              item2.Type = item_1.ItemType.tIndentation;
              item2.low = this.start;
              item2.high = this.pos;
              this.append(item2);
              defer();
              return;
            } else if (b === 10 && i < this.pos - 1) {
              const textItem = new item_1.Item();
              textItem.Type = t;
              textItem.low = this.start;
              textItem.high = i + 1;
              this.append(textItem);
              const indentItem = new item_1.Item();
              indentItem.Type = item_1.ItemType.tIndentation;
              indentItem.low = i + 1;
              indentItem.high = this.pos;
              this.append(indentItem);
              defer();
              return;
            } else if (b === 10 && i === this.pos - 1) {
              break;
            }
          }
        }
        const item = new item_1.Item();
        item.Type = t;
        item.low = this.start;
        item.high = this.pos;
        if (item.low < this.input.length) {
          if (t === item_1.ItemType.TypeIgnore && this.input[item.low] === 239) {
            item.firstByte = 239;
          } else {
            item.firstByte = this.input[item.low];
          }
        }
        this.append(item);
        defer();
      }
      emitString(t) {
        const item = new item_1.Item();
        item.Type = t;
        item["low"] = this.start;
        item["high"] = this.pos;
        item["isString"] = true;
        if (this.pos > this.start) {
          item.firstByte = this.input[this.start];
        }
        this.items.push(item);
        this.start = this.pos;
      }
      isEOF() {
        return this.pos >= this.input.length;
      }
      ignoreEscapesAndEmit(t, isString) {
        let i = this.start;
        let k = i;
        const segments = [];
        while (i < this.pos) {
          const r = this.input[i];
          const w = 1;
          if (r === 92) {
            if (i > k) {
              segments.push({ Low: k, High: i });
            }
            k = i + w;
          }
          i += w;
        }
        if (k < this.pos) {
          segments.push({ Low: k, High: this.pos });
        }
        if (segments.length > 0) {
          const item = new item_1.Item();
          item.Type = t;
          item["segments"] = segments;
          if (segments[0].High > segments[0].Low) {
            item.firstByte = this.input[segments[0].Low];
          }
          this.items.push(item);
          this.start = this.pos;
        }
        this.start = this.pos;
      }
      current() {
        return this.input.slice(this.start, this.pos);
      }
      ignore() {
        this.start = this.pos;
      }
      errorf(format, ...args) {
        const err = new Error(format.replace(/%[a-z]/g, () => String(args.shift())));
        const item = new item_1.Item();
        item.Type = item_1.ItemType.tError;
        item.Err = err;
        item.low = this.start;
        item.high = this.pos;
        this.append(item);
        return null;
      }
      consumeCRLF() {
        let consumed = false;
        const r = this.peek();
        if (r === 13) {
          this.next();
          if (this.peek() === 10) {
            this.next();
            consumed = true;
          }
        } else if (r === 10) {
          this.next();
          consumed = true;
        }
        return consumed;
      }
      consumeToSpace() {
        while (true) {
          const r = this.next();
          if (r === eof || isSpace(r)) {
            this.backup();
            return;
          }
        }
      }
      consumeSpace() {
        for (; ; ) {
          const r = this.next();
          if (r === eof || !this.isUnicodeSpace(r)) {
            this.backup();
            return;
          }
        }
      }
      isUnicodeSpace(r) {
        return r === 32 || r === 9 || r === 10 || r === 12 || r === 13 || r === 133 || r === 160 || r === 8192 || r === 8193 || r === 8194 || r === 8195 || r === 8196 || r === 8197 || r === 8198 || r === 8199 || r === 8200 || r === 8201 || r === 8202 || r === 8232 || r === 8233 || r === 8239 || r === 8287 || r === 12288;
      }
      index(sep2) {
        const input = this.input.slice(this.pos);
        const sepLen = sep2.length;
        const inputLen = input.length;
        if (sepLen > inputLen) {
          return -1;
        }
        outer:
          for (let i = 0; i <= inputLen - sepLen; i++) {
            for (let j = 0; j < sepLen; j++) {
              if (input[i + j] !== sep2[j]) {
                continue outer;
              }
            }
            return i;
          }
        return -1;
      }
      hasPrefix(prefix) {
        if (this.pos + prefix.length > this.input.length) {
          return false;
        }
        for (let i = 0; i < prefix.length; i++) {
          if (this.input[this.pos + i] !== prefix[i]) {
            return false;
          }
        }
        return true;
      }
      isShortCodeStart() {
        return this.hasPrefix(leftDelimScWithMarkup) || this.hasPrefix(leftDelimScNoMarkup);
      }
      lexFrontMatterSection(tp, delimr, name, delim) {
        for (let i = 0; i < 2; i++) {
          if (this.next() !== delimr) {
            return this.errorf(`invalid ${name} delimiter`);
          }
        }
        let wasEndOfLine = this.consumeCRLF();
        this.ignore();
        let r;
        for (; ; ) {
          if (!wasEndOfLine) {
            r = this.next();
            if (r === eof) {
              return this.errorf(`EOF looking for end ${name} front matter delimiter`);
            }
          }
          if (wasEndOfLine || isEndOfLine(r)) {
            if (this.hasPrefix(delim)) {
              this.emit(tp);
              this.pos += 3;
              this.consumeCRLF();
              this.ignore();
              break;
            }
          }
          wasEndOfLine = false;
        }
        return () => this.lexMainSection();
      }
      currentLeftShortcodeDelimItem() {
        return this.lexerShortcodeState.currLeftDelimItem;
      }
      currentRightShortcodeDelimItem() {
        return this.lexerShortcodeState.currRightDelimItem;
      }
      currentLeftShortcodeDelim() {
        if (this.lexerShortcodeState.currLeftDelimItem === item_1.ItemType.tLeftDelimScWithMarkup) {
          return leftDelimScWithMarkup;
        }
        return leftDelimScNoMarkup;
      }
      currentRightShortcodeDelim() {
        if (this.lexerShortcodeState.currRightDelimItem === item_1.ItemType.tRightDelimScWithMarkup) {
          return rightDelimScWithMarkup;
        }
        return rightDelimScNoMarkup;
      }
      lexIdentifier() {
        for (; ; ) {
          const r = this.next();
          if (isAlphaNumericOrHyphen(r)) {
            continue;
          }
          this.backup();
          const word = new TextDecoder().decode(this.input.slice(this.start, this.pos));
          if (word.length === 0) {
            return null;
          }
          this.emit(item_1.ItemType.tScParam);
          return null;
        }
      }
      lexMainSection() {
        if (this.isEOF()) {
          return () => this.lexDone();
        }
        const skip = this.sectionHandlers.skip();
        if (skip === -1) {
          this.pos = this.input.length;
          return () => this.lexDone();
        } else if (skip > 0) {
          this.pos += skip;
        }
        const next = this.sectionHandlers.lex(this.lexMainSection);
        if (next !== null) {
          return next;
        }
        this.pos = this.input.length;
        return this.lexDone;
      }
      lexInlineShortcodeContent() {
        for (; ; ) {
          if (this.pos >= this.input.length) {
            return this.errorf("unclosed inline shortcode");
          }
          if (this.hasPrefix(leftDelimScWithMarkup) || this.hasPrefix(leftDelimScNoMarkup)) {
            return this.errorf("inline shortcodes do not support nesting");
          }
          if (this.hasPrefix(this.currentRightShortcodeDelim())) {
            this.backup();
            if (this.pos > this.start) {
              this.emit(item_1.ItemType.tText);
            }
            return () => this.lexShortcodeRightDelim();
          }
          this.next();
        }
      }
      lexIdentifierInShortcode() {
        let lookForEnd = false;
        for (; ; ) {
          const r = this.next();
          switch (true) {
            case isAlphaNumericOrHyphen(r):
              break;
            case r === 47:
              break;
            case r === 46:
              this.lexerShortcodeState.isInline = this.hasPrefix(inlineIdentifier);
              if (!this.lexerShortcodeState.isInline) {
                return this.errorf("period in shortcode name only allowed for inline identifiers");
              }
              break;
            default:
              this.backup();
              const word = new TextDecoder().decode(this.input.slice(this.start, this.pos));
              if (this.lexerShortcodeState.closingState > 0 && !this.lexerShortcodeState.openShortcodes[word]) {
                return this.errorf(`closing tag for shortcode '${word}' does not match start tag`);
              } else if (this.lexerShortcodeState.closingState > 0) {
                this.lexerShortcodeState.openShortcodes[word] = false;
                lookForEnd = true;
              }
              this.lexerShortcodeState.closingState = 0;
              this.lexerShortcodeState.currShortcodeName = word;
              this.lexerShortcodeState.openShortcodes[word] = true;
              this.lexerShortcodeState.elementStepNum++;
              if (this.lexerShortcodeState.isInline) {
                this.emit(item_1.ItemType.tScNameInline);
              } else {
                this.emit(item_1.ItemType.tScName);
              }
              if (lookForEnd) {
                return () => this.lexEndOfShortcode();
              }
              return this.lexInsideShortcode;
          }
        }
      }
      lexEndOfShortcode() {
        this.lexerShortcodeState.isInline = false;
        if (this.hasPrefix(this.currentRightShortcodeDelim())) {
          return () => this.lexShortcodeRightDelim();
        }
        const r = this.next();
        switch (true) {
          case isSpace(r):
            this.ignore();
            break;
          default:
            return this.errorf("unclosed shortcode");
        }
        return () => this.lexEndOfShortcode();
      }
      lexShortcodeLeftDelim() {
        this.pos += this.currentLeftShortcodeDelim().length;
        if (this.isComment()) {
          return () => this.lexComment();
        }
        this.emit(this.lexerShortcodeState.currLeftDelimItem);
        this.lexerShortcodeState.elementStepNum = 0;
        this.lexerShortcodeState.paramElements = 0;
        this.lexerShortcodeState.paramState = ParamState.none;
        this.start = this.pos;
        return this.lexInsideShortcode;
      }
      peekString(s) {
        const n2 = s instanceof Uint8Array ? s.length : s.length;
        if (this.pos + n2 > this.input.length) {
          return null;
        }
        const peek = this.input.slice(this.pos, this.pos + n2);
        if (s instanceof Uint8Array) {
          for (let i = 0; i < n2; i++) {
            if (peek[i] !== s[i]) {
              return null;
            }
          }
          return new TextDecoder().decode(peek);
        } else {
          const str = new TextDecoder().decode(peek);
          if (str === s) {
            return str;
          }
          return null;
        }
      }
      lexSummaryDivider() {
        if (!this.hasPrefix(summaryDivider)) {
          return null;
        }
        if (this.start < this.pos) {
          const item = new item_1.Item();
          item.Type = item_1.ItemType.tText;
          item.low = this.start;
          item.high = this.pos;
          if (item.low < this.input.length) {
            item.firstByte = this.input[item.low];
          }
          this.append(item);
        }
        const divider = new item_1.Item();
        divider.Type = item_1.ItemType.TypeLeadSummaryDivider;
        divider.low = this.pos;
        divider.high = this.pos + summaryDivider.length;
        if (divider.low < this.input.length) {
          divider.firstByte = this.input[divider.low];
        }
        this.append(divider);
        this.pos += summaryDivider.length;
        this.start = this.pos;
        return () => this.lexMainSection();
      }
      handleBOM() {
        if (this.pos + 3 <= this.input.length) {
          const possibleBOM = this.input.slice(this.pos, this.pos + 3);
          if (possibleBOM[0] === 239 && possibleBOM[1] === 187 && possibleBOM[2] === 191) {
            const item = new item_1.Item();
            item.Type = item_1.ItemType.TypeIgnore;
            item.low = this.pos;
            item.high = this.pos + 3;
            item.firstByte = 239;
            this.append(item);
            this.pos += 3;
            this.start = this.pos;
            return true;
          }
        }
        return false;
      }
      lexIntroSection() {
        this.summaryDivider = summaryDivider;
        if (this.pos === 0 && this.handleBOM()) {
        }
        LOOP:
          for (; ; ) {
            const r = this.next();
            if (r === eof) {
              break;
            }
            switch (true) {
              case r === 43:
                if (this.hasPrefix(delimTOML.slice(1))) {
                  return () => this.lexFrontMatterSection(item_1.ItemType.TypeFrontMatterTOML, r, "TOML", delimTOML);
                } else {
                  this.backup();
                  break LOOP;
                }
              case r === 45:
                if (this.hasPrefix(delimYAML.slice(1))) {
                  return () => this.lexFrontMatterSection(item_1.ItemType.TypeFrontMatterYAML, r, "YAML", delimYAML);
                } else {
                  this.backup();
                  break LOOP;
                }
              case r === 123:
                return lexFrontMatterJSON;
              case r === 35:
                return lexFrontMatterOrgMode;
              case r === byteOrderMark:
                this.emit(item_1.ItemType.TypeIgnore);
                break;
              case (!isSpace(r) && !isEndOfLine(r)):
                break LOOP;
            }
          }
        return () => this.lexMainSection();
      }
      lexInsideShortcode() {
        if (this.hasPrefix(this.currentRightShortcodeDelim())) {
          return this.lexShortcodeRightDelim;
        }
        const r = this.next();
        if (r === eof) {
          return this.errorf("unclosed shortcode action");
        }
        if (isSpace(r) || isEndOfLine(r)) {
          this.ignore();
        } else if (r === 61) {
          this.consumeSpace();
          this.ignore();
          const peek = this.peek();
          if (peek === 34 || peek === 92) {
            return this.lexShortcodeQuotedParamVal(peek !== 92, item_1.ItemType.tScParamVal);
          } else if (peek === 96) {
            return this.lexShortCodeParamRawStringVal(item_1.ItemType.tScParamVal);
          }
          return this.lexShortcodeParamVal;
        } else if (r === 47) {
          if (this.lexerShortcodeState.currShortcodeName === "") {
            return this.errorf("got closing shortcode, but none is open");
          }
          this.lexerShortcodeState.closingState++;
          this.lexerShortcodeState.isInline = false;
          this.emit(item_1.ItemType.tScClose);
        } else if (r === 92) {
          this.ignore();
          if (this.peek() === 34 || this.peek() === 96) {
            return this.lexShortcodeParam(true);
          }
        } else if (this.lexerShortcodeState.elementStepNum > 0 && (isAlphaNumericOrHyphen(r) || r === 34 || r === 96)) {
          this.backup();
          return this.lexShortcodeParam(false);
        } else if (isAlphaNumeric(r)) {
          this.backup();
          return this.lexIdentifierInShortcode;
        } else {
          return this.errorf(`unrecognized character in shortcode action: U+${r.toString(16).toUpperCase()} '${String.fromCharCode(r)}'. Note: Parameters with non-alphanumeric args must be quoted`);
        }
        return this.lexInsideShortcode;
      }
      lexShortcodeParam(escapedQuoteStart) {
        let first = true;
        let nextEq = false;
        let r;
        for (; ; ) {
          r = this.next();
          if (first) {
            if (r === 34 || r === 96 && !escapedQuoteStart) {
              if (this.lexerShortcodeState.paramElements === 2) {
                return this.errorf("got quoted positional parameter. Cannot mix named and positional parameters");
              }
              this.lexerShortcodeState.paramElements = 1;
              this.backup();
              if (r === 34) {
                return () => this.lexShortcodeQuotedParamVal(!escapedQuoteStart, item_1.ItemType.tScParam);
              }
              return () => this.lexShortCodeParamRawStringVal(item_1.ItemType.tScParam);
            } else if (r === 96 && escapedQuoteStart) {
              return this.errorf("unrecognized escape character");
            }
            first = false;
          } else if (r === 61) {
            this.backup();
            nextEq = true;
            break;
          }
          if (!isAlphaNumericOrHyphen(r) && r !== 46) {
            this.backup();
            break;
          }
        }
        if (this.lexerShortcodeState.paramElements === 0) {
          this.lexerShortcodeState.paramElements++;
          if (nextEq) {
            this.lexerShortcodeState.paramElements++;
          }
        } else {
          if (nextEq && this.lexerShortcodeState.paramElements === 1) {
            return this.errorf(`got named parameter '${new TextDecoder().decode(this.current())}'. Cannot mix named and positional parameters`);
          } else if (!nextEq && this.lexerShortcodeState.paramElements === 2) {
            return this.errorf(`got positional parameter '${new TextDecoder().decode(this.current())}'. Cannot mix named and positional parameters`);
          }
        }
        this.emit(item_1.ItemType.tScParam);
        return this.lexInsideShortcode;
      }
      lexShortcodeParamVal() {
        const r = this.next();
        if (isSpace(r)) {
          this.ignore();
          return () => this.lexShortcodeParamVal();
        }
        this.backup();
        switch (r) {
          case 34:
            this.next();
            this.ignore();
            return () => this.lexShortcodeQuotedParamVal(false, item_1.ItemType.tScParamVal);
          case 96:
            this.next();
            this.ignore();
            return () => this.lexShortCodeParamRawStringVal(item_1.ItemType.tScParamVal);
          default:
            return () => this.lexShortcodeValueUnquoted();
        }
      }
      lexShortcodeValueUnquoted() {
        for (; ; ) {
          const r = this.next();
          if (r === eof || isSpace(r) || this.isRightShortcodeDelim()) {
            this.backup();
            if (this.pos > this.start) {
              this.emit(item_1.ItemType.tScParamVal);
            }
            return this.lexInsideShortcode;
          }
        }
      }
      lexShortcodeQuotedParamVal(escapedQuotedValuesAllowed, typ2) {
        let openQuoteFound = false;
        let escapedInnerQuoteFound = false;
        let escapedQuoteState = 0;
        LOOP:
          for (; ; ) {
            const r2 = this.next();
            switch (true) {
              case r2 === 92:
                if (this.peek() === 34) {
                  if (openQuoteFound && !escapedQuotedValuesAllowed) {
                    this.backup();
                    break LOOP;
                  } else if (openQuoteFound) {
                    escapedInnerQuoteFound = true;
                    escapedQuoteState = 1;
                  }
                } else if (this.peek() === 96) {
                  return this.errorf("unrecognized escape character");
                }
                break;
              case r2 === eof:
              case r2 === 10:
                return this.errorf(`unterminated quoted string in shortcode parameter-argument: '${new TextDecoder().decode(this.current())}'`);
              case r2 === 34:
                if (escapedQuoteState === 0) {
                  if (openQuoteFound) {
                    this.backup();
                    break LOOP;
                  } else {
                    openQuoteFound = true;
                    this.ignore();
                  }
                } else {
                  escapedQuoteState = 0;
                }
                break;
            }
          }
        if (escapedInnerQuoteFound) {
          this.ignoreEscapesAndEmit(typ2, true);
        } else {
          this.emitString(typ2);
        }
        const r = this.next();
        if (r === 92) {
          if (this.peek() === 34) {
            this.ignore();
            this.next();
            this.ignore();
          }
        } else if (r === 34) {
          this.ignore();
        } else {
          this.backup();
        }
        return this.lexInsideShortcode;
      }
      lexShortCodeParamRawStringVal(typ2) {
        let openBacktickFound = false;
        LOOP:
          for (; ; ) {
            const r = this.next();
            switch (r) {
              case 96:
                if (openBacktickFound) {
                  this.backup();
                  break LOOP;
                } else {
                  openBacktickFound = true;
                  this.ignore();
                }
                break;
              case eof:
                return this.errorf(`unterminated raw string in shortcode parameter-argument: '${new TextDecoder().decode(this.input.slice(this.start, this.pos))}'`);
            }
          }
        this.emitString(typ2);
        this.next();
        this.ignore();
        return this.lexInsideShortcode;
      }
      lexDone() {
        if (this.pos > this.start) {
          this.emit(item_1.ItemType.tText);
        }
        this.emit(item_1.ItemType.tEOF);
        return null;
      }
      lexShortcodeRightDelim() {
        this.pos += this.currentRightShortcodeDelim().length;
        this.emit(this.lexerShortcodeState.currRightDelimItem);
        this.lexerShortcodeState.closingState = 0;
        return () => this.lexMainSection();
      }
      lexShortcodeValue() {
        const r = this.next();
        switch (r) {
          case eof:
            return this.errorf("unterminated quoted string in shortcode parameter");
          case 32:
          case 9:
            this.ignore();
            return () => this.lexShortcodeValue();
          case 34:
            this.ignore();
            return () => this.lexShortcodeValueQuoted();
          default:
            this.backup();
            return () => this.lexShortcodeValueUnquoted();
        }
      }
      lexShortcodeValueQuoted() {
        for (; ; ) {
          const r = this.next();
          switch (r) {
            case eof:
              return this.errorf("unterminated quoted string in shortcode parameter");
            case 92:
              const peek = this.peek();
              if (peek === 34) {
                this.next();
              }
              break;
            case 34:
              this.backup();
              this.emitString(item_1.ItemType.tScParamVal);
              this.next();
              this.ignore();
              return this.lexInsideShortcode;
          }
        }
      }
      isRightShortcodeDelim() {
        return this.hasPrefix(this.currentRightShortcodeDelim());
      }
      lexComment() {
        const posRightComment = this.index(new Uint8Array([...rightComment, ...this.currentRightShortcodeDelim()]));
        if (posRightComment <= 1) {
          return this.errorf("comment must be closed");
        }
        this.emit(item_1.ItemType.tText);
        this.pos += leftComment.length;
        this.ignore();
        this.pos += posRightComment - leftComment.length;
        this.emit(item_1.ItemType.tText);
        this.pos += rightComment.length;
        this.ignore();
        this.pos += this.currentRightShortcodeDelim().length;
        this.emit(item_1.ItemType.tText);
        return this.lexMainSection;
      }
      isComment() {
        if (this.pos + 2 > this.input.length) {
          return false;
        }
        return this.input[this.pos] === 47 && this.input[this.pos + 1] === 42;
      }
    };
    exports2.pageLexer = pageLexer;
    function lexFrontMatterJSON(l) {
      l.backup();
      let inQuote = false;
      let level = 0;
      for (; ; ) {
        const r = l.next();
        switch (true) {
          case r === eof:
            return l.errorf("unexpected EOF parsing JSON front matter");
          case r === 123:
            if (!inQuote) {
              level++;
            }
            break;
          case r === 125:
            if (!inQuote) {
              level--;
            }
            break;
          case r === 34:
            inQuote = !inQuote;
            break;
          case r === 92:
            l.next();
            break;
        }
        if (level === 0) {
          break;
        }
      }
      l.consumeCRLF();
      l.emit(item_1.ItemType.TypeFrontMatterJSON);
      return () => l.lexMainSection();
    }
    function lexFrontMatterOrgMode(l) {
      l.summaryDivider = summaryDividerOrg;
      l.backup();
      if (!l.hasPrefix(delimOrg)) {
        return () => l.lexMainSection();
      }
      LOOP:
        for (; ; ) {
          const r = l.next();
          switch (true) {
            case r === 10:
              if (!l.hasPrefix(delimOrg)) {
                break LOOP;
              }
              break;
            case r === eof:
              break LOOP;
          }
        }
      l.emit(item_1.ItemType.TypeFrontMatterORG);
      return () => l.lexMainSection();
    }
    function ParseBytes(b, cfg) {
      const l = parseBytes(b, cfg, lexIntroSection);
      return [l.items, l.err];
    }
    function ParseBytesMain(b, cfg) {
      const l = parseBytes(b, cfg, lexMainSection);
      return [l.items, l.err];
    }
    function parseBytes(b, cfg, start) {
      const l = newPageLexer(b, start, cfg);
      return l.run();
    }
    function HasShortcode(s) {
      return s.includes("{{<") || s.includes("{{%");
    }
    function newPageLexer(input, stateStart, cfg) {
      return new pageLexer(input, stateStart, cfg);
    }
    function lexIntroSection(l) {
      return l.lexIntroSection();
    }
    function lexMainSection(l) {
      return l.lexMainSection();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/md/parser/pageparser.js
var require_pageparser = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/md/parser/pageparser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Format = void 0;
    exports2.ParseBytes = ParseBytes;
    exports2.ParseBytesMain = ParseBytesMain;
    exports2.ParseFrontMatterAndContent = ParseFrontMatterAndContent;
    exports2.FormatFromFrontMatterType = FormatFromFrontMatterType;
    exports2.ParseMain = ParseMain;
    exports2.IsProbablySourceOfItems = IsProbablySourceOfItems;
    exports2.HasShortcode = HasShortcode;
    exports2.collectStringMain = collectStringMain;
    var item_1 = require_item();
    var pagelexer_1 = require_pagelexer();
    var pagelexer_2 = require_pagelexer();
    function ParseBytes(b, cfg) {
      const [l, err] = parseBytes(b, cfg, pagelexer_2.lexIntroSection);
      if (err) {
        return [[], err];
      }
      return [l.items, l.err];
    }
    function ParseBytesMain(b, cfg) {
      const [l, err] = parseBytes(b, cfg, pagelexer_2.lexMainSection);
      if (err) {
        return [[], err];
      }
      return [l.items, l.err];
    }
    var Format;
    (function(Format2) {
      Format2["JSON"] = "json";
      Format2["ORG"] = "org";
      Format2["TOML"] = "toml";
      Format2["YAML"] = "yaml";
      Format2["UNKNOWN"] = "";
    })(Format || (exports2.Format = Format = {}));
    async function ParseFrontMatterAndContent(input) {
      let cf = {
        Content: new Uint8Array(),
        FrontMatter: {},
        FrontMatterFormat: Format.UNKNOWN
      };
      const [psr, err] = ParseBytes(input, {});
      if (err) {
        return [cf, err];
      }
      let frontMatterSource = null;
      const iter = new pagelexer_1.Iterator(psr);
      const walkFn = (item) => {
        if (frontMatterSource !== null) {
          cf.Content = input.slice(item.Pos());
          return false;
        } else if (item.IsFrontMatter()) {
          cf.FrontMatterFormat = FormatFromFrontMatterType(item.Type);
          frontMatterSource = item.Val(input);
        }
        return true;
      };
      iter.PeekWalk(walkFn);
      if (frontMatterSource) {
        try {
          switch (cf.FrontMatterFormat) {
            case Format.JSON:
              cf.FrontMatter = JSON.parse(new TextDecoder().decode(frontMatterSource));
              break;
            case Format.YAML:
              throw new Error("YAML parsing not implemented");
            case Format.TOML:
              throw new Error("TOML parsing not implemented");
            case Format.ORG:
              throw new Error("ORG parsing not implemented");
          }
        } catch (e) {
          return [cf, new Error(`Failed to parse front matter: ${e}`)];
        }
      }
      return [cf, null];
    }
    function FormatFromFrontMatterType(typ2) {
      switch (typ2) {
        case item_1.ItemType.TypeFrontMatterJSON:
          return Format.JSON;
        case item_1.ItemType.TypeFrontMatterORG:
          return Format.ORG;
        case item_1.ItemType.TypeFrontMatterTOML:
          return Format.TOML;
        case item_1.ItemType.TypeFrontMatterYAML:
          return Format.YAML;
        default:
          return Format.UNKNOWN;
      }
    }
    function ParseMain(input, cfg) {
      return parseSection(input, cfg, pagelexer_2.lexMainSection);
    }
    function parseSection(input, cfg, start) {
      return parseBytes(input, cfg, start);
    }
    function parseBytes(b, cfg, start) {
      const lexer = (0, pagelexer_2.newPageLexer)(b, start, cfg);
      lexer.run();
      return [lexer, null];
    }
    function IsProbablySourceOfItems(source, items) {
      if (source.length === 0 && items.length === 0) {
        return false;
      }
      if (items.length === 0) {
        return false;
      }
      const last = items[items.length - 1];
      if (last.Type !== item_1.ItemType.tEOF) {
        return false;
      }
      if (last.Pos() !== source.length) {
        return false;
      }
      for (const item of items) {
        if (item.Type === item_1.ItemType.tError) {
          return false;
        }
        if (item.Type === item_1.ItemType.tEOF) {
          return true;
        }
        if (item.Pos() >= source.length) {
          return false;
        }
        if (item["firstByte"] !== source[item.Pos()]) {
          return false;
        }
      }
      return true;
    }
    var hasShortcodeRe = /{{[%,<][^\/]/;
    function HasShortcode(s) {
      if (!s.includes("{{")) {
        return false;
      }
      return hasShortcodeRe.test(s);
    }
    function collectStringMain(input) {
      const bytes = new TextEncoder().encode(input);
      const lexer = (0, pagelexer_2.newPageLexer)(bytes, pagelexer_2.lexMainSection, {});
      lexer.run();
      const items = lexer.items;
      let items2 = [];
      for (const item of items) {
        items2.push(item);
        if (item.Type === item_1.ItemType.tEOF || item.Type === item_1.ItemType.tError) {
          break;
        }
      }
      return [items2, lexer.err];
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/pageparser.js
var require_pageparser2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/pageparser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseBytes = parseBytes;
    exports2.posFromInput = posFromInput;
    var log_1 = require_log();
    var pageparser_1 = require_pageparser();
    var log = (0, log_1.getDomainLogger)("markdown", { component: "pageparser" });
    function parseBytes(input, config = {}) {
      const [items, err] = (0, pageparser_1.ParseBytes)(input, config);
      if (err) {
        log.error("Error parsing bytes:", err);
        throw err;
      }
      return items;
    }
    function posFromInput(filename, input, offset) {
      const inputBytes = typeof input === "string" ? stringToBytes(input) : input;
      if (offset < 0) {
        return {
          filename,
          line: 1,
          column: 1,
          offset: 0
        };
      }
      let lineNumber = 1;
      let columnNumber = 1;
      for (let i = 0; i < Math.min(offset, inputBytes.length); i++) {
        if (inputBytes[i] === 10) {
          lineNumber++;
          columnNumber = 1;
        } else {
          columnNumber++;
        }
      }
      return {
        filename,
        line: lineNumber,
        column: columnNumber,
        offset
      };
    }
    function stringToBytes(str) {
      return new TextEncoder().encode(str);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/parseinfo.js
var require_parseinfo = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/parseinfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceParseInfo = void 0;
    exports2.createSourceParseInfo = createSourceParseInfo;
    var pageparser_1 = require_pageparser2();
    var item_1 = require_item();
    var pagelexer_1 = require_pagelexer();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("markdown", { component: "parseinfo" });
    var SourceParseInfo = class {
      constructor(source, handlers) {
        this.posMainContent = -1;
        this.itemsStep1 = [];
        this.source = source;
        this.handlers = handlers;
        this.validateHandlers();
      }
      validateHandlers() {
        if (!this.handlers.frontMatterHandler()) {
          throw new Error("no front matter handler");
        }
        if (!this.handlers.summaryHandler()) {
          throw new Error("no summary handler");
        }
        if (!this.handlers.shortcodeHandler()) {
          throw new Error("no shortcode handler");
        }
        if (!this.handlers.bytesHandler()) {
          throw new Error("no bytes handler");
        }
      }
      isEmpty() {
        return this.itemsStep1.length === 0;
      }
      async parse() {
        const items = (0, pageparser_1.parseBytes)(this.source, {});
        this.itemsStep1 = items;
      }
      async handle() {
        if (this.isEmpty()) {
          return;
        }
        const iter = new pagelexer_1.Iterator(this.itemsStep1);
        while (true) {
          const it = iter.Next();
          try {
            if (it.Type === item_1.ItemType.TypeIgnore) {
              log.info(`Ignoring item at position ${it.Pos()}: ${it.ValStr(this.source)}`);
            } else if (it.IsFrontMatter()) {
              await this.handlers.frontMatterHandler()(it);
              const next = iter.Peek();
              if (!next.IsDone()) {
                this.posMainContent = next.Pos();
              }
            } else if (it.Type === item_1.ItemType.TypeLeadSummaryDivider) {
              await this.handlers.summaryHandler()(it, iter);
            } else if (it.IsLeftShortcodeDelim()) {
              iter.Backup();
              const currentItem = iter.Current();
              await this.handlers.shortcodeHandler()(currentItem, iter);
            } else if (it.IsEOF()) {
              break;
            } else if (it.IsError()) {
              log.error(`Error parsing item at position ${it.Pos()}: ${it.Err}`);
              throw this.createError(it.Err || new Error("Unknown parsing error"), it);
            } else {
              await this.handlers.bytesHandler()(it);
            }
          } catch (error) {
            throw this.createError(error, it);
          }
        }
      }
      getMainContentPosition() {
        return this.posMainContent;
      }
      getItems() {
        return this.itemsStep1;
      }
      getSource() {
        return this.source;
      }
      createError(err, item) {
        const pos2 = (0, pageparser_1.posFromInput)("", this.source, item.Pos());
        const positionedError = new Error(`${err.message} at line ${pos2.line}, column ${pos2.column}`);
        positionedError.position = pos2;
        return positionedError;
      }
    };
    exports2.SourceParseInfo = SourceParseInfo;
    function createSourceParseInfo(source, handlers) {
      return new SourceParseInfo(source, handlers);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/shortcode.js
var require_shortcode = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/shortcode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHORTCODE_PLACEHOLDER_PREFIX = exports2.TOC_SHORTCODE_PLACEHOLDER = exports2.ShortcodeParser = exports2.ShortcodeImpl = void 0;
    exports2.createShortcodePlaceholder = createShortcodePlaceholder;
    exports2.hasShortcodePlaceholder = hasShortcodePlaceholder;
    exports2.replaceShortcodePlaceholders = replaceShortcodePlaceholders;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("markdown", { component: "vo/shortcode" });
    var ShortcodeImpl = class {
      constructor(ordinal = 0, name = "", params = null, pos2 = 0, length = 0, inline = false, closed = false) {
        this.ordinal = ordinal;
        this.name = name;
        this.params = params;
        this.pos = pos2;
        this.length = length;
        this.rawContent = "";
        this.inline = inline;
        this.closed = closed;
        this.doMarkup = false;
        this.isClosing = false;
        this.placeholder = "";
        this.inner = [];
      }
      needsInner() {
        return !this.inline;
      }
    };
    exports2.ShortcodeImpl = ShortcodeImpl;
    var ShortcodeParser = class {
      constructor(source, pid = Date.now()) {
        this.shortcodes = [];
        this.nameSet = /* @__PURE__ */ new Set();
        this.ordinal = 0;
        this.openShortcodes = /* @__PURE__ */ new Map();
        this.paramElements = 0;
        this.source = source;
        this.pid = pid;
      }
      parseItem(item, iter) {
        const shortcode = this.extractShortcode(this.ordinal, 0, iter);
        if (!shortcode) {
          throw new Error("Failed to extract shortcode");
        }
        shortcode.pos = item.Pos() + item.ValStr(this.source).length;
        shortcode.length = iter.Current().Pos() + iter.Current().ValStr(this.source).length - shortcode.pos;
        const rawContent = this.source.slice(shortcode.pos, shortcode.pos + shortcode.length);
        shortcode.rawContent = new TextDecoder().decode(rawContent);
        if (shortcode.name) {
          this.nameSet.add(shortcode.name);
        }
        shortcode.params ?? (shortcode.params = []);
        shortcode.placeholder = createShortcodePlaceholder("s", this.pid, this.ordinal);
        this.ordinal++;
        this.shortcodes.push(shortcode);
        return shortcode;
      }
      extractShortcode(ordinal, level, pt) {
        const sc = new ShortcodeImpl(ordinal);
        if (pt.Pos() > 0) {
          pt.Backup();
          const item = pt.Next();
          if (item.IsIndentation()) {
            sc.indentation = item.ValStr(this.source);
          }
        }
        let cnt = 0;
        let nestedOrdinal = 0;
        const nextLevel = level + 1;
        let closed = false;
        const errorPrefix = "failed to extract shortcode";
        let paramElements = 0;
        while (true) {
          const currItem = pt.Next();
          if (currItem.IsLeftShortcodeDelim()) {
            const next = pt.Peek();
            if (next.IsRightShortcodeDelim()) {
              throw new Error("shortcode has no name");
            }
            if (next.IsShortcodeClose()) {
              continue;
            }
            if (cnt > 0) {
              pt.Backup();
              const nested = this.extractShortcode(nestedOrdinal, nextLevel, pt);
              nestedOrdinal++;
              if (nested && nested.name) {
                this.nameSet.add(nested.name);
                if (!Array.isArray(sc.inner)) {
                  sc.inner = [];
                }
                sc.inner.push(nested);
              }
            } else {
              sc.doMarkup = currItem.IsShortcodeMarkupDelimiter();
            }
            cnt++;
          } else if (currItem.IsRightShortcodeDelim()) {
            if (!sc.inline) {
              if (!sc.needsInner()) {
                this.openShortcodes.set(sc.name, false);
                return sc;
              }
            }
          } else if (currItem.IsShortcodeClose()) {
            closed = true;
            const next = pt.Peek();
            if (!sc.inline && !sc.needsInner()) {
              if (next.IsError()) {
                continue;
              }
              throw new Error(`${errorPrefix}: shortcode "${sc.name}" does not evaluate .Inner or .InnerDeindent, yet a closing tag was provided`);
            }
            if (next.IsRightShortcodeDelim()) {
              pt.Consume(1);
            } else {
              sc.isClosing = true;
              pt.Consume(2);
            }
            if (!sc.inline) {
              this.openShortcodes.set(sc.name, false);
            }
            return sc;
          } else if (currItem.IsText()) {
            if (!Array.isArray(sc.inner)) {
              sc.inner = [];
            }
            const text3 = currItem.ValStr(this.source);
            sc.inner.push(text3);
          } else if (currItem.IsShortcodeName() || currItem.IsInlineShortcodeName()) {
            sc.name = currItem.ValStr(this.source).trim();
            sc.inline = currItem.IsInlineShortcodeName();
            if (this.openShortcodes.has(sc.name) && this.openShortcodes.get(sc.name)) {
              throw new Error(`shortcode ${sc.name} nested in itself`);
            }
            if (!sc.inline) {
              this.openShortcodes.set(sc.name, true);
            }
            if (sc.inline) {
              const b = this.source.slice(pt.Pos() + 3);
              const end = indexNonWhiteSpace(b, "/");
              if (end !== this.source.length - 1) {
                const remainingText = new TextDecoder().decode(b.slice(end + 1));
                if (end === -1 || !remainingText.startsWith(sc.name + " ")) {
                  throw new Error("inline shortcodes do not support nesting");
                }
              }
            }
          } else if (currItem.IsShortcodeParam()) {
            if (!pt.IsValueNext()) {
              log.warn(`${errorPrefix}: shortcode "${sc.name}" has a parameter without a value`);
              continue;
            }
            if (pt.Peek().IsShortcodeParamVal()) {
              if (sc.params === null || sc.params === void 0) {
                const params = {};
                const paramName = currItem.ValStr(this.source);
                pt.Next();
                params[paramName] = pt.Current().ValTyped(this.source);
                sc.params = params;
              } else {
                if (Array.isArray(sc.params)) {
                  throw new Error(`${errorPrefix}: invalid state: invalid param type Array for shortcode "${sc.name}", expected a map`);
                } else {
                  const paramName = currItem.ValStr(this.source);
                  pt.Next();
                  sc.params[paramName] = pt.Current().ValTyped(this.source);
                }
              }
            } else {
              if (sc.params === null || sc.params === void 0) {
                const params = [];
                params.push(currItem.ValTyped(this.source));
                sc.params = params;
              } else {
                if (!Array.isArray(sc.params)) {
                  throw new Error(`${errorPrefix}: invalid state: invalid param type Object for shortcode "${sc.name}", expected an array`);
                } else {
                  sc.params.push(currItem.ValTyped(this.source));
                }
              }
            }
          } else if (currItem.IsShortcodeParamVal()) {
            if (paramElements === 0) {
              paramElements = 1;
            }
            if (Array.isArray(sc.params)) {
              sc.params.push(currItem.ValTyped(this.source));
            } else if (sc.params === null || sc.params === void 0) {
              const params = [];
              params.push(currItem.ValTyped(this.source));
              sc.params = params;
            }
          } else if (currItem.IsDone()) {
            if (!currItem.IsError()) {
              if (!closed && sc.needsInner()) {
                throw new Error(`${errorPrefix}: shortcode "${sc.name}" must be closed or self-closed`);
              }
            }
            pt.Backup();
            break;
          }
        }
        if (!sc.inline) {
          this.openShortcodes.set(sc.name, false);
        }
        return sc;
      }
      getShortcodes() {
        return this.shortcodes;
      }
      getNames() {
        return Array.from(this.nameSet);
      }
    };
    exports2.ShortcodeParser = ShortcodeParser;
    exports2.TOC_SHORTCODE_PLACEHOLDER = createShortcodePlaceholder("TOC", 0, 0);
    exports2.SHORTCODE_PLACEHOLDER_PREFIX = "HAHAHUGOSHORTCODE";
    function createShortcodePlaceholder(id, sid, ordinal) {
      return `${exports2.SHORTCODE_PLACEHOLDER_PREFIX}${id}${sid}${ordinal}HBHB`;
    }
    function hasShortcodePlaceholder(content) {
      return content.includes(exports2.SHORTCODE_PLACEHOLDER_PREFIX);
    }
    function replaceShortcodePlaceholders(content, shortcodes, renderer) {
      let result = content;
      for (const shortcode of shortcodes) {
        const rendered = renderer(shortcode);
        result = result.replace(shortcode.placeholder, rendered);
      }
      return result;
    }
    function indexNonWhiteSpace(source, char2) {
      const charCode = char2.charCodeAt(0);
      for (let i = 0; i < source.length; i++) {
        if (!isSpace(source[i])) {
          if (source[i] === charCode) {
            return i;
          }
        }
      }
      return -1;
    }
    function isSpace(b) {
      return b === 32 || b === 9 || b === 13 || b === 10;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/media/type.js
var require_type7 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/media/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MediaType = void 0;
    var MediaType = class {
      constructor(init2) {
        this.type = init2.type;
        this.mainType = init2.mainType;
        this.subType = init2.subType;
        this.delimiter = init2.delimiter;
        this.firstSuffix = init2.firstSuffix;
        this.mimeSuffix = init2.mimeSuffix;
        this.suffixesCSV = init2.suffixesCSV;
      }
      sub() {
        if (this.subType) {
          return this.subType;
        }
        const parts = this.type.split("/");
        if (parts.length === 2) {
          const subTypeParts = parts[1].split("+");
          return subTypeParts[0];
        }
        return "";
      }
      getMimeSuffix() {
        if (this.mimeSuffix)
          return this.mimeSuffix;
        const plusIndex = this.type.indexOf("+");
        if (plusIndex !== -1) {
          return this.type.substring(plusIndex + 1);
        }
        return void 0;
      }
      getSuffixList() {
        return this.suffixesCSV ? this.suffixesCSV.split(",") : [];
      }
    };
    exports2.MediaType = MediaType;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/content.js
var require_content = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/content.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Content = exports2.INTERNAL_SUMMARY_DIVIDER_PRE = exports2.INTERNAL_SUMMARY_DIVIDER_BASE = void 0;
    var type_1 = require_type7();
    exports2.INTERNAL_SUMMARY_DIVIDER_BASE = "HUGOMORE42";
    exports2.INTERNAL_SUMMARY_DIVIDER_PRE = new TextEncoder().encode(`

${exports2.INTERNAL_SUMMARY_DIVIDER_BASE}

`);
    var Content = class {
      constructor(source, renderer) {
        this.hasSummaryDivider = false;
        this.summaryTruncated = false;
        this.items = [];
        this.rawSource = source;
        this.renderer = renderer;
      }
      isEmpty() {
        return !this.rawSource || this.rawSource.length === 0;
      }
      setSummaryDivider() {
        this.hasSummaryDivider = true;
      }
      getHasSummaryDivider() {
        return this.hasSummaryDivider;
      }
      setSummaryTruncated() {
        this.summaryTruncated = true;
      }
      getTruncated() {
        return this.summaryTruncated;
      }
      addReplacement(val, source) {
        const replacement = { val, source };
        this.items.push(replacement);
      }
      addShortcode(shortcode) {
        this.items.push(shortcode);
      }
      addItem(item) {
        this.items.push(item);
      }
      addItems(...items) {
        this.items.push(...items);
      }
      rawContent() {
        const decoder = new TextDecoder();
        return decoder.decode(this.rawSource);
      }
      pureContent() {
        const content = [];
        const decoder = new TextDecoder();
        const encoder = new TextEncoder();
        for (const item of this.items) {
          if (this.isItem(item)) {
            const itemContent = this.rawSource.slice(item.Pos(), item.Pos() + item.Val(this.rawSource).length);
            content.push(itemContent);
          } else if (this.isContentReplacement(item)) {
            content.push(item.val);
          } else if (this.isShortcode(item)) {
            content.push(encoder.encode(item.placeholder));
          }
        }
        const totalLength = content.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of content) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        return decoder.decode(result);
      }
      pureContentWithoutPlaceholder() {
        const content = [];
        const decoder = new TextDecoder();
        for (const item of this.items) {
          if (this.isItem(item)) {
            const itemContent = this.rawSource.slice(item.Pos(), item.Pos() + item.Val(this.rawSource).length);
            content.push(itemContent);
          } else if (this.isContentReplacement(item)) {
            content.push(item.val);
          } else if (this.isShortcode(item)) {
          }
        }
        const totalLength = content.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of content) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        return decoder.decode(result);
      }
      renderedContent(shortcodeRenderer) {
        let content = this.pureContent();
        if (shortcodeRenderer) {
          for (const item of this.items) {
            if (this.isShortcode(item)) {
              const rendered = shortcodeRenderer(item);
              content = content.replace(item.placeholder, rendered);
            }
          }
        }
        return content;
      }
      async renderedContentAsync(shortcodeRenderer) {
        let content = await this.renderer.render(this.pureContent());
        if (shortcodeRenderer) {
          for (const item of this.items) {
            if (this.isShortcode(item)) {
              try {
                const rendered = await shortcodeRenderer(item);
                content = content.replace(item.placeholder, rendered);
              } catch (error) {
              }
            }
          }
        }
        return content;
      }
      getItems() {
        return [...this.items];
      }
      getShortcodes() {
        return this.items.filter(this.isShortcode);
      }
      getTextItems() {
        return this.items.filter(this.isItem);
      }
      getReplacements() {
        return this.items.filter(this.isContentReplacement);
      }
      isSummaryEmpty() {
        const summary = this.getSummary();
        return !summary || summary.trim() === "";
      }
      extractSummary(input, mediaType) {
        const inputStr = new TextDecoder().decode(input);
        const res = this.extractSummaryFromHTML(mediaType, inputStr, 70, this.containsCJK(inputStr));
        const sum = res.summaryLowHigh.high > res.summaryLowHigh.low ? inputStr.substring(res.summaryLowHigh.low, res.summaryLowHigh.high).trim() : "";
        if (sum) {
          this.summaryTruncated = res.truncated;
          return { summary: sum, truncated: res.truncated };
        }
        const ts = this.trimShortHTML(input);
        this.summaryTruncated = ts.length < input.length;
        return {
          summary: new TextDecoder().decode(input),
          truncated: this.summaryTruncated
        };
      }
      extractSummaryFromHTML(mediaType, input, numWords, isCJK) {
        const result = {
          source: input,
          summaryLowHigh: { low: 0, high: input.length },
          truncated: false
        };
        if (numWords <= 0) {
          return result;
        }
        let count = 0;
        const words = input.split(/\s+/);
        for (let i = 0; i < words.length && count < numWords; i++) {
          const word = words[i].trim();
          if (word.length === 0)
            continue;
          if (this.isProbablyHTMLToken(word))
            continue;
          if (isCJK) {
            const cleanWord = this.stripHTML(word);
            const runeCount = [...cleanWord].length;
            count += cleanWord.length === cleanWord.replace(/[^\u0000-\u007F]/g, "").length ? 1 : runeCount;
          } else {
            count += 1;
          }
          if (count >= numWords) {
            const wordsUpToHere = words.slice(0, i + 1).join(" ");
            const endPos = input.indexOf(wordsUpToHere) + wordsUpToHere.length;
            result.summaryLowHigh = { low: 0, high: Math.min(endPos, input.length) };
            result.truncated = true;
            break;
          }
        }
        return result;
      }
      containsCJK(s) {
        return /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(s);
      }
      isProbablyHTMLToken(s) {
        return s === ">" || /^<\/?[A-Za-z]+>?$/.test(s) || /^[A-Za-z]+=["']/.test(s);
      }
      stripHTML(s) {
        return s.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
      }
      trimShortHTML(input) {
        const decoder = new TextDecoder();
        const encoder = new TextEncoder();
        let content = decoder.decode(input);
        const openingTag = "<p>";
        const closingTag = "</p>";
        const openTagCount = (content.match(/<p>/g) || []).length;
        if (openTagCount === 1) {
          content = content.trim();
          if (content.startsWith(openingTag) && content.endsWith(closingTag)) {
            content = content.slice(openingTag.length, -closingTag.length).trim();
          }
        }
        return encoder.encode(content);
      }
      getSummary(maxLength) {
        const content = this.pureContent();
        if (this.hasSummaryDivider) {
          const dividerIndex = content.indexOf(exports2.INTERNAL_SUMMARY_DIVIDER_BASE);
          if (dividerIndex !== -1) {
            return content.substring(0, dividerIndex).trim();
          }
        }
        return "";
      }
      async getRenderedSummary(maxLength) {
        let rawSummary = this.getSummary(maxLength);
        if (this.isSummaryEmpty()) {
          const pureContent = this.pureContentWithoutPlaceholder();
          const encoder = new TextEncoder();
          const contentBytes = encoder.encode(pureContent);
          const defaultMediaType = new type_1.MediaType({
            type: "text/html",
            mainType: "text",
            subType: "html",
            delimiter: ".",
            firstSuffix: { suffix: "html", fullSuffix: ".html" },
            mimeSuffix: "",
            suffixesCSV: "html"
          });
          const extracted = this.extractSummary(contentBytes, defaultMediaType);
          rawSummary = extracted.summary;
          if (extracted.truncated) {
            rawSummary += "...";
          }
        }
        if (maxLength && rawSummary.length > maxLength) {
          rawSummary = rawSummary.substring(0, maxLength).trim() + "...";
        }
        return await this.renderer.render(rawSummary);
      }
      getWordCount() {
        const content = this.pureContent();
        const words = content.trim().split(/\s+/).filter((word) => word.length > 0);
        return words.length;
      }
      getReadingTime(wordsPerMinute = 200) {
        const wordCount = this.getWordCount();
        return Math.ceil(wordCount / wordsPerMinute);
      }
      isItem(item) {
        return "Type" in item && "firstByte" in item && "low" in item && "high" in item;
      }
      isShortcode(item) {
        return "name" in item && "placeholder" in item && "params" in item;
      }
      isContentReplacement(item) {
        return "val" in item && "source" in item;
      }
    };
    exports2.Content = Content;
  }
});

// node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports2, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports2, module2) {
    "use strict";
    var common = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type8 = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type8();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports2, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type8();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value2 = data, sign = 1, ch;
      if (value2.indexOf("_") !== -1) {
        value2 = value2.replace(/_/g, "");
      }
      ch = value2[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value2 = value2.slice(1);
        ch = value2[0];
      }
      if (value2 === "0")
        return 0;
      if (ch === "0") {
        if (value2[1] === "b")
          return sign * parseInt(value2.slice(2), 2);
        if (value2[1] === "x")
          return sign * parseInt(value2.slice(2), 16);
        if (value2[1] === "o")
          return sign * parseInt(value2.slice(2), 8);
      }
      return sign * parseInt(value2, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports2, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type8();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value2, sign;
      value2 = data.replace(/_/g, "").toLowerCase();
      sign = value2[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value2[0]) >= 0) {
        value2 = value2.slice(1);
      }
      if (value2 === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value2 === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value2, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports2, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports2, module2) {
    "use strict";
    module2.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type8();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader2 = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports2, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports2, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos2) {
      var first = string.charCodeAt(pos2), second;
      if (first >= 55296 && first <= 56319 && pos2 + 1 < string.length) {
        second = string.charCodeAt(pos2 + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char2 = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
          char2 = codePointAt(string, i);
          if (!isPrintable(char2)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char2, prevChar, inblock);
          prevChar = char2;
        }
      } else {
        for (i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
          char2 = codePointAt(string, i);
          if (char2 === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char2)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char2, prevChar, inblock);
          prevChar = char2;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char2 = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
        char2 = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char2];
        if (!escapeSeq && isPrintable(char2)) {
          result += string[i];
          if (char2 >= 65536)
            result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char2);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value2;
      for (index = 0, length = object.length; index < length; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level, value2, false, false) || typeof value2 === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value2;
      for (index = 0, length = object.length; index < length; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level + 1, value2, true, true, false, true) || typeof value2 === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value2 = input;
      if (state.replacer) {
        value2 = state.replacer.call({ "": value2 }, "", value2);
      }
      if (writeNode(state, 0, value2, true, true))
        return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var loader = require_loader2();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type8();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/parserresult.js
var require_parserresult = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/vo/parserresult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResultImpl = exports2.RenderingResultImpl = void 0;
    var RenderingResultImpl = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      bytes() {
        return this.buffer.bytes();
      }
      toString() {
        const decoder = new TextDecoder();
        return decoder.decode(this.bytes());
      }
    };
    exports2.RenderingResultImpl = RenderingResultImpl;
    var ResultImpl = class {
      constructor(parsingResult, renderingResult) {
        this.parsingResult = parsingResult;
        this.renderingResult = renderingResult;
      }
      headers() {
        return this.parsingResult.headers();
      }
      tableOfContents() {
        return this.parsingResult.tableOfContents();
      }
      bytes() {
        return this.renderingResult.bytes();
      }
    };
    exports2.ResultImpl = ResultImpl;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/entity/markdown.js
var require_markdown = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/entity/markdown.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownImpl = void 0;
    var yaml = __importStar(require_js_yaml());
    var smol_toml_1 = require_dist();
    var parserresult_1 = require_parserresult();
    var context_1 = require_context();
    var parseinfo_1 = require_parseinfo();
    var item_1 = require_item();
    var shortcode_1 = require_shortcode();
    var content_1 = require_content();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("markdown", { component: "MarkdownImpl" });
    var MarkdownImpl = class {
      constructor(renderer, highlighter) {
        this.renderer = renderer;
        this.highlighter = highlighter;
      }
      async render(rctx, dctx) {
        const parseResult = await this.parse(rctx);
        const renderResult = await this.renderToBytes(rctx, dctx, parseResult);
        return new parserresult_1.ResultImpl(parseResult, renderResult);
      }
      async highlight(code, lang, opts) {
        return this.highlighter.highlight(code, lang, opts);
      }
      async highlightCodeBlock(ctx, opts) {
        return this.highlighter.highlightCodeBlock(ctx, opts);
      }
      async renderCodeblock(cctx, w, ctx) {
        return this.highlighter.renderCodeblock(cctx, w, ctx);
      }
      isDefaultCodeBlockRenderer() {
        return this.highlighter.isDefaultCodeBlockRenderer();
      }
      async prepareRender(source) {
        const parseResult = await this.parseContent(source);
        const frontMatter = parseResult.frontMatter?.params;
        const res = await this.renderer.parse(parseResult.content.pureContent());
        return {
          frontMatter: () => frontMatter || {},
          toc: () => res.tableOfContents(),
          render: async (options) => {
            const htmlContent = await parseResult.content.renderedContentAsync(options.shortcodeRenderer);
            const summary = await parseResult.content.getRenderedSummary(options.maxSummaryLength);
            const wordCount = parseResult.content.getWordCount();
            const readingTime = parseResult.content.getReadingTime(options.wordsPerMinute);
            const result = {
              renderedContent: htmlContent,
              wordCount,
              readingTime
            };
            if (frontMatter) {
              result.frontMatter = frontMatter;
            }
            if (summary) {
              result.summary = summary;
            }
            return result;
          }
        };
      }
      async parseAndRenderContent(source, options = {}) {
        const parseResult = await this.parseContent(source);
        const frontMatter = parseResult.frontMatter?.params;
        let renderedContent;
        if (options.shortcodeRenderer && parseResult.shortcodes.length > 0) {
          renderedContent = await parseResult.content.renderedContentAsync(options.shortcodeRenderer);
        } else {
          renderedContent = parseResult.content.pureContent();
        }
        const htmlContent = await this.renderer.render(renderedContent);
        const summary = parseResult.content.getSummary(options.maxSummaryLength);
        const wordCount = parseResult.content.getWordCount();
        const readingTime = parseResult.content.getReadingTime(options.wordsPerMinute);
        const result = {
          renderedContent: htmlContent,
          wordCount,
          readingTime
        };
        if (frontMatter) {
          result.frontMatter = frontMatter;
        }
        if (summary) {
          result.summary = summary;
        }
        return result;
      }
      async parseContent(source) {
        let frontMatter;
        const content = new content_1.Content(source, this.renderer);
        const shortcodeParser = new shortcode_1.ShortcodeParser(source);
        const shortcodes = [];
        const handlers = {
          frontMatterHandler: () => {
            return (item) => {
              frontMatter = this.parseFrontMatter(item, source);
            };
          },
          summaryHandler: () => {
            return (item, iter) => {
              let posBody = -1;
              const walkFn = (walkItem) => {
                if (posBody === -1 && !walkItem.IsDone()) {
                  posBody = walkItem.Pos();
                }
                if (walkItem.IsNonWhitespace(source)) {
                  content.setSummaryTruncated();
                  return false;
                }
                return true;
              };
              iter.PeekWalk(walkFn);
              content.setSummaryDivider();
              content.addReplacement(content_1.INTERNAL_SUMMARY_DIVIDER_PRE, item);
            };
          },
          shortcodeHandler: () => {
            return (item, iter) => {
              const shortcode = shortcodeParser.parseItem(item, iter);
              shortcodes.push(shortcode);
              content.addShortcode(shortcode);
            };
          },
          bytesHandler: () => {
            return (item) => {
              content.addItem(item);
            };
          }
        };
        const parseInfo = (0, parseinfo_1.createSourceParseInfo)(source, handlers);
        await parseInfo.parse();
        await parseInfo.handle();
        return {
          frontMatter,
          content,
          shortcodes,
          summary: content.getSummary(),
          wordCount: content.getWordCount(),
          readingTime: content.getReadingTime()
        };
      }
      parseFrontMatter(item, source) {
        const content = item.ValStr(source);
        let format;
        let params = {};
        switch (item.Type) {
          case item_1.ItemType.TypeFrontMatterYAML:
            format = "yaml";
            params = this.parseYAML(content);
            break;
          case item_1.ItemType.TypeFrontMatterTOML:
            format = "toml";
            params = this.parseTOML(content);
            break;
          case item_1.ItemType.TypeFrontMatterJSON:
            format = "json";
            params = this.parseJSON(content);
            break;
          case item_1.ItemType.TypeFrontMatterORG:
            format = "org";
            params = this.parseOrg(content);
            break;
          default:
            format = "yaml";
        }
        return { params, format };
      }
      parseYAML(content) {
        try {
          const parsed = yaml.load(content);
          if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
            return parsed;
          }
          return {};
        } catch (error) {
          return {};
        }
      }
      parseTOML(content) {
        try {
          const parsed = (0, smol_toml_1.parse)(content);
          if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
            return parsed;
          }
          return {};
        } catch (error) {
          return {};
        }
      }
      parseJSON(content) {
        try {
          return JSON.parse(content);
        } catch (error) {
          return {};
        }
      }
      parseOrg(content) {
        const params = {};
        const lines = content.split("\n");
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed.startsWith("#+"))
            continue;
          const match = trimmed.match(/^#\+([^:]+):\s*(.*)$/);
          if (match) {
            const key = match[1].trim().toLowerCase();
            const value2 = match[2].trim();
            params[key] = this.parseValue(value2);
          }
        }
        return params;
      }
      parseValue(value2) {
        if (value2.startsWith('"') && value2.endsWith('"') || value2.startsWith("'") && value2.endsWith("'")) {
          return value2.slice(1, -1);
        }
        if (value2 === "true")
          return true;
        if (value2 === "false")
          return false;
        if (/^-?\d+$/.test(value2)) {
          return parseInt(value2, 10);
        }
        if (/^-?\d*\.\d+$/.test(value2)) {
          return parseFloat(value2);
        }
        if (value2.startsWith("[") && value2.endsWith("]")) {
          const arrayContent = value2.slice(1, -1).trim();
          if (!arrayContent)
            return [];
          return arrayContent.split(",").map((item) => this.parseValue(item.trim()));
        }
        return value2;
      }
      async parse(rctx) {
        const decoder = new TextDecoder();
        const source = decoder.decode(rctx.src);
        return await this.renderer.parse(source);
      }
      async renderToBytes(rctx, dctx, parseResult) {
        const decoder = new TextDecoder();
        const source = decoder.decode(rctx.src);
        const html = await this.renderer.render(source);
        const buf = new context_1.BufWriter();
        await buf.writeString(html);
        return new parserresult_1.RenderingResultImpl(buf);
      }
    };
    exports2.MarkdownImpl = MarkdownImpl;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/factory/markdown.js
var require_markdown2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/factory/markdown.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMarkdown = createMarkdown;
    var markdown_1 = require_markdown();
    var highlight_1 = require_highlight();
    function createMarkdown(renderer) {
      const highlighter = (0, highlight_1.createDefaultHighlighter)();
      return new markdown_1.MarkdownImpl(renderer, highlighter);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/markdown/index.js
var require_markdown3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/markdown/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.posFromInput = exports2.parseBytes = void 0;
    __exportStar(require_type6(), exports2);
    __exportStar(require_config4(), exports2);
    __exportStar(require_context(), exports2);
    __exportStar(require_tableofcontents(), exports2);
    __exportStar(require_highlight(), exports2);
    var pageparser_1 = require_pageparser2();
    Object.defineProperty(exports2, "parseBytes", { enumerable: true, get: function() {
      return pageparser_1.parseBytes;
    } });
    Object.defineProperty(exports2, "posFromInput", { enumerable: true, get: function() {
      return pageparser_1.posFromInput;
    } });
    __exportStar(require_parseinfo(), exports2);
    __exportStar(require_shortcode(), exports2);
    __exportStar(require_content(), exports2);
    __exportStar(require_markdown(), exports2);
    __exportStar(require_markdown2(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/translator.js
var require_translator = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/translator.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Translator = void 0;
    var log_1 = require_log();
    var yaml = __importStar(require_js_yaml());
    var log = (0, log_1.getDomainLogger)("content", { component: "translator" });
    var Translator = class {
      constructor(contentLanguage) {
        this.translateFuncs = /* @__PURE__ */ new Map();
        this.contentLanguage = contentLanguage;
      }
      translate(lang, translationID) {
        const langKey = lang.toLowerCase();
        const translateFunc = this.translateFuncs.get(langKey);
        if (translateFunc) {
          const result = translateFunc(translationID);
          if (result) {
            return result;
          }
        }
        log.info(`Translation func for language ${lang} not found, use default.`);
        const defaultTranslateFunc = this.translateFuncs.get(this.contentLanguage.toLowerCase());
        if (defaultTranslateFunc) {
          const result = defaultTranslateFunc(translationID);
          if (result) {
            return result;
          }
        }
        log.info("i18n not initialized; if you need string translations, check that you have a bundle in /i18n that matches the site language or the default language.");
        return `[i18n] ${translationID}`;
      }
      async setupTranslateFuncs(fsService) {
        try {
          await fsService.walkI18n("", {
            walkFn: async (path6, info) => {
              if (!path6.endsWith(".yaml") && !path6.endsWith(".yml")) {
                return;
              }
              try {
                const filename = path6.split("/").pop() || "";
                const langKey = filename.replace(/\.(yaml|yml)$/, "").toLowerCase();
                const content = await this.readI18nFile(info);
                const translations = this.parseI18nContent(content);
                const translationMap = /* @__PURE__ */ new Map();
                translations.forEach((item) => {
                  translationMap.set(item.id, item.translation);
                });
                const translateFunc = (translationID) => {
                  const translation = translationMap.get(translationID);
                  if (translation) {
                    return translation;
                  }
                  log.warn(`i18n|MISSING_TRANSLATION|${langKey}|${translationID}`);
                  return "";
                };
                this.translateFuncs.set(langKey, translateFunc);
                log.info(`\u2705 Loaded i18n translations for language: ${langKey} (${translations.length} items)`);
              } catch (error) {
                log.error(`\u274C Failed to load i18n file ${path6}:`, error);
              }
            }
          }, {});
          log.info(`\u{1F30D} Translation setup complete. Loaded ${this.translateFuncs.size} languages: [${Array.from(this.translateFuncs.keys()).join(", ")}]`);
        } catch (error) {
          throw error;
        }
      }
      async readI18nFile(info) {
        let file = null;
        try {
          file = await info.open();
          const fileInfo = await file.stat();
          const buffer = new Uint8Array(fileInfo.size());
          const result = await file.read(buffer);
          const content = new TextDecoder("utf-8").decode(result.buffer);
          const cleanContent = content.charCodeAt(0) === 65279 ? content.slice(1) : content;
          return cleanContent;
        } catch (error) {
          log.error("\u274C Failed to read i18n file:", error);
          throw error;
        } finally {
          if (file) {
            try {
              await file.close();
            } catch (closeError) {
              log.warn(`Failed to close i18n file: ${closeError}`);
            }
          }
        }
      }
      parseI18nContent(content) {
        try {
          const parsed = yaml.load(content);
          if (!Array.isArray(parsed)) {
            log.warn("i18n YAML content is not an array");
            return [];
          }
          return parsed.filter((item) => item && typeof item === "object" && item.id && item.translation).map((item) => ({
            id: String(item.id),
            translation: String(item.translation)
          }));
        } catch (error) {
          log.error("\u274C Failed to parse i18n YAML content:", error);
          return [];
        }
      }
      getAvailableLanguages() {
        return Array.from(this.translateFuncs.keys());
      }
      hasLanguage(lang) {
        return this.translateFuncs.has(lang.toLowerCase());
      }
    };
    exports2.Translator = Translator;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/factory/hub.js
var require_hub = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/factory/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createContent = createContent;
    var index_1 = require_content3();
    var markdown_1 = require_markdown3();
    var translator_1 = require_translator();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "content" });
    async function createTranslator(services) {
      const translator = new translator_1.Translator(services.defaultLanguage());
      try {
        await translator.setupTranslateFuncs(services);
      } catch (error) {
        log.warn("Failed to setup translator, continuing without i18n support:", error);
      }
      return translator;
    }
    async function createContent(services) {
      const converter = new index_1.MDConverter((0, markdown_1.createMarkdown)(services.markdown()));
      const translator = await createTranslator(services);
      const pageBuilder = new index_1.PageBuilder(services, services, null, null, new index_1.Taxonomy(services.views(), services), new index_1.Term(services), new index_1.Section(services), new index_1.Standalone(services), converter, null);
      const pageMap = new index_1.PageMap(pageBuilder);
      pageBuilder.pageMapper = pageMap;
      pageMap.setupReverseIndex();
      const contentHub = new index_1.Content(services, converter, pageMap, translator);
      pageBuilder.contentHub = contentHub;
      return contentHub;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/kind.js
var require_kind = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKindMain = getKindMain;
    exports2.isBranch = isBranch;
    exports2.isDeprecatedAndReplacedWith = isDeprecatedAndReplacedWith;
    var type_1 = require_type5();
    var kindMapMain = {
      [type_1.PageKind.PAGE]: type_1.PageKind.PAGE,
      [type_1.PageKind.HOME]: type_1.PageKind.HOME,
      [type_1.PageKind.SECTION]: type_1.PageKind.SECTION,
      [type_1.PageKind.TAXONOMY]: type_1.PageKind.TAXONOMY,
      [type_1.PageKind.TERM]: type_1.PageKind.TERM,
      [type_1.PageKind.STATUS_404]: type_1.PageKind.STATUS_404,
      [type_1.PageKind.SITEMAP]: type_1.PageKind.SITEMAP,
      "taxonomyterm": type_1.PageKind.TAXONOMY
    };
    function getKindMain(s) {
      return kindMapMain[s.toLowerCase()] || "";
    }
    function isBranch(kind) {
      switch (kind) {
        case type_1.PageKind.HOME:
        case type_1.PageKind.SECTION:
        case type_1.PageKind.TAXONOMY:
        case type_1.PageKind.TERM:
          return true;
        default:
          return false;
      }
    }
    function isDeprecatedAndReplacedWith(s) {
      const lowered = s.toLowerCase();
      switch (lowered) {
        case "taxonomyterm":
          return type_1.PageKind.TAXONOMY;
        default:
          return "";
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/identity.js
var require_identity = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Identity = void 0;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "identity" });
    var Identity = class {
      constructor(id, lang = "", langIdx = 0) {
        this.stale = true;
        this.id = id;
        this.lang = lang;
        this.langIdx = langIdx;
      }
      ID() {
        return this.id;
      }
      identifierBase() {
        return `${this.id}-${this.lang}`;
      }
      pageLanguage() {
        return this.lang;
      }
      pageLanguageIndex() {
        return this.langIdx;
      }
      pageIdentity() {
        return this;
      }
      markStale() {
        if (!this.stale) {
          this.stale = true;
        }
      }
      isStale() {
        return this.stale;
      }
      clearStale() {
        if (this.stale) {
          this.stale = false;
        }
      }
    };
    exports2.Identity = Identity;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/fileinfo.js
var require_fileinfo2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/fileinfo.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathType = exports2.FileInfo = void 0;
    exports2.newFileInfo = newFileInfo;
    var paths_1 = require_paths();
    Object.defineProperty(exports2, "PathType", { enumerable: true, get: function() {
      return paths_1.PathType;
    } });
    var crypto = __importStar(require("crypto"));
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "FileInfo" });
    var contentFileExtensions = [
      ".md"
    ];
    var contentFileExtensionsSet = new Set(contentFileExtensions);
    function isContentExt(ext) {
      return contentFileExtensionsSet.has(ext);
    }
    var FileInfo = class {
      constructor(fi, relName) {
        this.lazyInitDone = false;
        this.fileMetaInfo = fi;
        const pathProcessor = paths_1.PathDomain.createProcessor();
        this.pathInfo = pathProcessor.parse(paths_1.PATH_CONSTANTS.COMPONENT_FOLDER_CONTENT, relName);
        this.bundleType = paths_1.PathType.File;
        this.determineBundleType();
      }
      static newFileInfo(fi) {
        const relName = paths_1.PATH_CONSTANTS.normalizePath(fi.relativeFilename());
        return new FileInfo(fi, relName);
      }
      pageFile() {
        return this;
      }
      shiftToResource() {
        if (this.isContent()) {
          this.bundleType = paths_1.PathType.ContentResource;
        }
      }
      relPath() {
        const dir = this.pathInfo.dir();
        const dirWithoutLeadingSlash = dir.startsWith("/") ? dir.substring(1) : dir;
        return path6.join(dirWithoutLeadingSlash, this.pathInfo.name());
      }
      section() {
        return this.pathInfo.section();
      }
      isZero() {
        return this.fileMetaInfo == null;
      }
      filename() {
        return this.fileMetaInfo.fileName();
      }
      dir() {
        return this.pathToDir(this.pathInfo.dir());
      }
      ext() {
        return this.pathInfo.ext();
      }
      logicalName() {
        return this.pathInfo.name();
      }
      baseFileName() {
        return this.pathInfo.nameNoExt();
      }
      translationBaseName() {
        return this.pathInfo.nameNoIdentifier();
      }
      contentBaseName() {
        return this.pathInfo.baseNameNoIdentifier();
      }
      baseNameNoIdentifier() {
        return this.pathInfo.baseNameNoIdentifier();
      }
      root() {
        return this.pathInfo.dir() || "/";
      }
      uniqueID() {
        this.init();
        return this.uniqueIDCache;
      }
      fileInfo() {
        return this.fileMetaInfo;
      }
      type() {
        const sect = this.section();
        if (sect !== "") {
          return sect;
        }
        return "page";
      }
      async open() {
        return await this.fileMetaInfo.open();
      }
      paths() {
        return this.pathInfo;
      }
      path() {
        return this.pathInfo.path();
      }
      toString() {
        return this.baseFileName();
      }
      getBundleType() {
        return this.bundleType;
      }
      isBundle() {
        return this.bundleType >= paths_1.PathType.Leaf;
      }
      isLeafBundle() {
        return this.bundleType === paths_1.PathType.Leaf;
      }
      isBranchBundle() {
        return this.bundleType === paths_1.PathType.Branch;
      }
      isContentResource() {
        return this.bundleType === paths_1.PathType.ContentResource;
      }
      isContent() {
        return this.bundleType >= paths_1.PathType.ContentResource;
      }
      init() {
        if (!this.lazyInitDone) {
          this.lazyInitDone = true;
          const normalizedPath = this.relPath().replace(/\\/g, "/");
          this.uniqueIDCache = crypto.createHash("md5").update(normalizedPath).digest("hex");
        }
      }
      pathToDir(s) {
        if (s === "") {
          return s;
        }
        return path6.normalize(s.substring(1) + "/");
      }
      determineBundleType() {
        const isContent = isContentExt(this.pathInfo.ext());
        if (isContent) {
          const nameNoId = this.pathInfo.nameNoIdentifier();
          switch (nameNoId) {
            case "index":
              this.bundleType = paths_1.PathType.Leaf;
              break;
            case "_index":
              this.bundleType = paths_1.PathType.Branch;
              break;
            default:
              this.bundleType = paths_1.PathType.ContentSingle;
              break;
          }
        }
      }
    };
    exports2.FileInfo = FileInfo;
    function newFileInfo(fi) {
      return FileInfo.newFileInfo(fi);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/sort.js
var require_sort = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortByDefault = sortByDefault;
    exports2.sortByWeight = sortByWeight;
    exports2.sortByLanguage = sortByLanguage;
    function sortByDefault(pages) {
      pageBy(lessPageTitle).sort(pages);
    }
    function sortByWeight(pages) {
      pageBy(weight).sort(pages);
    }
    function sortByLanguage(pages) {
      pageBy(language).sort(pages);
    }
    function pageBy(by) {
      return new PageByWrapper(by);
    }
    var PageByWrapper = class {
      constructor(by) {
        this.by = by;
      }
      sort(pages) {
        const ps = new PageSorterImpl(pages, this.by);
        stableSort(pages, ps);
      }
    };
    var lessPageTitle = (p1, p2) => {
      return collatorStringCompare((p) => p.title(), p1, p2) < 0;
    };
    var language = (p1, p2) => {
      return collatorStringCompare((p) => p.pageIdentity().pageLanguage(), p1, p2) < 0;
    };
    var weight = (p1, p2) => {
      return p1.pageWeight() < p2.pageWeight();
    };
    var collatorStringCompare = (getString, p1, p2) => {
      const str1 = getString(p1);
      const str2 = getString(p2);
      if (str1 < str2)
        return -1;
      if (str1 > str2)
        return 1;
      return 0;
    };
    var PageSorterImpl = class {
      constructor(pages, by) {
        this.pages = pages;
        this.by = by;
      }
      len() {
        return this.pages.length;
      }
      swap(i, j) {
        [this.pages[i], this.pages[j]] = [this.pages[j], this.pages[i]];
      }
      less(i, j) {
        return this.by(this.pages[i], this.pages[j]);
      }
    };
    function stableSort(pages, sorter) {
      const indices = Array.from({ length: sorter.len() }, (_, i) => i);
      indices.sort((i, j) => {
        const comparison = sorter.less(i, j);
        if (comparison)
          return -1;
        if (sorter.less(j, i))
          return 1;
        return i - j;
      });
      const originalPages = [...pages];
      for (let i = 0; i < indices.length; i++) {
        pages[i] = originalPages[indices[i]];
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/cast/cast.js
var require_cast = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/cast/cast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cast = void 0;
    var Cast = class {
      static toString(v) {
        if (v === null || v === void 0)
          return "";
        if (typeof v === "string")
          return v;
        if (typeof v === "number")
          return v.toString();
        if (typeof v === "boolean")
          return v.toString();
        return String(v);
      }
      static toInt(v) {
        if (v === null || v === void 0)
          return 0;
        if (typeof v === "number")
          return Math.floor(v);
        if (typeof v === "string") {
          const parsed = parseInt(v, 10);
          return isNaN(parsed) ? 0 : parsed;
        }
        return 0;
      }
      static toTime(v) {
        if (v === null || v === void 0)
          return new Date();
        if (v instanceof Date)
          return v;
        if (typeof v === "string") {
          const parsed = new Date(v);
          return isNaN(parsed.getTime()) ? new Date() : parsed;
        }
        if (typeof v === "number")
          return new Date(v);
        return new Date();
      }
    };
    exports2.Cast = Cast;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/cast/index.js
var require_cast2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/cast/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cast(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/string/string.js
var require_string = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/string/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Strings = void 0;
    var Strings = class {
      static sliceToLower(slice) {
        return slice.map((s) => s.toLowerCase());
      }
    };
    exports2.Strings = Strings;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/string/index.js
var require_string2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/string/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_string(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/types/types.js
var require_types2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/types/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Types = void 0;
    var cast_1 = require_cast2();
    var Types = class {
      static toStringSlicePreserveString(v) {
        if (v === null || v === void 0)
          return null;
        if (Array.isArray(v)) {
          return v.map((item) => cast_1.Cast.toString(item));
        }
        if (typeof v === "string") {
          return [v];
        }
        return [cast_1.Cast.toString(v)];
      }
    };
    exports2.Types = Types;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/types/index.js
var require_types3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/types/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/frontmatter.js
var require_frontmatter = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/frontmatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FrontMatterParserImpl = void 0;
    exports2.newFrontMatter = newFrontMatter;
    exports2.getParamToLower = getParamToLower;
    exports2.getParam = getParam;
    var kind_1 = require_kind();
    var cast_1 = require_cast2();
    var string_1 = require_string2();
    var types_1 = require_types3();
    function newFrontMatter() {
      return {
        path: "",
        lang: "",
        kind: "",
        title: "",
        weight: 999,
        date: new Date(),
        terms: {},
        params: {}
      };
    }
    var FrontMatterParserImpl = class {
      constructor(params, langSvc, taxonomySvc) {
        this.params = params;
        this.langSvc = langSvc;
        this.taxonomySvc = taxonomySvc;
      }
      async parse() {
        const fm = {
          terms: {},
          params: this.params,
          path: "",
          lang: "",
          kind: "",
          title: "",
          weight: 0,
          date: new Date()
        };
        try {
          await this.parseCustomized(fm);
        } catch (err) {
          throw err;
        }
        try {
          await this.parseTerms(fm);
        } catch (err) {
          throw err;
        }
        try {
          await this.parseTitle(fm);
        } catch (err) {
          throw err;
        }
        try {
          await this.parseWeight(fm);
        } catch (err) {
          throw err;
        }
        try {
          await this.parseDate(fm);
        } catch (err) {
          throw err;
        }
        return fm;
      }
      async parseDate(fm) {
        fm.date = new Date();
        if (this.params) {
          const v = this.params["date"];
          if (v !== void 0 && v !== null) {
            fm.date = cast_1.Cast.toTime(v);
          }
        }
      }
      async parseWeight(fm) {
        fm.weight = 1e4;
        if (this.params) {
          const v = this.params["weight"];
          if (v !== void 0 && v !== null) {
            fm.weight = cast_1.Cast.toInt(v);
          }
        }
      }
      async parseTitle(fm) {
        if (this.params) {
          const v = this.params["title"];
          if (v !== void 0 && v !== null) {
            fm.title = cast_1.Cast.toString(v);
          }
        }
      }
      async parseCustomized(fm) {
        if (!this.params)
          return;
        const pathValue = this.params["path"];
        if (pathValue !== void 0 && pathValue !== null) {
          fm.path = this.toSlashPreserveLeading(cast_1.Cast.toString(pathValue));
        }
        const langValue = this.params["lang"];
        if (langValue !== void 0 && langValue !== null) {
          const lang = cast_1.Cast.toString(langValue).toLowerCase();
          if (this.langSvc.isLanguageValid(lang)) {
            fm.lang = lang;
          }
        }
        const kindValue = this.params["kind"];
        if (kindValue !== void 0 && kindValue !== null) {
          const s = cast_1.Cast.toString(kindValue);
          if (s !== "") {
            const kind = (0, kind_1.getKindMain)(s);
            if (kind === "") {
              throw new Error(`unknown kind "${s}" in front matter`);
            }
            fm.kind = kind;
          }
        }
      }
      async parseTerms(fm) {
        const views = this.taxonomySvc.views();
        for (const viewName of views) {
          const vals = types_1.Types.toStringSlicePreserveString(getParam(this.params || {}, viewName.plural(), false));
          if (vals === null) {
            continue;
          }
          fm.terms[viewName.plural()] = vals;
        }
      }
      toSlashPreserveLeading(path6) {
        return path6.replace(/\\/g, "/");
      }
    };
    exports2.FrontMatterParserImpl = FrontMatterParserImpl;
    function getParamToLower(m, key) {
      return getParam(m, key, true);
    }
    function getParam(p, key, stringToLower) {
      const v = p[key.toLowerCase()];
      if (v === null || v === void 0) {
        return null;
      }
      switch (typeof v) {
        case "boolean":
          return v;
        case "string":
          if (stringToLower) {
            return v.toLowerCase();
          }
          return v;
        case "number":
          if (Number.isInteger(v)) {
            return cast_1.Cast.toInt(v);
          } else {
            return v;
          }
        default:
          if (v instanceof Date) {
            return v;
          }
          if (Array.isArray(v) && v.every((item) => typeof item === "string")) {
            if (stringToLower) {
              return string_1.Strings.sliceToLower(v);
            }
            return v;
          }
          return v;
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/classifier.js
var require_classifier = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/vo/classifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Classifier = void 0;
    var fileinfo_1 = require_fileinfo2();
    var Classifier = class {
      constructor(files) {
        this.files = files;
      }
      static async newClassifier(fis) {
        const fsFiles = [];
        for (const f of fis) {
          try {
            const file = (0, fileinfo_1.newFileInfo)(f);
            fsFiles.push(file);
          } catch (error) {
            throw new Error(`Failed to create FileInfo: ${error}`);
          }
        }
        const fsm = new Classifier(fsFiles);
        fsm.sort();
        return fsm;
      }
      sort() {
        this.files.sort((i, j) => {
          const fi = i;
          const fj = j;
          const fimi = fi.fileInfo();
          const fimj = fj.fileInfo();
          if (fimi.isDir() !== fimj.isDir()) {
            return fimi.isDir() ? -1 : 1;
          }
          const pii = fi.paths();
          const pij = fj.paths();
          if (pii) {
            if (fi.isBundle() !== fj.isBundle()) {
              return fi.isBundle() ? -1 : 1;
            }
            const exti = fi.ext();
            const extj = fj.ext();
            if (exti !== extj) {
              return exti > extj ? -1 : 1;
            }
            const basei = pii.base();
            const basej = pij.base();
            if (basei !== basej) {
              return basei < basej ? -1 : 1;
            }
          }
          return fimi.name() < fimj.name() ? -1 : 1;
        });
      }
      getLeaf() {
        for (const file of this.files) {
          if (file.isLeafBundle()) {
            return file;
          }
        }
        return null;
      }
      getFiles() {
        return this.files;
      }
      length() {
        return this.files.length;
      }
      at(index) {
        return this.files[index];
      }
      filter(predicate) {
        return this.files.filter(predicate);
      }
      find(predicate) {
        return this.files.find(predicate);
      }
      isEmpty() {
        return this.files.length === 0;
      }
    };
    exports2.Classifier = Classifier;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/dimensions.js
var require_dimensions = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/dimensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dimensionFlag = exports2.DimensionFlagHelper = exports2.DimensionFlag = void 0;
    var DimensionFlag;
    (function(DimensionFlag2) {
      DimensionFlag2[DimensionFlag2["DimensionLanguage"] = 1] = "DimensionLanguage";
      DimensionFlag2[DimensionFlag2["DimensionNone"] = 2] = "DimensionNone";
    })(DimensionFlag || (exports2.DimensionFlag = DimensionFlag = {}));
    var DimensionFlagHelper = class {
      constructor(flag) {
        this.flag = flag;
      }
      has(o) {
        return (this.flag & o) === o;
      }
      set(o) {
        return this.flag | o;
      }
      index() {
        if (this.flag === 0) {
          throw new Error("dimension flag not set");
        }
        return this.flag - 1;
      }
      valueOf() {
        return this.flag;
      }
    };
    exports2.DimensionFlagHelper = DimensionFlagHelper;
    exports2.dimensionFlag = {
      has: (flag, other) => {
        return (flag & other) === other;
      },
      set: (flag, other) => {
        return flag | other;
      },
      index: (flag) => {
        if (flag === 0) {
          throw new Error("dimension flag not set");
        }
        return flag - 1;
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/radix/radix.js
var require_radix = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/radix/radix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tree = void 0;
    exports2.createTree = createTree;
    exports2.createTreeFromMap = createTreeFromMap;
    var LeafNode = class {
      constructor(key, val) {
        this.key = key;
        this.val = val;
      }
    };
    var Edge = class {
      constructor(label, node) {
        this.label = label;
        this.node = node;
      }
    };
    var Node = class {
      constructor() {
        this.leaf = null;
        this.prefix = "";
        this.edges = [];
      }
      isLeaf() {
        return this.leaf !== null;
      }
      addEdge(e) {
        const num = this.edges.length;
        let idx = 0;
        while (idx < num && this.edges[idx].label < e.label) {
          idx++;
        }
        this.edges.splice(idx, 0, e);
      }
      updateEdge(label, node) {
        const num = this.edges.length;
        let idx = 0;
        while (idx < num && this.edges[idx].label < label) {
          idx++;
        }
        if (idx < num && this.edges[idx].label === label) {
          this.edges[idx].node = node;
          return;
        }
        throw new Error("replacing missing edge");
      }
      getEdge(label) {
        const num = this.edges.length;
        let idx = 0;
        while (idx < num && this.edges[idx].label < label) {
          idx++;
        }
        if (idx < num && this.edges[idx].label === label) {
          return this.edges[idx].node;
        }
        return null;
      }
      delEdge(label) {
        const num = this.edges.length;
        let idx = 0;
        while (idx < num && this.edges[idx].label < label) {
          idx++;
        }
        if (idx < num && this.edges[idx].label === label) {
          this.edges.splice(idx, 1);
        }
      }
      mergeChild() {
        const e = this.edges[0];
        const child = e.node;
        this.prefix = this.prefix + child.prefix;
        this.leaf = child.leaf;
        this.edges = child.edges;
      }
    };
    function longestPrefix(k1, k2) {
      const max = Math.min(k1.length, k2.length);
      let i = 0;
      for (i = 0; i < max; i++) {
        if (k1[i] !== k2[i]) {
          break;
        }
      }
      return i;
    }
    var Tree = class {
      constructor() {
        this.root = new Node();
        this.size = 0;
      }
      static newFromMap(m) {
        const t = new Tree();
        if (m) {
          if (m instanceof Map) {
            m.forEach((v, k) => {
              t.insert(k, v);
            });
          } else {
            for (const [k, v] of Object.entries(m)) {
              t.insert(k, v);
            }
          }
        }
        return t;
      }
      len() {
        return this.size;
      }
      insert(s, v) {
        let parent = null;
        let n2 = this.root;
        let search = s;
        while (true) {
          if (search.length === 0) {
            if (n2.isLeaf()) {
              const old = n2.leaf.val;
              n2.leaf.val = v;
              return [old, true];
            }
            n2.leaf = new LeafNode(s, v);
            this.size++;
            return [void 0, false];
          }
          parent = n2;
          n2 = n2.getEdge(search.charCodeAt(0));
          if (n2 === null) {
            const e = new Edge(search.charCodeAt(0), new Node());
            e.node.leaf = new LeafNode(s, v);
            e.node.prefix = search;
            parent.addEdge(e);
            this.size++;
            return [void 0, false];
          }
          const commonPrefix = longestPrefix(search, n2.prefix);
          if (commonPrefix === n2.prefix.length) {
            search = search.substring(commonPrefix);
            continue;
          }
          this.size++;
          const child = new Node();
          child.prefix = search.substring(0, commonPrefix);
          parent.updateEdge(search.charCodeAt(0), child);
          child.addEdge(new Edge(n2.prefix.charCodeAt(commonPrefix), n2));
          n2.prefix = n2.prefix.substring(commonPrefix);
          const leaf = new LeafNode(s, v);
          search = search.substring(commonPrefix);
          if (search.length === 0) {
            child.leaf = leaf;
            return [void 0, false];
          }
          const newNode = new Node();
          newNode.leaf = leaf;
          newNode.prefix = search;
          child.addEdge(new Edge(search.charCodeAt(0), newNode));
          return [void 0, false];
        }
      }
      delete(s) {
        let parent = null;
        let label = 0;
        let n2 = this.root;
        let search = s;
        while (true) {
          if (search.length === 0) {
            if (!n2.isLeaf()) {
              break;
            }
            const leaf = n2.leaf;
            n2.leaf = null;
            this.size--;
            if (parent !== null && n2.edges.length === 0) {
              parent.delEdge(label);
            }
            if (n2 !== this.root && n2.edges.length === 1) {
              n2.mergeChild();
            }
            if (parent !== null && parent !== this.root && parent.edges.length === 1 && !parent.isLeaf()) {
              parent.mergeChild();
            }
            return [leaf.val, true];
          }
          parent = n2;
          label = search.charCodeAt(0);
          n2 = n2.getEdge(label);
          if (n2 === null) {
            break;
          }
          if (search.startsWith(n2.prefix)) {
            search = search.substring(n2.prefix.length);
          } else {
            break;
          }
        }
        return [void 0, false];
      }
      async deletePrefix(s) {
        return await this._deletePrefix(null, this.root, s);
      }
      async _deletePrefix(parent, n2, prefix) {
        if (prefix.length === 0) {
          let subTreeSize = 0;
          await recursiveWalk(n2, (s, v) => {
            subTreeSize++;
            return Promise.resolve(false);
          });
          if (n2.isLeaf()) {
            n2.leaf = null;
          }
          n2.edges = [];
          if (parent !== null && parent !== this.root && parent.edges.length === 1 && !parent.isLeaf()) {
            parent.mergeChild();
          }
          this.size -= subTreeSize;
          return subTreeSize;
        }
        const label = prefix.charCodeAt(0);
        const child = n2.getEdge(label);
        if (child === null || !child.prefix.startsWith(prefix) && !prefix.startsWith(child.prefix)) {
          return 0;
        }
        if (child.prefix.length > prefix.length) {
          prefix = prefix.substring(prefix.length);
        } else {
          prefix = prefix.substring(child.prefix.length);
        }
        return this._deletePrefix(n2, child, prefix);
      }
      get(s) {
        let n2 = this.root;
        let search = s;
        while (true) {
          if (search.length === 0) {
            if (n2.isLeaf()) {
              return [n2.leaf.val, true];
            }
            break;
          }
          n2 = n2.getEdge(search.charCodeAt(0));
          if (n2 === null) {
            break;
          }
          if (search.startsWith(n2.prefix)) {
            search = search.substring(n2.prefix.length);
          } else {
            break;
          }
        }
        return [void 0, false];
      }
      longestPrefix(s) {
        let last = null;
        let n2 = this.root;
        let search = s;
        while (true) {
          if (n2.isLeaf()) {
            last = n2.leaf;
          }
          if (search.length === 0) {
            break;
          }
          n2 = n2.getEdge(search.charCodeAt(0));
          if (n2 === null) {
            break;
          }
          if (search.startsWith(n2.prefix)) {
            search = search.substring(n2.prefix.length);
          } else {
            break;
          }
        }
        if (last !== null) {
          return [last.key, last.val, true];
        }
        return ["", void 0, false];
      }
      minimum() {
        let n2 = this.root;
        while (true) {
          if (n2.isLeaf()) {
            return [n2.leaf.key, n2.leaf.val, true];
          }
          if (n2.edges.length > 0) {
            n2 = n2.edges[0].node;
          } else {
            break;
          }
        }
        return ["", void 0, false];
      }
      maximum() {
        let n2 = this.root;
        while (true) {
          const num = n2.edges.length;
          if (num > 0) {
            n2 = n2.edges[num - 1].node;
            continue;
          }
          if (n2.isLeaf()) {
            return [n2.leaf.key, n2.leaf.val, true];
          }
          break;
        }
        return ["", void 0, false];
      }
      async walk(fn) {
        await recursiveWalk(this.root, fn);
      }
      async walkPrefix(prefix, fn) {
        let n2 = this.root;
        let search = prefix;
        while (true) {
          if (search.length === 0) {
            await recursiveWalk(n2, fn);
            return;
          }
          n2 = n2.getEdge(search.charCodeAt(0));
          if (n2 === null) {
            return;
          }
          if (search.startsWith(n2.prefix)) {
            search = search.substring(n2.prefix.length);
            continue;
          }
          if (n2.prefix.startsWith(search)) {
            await recursiveWalk(n2, fn);
          }
          return;
        }
      }
      async walkPath(path6, fn) {
        let n2 = this.root;
        let search = path6;
        while (true) {
          if (n2.leaf !== null && await fn(n2.leaf.key, n2.leaf.val)) {
            return;
          }
          if (search.length === 0) {
            return;
          }
          n2 = n2.getEdge(search.charCodeAt(0));
          if (n2 === null) {
            return;
          }
          if (search.startsWith(n2.prefix)) {
            search = search.substring(n2.prefix.length);
          } else {
            break;
          }
        }
      }
      async toMap() {
        const out = {};
        await this.walk((k, v) => {
          out[k] = v;
          return Promise.resolve(false);
        });
        return out;
      }
    };
    exports2.Tree = Tree;
    async function recursiveWalk(n2, fn) {
      if (n2.leaf !== null && await fn(n2.leaf.key, n2.leaf.val)) {
        return true;
      }
      let i = 0;
      let k = n2.edges.length;
      while (i < k) {
        const e = n2.edges[i];
        if (await recursiveWalk(e.node, fn)) {
          return true;
        }
        if (n2.edges.length === 0) {
          return recursiveWalk(n2, fn);
        }
        if (n2.edges.length >= k) {
          i++;
        }
        k = n2.edges.length;
      }
      return false;
    }
    function createTree() {
      return new Tree();
    }
    function createTreeFromMap(m) {
      return Tree.newFromMap(m);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/radix/index.js
var require_radix2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/radix/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTreeFromMap = exports2.createTree = exports2.Tree = void 0;
    var radix_1 = require_radix();
    Object.defineProperty(exports2, "Tree", { enumerable: true, get: function() {
      return radix_1.Tree;
    } });
    Object.defineProperty(exports2, "createTree", { enumerable: true, get: function() {
      return radix_1.createTree;
    } });
    Object.defineProperty(exports2, "createTreeFromMap", { enumerable: true, get: function() {
      return radix_1.createTreeFromMap;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/support.js
var require_support = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/support.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MutableTrees = exports2.WalkableTrees = exports2.WalkContext = exports2.Event = exports2.LockType = void 0;
    exports2.validateKey = validateKey;
    exports2.cleanKey = cleanKey;
    exports2.mustValidateKey = mustValidateKey;
    var radix_1 = require_radix2();
    var LockType;
    (function(LockType2) {
      LockType2[LockType2["LockTypeNone"] = 0] = "LockTypeNone";
      LockType2[LockType2["LockTypeRead"] = 1] = "LockTypeRead";
      LockType2[LockType2["LockTypeWrite"] = 2] = "LockTypeWrite";
    })(LockType || (exports2.LockType = LockType = {}));
    var Event = class {
      constructor(name, path6, source) {
        this.stopPropagationFlag = false;
        this.name = name;
        this.path = path6;
        this.source = source;
      }
      stopPropagation() {
        this.stopPropagationFlag = true;
      }
      get shouldStopPropagation() {
        return this.stopPropagationFlag;
      }
    };
    exports2.Event = Event;
    var WalkContext = class {
      constructor() {
        this.dataInitialized = false;
        this.events = [];
        this.hooksPost = [];
      }
      addEventListener(event, path6, handler) {
        if (!this.eventHandlers) {
          this.eventHandlers = /* @__PURE__ */ new Map();
        }
        if (!this.eventHandlers.has(event)) {
          this.eventHandlers.set(event, []);
        }
        let targetPath = path6;
        if (!targetPath.endsWith("/")) {
          targetPath += "/";
        }
        this.eventHandlers.get(event).push((e) => {
          if (e.path.startsWith(targetPath)) {
            handler(e);
          }
        });
      }
      addPostHook(handler) {
        this.hooksPost.push(handler);
      }
      data() {
        if (!this.dataInitialized) {
          this.dataInstance = {
            tree: new radix_1.Tree()
          };
          this.dataInitialized = true;
        }
        return this.dataInstance;
      }
      sendEvent(event) {
        this.events.push(event);
      }
      async handleEvents() {
        while (this.events.length > 0) {
          const event = this.events.shift();
          if (this.eventHandlers && this.eventHandlers.has(event.name)) {
            const handlers = this.eventHandlers.get(event.name);
            for (let i = handlers.length - 1; i >= 0; i--) {
              handlers[i](event);
              if (event.shouldStopPropagation) {
                break;
              }
            }
          }
        }
      }
      async handleEventsAndHooks() {
        await this.handleEvents();
        for (const hook of this.hooksPost) {
          await hook();
        }
      }
    };
    exports2.WalkContext = WalkContext;
    var WalkableTrees = class {
      constructor(trees) {
        this.trees = trees;
      }
      walkPrefixRaw(prefix, walker) {
        for (const tree of this.trees) {
          tree.walkPrefixRaw(prefix, walker);
        }
      }
    };
    exports2.WalkableTrees = WalkableTrees;
    var MutableTrees = class {
      constructor(trees) {
        this.trees = trees;
      }
      delete(key) {
        for (const tree of this.trees) {
          tree.delete(key);
        }
      }
      deleteAll(key) {
        for (const tree of this.trees) {
          tree.deleteAll(key);
        }
      }
      async deletePrefix(prefix) {
        let count = 0;
        for (const tree of this.trees) {
          count += await tree.deletePrefix(prefix);
        }
        return Promise.resolve(count);
      }
      async deletePrefixAll(prefix) {
        let count = 0;
        for (const tree of this.trees) {
          count += await tree.deletePrefixAll(prefix);
        }
        return count;
      }
      lock(writable2) {
        const commits = this.trees.map((tree) => tree.lock(writable2));
        return () => {
          for (const commit of commits) {
            commit();
          }
        };
      }
      canLock() {
        for (const tree of this.trees) {
          if (!tree.canLock()) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.MutableTrees = MutableTrees;
    function validateKey(key) {
      if (key === "") {
        return null;
      }
      if (key.length < 2) {
        return new Error(`too short key: "${key}"`);
      }
      if (key[0] !== "/") {
        return new Error(`key must start with '/': "${key}"`);
      }
      if (key[key.length - 1] === "/") {
        return new Error(`key must not end with '/': "${key}"`);
      }
      return null;
    }
    function cleanKey(key) {
      if (key === "/") {
        return "";
      }
      return key;
    }
    function mustValidateKey(key) {
      const err = validateKey(key);
      if (err) {
        throw err;
      }
      return key;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/simpletree.js
var require_simpletree = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/simpletree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleTree = void 0;
    exports2.newSimpleTree = newSimpleTree;
    var radix_1 = require_radix2();
    var support_1 = require_support();
    function newSimpleTree() {
      return new SimpleTree();
    }
    var SimpleTree = class {
      constructor() {
        this.tree = new radix_1.Tree();
        this.zero = void 0;
        let locked = false;
        let readLocks = 0;
        this.mu = {
          lock: () => {
            while (locked || readLocks > 0) {
            }
            locked = true;
          },
          unlock: () => {
            locked = false;
          },
          rLock: () => {
            while (locked) {
            }
            readLocks++;
          },
          rUnlock: () => {
            readLocks--;
          }
        };
      }
      get(s) {
        this.mu.rLock();
        try {
          const [v, ok] = this.tree.get(s);
          if (ok) {
            return v;
          }
          return this.zero;
        } finally {
          this.mu.rUnlock();
        }
      }
      longestPrefix(s) {
        this.mu.rLock();
        try {
          const [key, v, ok] = this.tree.longestPrefix(s);
          if (ok) {
            return [key, v];
          }
          return ["", this.zero];
        } finally {
          this.mu.rUnlock();
        }
      }
      insert(s, v) {
        this.mu.lock();
        try {
          this.tree.insert(s, v);
          return v;
        } finally {
          this.mu.unlock();
        }
      }
      async walkPrefix(lockType, s, f) {
        switch (lockType) {
          case support_1.LockType.LockTypeNone:
            break;
          case support_1.LockType.LockTypeRead:
            this.mu.rLock();
            break;
          case support_1.LockType.LockTypeWrite:
            this.mu.lock();
            break;
        }
        try {
          let err = null;
          await this.tree.walkPrefix(s, async (key, v) => {
            const [shouldStop, error] = f(key, v);
            if (error) {
              err = error;
              return Promise.resolve(true);
            }
            return shouldStop;
          });
          return err;
        } finally {
          switch (lockType) {
            case support_1.LockType.LockTypeNone:
              break;
            case support_1.LockType.LockTypeRead:
              this.mu.rUnlock();
              break;
            case support_1.LockType.LockTypeWrite:
              this.mu.unlock();
              break;
          }
        }
      }
    };
    exports2.SimpleTree = SimpleTree;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/treeshifttree.js
var require_treeshifttree = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/treeshifttree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeShiftTree = void 0;
    var simpletree_1 = require_simpletree();
    var TreeShiftTree = class {
      constructor(d, length) {
        if (length <= 0) {
          throw new Error("length must be > 0");
        }
        this.d = d;
        this.v = 0;
        this.trees = [];
        for (let i = 0; i < length; i++) {
          this.trees.push((0, simpletree_1.newSimpleTree)());
        }
      }
      static newTreeShiftTree(d, length) {
        return new TreeShiftTree(d, length);
      }
      shape(d, v) {
        if (d !== this.d) {
          throw new Error("dimension mismatch");
        }
        if (v >= this.trees.length) {
          throw new Error("value out of range");
        }
        const newTree = Object.create(TreeShiftTree.prototype);
        Object.assign(newTree, this);
        newTree.v = v;
        return newTree;
      }
      get(s) {
        return this.trees[this.v].get(s);
      }
      longestPrefix(s) {
        return this.trees[this.v].longestPrefix(s);
      }
      insert(s, v) {
        return this.trees[this.v].insert(s, v);
      }
      async walkPrefix(lockType, s, f) {
        return await this.trees[this.v].walkPrefix(lockType, s, f);
      }
      delete(key) {
        for (const tree of this.trees) {
          tree.tree.delete(key);
        }
      }
      async deletePrefix(prefix) {
        let count = 0;
        for (const tree of this.trees) {
          count += await tree.tree.deletePrefix(prefix);
        }
        return count;
      }
      lock(writable2) {
        if (writable2) {
          for (const tree of this.trees) {
            tree.mu.lock();
          }
          return () => {
            for (const tree of this.trees) {
              tree.mu.unlock();
            }
          };
        }
        for (const tree of this.trees) {
          tree.mu.rLock();
        }
        return () => {
          for (const tree of this.trees) {
            tree.mu.rUnlock();
          }
        };
      }
    };
    exports2.TreeShiftTree = TreeShiftTree;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/nodeshifttree.js
var require_nodeshifttree = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/nodeshifttree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeShiftTreeWalker = exports2.NodeShiftTree = void 0;
    var radix_1 = require_radix2();
    var dimensions_1 = require_dimensions();
    var support_1 = require_support();
    var NodeShiftTree = class {
      constructor(cfg) {
        if (!cfg.shifter) {
          throw new Error("Shifter is required");
        }
        this.shifter = cfg.shifter;
        this.tree = new radix_1.Tree();
        this.dims = [0];
        let locked = false;
        let readLocks = 0;
        this.mu = {
          lock: () => {
            while (locked || readLocks > 0) {
            }
            locked = true;
          },
          unlock: () => {
            locked = false;
          },
          rLock: () => {
            while (locked) {
            }
            readLocks++;
          },
          rUnlock: () => {
            readLocks--;
          },
          tryLock: () => {
            if (locked || readLocks > 0) {
              return false;
            }
            locked = true;
            return true;
          }
        };
      }
      static new(cfg) {
        return new NodeShiftTree(cfg);
      }
      delete(key) {
        this.deleteInternal(key);
      }
      async deleteAll(key) {
        await this.tree.walkPrefix(key, (k, value2) => {
          const [v, ok] = this.tree.delete(k);
          if (ok) {
          }
          return Promise.resolve(false);
        });
      }
      async deletePrefix(prefix) {
        let count = 0;
        const keys = [];
        await this.tree.walkPrefix(prefix, (key, value2) => {
          keys.push(key);
          return Promise.resolve(false);
        });
        for (const key of keys) {
          if (this.deleteInternal(key)) {
            count++;
          }
        }
        return count;
      }
      deleteInternal(key) {
        let wasDeleted = false;
        const [v, ok] = this.tree.get(key);
        if (ok) {
          const [deleted, isEmpty] = this.shifter.delete(v, this.dims);
          wasDeleted = deleted;
          if (isEmpty) {
            this.tree.delete(key);
          }
        }
        return wasDeleted;
      }
      async deletePrefixAll(prefix) {
        let count = 0;
        await this.tree.walkPrefix(prefix, (key, value2) => {
          const [v, ok] = this.tree.delete(key);
          if (ok) {
            count++;
          }
          return Promise.resolve(false);
        });
        return count;
      }
      increment(d) {
        return this.shape(d, this.dims[d] + 1);
      }
      insertIntoCurrentDimension(s, v) {
        s = (0, support_1.mustValidateKey)((0, support_1.cleanKey)(s));
        const [vv, ok] = this.tree.get(s);
        if (ok) {
          v = this.shifter.insertInto(vv, v, this.dims);
        }
        this.tree.insert(s, v);
        return [v, true];
      }
      insertIntoValuesDimension(s, v) {
        s = (0, support_1.mustValidateKey)((0, support_1.cleanKey)(s));
        const [vv, ok] = this.tree.get(s);
        if (ok) {
          v = this.shifter.insert(vv, v);
        }
        this.tree.insert(s, v);
        return [v, true];
      }
      insertRawWithLock(s, v) {
        this.mu.lock();
        try {
          return this.tree.insert(s, v);
        } finally {
          this.mu.unlock();
        }
      }
      insertWithLock(s, v) {
        this.mu.lock();
        try {
          return this.insertIntoValuesDimension(s, v);
        } finally {
          this.mu.unlock();
        }
      }
      len() {
        return this.tree.len();
      }
      canLock() {
        const ok = this.mu.tryLock();
        if (ok) {
          this.mu.unlock();
        }
        return ok;
      }
      lock(writable2) {
        if (writable2) {
          this.mu.lock();
        } else {
          this.mu.rLock();
        }
        return () => {
          if (writable2) {
            this.mu.unlock();
          } else {
            this.mu.rUnlock();
          }
        };
      }
      longestPrefix(s, exact, predicate) {
        let currentPath = s;
        while (true) {
          const [longestPrefix, v, found] = this.tree.longestPrefix(currentPath);
          if (found) {
            const [t, ok] = this.shift(v, exact);
            if (ok && (!predicate || predicate(t))) {
              return [longestPrefix, t];
            }
          }
          if (currentPath === "" || currentPath === "/") {
            const zero2 = void 0;
            return ["", zero2];
          }
          const lastSlash = currentPath.lastIndexOf("/");
          if (lastSlash === 0) {
            currentPath = "";
          } else if (lastSlash > 0) {
            currentPath = currentPath.substring(0, lastSlash);
          } else {
            break;
          }
        }
        const zero = void 0;
        return ["", zero];
      }
      longestPrefixAll(s) {
        const [key, , found] = this.tree.longestPrefix(s);
        return [key, found];
      }
      getRaw(s) {
        const [v, ok] = this.tree.get(s);
        if (!ok) {
          const zero = void 0;
          return [zero, false];
        }
        return [v, true];
      }
      async walkPrefixRaw(prefix, walker) {
        await this.tree.walkPrefix(prefix, (key, value2) => {
          return walker(key, value2);
        });
      }
      shape(d, v) {
        const x = this.clone();
        x.dims[d] = v;
        return x;
      }
      toString() {
        return `Root{${this.dims}}`;
      }
      get(s) {
        const [t] = this.getInternal(s);
        return t;
      }
      forEachInDimension(s, d, f) {
        s = (0, support_1.cleanKey)(s);
        const [v, ok] = this.tree.get(s);
        if (!ok) {
          return;
        }
        this.shifter.forEachInDimension(v, d, f);
      }
      has(s) {
        const [, ok] = this.getInternal(s);
        return ok;
      }
      clone() {
        const cloned = Object.create(NodeShiftTree.prototype);
        Object.assign(cloned, this);
        cloned.dims = [...this.dims];
        return cloned;
      }
      shift(t, exact) {
        const [shifted, ok] = this.shifter.shift(t, this.dims, exact);
        return [shifted, ok];
      }
      getInternal(s) {
        s = (0, support_1.cleanKey)(s);
        const [v, ok] = this.tree.get(s);
        if (!ok) {
          const zero = void 0;
          return [zero, false];
        }
        const [t, success] = this.shift(v, true);
        return [t, success];
      }
    };
    exports2.NodeShiftTree = NodeShiftTree;
    var NodeShiftTreeWalker = class {
      constructor(config) {
        this.skipPrefixes = [];
        if (!config.tree) {
          throw new Error("Tree is required");
        }
        this.tree = config.tree;
        this.handle = config.handle;
        this.prefix = config.prefix || "";
        this.lockType = config.lockType || support_1.LockType.LockTypeNone;
        this.noShift = config.noShift || false;
        this.exact = config.exact || false;
        this.debug = config.debug || false;
        this.walkContext = config.walkContext;
      }
      extend() {
        const extended = new NodeShiftTreeWalker({
          tree: this.tree,
          handle: this.handle,
          prefix: this.prefix,
          lockType: this.lockType,
          noShift: this.noShift,
          exact: this.exact,
          debug: this.debug,
          walkContext: this.walkContext
        });
        extended.resetLocalState();
        return extended;
      }
      skipPrefix(...prefixes) {
        this.skipPrefixes.push(...prefixes);
      }
      shouldSkip(s) {
        for (const prefix of this.skipPrefixes) {
          if (s.startsWith(prefix)) {
            return true;
          }
        }
        return false;
      }
      async walk() {
        this.resetLocalState();
        let commit = null;
        if (this.lockType > support_1.LockType.LockTypeNone) {
          commit = this.tree.lock(this.lockType === support_1.LockType.LockTypeWrite);
        }
        try {
          let err = null;
          const fnMain = async (s, v) => {
            if (this.shouldSkip(s)) {
              return false;
            }
            const [t, ok, exact] = this.toT(this.tree, v);
            if (!ok) {
              return false;
            }
            const [terminate, error] = await this.handle(s, t, exact);
            if (terminate || error) {
              err = error;
              return true;
            }
            return false;
          };
          if (this.prefix !== "") {
            await this.tree.tree.walkPrefix(this.prefix, fnMain);
          } else {
            await this.tree.tree.walk(fnMain);
          }
          return err;
        } finally {
          if (commit) {
            commit();
          }
        }
      }
      resetLocalState() {
        this.skipPrefixes = [];
      }
      toT(tree, v) {
        if (this.noShift) {
          return [v, true, dimensions_1.DimensionFlag.DimensionNone];
        } else {
          const [t, ok, exact] = tree.shifter.shift(v, tree.dims, this.exact);
          return [t, ok, exact];
        }
      }
    };
    exports2.NodeShiftTreeWalker = NodeShiftTreeWalker;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/doctree/index.js
var require_doctree = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/doctree/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeShiftTreeWalker = exports2.NodeShiftTree = exports2.TreeShiftTree = exports2.newSimpleTree = exports2.SimpleTree = exports2.mustValidateKey = exports2.cleanKey = exports2.validateKey = exports2.MutableTrees = exports2.WalkableTrees = exports2.WalkContext = exports2.Event = exports2.LockType = exports2.dimensionFlag = exports2.DimensionFlagHelper = exports2.DimensionFlag = void 0;
    var dimensions_1 = require_dimensions();
    Object.defineProperty(exports2, "DimensionFlag", { enumerable: true, get: function() {
      return dimensions_1.DimensionFlag;
    } });
    Object.defineProperty(exports2, "DimensionFlagHelper", { enumerable: true, get: function() {
      return dimensions_1.DimensionFlagHelper;
    } });
    Object.defineProperty(exports2, "dimensionFlag", { enumerable: true, get: function() {
      return dimensions_1.dimensionFlag;
    } });
    var support_1 = require_support();
    Object.defineProperty(exports2, "LockType", { enumerable: true, get: function() {
      return support_1.LockType;
    } });
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return support_1.Event;
    } });
    Object.defineProperty(exports2, "WalkContext", { enumerable: true, get: function() {
      return support_1.WalkContext;
    } });
    Object.defineProperty(exports2, "WalkableTrees", { enumerable: true, get: function() {
      return support_1.WalkableTrees;
    } });
    Object.defineProperty(exports2, "MutableTrees", { enumerable: true, get: function() {
      return support_1.MutableTrees;
    } });
    Object.defineProperty(exports2, "validateKey", { enumerable: true, get: function() {
      return support_1.validateKey;
    } });
    Object.defineProperty(exports2, "cleanKey", { enumerable: true, get: function() {
      return support_1.cleanKey;
    } });
    Object.defineProperty(exports2, "mustValidateKey", { enumerable: true, get: function() {
      return support_1.mustValidateKey;
    } });
    var simpletree_1 = require_simpletree();
    Object.defineProperty(exports2, "SimpleTree", { enumerable: true, get: function() {
      return simpletree_1.SimpleTree;
    } });
    Object.defineProperty(exports2, "newSimpleTree", { enumerable: true, get: function() {
      return simpletree_1.newSimpleTree;
    } });
    var treeshifttree_1 = require_treeshifttree();
    Object.defineProperty(exports2, "TreeShiftTree", { enumerable: true, get: function() {
      return treeshifttree_1.TreeShiftTree;
    } });
    var nodeshifttree_1 = require_nodeshifttree();
    Object.defineProperty(exports2, "NodeShiftTree", { enumerable: true, get: function() {
      return nodeshifttree_1.NodeShiftTree;
    } });
    Object.defineProperty(exports2, "NodeShiftTreeWalker", { enumerable: true, get: function() {
      return nodeshifttree_1.NodeShiftTreeWalker;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifter.js
var require_shifter = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Shifter = void 0;
    var pagetrees_1 = require_pagetrees();
    var doctree_1 = require_doctree();
    var Shifter = class {
      delete(n2, dimension) {
        const wasDeleted = n2.delete(dimension[doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)]);
        return [wasDeleted, n2.isEmpty()];
      }
      shift(n2, dimension, exact) {
        const [newNode, found] = n2.shift(dimension[doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)], exact);
        if (newNode !== null) {
          if (found) {
            return [newNode, true, doctree_1.DimensionFlag.DimensionLanguage];
          }
          return [newNode, true, doctree_1.DimensionFlag.DimensionNone];
        }
        return [new pagetrees_1.PageTreesNode(), false, doctree_1.DimensionFlag.DimensionNone];
      }
      forEachInDimension(n2, d, f) {
        if (d !== doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)) {
          throw new Error("only language dimension supported");
        }
        f(n2);
      }
      insertInto(old, newNode, dimension) {
        return old.mergeWithLang(newNode, dimension[doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)]);
      }
      insert(old, newNode) {
        return old.merge(newNode);
      }
    };
    exports2.Shifter = Shifter;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifterpage.js
var require_shifterpage = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifterpage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageShifter = void 0;
    var pagetrees_1 = require_pagetrees();
    var doctree_1 = require_doctree();
    var shifter_1 = require_shifter();
    var PageShifter = class extends shifter_1.Shifter {
      shift(n2, dimension, exact) {
        const [newNode, found] = n2.shift(dimension[doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)], exact);
        if (newNode !== null) {
          if (found) {
            return [newNode, true, doctree_1.DimensionFlag.DimensionLanguage];
          }
        }
        return [new pagetrees_1.PageTreesNode(), false, doctree_1.DimensionFlag.DimensionNone];
      }
    };
    exports2.PageShifter = PageShifter;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifterpagesource.js
var require_shifterpagesource = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shifterpagesource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceShifter = void 0;
    var pagetrees_1 = require_pagetrees();
    var doctree_1 = require_doctree();
    var shifter_1 = require_shifter();
    var SourceShifter = class extends shifter_1.Shifter {
      shift(n2, dimension, exact) {
        const [newNode, found] = n2.shift(dimension[doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage)], exact);
        if (newNode !== null) {
          if (found) {
            return [newNode, true, doctree_1.DimensionFlag.DimensionLanguage];
          }
          return [newNode, true, doctree_1.DimensionFlag.DimensionNone];
        }
        return [new pagetrees_1.PageTreesNode(), false, doctree_1.DimensionFlag.DimensionNone];
      }
    };
    exports2.SourceShifter = SourceShifter;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagetrees.js
var require_pagetrees = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagetrees.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageTrees = exports2.PageTreesNode = exports2.WeightedTermTreeNode = void 0;
    exports2.newPageTreesNode = newPageTreesNode;
    var doctree_1 = require_doctree();
    var shifterpage_1 = require_shifterpage();
    var shifterpagesource_1 = require_shifterpagesource();
    var WeightedTermTreeNode = class {
      constructor(pageTreesNode, term) {
        this.pageTreesNodeInstance = pageTreesNode;
        this.term = term;
      }
      getPage() {
        return this.pageTreesNodeInstance.getPage();
      }
      getPages() {
        return this.pageTreesNodeInstance.getPages();
      }
      getResource() {
        return this.pageTreesNodeInstance.getResource();
      }
      isEmpty() {
        return this.pageTreesNodeInstance.isEmpty();
      }
      shift(languageIndex, exact) {
        return this.pageTreesNodeInstance.shift(languageIndex, exact);
      }
    };
    exports2.WeightedTermTreeNode = WeightedTermTreeNode;
    var PageTreesNode = class {
      constructor() {
        this.nodes = /* @__PURE__ */ new Map();
      }
      setNode(key, value2) {
        this.nodes.set(key, value2);
      }
      merge(newNode) {
        const existingKeys = /* @__PURE__ */ new Map();
        for (const key of this.nodes.keys()) {
          existingKeys.set(key.pageLanguage(), key);
        }
        for (const [newKey, newValue] of newNode.nodes.entries()) {
          const oldKey = existingKeys.get(newKey.pageLanguage());
          if (oldKey) {
            this.nodes.set(oldKey, newValue);
          } else {
            this.nodes.set(newKey, newValue);
          }
        }
        return this;
      }
      mergeWithLang(newNode, languageIndex) {
        const existingKeys = /* @__PURE__ */ new Map();
        for (const key of this.nodes.keys()) {
          existingKeys.set(key.pageLanguage(), key);
        }
        for (const [newKey, newValue] of newNode.nodes.entries()) {
          const oldKey = existingKeys.get(newKey.pageLanguage());
          if (oldKey) {
            const existingPageSource = this.nodes.get(oldKey);
            if (existingPageSource && existingPageSource.pageIdentity().pageLanguageIndex() === languageIndex) {
              this.remove(oldKey);
            }
          }
          this.nodes.set(newKey, newValue);
        }
        return this;
      }
      remove(k) {
        const v = this.nodes.get(k);
        if (!v) {
          return false;
        }
        this.markStale(v);
        this.nodes.delete(k);
        return true;
      }
      delete(languageIndex) {
        for (const [k, v] of this.nodes.entries()) {
          if (v.pageIdentity().pageLanguageIndex() === languageIndex) {
            return this.remove(k);
          }
        }
        return false;
      }
      isEmpty() {
        return this.nodes.size === 0;
      }
      shift(languageIndex, exact) {
        let firstV = null;
        for (const [k, v] of this.nodes.entries()) {
          if (firstV === null) {
            firstV = v;
          }
          if (v.pageIdentity().pageLanguageIndex() === languageIndex) {
            return [newPageTreesNode(v), true];
          }
        }
        if (firstV !== null && !exact) {
          return [newPageTreesNode(firstV), false];
        }
        return [null, false];
      }
      getPage() {
        for (const v of this.nodes.values()) {
          if (v && typeof v.kind === "function") {
            return [v, true];
          }
        }
        return [null, false];
      }
      getPages() {
        const pages = [];
        for (const v of this.nodes.values()) {
          if (v && typeof v.kind === "function") {
            pages.push(v);
          }
        }
        return pages;
      }
      getResource() {
        for (const v of this.nodes.values()) {
          return [v, true];
        }
        return [null, false];
      }
      markStale(v) {
        if ("staleVersions" in v && typeof v.staleVersions === "function") {
        }
      }
    };
    exports2.PageTreesNode = PageTreesNode;
    var PageTrees = class {
      constructor() {
        this.treePages = new doctree_1.NodeShiftTree({
          shifter: new shifterpage_1.PageShifter()
        });
        this.treeResources = new doctree_1.NodeShiftTree({
          shifter: new shifterpagesource_1.SourceShifter()
        });
        this.treeTaxonomyEntries = doctree_1.TreeShiftTree.newTreeShiftTree(0, 10);
        this.treePagesResources = new doctree_1.WalkableTrees([]);
        this.resourceTrees = new doctree_1.MutableTrees([]);
        this.treePagesResources = new doctree_1.WalkableTrees([
          this.treePages,
          this.treeResources
        ]);
        this.resourceTrees = new doctree_1.MutableTrees([
          this.treeResources
        ]);
      }
      createMutableTrees() {
        this.treePagesResources = new doctree_1.WalkableTrees([
          this.treePages,
          this.treeResources
        ]);
        this.resourceTrees = new doctree_1.MutableTrees([
          this.treeResources
        ]);
      }
      get TreePages() {
        return this.treePages;
      }
      get TreeResources() {
        return this.treeResources;
      }
      get TreePagesResources() {
        return this.treePagesResources;
      }
      get TreeTaxonomyEntries() {
        return this.treeTaxonomyEntries;
      }
      get ResourceTrees() {
        return this.resourceTrees;
      }
    };
    exports2.PageTrees = PageTrees;
    function newPageTreesNode(ps) {
      const n2 = new PageTreesNode();
      if (ps) {
        n2.setNode(ps.pageIdentity(), ps);
      }
      return n2;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagesource.js
var require_pagesource = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagesource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Source = void 0;
    exports2.posFromInput = posFromInput;
    exports2.newPageSource = newPageSource;
    var log_1 = require_log();
    var identity_1 = require_identity();
    var pageIDCounter = 0;
    var log = (0, log_1.getDomainLogger)("content", { component: "pagesource" });
    function posFromInput(filename, input, offset) {
      if (offset < 0) {
        return {
          filename,
          lineNumber: 0,
          columnNumber: 0,
          offset: 0
        };
      }
      const inputSlice = input.slice(0, offset);
      const newlineChar = 10;
      let lineNumber = 1;
      for (let i = 0; i < inputSlice.length; i++) {
        if (inputSlice[i] === newlineChar) {
          lineNumber++;
        }
      }
      let endOfLastLine = -1;
      for (let i = inputSlice.length - 1; i >= 0; i--) {
        if (inputSlice[i] === newlineChar) {
          endOfLastLine = i;
          break;
        }
      }
      return {
        filename,
        lineNumber,
        columnNumber: offset - endOfLastLine,
        offset
      };
    }
    var Source = class {
      constructor(file) {
        this.id = (++pageIDCounter).toString();
        this.identity = new identity_1.Identity(pageIDCounter);
        this.file = file;
      }
      sourceKey() {
        return `${this.identity.lang}/${this.file.filename()}`.replace(/\\/g, "/");
      }
      async contentSource() {
        return await this.readSourceAll();
      }
      async readSourceAll() {
        try {
          const file = await this.file.open();
          const fileInfo = await file.stat();
          const buffer = new Uint8Array(fileInfo.size());
          const result = await file.read(buffer);
          await file.close();
          return result.buffer;
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new Error(`Failed to read file content: ${message}`);
        }
      }
      async posOffset(offset) {
        try {
          const source = await this.contentSource();
          return posFromInput(this.file.filename(), source, offset);
        } catch (error) {
          throw new Error(`failed to read content source for "${this.file.filename()}": ${error}`);
        }
      }
      pageIdentity() {
        return this.identity;
      }
      pageFile() {
        return this.file;
      }
      staleVersions() {
        return [];
      }
      section() {
        return this.file.section();
      }
      paths() {
        return this.file.paths();
      }
      path() {
        return this.file.paths().path();
      }
      opener() {
        return () => this.file.open();
      }
      openReader() {
        return {
          read: async () => {
            return new Uint8Array(0);
          }
        };
      }
      async content() {
        try {
          log.error(`Reading content not implemented from: ${this.file.filename()}`);
          return new Uint8Array(0);
        } catch (error) {
          const errorMsg = `failed to read content source for "${this.file.filename()}": ${error}`;
          log.error(errorMsg);
          throw new Error(errorMsg);
        }
      }
    };
    exports2.Source = Source;
    function newPageSource(file) {
      return new Source(file);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagemap.js
var require_pagemap = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagemap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageMap = exports2.PageMapQueryPagesInSectionImpl = exports2.PageMapQueryPagesBelowPathImpl = exports2.pagePredicates = void 0;
    exports2.addTrailingSlash = addTrailingSlash;
    var pagetrees_1 = require_pagetrees();
    var pagesource_1 = require_pagesource();
    var type_1 = require_type4();
    var doctree_1 = require_doctree();
    var sort_1 = require_sort();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "pagemap" });
    function addTrailingSlash(path6) {
      if (!path6.endsWith("/")) {
        path6 += "/";
      }
      return path6;
    }
    function addLeadingSlash(path6) {
      if (!path6.startsWith("/")) {
        path6 = "/" + path6;
      }
      return path6;
    }
    var ambiguousContentNode = new pagetrees_1.PageTreesNode();
    var ContentTreeReverseIndexMap = class {
      constructor() {
        this.initOnce = false;
        this.m = /* @__PURE__ */ new Map();
      }
    };
    var ContentTreeReverseIndex = class {
      constructor(initFn) {
        this.initFn = initFn;
        this.contentTreeReverseIndexMap = new ContentTreeReverseIndexMap();
      }
      reset() {
        this.contentTreeReverseIndexMap = new ContentTreeReverseIndexMap();
      }
      get(key) {
        if (!this.contentTreeReverseIndexMap.initOnce) {
          this.contentTreeReverseIndexMap.m = /* @__PURE__ */ new Map();
          this.initFn(this.contentTreeReverseIndexMap.m);
          this.contentTreeReverseIndexMap.initOnce = true;
        }
        return this.contentTreeReverseIndexMap.m.get(key) || null;
      }
    };
    exports2.pagePredicates = {
      kindPage: (p) => p.kind() === "page",
      kindSection: (p) => p.kind() === "section",
      kindHome: (p) => p.kind() === "home",
      kindTerm: (p) => p.kind() === "term",
      shouldListLocal: (p) => p.shouldList ? p.shouldList(false) : true,
      shouldListGlobal: (p) => p.shouldList ? p.shouldList(true) : true,
      shouldListAny: (p) => p.shouldListAny ? p.shouldListAny() : true,
      shouldLink: (p) => p.noLink ? !p.noLink() : true
    };
    var PageMapQueryPagesBelowPathImpl = class {
      constructor(path6, keyPart, include = exports2.pagePredicates.shouldListLocal) {
        this.path = path6;
        this.keyPart = keyPart;
        this.include = include;
      }
      key() {
        return this.path + "/" + this.keyPart;
      }
    };
    exports2.PageMapQueryPagesBelowPathImpl = PageMapQueryPagesBelowPathImpl;
    var PageMapQueryPagesInSectionImpl = class extends PageMapQueryPagesBelowPathImpl {
      constructor(path6, keyPart, recursive, includeSelf, index, include) {
        super(path6, keyPart, include);
        this.recursive = recursive;
        this.includeSelf = includeSelf;
        this.index = index;
      }
      key() {
        return "gagesInSection/" + super.key() + "/" + this.recursive.toString() + "/" + this.index.toString() + "/" + this.includeSelf.toString();
      }
    };
    exports2.PageMapQueryPagesInSectionImpl = PageMapQueryPagesInSectionImpl;
    var PageMap = class extends pagetrees_1.PageTrees {
      constructor(pageBuilder) {
        super();
        this.pageReverseIndex = null;
        this.pageBuilder = pageBuilder;
      }
      setupReverseIndex() {
        this.pageReverseIndex = new ContentTreeReverseIndex(async (rm) => {
          const add = (k, n2) => {
            const existing = rm.get(k);
            if (existing && existing !== ambiguousContentNode) {
              rm.set(k, ambiguousContentNode);
            } else if (!existing) {
              rm.set(k, n2);
            }
          };
          const walker = new doctree_1.NodeShiftTreeWalker({
            tree: this.treePages,
            lockType: doctree_1.LockType.LockTypeRead,
            handle: async (s, n2, match) => {
              if (n2) {
                const [p, found] = n2.getPage();
                if (!found) {
                  return [false, null];
                }
                if (p.pageFile && p.pageFile()) {
                  add(p.paths().baseNameNoIdentifier(), n2);
                }
              }
              return [false, null];
            }
          });
          try {
            await walker.walk();
          } catch (err) {
            log.error(`setupReverseIndex error: ${err}`);
          }
        });
      }
      insertResourceNode(key, node) {
        const tree = this.treeResources;
        const commit = tree.lock(true);
        try {
          tree.insertIntoValuesDimension(key, node);
        } finally {
          commit();
        }
      }
      async addFi(f) {
        if (f.fileInfo().isDir()) {
          return;
        }
        const ps = (0, pagesource_1.newPageSource)(f);
        const key = ps.paths().base();
        const bundleType = ps.file.getBundleType();
        switch (bundleType) {
          case type_1.PathType.File:
            this.insertResourceNode(key, (0, pagetrees_1.newPageTreesNode)(ps));
            break;
          case type_1.PathType.ContentResource:
            const p = await this.pageBuilder.withSource(ps).build();
            if (!p) {
              return;
            }
            this.insertResourceNode(key, (0, pagetrees_1.newPageTreesNode)(p));
            break;
          default:
            const page = await this.pageBuilder.withSource(ps).build();
            this.treePages.insertWithLock(ps.paths().base(), (0, pagetrees_1.newPageTreesNode)(page));
            break;
        }
      }
      async assemble() {
        await this.assembleStructurePages();
        await this.applyAggregates();
        await this.cleanPages();
        await this.assembleTerms();
      }
      async assembleTerms() {
        for (const idx of this.pageBuilder.langSvc.languageIndexes()) {
          const tree = this.treePages.shape(0, idx);
          const treeTaxonomyEntries = this.treeTaxonomyEntries.shape(0, idx);
          await this.pageBuilder.term.assemble(tree, treeTaxonomyEntries, this.pageBuilder, idx);
        }
      }
      async cleanPages() {
      }
      async applyAggregates() {
      }
      async assembleStructurePages() {
        await this.addMissingTaxonomies();
        for (const idx of this.pageBuilder.langSvc.languageIndexes()) {
          const tree = this.treePages.shape(0, idx);
          await this.pageBuilder.section.assemble(tree, this.pageBuilder, idx);
        }
        await this.addMissingStandalone();
      }
      async addMissingTaxonomies() {
        const tree = this.treePages;
        const commit = tree.lock(true);
        try {
          for (const idx of this.pageBuilder.langSvc.languageIndexes()) {
            const tree2 = this.treePages.shape(0, idx);
            await this.pageBuilder.taxonomy.assemble(tree2, this.pageBuilder, idx);
          }
        } finally {
          commit();
        }
      }
      async addMissingStandalone() {
        const tree = this.treePages;
        const commit = tree.lock(true);
        try {
          await this.pageBuilder.standalone.assemble(tree, this.pageBuilder);
        } finally {
          commit();
        }
      }
      async getResourcesForPage(ps) {
        const res = [];
        await this.forEachResourceInPage(ps, doctree_1.LockType.LockTypeNone, false, (resourceKey, n2, match) => {
          const [rs, found] = n2.getResource();
          if (found) {
            res.push(rs);
          }
          return [false, null];
        });
        return res;
      }
      async forEachResourceInPage(ps, lockType, exact, handle) {
        let keyPage = ps.paths().base();
        if (keyPage === "/") {
          keyPage = "";
        }
        const prefix = addTrailingSlash(keyPage);
        const isBranch = ps.kind() !== "page";
        const rw = new doctree_1.NodeShiftTreeWalker({
          tree: this.treeResources.shape(0, ps.pageIdentity().pageLanguageIndex()),
          prefix,
          lockType,
          exact,
          handle: async (resourceKey, n2, match) => {
            if (isBranch) {
              const [ownerKey] = this.treePages.longestPrefixAll(resourceKey);
              if (ownerKey !== keyPage && this.pathDir(ownerKey) !== this.pathDir(resourceKey)) {
                rw.skipPrefix(ownerKey + "/");
                return [false, null];
              }
            }
            return handle(resourceKey, n2, match);
          }
        });
        try {
          await rw.walk();
        } catch (err) {
          log.error(`forEachResourceInPage error: ${err}`);
        }
      }
      async getPagesInSection(langIndex, q) {
        const cacheKey = q.key();
        const tree = this.treePages.shape(0, langIndex);
        return this.getOrCreatePagesFromCacheSync(null, cacheKey, async (key) => {
          const prefix = addTrailingSlash(q.path);
          const pas = [];
          let otherBranch = "";
          const include = q.include;
          const walker = new doctree_1.NodeShiftTreeWalker({
            tree,
            prefix,
            handle: async (key2, n2, match) => {
              if (q.recursive) {
                const [p2, found2] = n2.getPage();
                if (found2 && include(p2)) {
                  pas.push(p2);
                }
                return [false, null];
              }
              const [p, found] = n2.getPage();
              if (found && include(p)) {
                pas.push(p);
              }
              if (!p.isPage || !p.isPage()) {
                const currentBranch = key2 + "/";
                if (otherBranch === "" || otherBranch !== currentBranch) {
                  walker.skipPrefix(currentBranch);
                }
                otherBranch = currentBranch;
              }
              return [false, null];
            }
          });
          try {
            await walker.walk();
            if (q.includeSelf) {
              const n2 = tree.get(q.path);
              if (n2) {
                const [p, found] = n2.getPage();
                if (found && include(p)) {
                  pas.push(p);
                }
              }
            }
            const pages = pas;
            (0, sort_1.sortByWeight)(pages);
            return Promise.resolve(pages);
          } catch (err) {
            log.error(`getPagesInSection error: ${err}`);
          }
          return Promise.resolve(pas);
        });
      }
      async getOrCreatePagesFromCacheSync(cache, key, create) {
        return await create(key);
      }
      async getPagesWithTerm(langIndex, q) {
        const key = q.key();
        const tree = this.treeTaxonomyEntries.shape(0, langIndex);
        return await this.getOrCreatePagesFromCacheSync(null, key, async (cacheKey) => {
          const pas = [];
          const include = q.include;
          try {
            await tree.walkPrefix(doctree_1.LockType.LockTypeNone, addTrailingSlash(q.path), (s, n2) => {
              const [p, found] = n2.getPage();
              if (found && include(p)) {
                pas.push(p);
              }
              return [false, null];
            });
            const pages = pas;
            (0, sort_1.sortByDefault)(pages);
            return pages;
          } catch (err) {
            log.error(`getPagesWithTerm error: ${err}`);
          }
          return pas;
        });
      }
      getTermsForPageInTaxonomy(langIndex, base, taxonomy) {
        const prefix = addLeadingSlash(taxonomy);
        const tree = this.treeTaxonomyEntries.shape(0, langIndex);
        return this.getOrCreatePagesFromCacheSync(null, prefix + base, async (cacheKey) => {
          const pas = [];
          try {
            await tree.walkPrefix(doctree_1.LockType.LockTypeNone, addTrailingSlash(prefix), (s, n2) => {
              if (s.endsWith(base)) {
                pas.push(n2.term.page);
              }
              return [false, null];
            });
            const pages = pas;
            (0, sort_1.sortByDefault)(pages);
            return pages;
          } catch (err) {
            log.error(`getTermsForPageInTaxonomy error: ${err}`);
          }
          return pas;
        });
      }
      async getSections(langIndex, prefix) {
        const pagesList = [];
        let currentBranchPrefix = "";
        const tree = this.treePages.shape(0, langIndex);
        const walker = new doctree_1.NodeShiftTreeWalker({
          tree,
          prefix,
          handle: async (ss, n2, match) => {
            const [p, found] = n2.getPage();
            if (!found) {
              return [false, null];
            }
            if (p.isPage && p.isPage()) {
              return [false, null];
            }
            if (currentBranchPrefix === "" || !ss.startsWith(currentBranchPrefix)) {
              if (p.isSection && p.isSection() && p.shouldList && p.shouldList(false) && p.parent && p.parent() === p) {
                pagesList.push(p);
              } else {
                walker.skipPrefix(ss + "/");
              }
            }
            currentBranchPrefix = ss + "/";
            return [false, null];
          }
        });
        try {
          await walker.walk();
          const pages = pagesList;
          (0, sort_1.sortByDefault)(pages);
          return pages;
        } catch (err) {
          log.error(`getSections error: ${err}`);
        }
        return pagesList;
      }
      pathDir(path6) {
        const lastSlash = path6.lastIndexOf("/");
        if (lastSlash === -1) {
          return "";
        }
        return path6.substring(0, lastSlash);
      }
    };
    exports2.PageMap = PageMap;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagecollector.js
var require_pagecollector = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagecollector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PagesCollector = void 0;
    var content_1 = require_content3();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "pagecollector" });
    var PagesCollector = class {
      constructor(pageMap, fs5) {
        this.processedPaths = /* @__PURE__ */ new Set();
        this.m = pageMap;
        this.fs = fs5;
      }
      async collect() {
        try {
          const dirPath = "";
          const cfss = this.fs.contentFs();
          for (const cfs of cfss) {
            this.processedPaths.clear();
            const root = await cfs.stat(dirPath);
            await this.collectDir(cfs, dirPath, root);
          }
        } catch (error) {
          log.error(`Failed to collect directory: ${error}, continuing...`);
        }
      }
      async collectDir(fs5, path6, root) {
        try {
          await this.fs.walkContent(fs5, path6, {
            hookPre: async (dir, path7, readdir) => {
              const fullPath = path7;
              if (this.processedPaths.has(fullPath)) {
                log.warn("Path already processed!", {
                  path: fullPath,
                  dirName: dir.name(),
                  dirIsDir: dir.isDir(),
                  readdirLength: readdir.length
                });
                return [];
              }
              this.processedPaths.add(fullPath);
              if (readdir.length === 0) {
                return [];
              }
              for (const fi of readdir) {
                if (fi.isDir && fi.isDir()) {
                  continue;
                }
                const file = (0, content_1.newFileInfo)(fi);
                await this.m.addFi(file);
              }
              return readdir;
            },
            walkFn: async (filePath, fi) => {
              return;
            }
          }, {
            info: root
          });
        } catch (error) {
          log.error(`Failed to collect directory: ${error}`, {
            path: path6,
            rootName: root.name(),
            rootIsDir: root.isDir(),
            stack: error.stack || "No stack trace available"
          });
          throw new Error(`Failed to collect directory: ${error}`);
        }
      }
      async handleBundleLeaf(dir, bundle, inPath, readdir) {
        const bundlePath = bundle.paths();
        const walk = async (path6, info) => {
          if (info.isDir()) {
            return;
          }
          const f = (0, content_1.newFileInfo)(info);
          if (info !== bundle.fileInfo()) {
            if (!f.isLeafBundle() || f.paths().dir() !== bundlePath.dir()) {
              f.shiftToResource();
            }
          }
          await this.m.addFi(f);
        };
        const cfss = this.fs.contentFs();
        for (const cfs of cfss) {
          await this.fs.walkContent(cfs, inPath, {
            walkFn: walk
          }, {
            info: dir,
            dirEntries: readdir
          });
        }
      }
    };
    exports2.PagesCollector = PagesCollector;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/index.js
var require_entity = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_content2(), exports2);
    __exportStar(require_pagemap(), exports2);
    __exportStar(require_pagetrees(), exports2);
    __exportStar(require_pagecollector(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/content.js
var require_content2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/content.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Content = void 0;
    var _1 = require_entity();
    var doctree_1 = require_doctree();
    var fileinfo_1 = require_fileinfo2();
    var log_1 = require_log();
    var paths_1 = require_paths();
    var log = (0, log_1.getDomainLogger)("content", { component: "content" });
    var Content = class {
      constructor(fs5, converter, pageMap, translator) {
        this.fs = fs5;
        this.converter = converter;
        this.pageMap = pageMap;
        this.translator = translator;
      }
      setTemplateSvc(templateSvc) {
        this.pageMap.pageBuilder.templateSvc = templateSvc;
      }
      async renderString(ctx, ...args) {
        if (args.length < 1 || args.length > 2) {
          throw new Error("RenderString want 1 or 2 arguments");
        }
        let sidx = 1;
        if (args.length === 1) {
          sidx = 0;
        } else {
          const firstArg = args[0];
          if (typeof firstArg !== "object" || firstArg === null) {
            throw new Error("first argument must be a map");
          }
          throw new Error("RenderString not implemented yet");
        }
        const contentToRender = args[sidx];
        const contentStr = String(contentToRender);
        const fmi = this.fs.newFileMetaInfoWithContent(contentStr);
        const file = (0, fileinfo_1.newFileInfo)(fmi);
        return contentStr;
      }
      async collectPages() {
        try {
          await this.process();
          await this.assemble();
        } catch (error) {
          throw new Error(`process/assemble: ${error}`);
        }
      }
      async process() {
        try {
          const c = new _1.PagesCollector(this.pageMap, this.fs);
          await c.collect();
        } catch (error) {
          throw error;
        }
      }
      async assemble() {
        try {
          await this.pageMap.assemble();
        } catch (error) {
          throw error;
        }
      }
      async getPageSources(page) {
        let keyPage = page.paths().base();
        if (keyPage === "/") {
          keyPage = "";
        }
        const key = keyPage + "/get-sources-for-page";
        return await this.pageMap.getResourcesForPage(page);
      }
      async globalPages(langIndex) {
        return await this.pageMap.getPagesInSection(langIndex, new _1.PageMapQueryPagesInSectionImpl("", "global", true, true, 0, _1.pagePredicates.shouldListGlobal));
      }
      async globalRegularPages() {
        return await this.pageMap.getPagesInSection(0, new _1.PageMapQueryPagesInSectionImpl("", "global", true, true, 0, (p) => _1.pagePredicates.shouldListGlobal(p) && _1.pagePredicates.kindPage(p)));
      }
      async walkPages(langIndex, walker) {
        const tree = this.pageMap.treePages.shape(0, langIndex);
        const w = new doctree_1.NodeShiftTreeWalker({
          tree,
          handle: async (key, n2, match) => {
            const [ps, found] = n2.getPage();
            if (!found) {
              return [false, null];
            }
            try {
              await walker(ps);
            } catch (error) {
              return [false, error instanceof Error ? error : new Error(String(error))];
            }
            return [false, null];
          }
        });
        try {
          await w.walk();
        } catch (error) {
          log.error(`WalkPages failed for langIndex ${langIndex}:`, error);
          throw error;
        }
      }
      async walkTaxonomies(langIndex, walker) {
        try {
          const tree = this.pageMap.treePages.shape(0, langIndex);
          const tc = this.pageMap.pageBuilder.taxonomy;
          for (const viewName of tc.views) {
            const key = tc.pluralTreeKey(viewName.plural());
            const w = new doctree_1.NodeShiftTreeWalker({
              tree,
              prefix: (0, _1.addTrailingSlash)(key),
              lockType: doctree_1.LockType.LockTypeRead,
              handle: async (s, n2, match) => {
                const [p, found] = n2.getPage();
                if (!found) {
                  return [false, null];
                }
                if (p.kind() === "term") {
                  const t = p;
                  if (!t.term) {
                    return [true, new Error("term is empty")];
                  }
                  const k = t.term.toLowerCase();
                  try {
                    const treeTaxonomy = this.pageMap.treeTaxonomyEntries.shape(0, langIndex);
                    await treeTaxonomy.walkPrefix(doctree_1.LockType.LockTypeRead, (0, _1.addTrailingSlash)(s), (ss, wn) => {
                      const [sp, found2] = wn.getPage();
                      if (!found2) {
                        return [false, null];
                      }
                      walker(viewName.plural(), k, {
                        weight: () => wn.term.Weight(),
                        ordinal: () => wn.term.Ordinal(),
                        page: () => sp,
                        owner: () => t
                      }).catch((err) => {
                        log.error("Error in taxonomy walker:", err);
                      });
                      return [false, null];
                    });
                    return [false, null];
                  } catch (err) {
                    return [true, err];
                  }
                }
                return [false, null];
              }
            });
            await w.walk();
          }
        } catch (error) {
          throw error;
        }
      }
      getPageFromPath(langIndex, path6) {
        try {
          const pathProcessor = paths_1.PathDomain.createProcessor();
          const ps = pathProcessor.parse(paths_1.PATH_CONSTANTS.COMPONENT_FOLDER_CONTENT, path6);
          const tree = this.pageMap.treePages.shape(0, langIndex);
          let node = tree.get(ps.base());
          if (node) {
            const [page, found] = node.getPage();
            if (found) {
              return page;
            }
          }
          return null;
        } catch (error) {
          log.error(`\u274C Content.getPageFromPath error for path "${path6}":`, error);
          return null;
        }
      }
      getPageFromFile(langIndex, file) {
        try {
          const tree = this.pageMap.treePages.shape(0, langIndex);
          let node = tree.get(file.paths().base());
          if (node) {
            const [page, found] = node.getPage();
            if (found) {
              return page;
            }
          }
          return null;
        } catch (error) {
          log.error(`\u274C Content.getPageFromPath error for path "${file.path()}":`, error);
          return null;
        }
      }
      async handleChangeFiles(fileMetaInfos) {
        const affectedPageKeys = [];
        for (const [filePath, fileMetaInfo] of fileMetaInfos) {
          try {
            await this.addOrUpdateFile(fileMetaInfo, affectedPageKeys);
          } catch (error) {
            log.error(`Failed to process file change for ${filePath}:`, error);
          }
        }
        return affectedPageKeys;
      }
      async addOrUpdateFile(fileMetaInfo, affectedPageKeys) {
        if (fileMetaInfo.isDir()) {
          return;
        }
        try {
          const file = (0, fileinfo_1.newFileInfo)(fileMetaInfo);
          const pageKey = file.paths().base();
          if (pageKey) {
            affectedPageKeys.push(pageKey);
          }
          await this.pageMap.addFi(file);
          const page = this.getPageFromFile(0, file);
          if (page && page.pageIdentity) {
            page.pageIdentity().markStale();
          }
        } catch (error) {
          log.error(`Failed to add/update file in PageMap: ${fileMetaInfo.fileName()}`, error);
          throw error;
        }
      }
      translate(lang, translationID) {
        if (!this.translator) {
          log.warn("Translator not initialized, returning fallback translation");
          return `[i18n] ${translationID}`;
        }
        return this.translator.translate(lang, translationID);
      }
      getAvailableLanguages() {
        if (!this.translator) {
          return [];
        }
        return this.translator.getAvailableLanguages();
      }
      hasLanguageSupport(lang) {
        if (!this.translator) {
          return false;
        }
        return this.translator.hasLanguage(lang);
      }
    };
    exports2.Content = Content;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/converter.js
var require_converter = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/converter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MDConverter = void 0;
    var MDConverter = class {
      constructor(markdown) {
        this.md = markdown;
      }
      async convert(dctx, rctx) {
        return this.md.render(rctx, dctx);
      }
      async parseContent(source) {
        return this.md.parseContent(source);
      }
      async parseAndRenderContent(source, options) {
        return this.md.parseAndRenderContent(source, options);
      }
      async prepareRender(source) {
        return this.md.prepareRender(source);
      }
    };
    exports2.MDConverter = MDConverter;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagecontent.js
var require_pagecontent = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagecontent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Content = void 0;
    exports2.newContent = newContent;
    var Content = class {
      constructor(source) {
        this.renderedContent = "";
        this.summary = "";
        this.wordCount = 0;
        this.readingTime = 0;
        this.lazyRendered = true;
        this.rawSource = source;
      }
      updateWithContentResult(result) {
        if (result.frontMatter) {
          this.frontMatter = result.frontMatter;
        }
        this.renderedContent = result.renderedContent || "";
        this.summary = result.summary;
        this.wordCount = result.wordCount || 0;
        this.readingTime = result.readingTime || 0;
      }
      getRawSource() {
        return this.rawSource;
      }
      async RenderedContent() {
        await this.render();
        return this.renderedContent;
      }
      async Summary() {
        await this.render();
        return this.summary;
      }
      async WordCount() {
        await this.render();
        return this.wordCount;
      }
      async ReadingTime() {
        await this.render();
        return this.readingTime;
      }
      async render() {
        if (this.lazyRendered && this.lazyRender) {
          await this.lazyRender();
          this.lazyRendered = false;
        }
        return Promise.resolve();
      }
      isEmpty() {
        return !this.rawSource || this.rawSource.length === 0;
      }
    };
    exports2.Content = Content;
    function newContent(source) {
      return new Content(source);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/section.js
var require_section = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/section.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Section = exports2.PAGE_HOME_BASE = void 0;
    var pagetrees_1 = require_pagetrees();
    var fileinfo_1 = require_fileinfo2();
    var pagesource_1 = require_pagesource();
    var kind_1 = require_kind();
    var doctree_1 = require_doctree();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "section" });
    exports2.PAGE_HOME_BASE = "/";
    var Section = class {
      constructor(fsSvc) {
        this.home = null;
        this.seen = {};
        this.fsSvc = fsSvc;
      }
      isHome(key) {
        return key === "";
      }
      isSectionExist(section) {
        if (section === "" || this.seen[section]) {
          return true;
        }
        this.seen[section] = true;
        return false;
      }
      async assemble(pages, pb, langIdx) {
        this.seen = {};
        const lockType = doctree_1.LockType.LockTypeWrite;
        const walker = new doctree_1.NodeShiftTreeWalker({
          tree: pages,
          lockType,
          handle: async (k, n2, match) => {
            if (!n2) {
              throw new Error("n is null");
            }
            const [ps, found] = n2.getPage();
            if (!found) {
              return [false, null];
            }
            if (this.isHome(k)) {
              this.home = ps;
              return [false, null];
            }
            const kind = ps.kind();
            if (kind !== (0, kind_1.getKindMain)("page") && kind !== (0, kind_1.getKindMain)("section")) {
              return [false, null];
            }
            const p = ps.paths();
            const sections = p.sections();
            for (const section of sections) {
              if (this.isSectionExist(section)) {
                continue;
              }
              try {
                const fmi = this.fsSvc.newFileMetaInfo("/" + section + "/_index.md");
                const f = (0, fileinfo_1.newFileInfo)(fmi);
                const sectionSource = (0, pagesource_1.newPageSource)(f);
                const sectionBase = sectionSource.paths().base();
                const nn = walker.tree.get(sectionBase);
                if (!nn) {
                  const sectionPage = await pb.withSource(sectionSource).withLangIdx(langIdx).kindBuild();
                  walker.tree.insertIntoValuesDimension(sectionBase, (0, pagetrees_1.newPageTreesNode)(sectionPage));
                }
              } catch (error) {
                return [false, error];
              }
            }
            return [false, null];
          }
        });
        try {
          await walker.walk();
        } catch (error) {
          log.error("Error walking pages:", error);
          throw error;
        }
        if (!this.home) {
          await this.createHome(pb);
          if (this.home) {
            const homePage = this.home;
            pages.insertWithLock(homePage.paths().base(), (0, pagetrees_1.newPageTreesNode)(homePage));
          }
        }
      }
      async createHome(pb) {
        const fmi = this.fsSvc.newFileMetaInfo("/_index.md");
        const f = (0, fileinfo_1.newFileInfo)(fmi);
        const homeSource = (0, pagesource_1.newPageSource)(f);
        const homePage = await pb.withSource(homeSource).kindBuild();
        this.home = homePage;
      }
    };
    exports2.Section = Section;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/standalone.js
var require_standalone = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/standalone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Standalone = exports2.STANDALONE_PAGE_SITEMAP_BASE = exports2.STANDALONE_PAGE_404_BASE = void 0;
    var pagetrees_1 = require_pagetrees();
    var fileinfo_1 = require_fileinfo2();
    var pagesource_1 = require_pagesource();
    exports2.STANDALONE_PAGE_404_BASE = "404";
    exports2.STANDALONE_PAGE_SITEMAP_BASE = "_sitemap";
    var Standalone = class {
      constructor(fsSvc) {
        this.fsSvc = fsSvc;
      }
      async assemble(pages, pb) {
        const key404 = "/" + exports2.STANDALONE_PAGE_404_BASE;
        const page404 = await this.addStandalone(key404, pb);
        pages.insertIntoValuesDimension(key404, (0, pagetrees_1.newPageTreesNode)(page404));
        const keySitemap = "/" + exports2.STANDALONE_PAGE_SITEMAP_BASE;
        const pageSitemap = await this.addStandalone(keySitemap, pb);
        pages.insertIntoValuesDimension(keySitemap, (0, pagetrees_1.newPageTreesNode)(pageSitemap));
      }
      async addStandalone(key, pb) {
        const fmi = this.fsSvc.newFileMetaInfo(key + ".md");
        const f = (0, fileinfo_1.newFileInfo)(fmi);
        const ps = (0, pagesource_1.newPageSource)(f);
        return await pb.withSource(ps).kindBuild();
      }
    };
    exports2.Standalone = Standalone;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pageoutput.js
var require_pageoutput = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pageoutput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Output = void 0;
    var content_1 = require_content3();
    var Output = class {
      constructor(source, pageKind) {
        this.target = null;
        this.source = source;
        this.pageKind = pageKind;
        this.baseName = "";
        this.setBasename();
        this.buildTarget();
      }
      setBasename() {
        switch (this.pageKind) {
          case (0, content_1.getKindMain)("404"):
            this.baseName = "404";
            break;
          case (0, content_1.getKindMain)("sitemap"):
            this.baseName = "sitemap";
            break;
          default:
            this.baseName = this.source.paths().baseNameNoIdentifier() || "index";
            break;
        }
      }
      buildTarget() {
        let filePath = "";
        let subResourceBaseTarget = "";
        const htmlFormatBaseName = "index";
        switch (this.pageKind) {
          case (0, content_1.getKindMain)("home"):
            filePath = `${htmlFormatBaseName}.html`;
            subResourceBaseTarget = "";
            break;
          case (0, content_1.getKindMain)("page"):
            const dir = this.source.paths().containerDir();
            if (!dir || dir === "/") {
              filePath = `/${this.baseName}.html`;
            } else {
              filePath = `${dir}/${this.baseName}.html`;
            }
            subResourceBaseTarget = dir || "";
            break;
          case (0, content_1.getKindMain)("section"):
          case (0, content_1.getKindMain)("taxonomy"):
          case (0, content_1.getKindMain)("term"):
            const sectionDir = this.source.paths().dir();
            filePath = sectionDir ? `${sectionDir}/${htmlFormatBaseName}.html` : `${htmlFormatBaseName}.html`;
            subResourceBaseTarget = sectionDir || "";
            break;
          case (0, content_1.getKindMain)("404"):
            const notFoundDir = this.source.paths().dir();
            filePath = notFoundDir ? `${notFoundDir}/${this.baseName}.html` : `${this.baseName}.html`;
            subResourceBaseTarget = notFoundDir || "";
            break;
          case (0, content_1.getKindMain)("sitemap"):
            const sitemapDir = this.source.paths().dir();
            filePath = sitemapDir ? `${sitemapDir}/${this.baseName}.xml` : `${this.baseName}.xml`;
            subResourceBaseTarget = sitemapDir || "";
            break;
          default:
            filePath = `${htmlFormatBaseName}.html`;
            subResourceBaseTarget = "";
            break;
        }
        this.target = {
          prefix: this.source.identity.pageLanguage(),
          filePath,
          subResourceBaseTarget
        };
      }
      createBasicResult() {
        return {
          bytes: () => new Uint8Array(),
          headers: () => [],
          tableOfContents: () => ({
            toHTML: (startLevel, stopLevel, ordered) => ""
          })
        };
      }
      output(page) {
        return {
          targetFileBase: () => {
            if (!this.target) {
              return "index.html";
            }
            const filePath = this.target.filePath;
            const lastSlashIndex = filePath.lastIndexOf("/");
            return lastSlashIndex >= 0 ? filePath.substring(lastSlashIndex + 1) : filePath;
          },
          targetFilePath: () => this.target.filePath,
          targetSubResourceDir: () => this.target.subResourceBaseTarget,
          targetPrefix: () => this.target.prefix,
          content: async () => {
            return page.content ? page.content.RenderedContent() : "";
          },
          summary: async () => {
            return page.content ? page.content.Summary() : "";
          },
          tableOfContents: () => {
            return page.content ? page.content.toc ? page.content.toc.toHTML(1, 6, false) : "" : "";
          },
          result: () => {
            return this.createBasicResult();
          },
          readingTime: async () => {
            return page.content ? page.content.ReadingTime() : 0;
          },
          wordCount: async () => {
            return page.content ? page.content.WordCount() : 0;
          }
        };
      }
    };
    exports2.Output = Output;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/paginator.js
var require_paginator = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/paginator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PaginatorManagerImpl = exports2.PaginatorImpl = void 0;
    var PaginatorImpl = class {
      constructor(paginatedElements, total, size, base) {
        this.paginatedElements = paginatedElements;
        this.base = base;
        this.total = total;
        this.size = size;
        this._pagers = [];
        if (paginatedElements.length > 0) {
          for (let i = 0; i < paginatedElements.length; i++) {
            this._pagers.push(new PagerImpl(i + 1, this));
          }
        } else {
          this._pagers.push(new PagerImpl(1, this));
        }
      }
      totalPages() {
        return this.paginatedElements.length;
      }
      pagers() {
        return [...this._pagers];
      }
      getElement(pageNumber) {
        if (this.paginatedElements.length === 0) {
          return [];
        }
        return this.paginatedElements[pageNumber - 1] || [];
      }
      getBase() {
        return this.base;
      }
      getPagers() {
        return this._pagers;
      }
    };
    exports2.PaginatorImpl = PaginatorImpl;
    var PagerImpl = class {
      constructor(number, paginator) {
        this.number = number;
        this.paginator = paginator;
      }
      pageNumber() {
        return this.number;
      }
      totalPages() {
        return this.paginator.totalPages();
      }
      url() {
        const pageNumber = this.pageNumber();
        if (pageNumber > 1) {
          const rel = `/page/${pageNumber}/`;
          return this.pathJoin(this.paginator.getBase(), rel);
        }
        return this.paginator.getBase();
      }
      pages() {
        const elements = this.element();
        return elements;
      }
      pagers() {
        return this.paginator.pagers();
      }
      first() {
        const pagers = this.paginator.getPagers();
        return pagers[0];
      }
      last() {
        const pagers = this.paginator.getPagers();
        return pagers[pagers.length - 1];
      }
      hasPrev() {
        return this.pageNumber() > 1;
      }
      prev() {
        if (!this.hasPrev()) {
          return null;
        }
        const pagers = this.paginator.getPagers();
        return pagers[this.pageNumber() - 2];
      }
      hasNext() {
        return this.pageNumber() < this.paginator.totalPages();
      }
      next() {
        if (!this.hasNext()) {
          return null;
        }
        const pagers = this.paginator.getPagers();
        return pagers[this.pageNumber()];
      }
      element() {
        return this.paginator.getElement(this.pageNumber());
      }
      pathJoin(base, rel) {
        if (base.endsWith("/")) {
          base = base.slice(0, -1);
        }
        if (!rel.startsWith("/")) {
          rel = "/" + rel;
        }
        return base + rel;
      }
    };
    var PaginatorManagerImpl = class {
      constructor(svc, page) {
        this.currentPager = null;
        this.initialized = false;
        this.svc = svc;
        this.page = page;
      }
      async current() {
        if (!this.initialized) {
          await this.initializePaginator();
        }
        if (!this.currentPager) {
          const emptyPaginator = new PaginatorImpl([], 0, 10, this.page.paths().base());
          return emptyPaginator.pagers()[0];
        }
        return this.currentPager;
      }
      setCurrent(current) {
        this.currentPager = current;
      }
      async paginate(groups) {
        if (!this.initialized) {
          const pagerSize = this.svc.pageSize();
          const paginator = this.newPaginatorFromPageGroups(groups, pagerSize, this.page.paths().base());
          this.currentPager = paginator.pagers()[0];
          this.initialized = true;
        }
        return this.currentPager || this.current();
      }
      async paginator() {
        if (!this.initialized) {
          await this.initializePaginator();
        }
        return this.currentPager || this.current();
      }
      async initializePaginator() {
        try {
          const pagerSize = this.svc.pageSize();
          let pages = [];
          const kind = this.page.kind();
          switch (kind) {
            case "home":
              pages = await this.svc.globalRegularPages();
              break;
            case "term":
            case "taxonomy":
              const pageCollection = await this.page.pages();
              pages = pageCollection?.length ? Array.from({ length: pageCollection.length }, (_, i) => pageCollection[i]) : [];
              break;
            default:
              const regularPages = await this.page.regularPages();
              if (regularPages && regularPages.length > 0) {
                pages = Array.from({ length: regularPages.length }, (_, i) => regularPages[i]);
              } else {
                pages = await this.svc.globalRegularPages();
              }
              break;
          }
          const basePath = this.page.paths().base();
          const paginator = this.newPaginatorFromPages(pages, pagerSize, basePath);
          this.currentPager = paginator.pagers()[0];
          this.initialized = true;
        } catch (error) {
          const basePath = this.page.paths().base();
          const emptyPaginator = new PaginatorImpl([], 0, 10, basePath);
          this.currentPager = emptyPaginator.pagers()[0];
          this.initialized = true;
        }
      }
      newPaginatorFromPages(pages, size, base) {
        if (size <= 0) {
          throw new Error("paginator size must be positive");
        }
        const split = this.splitPages(pages, size);
        return new PaginatorImpl(split, pages.length, size, base);
      }
      newPaginatorFromPageGroups(pageGroups, size, base) {
        if (size <= 0) {
          throw new Error("paginator size must be positive");
        }
        const pages = [];
        if (pageGroups && pageGroups.length > 0) {
          for (let i = 0; i < pageGroups.length; i++) {
            const group = pageGroups[i];
            if (group && group.pages) {
              const groupPages = group.pages();
              if (groupPages) {
                for (let j = 0; j < groupPages.length; j++) {
                  pages.push(groupPages[j]);
                }
              }
            }
          }
        }
        const split = this.splitPages(pages, size);
        return new PaginatorImpl(split, pages.length, size, base);
      }
      splitPages(pages, size) {
        const split = [];
        for (let low = 0; low < pages.length; low += size) {
          const high = Math.min(low + size, pages.length);
          split.push(pages.slice(low, high));
        }
        return split;
      }
    };
    exports2.PaginatorManagerImpl = PaginatorManagerImpl;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/maps/scratch.js
var require_scratch = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/maps/scratch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scratch = void 0;
    var Scratch = class {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      add(key, newAddend) {
        const existingAddend = this.values.get(key);
        let newVal;
        if (existingAddend !== void 0) {
          if (Array.isArray(existingAddend)) {
            newVal = [...existingAddend, newAddend];
          } else if (typeof existingAddend === "number" && typeof newAddend === "number") {
            newVal = existingAddend + newAddend;
          } else if (typeof existingAddend === "string" && typeof newAddend === "string") {
            newVal = existingAddend + newAddend;
          } else {
            newVal = newAddend;
          }
        } else {
          newVal = newAddend;
        }
        this.values.set(key, newVal);
        return "";
      }
      set(key, value2) {
        this.values.set(key, value2);
        return "";
      }
      Set(key, value2) {
        return this.set(key, value2);
      }
      delete(key) {
        this.values.delete(key);
        return "";
      }
      get(key) {
        return this.values.get(key);
      }
      Get(key) {
        return this.get(key);
      }
      getValues() {
        return this.values;
      }
      setInMap(key, mapKey, value2) {
        let mapValue = this.values.get(key);
        if (!mapValue || typeof mapValue !== "object") {
          mapValue = {};
          this.values.set(key, mapValue);
        }
        mapValue[mapKey] = value2;
        return "";
      }
    };
    exports2.Scratch = Scratch;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/paths/index.js
var require_paths2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/paths/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sanitize = sanitize;
    exports2.addContextRoot = addContextRoot;
    exports2.makePermalink = makePermalink;
    exports2.dir = dir;
    function sanitize(input) {
      return input.replace(/[\s\t\n\r]+/g, "-").replace(/[^\w\-_]/g, "").replace(/-+/g, "-").replace(/^-|-$/g, "");
    }
    function addContextRoot(root, path6) {
      if (!root || path6.startsWith(root)) {
        return path6;
      }
      return joinPaths(root, path6);
    }
    function makePermalink(baseURL, path6) {
      const base = baseURL.replace(/\/$/, "");
      const cleanPath = path6.replace(/^\//, "");
      const fullURL = `${base}/${cleanPath}`;
      try {
        return new URL(fullURL);
      } catch {
        return new URL("http://" + fullURL);
      }
    }
    function joinPaths(...paths) {
      return paths.filter(Boolean).join("/").replace(/\/+/g, "/").replace(/\/$/, "");
    }
    function dir(s) {
      const lastSlashIndex = s.lastIndexOf("/");
      if (lastSlashIndex === -1) {
        return "";
      }
      let dir2 = s.slice(0, lastSlashIndex + 1);
      if (dir2.length > 1 && dir2.endsWith("/")) {
        dir2 = dir2.slice(0, -1);
      }
      return dir2;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/page.js
var require_page = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TermPageImpl = exports2.TaxonomyPageImpl = exports2.PageImpl = void 0;
    var content_1 = require_content3();
    var pageoutput_1 = require_pageoutput();
    var paginator_1 = require_paginator();
    var scratch_1 = require_scratch();
    var pagemap_1 = require_pagemap();
    var paths_1 = require_paths2();
    var doctree_1 = require_doctree();
    var sort_1 = require_sort();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "page" });
    var PageImpl = class {
      constructor(source, content, meta, layout, title = "", kind = "page", pageMap = null) {
        this.output_ = null;
        this.store_ = null;
        this.source = source;
        this.content = content;
        this.meta = meta;
        this.layout = layout;
        this.title_ = title;
        this.kind_ = kind;
        this.pageMap = pageMap;
        const pagerSvc = {
          pageSize: () => 10,
          globalRegularPages: async () => []
        };
        this.pagerManager = new paginator_1.PaginatorManagerImpl(pagerSvc, this);
      }
      rawContent() {
        if (!this.content)
          return "";
        const rawSource = this.content.getRawSource();
        return new TextDecoder().decode(rawSource);
      }
      pageIdentity() {
        return this.source.identity;
      }
      pageFile() {
        return this.source.file;
      }
      staleVersions() {
        return [];
      }
      section() {
        return this.source.file.section();
      }
      paths() {
        return this.source.file.paths();
      }
      path() {
        return this.source.file.paths().path();
      }
      posOffset(offset) {
        return this.source.posOffset(offset);
      }
      description() {
        return this.meta.description();
      }
      get Description() {
        return "";
      }
      params() {
        return this.meta.params();
      }
      get Params() {
        return this.params();
      }
      store() {
        if (!this.store_) {
          this.store_ = new scratch_1.Scratch();
        }
        return this.store_;
      }
      get Store() {
        return this.store();
      }
      scratch() {
        return this.store();
      }
      get Scratch() {
        return this.scratch();
      }
      pageWeight() {
        return this.meta.pageWeight();
      }
      pageDate() {
        return this.meta.pageDate();
      }
      publishDate() {
        return this.meta.publishDate();
      }
      async relatedKeywords(cfg) {
        return this.meta.relatedKeywords(cfg);
      }
      shouldList(global2) {
        return this.meta.shouldList(global2);
      }
      shouldListAny() {
        return this.meta.shouldListAny();
      }
      noLink() {
        return this.meta.noLink();
      }
      async current() {
        return await this.pagerManager.current();
      }
      setCurrent(current) {
        this.pagerManager.setCurrent(current);
      }
      async paginator() {
        return await this.pagerManager.paginator();
      }
      async paginate(groups) {
        return this.pagerManager.paginate(groups);
      }
      file() {
        return this.source.file;
      }
      get Type() {
        return this.file().type();
      }
      name() {
        return this.source.file.baseFileName();
      }
      title() {
        return this.title_;
      }
      get Title() {
        return this.title();
      }
      kind() {
        return this.kind_;
      }
      isHome() {
        return this.kind() === (0, content_1.getKindMain)("home");
      }
      isPage() {
        return this.kind() === (0, content_1.getKindMain)("page");
      }
      isSection() {
        return this.kind() === (0, content_1.getKindMain)("section");
      }
      isAncestor(other) {
        if (other.path() === this.path()) {
          return false;
        }
        return other.paths().base().startsWith(this.paths().base());
      }
      eq(other) {
        return this.pageIdentity().identifierBase() === other.pageIdentity().identifierBase();
      }
      layouts() {
        switch (this.kind_) {
          case (0, content_1.getKindMain)("home"):
            if (this.source.file.isBranchBundle()) {
              return this.layout.homeList();
            }
            return this.layout.home();
          case (0, content_1.getKindMain)("page"):
            return this.layout.page(this.source.file.section(), this.source.file.baseFileName());
          case (0, content_1.getKindMain)("section"):
            return this.layout.section(this.source.file.section());
          case (0, content_1.getKindMain)("taxonomy"):
            return this.layout.taxonomy();
          case (0, content_1.getKindMain)("term"):
            return this.layout.term();
          case (0, content_1.getKindMain)("404"):
            return this.layout.standalone404();
          case (0, content_1.getKindMain)("sitemap"):
            return this.layout.standaloneSitemap();
          default:
            return [];
        }
      }
      output() {
        if (!this.output_) {
          this.output_ = new pageoutput_1.Output(this.source, this.kind());
        }
        return this.output_.output(this);
      }
      get TargetPath() {
        return this.output().targetFilePath();
      }
      get Summary() {
        return this.output().summary();
      }
      truncated() {
        return false;
      }
      parent() {
        if (this.isHome()) {
          return null;
        }
        let dir = this.paths().containerDir();
        if (dir === "") {
          return null;
        }
        while (true) {
          const result = this.pageMap?.treePages.longestPrefix(dir, true);
          if (!result) {
            return null;
          }
          const [_, node] = result;
          if (!node) {
            return null;
          }
          const [page, found] = node.getPage();
          if (!page) {
            return null;
          }
          if (this.isBundled()) {
            if (found) {
              return page;
            }
            return null;
          }
          if (!page.isPage()) {
            if (found) {
              return page;
            }
            return null;
          }
          dir = (0, paths_1.dir)(dir);
        }
      }
      async Pages() {
        return await this.pages();
      }
      async pages() {
        const langIndex = this.pageIdentity().pageLanguageIndex();
        switch (this.kind()) {
          case content_1.PageKind.PAGE:
          case content_1.PageKind.SECTION:
          case content_1.PageKind.HOME:
            return await this.pageMap.getPagesInSection(langIndex, new pagemap_1.PageMapQueryPagesInSectionImpl(this.paths().base(), "page-section", false, false, langIndex, (p) => pagemap_1.pagePredicates.shouldListLocal(p) && (pagemap_1.pagePredicates.kindPage(p) || pagemap_1.pagePredicates.kindSection(p))));
          case content_1.PageKind.TERM:
            return await this.pageMap.getPagesWithTerm(langIndex, new pagemap_1.PageMapQueryPagesBelowPathImpl(this.paths().base(), "term"));
          case content_1.PageKind.TAXONOMY:
            return await this.pageMap.getPagesInSection(langIndex, new pagemap_1.PageMapQueryPagesInSectionImpl(this.paths().base(), "term", true, false, langIndex, (p) => pagemap_1.pagePredicates.shouldListLocal(p) && pagemap_1.pagePredicates.kindTerm(p)));
          default:
            return Promise.resolve([]);
        }
      }
      prevInSection() {
        return null;
      }
      nextInSection() {
        return null;
      }
      sections(langIndex) {
        return [];
      }
      async regularPages() {
        const langIndex = this.pageIdentity().pageLanguageIndex();
        switch (this.kind()) {
          case content_1.PageKind.PAGE:
          case content_1.PageKind.SECTION:
          case content_1.PageKind.HOME:
          case content_1.PageKind.TAXONOMY:
            if (!this.pageMap) {
              return [];
            }
            return await this.pageMap.getPagesInSection(langIndex, new pagemap_1.PageMapQueryPagesInSectionImpl(this.paths().base(), "", false, false, langIndex, (p) => pagemap_1.pagePredicates.shouldListLocal(p) && pagemap_1.pagePredicates.kindPage(p)));
          case content_1.PageKind.TERM:
            if (!this.pageMap) {
              return [];
            }
            return await this.pageMap.getPagesWithTerm(langIndex, new pagemap_1.PageMapQueryPagesBelowPathImpl(this.paths().base(), "", (p) => pagemap_1.pagePredicates.shouldListLocal(p) && pagemap_1.pagePredicates.kindPage(p)));
          default:
            return [];
        }
      }
      regularPagesRecursive() {
        return [];
      }
      async terms(langIndex, taxonomy) {
        if (!this.pageMap) {
          return null;
        }
        return this.pageMap?.getTermsForPageInTaxonomy(langIndex, this.paths().base(), taxonomy);
      }
      async isTranslated() {
        const ts = await this.translations();
        return ts.length > 0;
      }
      async translations() {
        const key = this.path() + "/" + this.pageIdentity().pageLanguage() + "/translations";
        if (!this.pageMap) {
          return [];
        }
        try {
          return await this.pageMap.getOrCreatePagesFromCacheSync(null, key, async (cacheKey) => {
            const allTranslations = await this.allTranslations();
            const pas = [];
            for (let i = 0; i < allTranslations.length; i++) {
              const pp = allTranslations.at(i);
              if (pp && !pp.eq(this)) {
                pas.push(pp);
              }
            }
            return pas;
          });
        } catch (error) {
          throw error;
        }
      }
      async allTranslations() {
        const key = this.path() + "/translations-all";
        if (!this.pageMap) {
          return [];
        }
        try {
          return await this.pageMap.getOrCreatePagesFromCacheSync(null, key, async (cacheKey) => {
            const pas = [];
            this.pageMap.treePages.forEachInDimension(this.paths().base(), doctree_1.dimensionFlag.index(doctree_1.DimensionFlag.DimensionLanguage), (n2) => {
              if (n2 != null) {
                const nodePages = n2.getPages();
                pas.push(...nodePages);
              }
              return false;
            });
            (0, sort_1.sortByLanguage)(pas);
            return pas;
          });
        } catch (error) {
          throw error;
        }
      }
      isBundled() {
        return this.source.file.isBundle();
      }
    };
    exports2.PageImpl = PageImpl;
    var TaxonomyPageImpl = class extends PageImpl {
      constructor(source, content, meta, layout, singular, title = "", kind = "taxonomy", pageMap = null) {
        super(source, content, meta, layout, title, kind, pageMap);
        this.singular = singular;
      }
      params() {
        const params = super.params();
        params["Singular"] = this.singular;
        return params;
      }
    };
    exports2.TaxonomyPageImpl = TaxonomyPageImpl;
    var TermPageImpl = class extends TaxonomyPageImpl {
      constructor(source, content, meta, layout, singular, term, title = "", kind = "term", pageMap = null) {
        super(source, content, meta, layout, singular, title, kind, pageMap);
        this.term = term;
      }
      params() {
        const params = super.params();
        params["Term"] = this.term;
        return params;
      }
    };
    exports2.TermPageImpl = TermPageImpl;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagemeta.js
var require_pagemeta = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagemeta.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Meta = void 0;
    var Meta = class {
      constructor(list = "always", parameters = {}, weight = 0, date = new Date()) {
        this.list = list;
        this.parameters = parameters;
        this.weight = weight;
        this.date = date;
      }
      description() {
        return "";
      }
      params() {
        return this.parameters;
      }
      pageWeight() {
        return this.weight;
      }
      pageDate() {
        return this.date;
      }
      publishDate() {
        return this.pageDate();
      }
      async relatedKeywords(cfg) {
        return [];
      }
      shouldList(global2) {
        switch (this.list) {
          case "always":
            return true;
          case "never":
            return false;
          case "local":
            return !global2;
          default:
            return true;
        }
      }
      shouldListAny() {
        return this.shouldList(true) || this.shouldList(false);
      }
      noLink() {
        return false;
      }
    };
    exports2.Meta = Meta;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagelayout.js
var require_pagelayout = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagelayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Layout = void 0;
    var Layout = class {
      home() {
        return [
          "index.html",
          "_default/index.html",
          "_default/single.html"
        ];
      }
      homeList() {
        return [
          "index.html",
          "_default/index.html",
          "_default/list.html"
        ];
      }
      section(section) {
        return [
          `${section}/section.html`,
          `${section}/list.html`,
          "_default/section.html",
          "_default/list.html",
          "_default/index.html"
        ];
      }
      page(section, base) {
        const basePath = section ? `${section}/${base}` : base;
        const singlePath = section ? `${section}/single.html` : "single.html";
        const layouts = [];
        if (basePath !== "index") {
          layouts.push(`${basePath}.html`);
        }
        layouts.push(singlePath);
        if (base !== "index") {
          layouts.push(`_default/${base}.html`);
        }
        layouts.push("_default/single.html");
        layouts.push("index.html");
        layouts.push("_default/index.html");
        return layouts;
      }
      taxonomy() {
        return [
          "taxonomy/taxonomy.html",
          "taxonomy/list.html",
          "_default/list.html",
          "_default/taxonomy.html"
        ];
      }
      term() {
        return [
          "taxonomy/tag.html",
          "term/term.html",
          "taxonomy/list.html",
          "_default/list.html",
          "_default/term.html"
        ];
      }
      standalone404() {
        return ["404.html"];
      }
      standaloneSitemap() {
        return [
          "sitemap.xml",
          "_default/sitemap.xml"
        ];
      }
    };
    exports2.Layout = Layout;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shortcode.js
var require_shortcode2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/shortcode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShortcodeWithPage = void 0;
    var scratch_1 = require_scratch();
    var ShortcodeWithPage = class {
      constructor(params, inner, page, parent, name, isNamedParams, ordinal, indentation = "", posOffset = 0) {
        this._innerDeindent = null;
        this._pos = null;
        this._scratch = null;
        this._params = params;
        this._inner = inner;
        this._page = page;
        this._parent = parent;
        this._name = name;
        this._isNamedParams = isNamedParams;
        this._ordinal = ordinal;
        this._indentation = indentation;
        this._posOffset = posOffset;
      }
      get params() {
        return this._params;
      }
      get Params() {
        return this._params;
      }
      get IsNamedParams() {
        return this._isNamedParams;
      }
      get inner() {
        return this._inner;
      }
      get Inner() {
        return this._inner;
      }
      get page() {
        return this._page;
      }
      get Page() {
        return this._page;
      }
      get parent() {
        return this._parent;
      }
      get Parent() {
        return this._parent;
      }
      get name() {
        return this._name;
      }
      get isNamedParams() {
        return this._isNamedParams;
      }
      get ordinal() {
        return this._ordinal;
      }
      get Ordinal() {
        return this._ordinal;
      }
      innerDeindent() {
        if (this._indentation === "") {
          return this._inner;
        }
        if (this._innerDeindent === null) {
          const lines = this._inner.split("\n");
          this._innerDeindent = lines.map((line) => {
            if (line.startsWith(this._indentation)) {
              return line.substring(this._indentation.length);
            }
            return line;
          }).join("\n");
        }
        return this._innerDeindent;
      }
      get InnerDeindent() {
        return this.innerDeindent();
      }
      async position() {
        if (!this._pos) {
          this._pos = await this._page.posOffset(this._posOffset);
        }
        return this._pos;
      }
      scratch() {
        if (!this._scratch) {
          this._scratch = new scratch_1.Scratch();
        }
        return this._scratch;
      }
      get(key) {
        if (!this._params) {
          return null;
        }
        if (Array.isArray(this._params)) {
          if (typeof key === "number") {
            if (key >= this._params.length) {
              return "";
            }
            return this._params[key];
          }
          return null;
        } else if (typeof this._params === "object") {
          if (typeof key === "string") {
            return this._params[key] || "";
          }
          return null;
        }
        return null;
      }
      Get(key) {
        return this.get(key);
      }
    };
    exports2.ShortcodeWithPage = ShortcodeWithPage;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/type.js
var require_type9 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateType = exports2.ErrInvalidTemplate = exports2.ErrTemplateExecuteFailed = exports2.ErrTemplateParseFailed = exports2.ErrTemplateNotFound = exports2.TemplateError = exports2.PARTIALS_PREFIX = exports2.BASE_DEFAULT = exports2.BASE_FILE_BASE = void 0;
    exports2.BASE_FILE_BASE = "baseof";
    exports2.BASE_DEFAULT = "_default";
    exports2.PARTIALS_PREFIX = "partials/";
    var TemplateError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        this.name = "TemplateError";
      }
    };
    exports2.TemplateError = TemplateError;
    exports2.ErrTemplateNotFound = new TemplateError("template not found", "TEMPLATE_NOT_FOUND");
    exports2.ErrTemplateParseFailed = new TemplateError("template parse failed", "PARSE_FAILED");
    exports2.ErrTemplateExecuteFailed = new TemplateError("template execute failed", "EXECUTE_FAILED");
    exports2.ErrInvalidTemplate = new TemplateError("invalid template", "INVALID_TEMPLATE");
    var TemplateType;
    (function(TemplateType2) {
      TemplateType2[TemplateType2["TypeUndefined"] = 0] = "TypeUndefined";
      TemplateType2[TemplateType2["TypeShortcode"] = 1] = "TypeShortcode";
      TemplateType2[TemplateType2["TypePartial"] = 2] = "TypePartial";
    })(TemplateType || (exports2.TemplateType = TemplateType = {}));
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/baseof.js
var require_baseof = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/baseof.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseOf = void 0;
    exports2.newBaseOf = newBaseOf;
    var type_1 = require_type9();
    var path6 = __importStar(require("path"));
    var BaseOf = class {
      constructor() {
        this.baseof = /* @__PURE__ */ new Map();
        this.needsBaseof = /* @__PURE__ */ new Map();
      }
      getTemplateSearchOrder(templateName) {
        const searchOrder = [];
        searchOrder.push(`${type_1.BASE_DEFAULT}/baseof.html`);
        return searchOrder;
      }
      getBaseOf(key) {
        return this.baseof.get(key) || null;
      }
      getNeedsBaseOf(key) {
        return this.needsBaseof.get(key) || null;
      }
      addBaseOf(key, info) {
        this.baseof.set(key, info);
      }
      addNeedsBaseOf(key, info) {
        this.needsBaseof.set(key, info);
      }
      isBaseTemplatePath(filePath) {
        return path6.basename(filePath).includes(type_1.BASE_FILE_BASE);
      }
      needsBaseOf(name, rawContent) {
        return !this.noBaseNeeded(name) && this.needsBaseTemplate(rawContent);
      }
      noBaseNeeded(name) {
        if (name.startsWith(type_1.PARTIALS_PREFIX)) {
          return true;
        }
        return false;
      }
      needsBaseTemplate(templ) {
        const baseTemplateDefineRe = /^{{-?\s*define/;
        let idx = -1;
        let inComment = false;
        for (let i = 0; i < templ.length; ) {
          if (!inComment && templ.substring(i).startsWith("{{/*")) {
            inComment = true;
            i += 4;
          } else if (!inComment && templ.substring(i).startsWith("{{- /*")) {
            inComment = true;
            i += 6;
          } else if (inComment && templ.substring(i).startsWith("*/}}")) {
            inComment = false;
            i += 4;
          } else if (inComment && templ.substring(i).startsWith("*/ -}}")) {
            inComment = false;
            i += 6;
          } else {
            const char2 = templ[i];
            if (!inComment) {
              if (templ.substring(i).startsWith("{{")) {
                idx = i;
                break;
              } else if (!/\s/.test(char2)) {
                break;
              }
            }
            i++;
          }
        }
        if (idx === -1) {
          return false;
        }
        return baseTemplateDefineRe.test(templ.substring(idx));
      }
      getAllBaseOf() {
        return new Map(this.baseof);
      }
      getAllNeedsBaseOf() {
        return new Map(this.needsBaseof);
      }
      clear() {
        this.baseof.clear();
        this.needsBaseof.clear();
      }
      getStats() {
        return {
          baseOfCount: this.baseof.size,
          needsBaseOfCount: this.needsBaseof.size
        };
      }
    };
    exports2.BaseOf = BaseOf;
    function newBaseOf() {
      return new BaseOf();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/info.js
var require_info = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateInfo = void 0;
    exports2.loadTemplate = loadTemplate;
    exports2.resolveTemplateType = resolveTemplateType;
    exports2.isShortcode = isShortcode;
    var type_1 = require_type9();
    var TemplateInfo = class {
      constructor(name, template, fi) {
        this.name = name;
        this.template = template;
        this.fi = fi;
      }
      identifierBase() {
        return this.name;
      }
      errWithFileContext(what, err) {
        const message = `${what}: ${err.message}`;
        const templateError = new type_1.TemplateError(message, "TEMPLATE_FILE_ERROR");
        Object.defineProperty(templateError, "fileName", {
          value: this.name,
          enumerable: true
        });
        Object.defineProperty(templateError, "fileContent", {
          value: this.template,
          enumerable: true
        });
        return templateError;
      }
      isZero() {
        return this.name === "";
      }
      copy() {
        return new TemplateInfo(this.name, this.template, this.fi);
      }
      getCleanContent() {
        return removeLeadingBOM(this.template);
      }
    };
    exports2.TemplateInfo = TemplateInfo;
    async function loadTemplate(name, fim) {
      let file = null;
      try {
        file = await fim.open();
        const fileInfo = await file.stat();
        const buffer = new Uint8Array(fileInfo.size());
        const result = await file.read(buffer);
        const content = new TextDecoder("utf-8").decode(result.buffer);
        const cleanContent = removeLeadingBOM(content);
        return new TemplateInfo(name, cleanContent, fim);
      } catch (error) {
        const templateInfo = new TemplateInfo(name, "", fim);
        throw templateInfo.errWithFileContext("failed to load template", error);
      } finally {
        if (file) {
          try {
            await file.close();
          } catch (closeError) {
            console.warn(`Failed to close template file: ${closeError}`);
          }
        }
      }
    }
    function removeLeadingBOM(s) {
      const BOM = "\uFEFF";
      for (let i = 0; i < s.length; i++) {
        const char2 = s[i];
        if (i === 0 && char2 !== BOM) {
          return s;
        }
        if (i > 0) {
          return s.substring(i);
        }
      }
      return s;
    }
    function resolveTemplateType(name) {
      if (isShortcode(name)) {
        return type_1.TemplateType.TypeShortcode;
      }
      if (name.includes("_partials/")) {
        return type_1.TemplateType.TypePartial;
      }
      return type_1.TemplateType.TypeUndefined;
    }
    function isShortcode(name) {
      return name.includes("_shortcodes/");
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/namespace.js
var require_namespace = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/namespace.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShortcodeTemplateNamespace = exports2.PartialTemplateNamespace = exports2.RegularTemplateNamespace = void 0;
    exports2.newRegularTemplateNamespace = newRegularTemplateNamespace;
    exports2.newPartialTemplateNamespace = newPartialTemplateNamespace;
    exports2.newShortcodeTemplateNamespace = newShortcodeTemplateNamespace;
    var type_1 = require_type9();
    var path_1 = __importDefault(require("path"));
    var BaseNamespace = class {
      constructor() {
        this.templates = /* @__PURE__ */ new Map();
        this.mutex = /* @__PURE__ */ new Set();
      }
      addTemplate(name, state) {
        this.withLock(() => {
          this.templates.set(name, state);
        });
      }
      findTemplate(name) {
        return this.withReadLock(() => {
          if (this.templates.has(name)) {
            return this.templates.get(name) || null;
          }
          for (const [key, template] of this.templates.entries()) {
            if (key.includes(name)) {
              return template;
            }
          }
          return null;
        });
      }
      getTemplates() {
        return this.withReadLock(() => {
          return new Map(this.templates);
        });
      }
      hasTemplate(name) {
        return this.withReadLock(() => {
          return this.templates.has(name);
        });
      }
      getTemplateNames() {
        return this.withReadLock(() => {
          return Array.from(this.templates.keys());
        });
      }
      removeTemplate(name) {
        return this.withLock(() => {
          return this.templates.delete(name);
        });
      }
      clear() {
        this.withLock(() => {
          this.templates.clear();
        });
      }
      size() {
        return this.withReadLock(() => {
          return this.templates.size;
        });
      }
      getTemplatesByPattern(pattern) {
        return this.withReadLock(() => {
          const results = [];
          for (const [name, state] of this.templates) {
            if (pattern.test(name)) {
              results.push(state);
            }
          }
          return results;
        });
      }
      withLock(fn) {
        const lockKey = "write";
        while (this.mutex.has(lockKey)) {
        }
        this.mutex.add(lockKey);
        try {
          return fn();
        } finally {
          this.mutex.delete(lockKey);
        }
      }
      withReadLock(fn) {
        const lockKey = "read";
        this.mutex.add(lockKey);
        try {
          return fn();
        } finally {
          this.mutex.delete(lockKey);
        }
      }
    };
    var RegularTemplateNamespace = class extends BaseNamespace {
      lookup(name) {
        const state = this.findTemplate(name);
        if (!state) {
          return null;
        }
        return state.template;
      }
      findTemplateWithDependencies(name) {
        return this.findTemplate(name);
      }
      getTemplatesNeedingBase() {
        return this.withReadLock(() => {
          return Array.from(this.templates.values()).filter((state) => state.baseInfo);
        });
      }
    };
    exports2.RegularTemplateNamespace = RegularTemplateNamespace;
    var PartialTemplateNamespace = class extends BaseNamespace {
      lookup(name) {
        const state = this.findTemplate(name);
        if (!state) {
          return null;
        }
        return state.template;
      }
      addPartialTemplate(name, state) {
        const partialState = {
          ...state,
          type: type_1.TemplateType.TypePartial
        };
        this.addTemplate(name, partialState);
      }
    };
    exports2.PartialTemplateNamespace = PartialTemplateNamespace;
    var ShortcodeTemplateNamespace = class extends BaseNamespace {
      lookup(name) {
        const state = this.findTemplate(name);
        if (!state) {
          return null;
        }
        return state.template;
      }
      addShortcodeTemplate(name, state) {
        const shortcodeState = {
          ...state,
          type: type_1.TemplateType.TypeShortcode
        };
        this.addTemplate(name, shortcodeState);
      }
      getShortcode(name) {
        return this.lookup(path_1.default.join("_shortcodes", name));
      }
      hasShortcode(name) {
        return this.hasTemplate(name);
      }
      getShortcodeNames() {
        return this.getTemplateNames();
      }
    };
    exports2.ShortcodeTemplateNamespace = ShortcodeTemplateNamespace;
    function newRegularTemplateNamespace() {
      return new RegularTemplateNamespace();
    }
    function newPartialTemplateNamespace() {
      return new PartialTemplateNamespace();
    }
    function newShortcodeTemplateNamespace() {
      return new ShortcodeTemplateNamespace();
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/executor.js
var require_executor = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/executor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Executor = void 0;
    exports2.newExecutor = newExecutor;
    var type_1 = require_type9();
    var Executor = class {
      async execute(tmpl, data) {
        try {
          const [result, execErr] = await tmpl.Execute(data);
          if (execErr) {
            throw new type_1.TemplateError(`Template execution failed: ${execErr.message}`, "EXECUTION_FAILED");
          }
          return result;
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Template execution failed: ${message}`, "EXECUTION_FAILED");
        }
      }
      async executeWithTimeout(tmpl, data, timeoutMs) {
        return new Promise(async (resolve, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new type_1.TemplateError("Template execution timeout", "EXECUTION_TIMEOUT"));
          }, timeoutMs);
          await this.execute(tmpl, data).then((result) => {
            clearTimeout(timeoutId);
            resolve(result);
          }).catch((error) => {
            clearTimeout(timeoutId);
            reject(error);
          });
        });
      }
      async executeSafely(tmpl, data) {
        try {
          const result = await this.execute(tmpl, data);
          return { result, error: null };
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            return { result: null, error };
          }
          const message = error instanceof Error ? error.message : String(error);
          return {
            result: null,
            error: new type_1.TemplateError(`Execution failed: ${message}`, "EXECUTION_ERROR")
          };
        }
      }
      async executeBatch(templates) {
        const results = await Promise.allSettled(templates.map(async ({ name, template, data }) => {
          try {
            const result = await this.execute(template, data);
            return { name, result, error: null };
          } catch (error) {
            return {
              name,
              result: null,
              error: error instanceof type_1.TemplateError ? error : new type_1.TemplateError(`Batch execution failed: ${error.message}`, "BATCH_EXECUTION_FAILED")
            };
          }
        }));
        return results.map((result) => {
          if (result.status === "fulfilled") {
            return result.value;
          } else {
            return {
              name: "unknown",
              result: null,
              error: new type_1.TemplateError(`Batch execution failed: ${result.reason}`, "BATCH_EXECUTION_FAILED")
            };
          }
        });
      }
      async executeWithContext(tmpl, data, context) {
        if (context.signal?.aborted) {
          throw new type_1.TemplateError("Template execution was cancelled", "EXECUTION_CANCELLED");
        }
        const cancellationPromise = new Promise((_, reject) => {
          if (context.signal) {
            context.signal.addEventListener("abort", () => {
              reject(new type_1.TemplateError("Template execution was cancelled", "EXECUTION_CANCELLED"));
            });
          }
        });
        const timeoutPromise = context.timeout ? new Promise((_, reject) => {
          setTimeout(() => {
            reject(new type_1.TemplateError("Template execution timeout", "EXECUTION_TIMEOUT"));
          }, context.timeout);
        }) : new Promise(() => {
        });
        try {
          return await Promise.race([
            this.execute(tmpl, data),
            cancellationPromise,
            timeoutPromise
          ]);
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            throw error;
          }
          throw new type_1.TemplateError(`Context execution failed: ${error.message}`, "CONTEXT_EXECUTION_FAILED");
        }
      }
    };
    exports2.Executor = Executor;
    function newExecutor() {
      return new Executor();
    }
  }
});

// node_modules/@mdfriday/text-template/dist/node.js
var require_node = __commonJS({
  "node_modules/@mdfriday/text-template/dist/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefineNode = exports2.TemplateNode = exports2.WithNode = exports2.RangeNode = exports2.IfNode = exports2.BranchNode = exports2.ContinueNode = exports2.BreakNode = exports2.ElseNode = exports2.EndNode = exports2.StringNode = exports2.NumberNode = exports2.BoolNode = exports2.ChainNode = exports2.FieldNode = exports2.NilNode = exports2.DotNode = exports2.IdentifierNode = exports2.VariableNode = exports2.CommentNode = exports2.CommandNode = exports2.PipeNode = exports2.ActionNode = exports2.ListNode = exports2.TemplateError = exports2.TextNode = exports2.StringBuilderImpl = exports2.NodeType = void 0;
    exports2.setTextFormat = setTextFormat;
    exports2.getTextFormat = getTextFormat;
    exports2.errorf = errorf;
    exports2.sprintf = sprintf;
    var parse_1 = require_parse();
    var textFormat = "%s";
    function setTextFormat(format) {
      const oldFormat = textFormat;
      textFormat = format;
      return oldFormat;
    }
    function getTextFormat() {
      return textFormat;
    }
    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["NodeText"] = 0] = "NodeText";
      NodeType2[NodeType2["NodeAction"] = 1] = "NodeAction";
      NodeType2[NodeType2["NodeBool"] = 2] = "NodeBool";
      NodeType2[NodeType2["NodeChain"] = 3] = "NodeChain";
      NodeType2[NodeType2["NodeCommand"] = 4] = "NodeCommand";
      NodeType2[NodeType2["NodeDot"] = 5] = "NodeDot";
      NodeType2[NodeType2["NodeElse"] = 6] = "NodeElse";
      NodeType2[NodeType2["NodeEnd"] = 7] = "NodeEnd";
      NodeType2[NodeType2["NodeField"] = 8] = "NodeField";
      NodeType2[NodeType2["NodeIdentifier"] = 9] = "NodeIdentifier";
      NodeType2[NodeType2["NodeIf"] = 10] = "NodeIf";
      NodeType2[NodeType2["NodeList"] = 11] = "NodeList";
      NodeType2[NodeType2["NodeNil"] = 12] = "NodeNil";
      NodeType2[NodeType2["NodeNumber"] = 13] = "NodeNumber";
      NodeType2[NodeType2["NodePipe"] = 14] = "NodePipe";
      NodeType2[NodeType2["NodeRange"] = 15] = "NodeRange";
      NodeType2[NodeType2["NodeString"] = 16] = "NodeString";
      NodeType2[NodeType2["NodeTemplate"] = 17] = "NodeTemplate";
      NodeType2[NodeType2["NodeVariable"] = 18] = "NodeVariable";
      NodeType2[NodeType2["NodeWith"] = 19] = "NodeWith";
      NodeType2[NodeType2["NodeComment"] = 20] = "NodeComment";
      NodeType2[NodeType2["NodeBreak"] = 21] = "NodeBreak";
      NodeType2[NodeType2["NodeContinue"] = 22] = "NodeContinue";
    })(NodeType || (exports2.NodeType = NodeType = {}));
    var StringBuilderImpl = class {
      constructor() {
        this.parts = [];
      }
      WriteString(str) {
        this.parts.push(str);
      }
      String() {
        return this.parts.join("");
      }
    };
    exports2.StringBuilderImpl = StringBuilderImpl;
    var TextNode = class {
      constructor(tr, pos2, text3) {
        this.nodeType = NodeType.NodeText;
        this.tr = tr;
        this.pos = pos2;
        this.Text = new TextEncoder().encode(text3);
      }
      Type() {
        return this.nodeType;
      }
      String() {
        return sprintf(textFormat, new TextDecoder().decode(this.Text));
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      Copy() {
        return new TextNode(this.tr, this.pos, new TextDecoder().decode(this.Text));
      }
      writeTo(sb) {
        const text3 = new TextDecoder().decode(this.Text);
        sb.WriteString(sprintf(textFormat, text3));
      }
    };
    exports2.TextNode = TextNode;
    var TemplateError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TemplateError";
      }
    };
    exports2.TemplateError = TemplateError;
    function errorf(format, ...args) {
      throw new TemplateError(sprintf(format, ...args));
    }
    function sprintf(format, ...args) {
      let argIndex = 0;
      return format.replace(/%[sqd%vT]/g, (match) => {
        if (match === "%%")
          return "%";
        if (argIndex >= args.length)
          return match;
        const arg = args[argIndex++];
        switch (match) {
          case "%s":
            return String(arg);
          case "%q":
            if (typeof arg === "string") {
              return `"${arg}"`;
            } else {
              return String(arg);
            }
          case "%d":
            return Number(arg).toString();
          case "%v":
            return arg instanceof Error ? arg.message : String(arg);
          case "%T":
            return typeof arg;
          default:
            return match;
        }
      });
    }
    var ListNode = class {
      constructor(pos2) {
        this.Nodes = [];
        this.pos = pos2;
      }
      Type() {
        return NodeType.NodeList;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      append(n2) {
        this.Nodes.push(n2);
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      CopyList() {
        const n2 = new ListNode(this.pos);
        n2.tr = this.tr;
        n2.Nodes = this.Nodes.map((node) => node.Copy());
        return n2;
      }
      Copy() {
        return this.CopyList();
      }
      writeTo(sb) {
        this.Nodes.forEach((node) => node.writeTo(sb));
      }
    };
    exports2.ListNode = ListNode;
    var ActionNode = class {
      constructor(pos2, line, pipe) {
        this.pos = pos2;
        this.line = line;
        this.Pipe = pipe;
      }
      Type() {
        return NodeType.NodeAction;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      setPos(pos2) {
        this.pos = pos2;
        return this;
      }
      String() {
        return `{{${this.Pipe.String()}}}`;
      }
      Copy() {
        return new ActionNode(this.pos, this.line, this.Pipe.Copy());
      }
      writeTo(sb) {
        sb.WriteString("{{");
        this.Pipe.writeTo(sb);
        sb.WriteString("}}");
      }
    };
    exports2.ActionNode = ActionNode;
    var PipeNode = class {
      constructor(pos2, line) {
        this.IsAssign = false;
        this.Decl = [];
        this.Cmds = [];
        this.pos = pos2;
        this.Line = line;
      }
      Type() {
        return NodeType.NodePipe;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      append(command) {
        this.Cmds.push(command);
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        const n2 = new PipeNode(this.pos, this.Line);
        n2.IsAssign = this.IsAssign;
        n2.Decl = this.Decl.map((v) => v.Copy());
        n2.Cmds = this.Cmds.map((c) => c.Copy());
        return n2;
      }
      writeTo(sb) {
        if (this.Decl.length > 0) {
          this.Decl.forEach((v, i) => {
            if (i > 0) {
              sb.WriteString(", ");
            }
            v.writeTo(sb);
          });
          sb.WriteString(" := ");
        }
        this.Cmds.forEach((c, i) => {
          if (i > 0) {
            sb.WriteString(" | ");
          }
          c.writeTo(sb);
        });
      }
    };
    exports2.PipeNode = PipeNode;
    var CommandNode = class {
      constructor(pos2) {
        this.Args = [];
        this.pos = pos2;
      }
      Type() {
        return NodeType.NodeCommand;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      append(arg) {
        this.Args.push(arg);
      }
      Copy() {
        const n2 = new CommandNode(this.pos);
        n2.Args = this.Args.map((a) => a.Copy());
        return n2;
      }
      writeTo(sb) {
        this.Args.forEach((a, i) => {
          if (i > 0) {
            sb.WriteString(" ");
          }
          if (a.Type() === NodeType.NodePipe) {
            sb.WriteString("(");
            a.writeTo(sb);
            sb.WriteString(")");
          } else {
            a.writeTo(sb);
          }
        });
      }
    };
    exports2.CommandNode = CommandNode;
    var CommentNode = class {
      constructor(pos2, text3) {
        this.pos = pos2;
        this.Text = text3;
      }
      Type() {
        return NodeType.NodeComment;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new CommentNode(this.pos, this.Text);
      }
      writeTo(sb) {
        if (this.tr && this.tr.Mode & parse_1.Mode.ParseComments) {
          sb.WriteString("{{");
          sb.WriteString(this.Text);
          sb.WriteString("}}");
        }
      }
    };
    exports2.CommentNode = CommentNode;
    var VariableNode = class {
      constructor(pos2, ident) {
        this.pos = pos2;
        this.Ident = ident;
      }
      Type() {
        return NodeType.NodeVariable;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        const result = sb.String();
        return result;
      }
      Copy() {
        return new VariableNode(this.pos, this.Ident.slice());
      }
      writeTo(sb) {
        for (let i = 0; i < this.Ident.length; i++) {
          if (i > 0) {
            sb.WriteString(".");
          }
          sb.WriteString(this.Ident[i]);
        }
      }
    };
    exports2.VariableNode = VariableNode;
    var IdentifierNode = class {
      constructor(ident) {
        this.Ident = ident;
      }
      Type() {
        return NodeType.NodeIdentifier;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      setPos(pos2) {
        this.pos = pos2;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new IdentifierNode(this.Ident).setTree(this.tr).setPos(this.pos);
      }
      writeTo(sb) {
        sb.WriteString(this.Ident);
      }
    };
    exports2.IdentifierNode = IdentifierNode;
    var DotNode = class {
      constructor(pos2) {
        this.pos = pos2;
      }
      Type() {
        return NodeType.NodeDot;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new DotNode(this.pos);
      }
      writeTo(sb) {
        sb.WriteString(".");
      }
    };
    exports2.DotNode = DotNode;
    var NilNode = class {
      constructor(pos2) {
        this.pos = pos2;
      }
      Type() {
        return NodeType.NodeNil;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      setPos(pos2) {
        this.pos = pos2;
        return this;
      }
      String() {
        return "nil";
      }
      Copy() {
        return new NilNode(this.pos);
      }
      writeTo(sb) {
        sb.WriteString("nil");
      }
    };
    exports2.NilNode = NilNode;
    var FieldNode = class {
      constructor(pos2, ident) {
        this.pos = pos2;
        this.Ident = ident;
      }
      Type() {
        return NodeType.NodeField;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      setPos(pos2) {
        this.pos = pos2;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new FieldNode(this.pos, this.Ident.slice());
      }
      writeTo(sb) {
        for (const id of this.Ident) {
          sb.WriteString(".");
          sb.WriteString(id);
        }
      }
    };
    exports2.FieldNode = FieldNode;
    var ChainNode = class {
      constructor(pos2, node) {
        this.Field = [];
        this.pos = pos2;
        this.Node = node;
      }
      Type() {
        return NodeType.NodeChain;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      setPos(pos2) {
        this.pos = pos2;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        const result = sb.String();
        return result;
      }
      add(field) {
        if (field.length === 0 || field[0] !== ".") {
          console.error(`[ChainNode.add] Field does not start with a dot: "${field}"`);
          throw new Error("no dot in field");
        }
        const cleanField = field.substring(1);
        if (cleanField === "") {
          console.error(`[ChainNode.add] Empty field after removing dot`);
          throw new Error("empty field");
        }
        this.Field.push(cleanField);
      }
      Copy() {
        const n2 = new ChainNode(this.pos, this.Node.Copy());
        n2.Field = this.Field.slice();
        return n2;
      }
      writeTo(sb) {
        if (this.Node.Type() === NodeType.NodePipe) {
          sb.WriteString("(");
          this.Node.writeTo(sb);
          sb.WriteString(")");
        } else {
          this.Node.writeTo(sb);
        }
        this.Field.forEach((f) => {
          sb.WriteString(".");
          sb.WriteString(f);
        });
      }
    };
    exports2.ChainNode = ChainNode;
    var BoolNode = class {
      constructor(pos2, value2) {
        this.pos = pos2;
        this.True = value2;
      }
      Type() {
        return NodeType.NodeBool;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new BoolNode(this.pos, this.True);
      }
      writeTo(sb) {
        sb.WriteString(this.True ? "true" : "false");
      }
    };
    exports2.BoolNode = BoolNode;
    var NumberNode = class {
      constructor(tr, pos2, text3) {
        this.IsInt = false;
        this.IsUint = false;
        this.IsFloat = false;
        this.IsComplex = false;
        this.Int64 = 0;
        this.Uint64 = 0;
        this.Float64 = 0;
        this.Complex128 = { re: 0, im: 0 };
        this.tr = tr;
        this.pos = pos2;
        this.Text = text3;
      }
      Type() {
        return NodeType.NodeNumber;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      String() {
        return this.Text;
      }
      Copy() {
        const n2 = new NumberNode(this.tr, this.pos, this.Text);
        n2.IsInt = this.IsInt;
        n2.IsUint = this.IsUint;
        n2.IsFloat = this.IsFloat;
        n2.IsComplex = this.IsComplex;
        n2.Int64 = this.Int64;
        n2.Uint64 = this.Uint64;
        n2.Float64 = this.Float64;
        n2.Complex128 = Object.assign({}, this.Complex128);
        return n2;
      }
      writeTo(sb) {
        sb.WriteString(this.Text);
      }
      simplifyComplex() {
        if (this.Complex128.im === 0) {
          this.IsFloat = true;
          this.Float64 = this.Complex128.re;
          if (Number.isInteger(this.Float64)) {
            this.IsInt = true;
            this.Int64 = this.Float64;
            if (this.Float64 >= 0) {
              this.IsUint = true;
              this.Uint64 = this.Float64;
            }
          }
        }
      }
    };
    exports2.NumberNode = NumberNode;
    var StringNode = class {
      constructor(pos2, quoted, text3) {
        this.pos = pos2;
        this.Quoted = quoted;
        this.Text = text3;
      }
      Type() {
        return NodeType.NodeString;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new StringNode(this.pos, this.Quoted, this.Text);
      }
      writeTo(sb) {
        sb.WriteString(this.Quoted);
      }
    };
    exports2.StringNode = StringNode;
    var EndNode = class {
      constructor(pos2) {
        this.pos = pos2;
      }
      Type() {
        return NodeType.NodeEnd;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new EndNode(this.pos);
      }
      writeTo(sb) {
        sb.WriteString("{{end}}");
      }
    };
    exports2.EndNode = EndNode;
    var ElseNode = class {
      constructor(pos2, line) {
        this.pos = pos2;
        this.Line = line;
      }
      Type() {
        return NodeType.NodeElse;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new ElseNode(this.pos, this.Line);
      }
      writeTo(sb) {
        sb.WriteString("{{else}}");
      }
    };
    exports2.ElseNode = ElseNode;
    var BreakNode = class {
      constructor(pos2, line) {
        this.pos = pos2;
        this.Line = line;
      }
      Type() {
        return NodeType.NodeBreak;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new BreakNode(this.pos, this.Line);
      }
      writeTo(sb) {
        sb.WriteString("{{break}}");
      }
    };
    exports2.BreakNode = BreakNode;
    var ContinueNode = class {
      constructor(pos2, line) {
        this.pos = pos2;
        this.Line = line;
      }
      Type() {
        return NodeType.NodeContinue;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        return new ContinueNode(this.pos, this.Line);
      }
      writeTo(sb) {
        sb.WriteString("{{continue}}");
      }
    };
    exports2.ContinueNode = ContinueNode;
    var BranchNode = class {
      constructor(nodeType, tr, pos2, line, pipe, list, elseList) {
        this.nodeType = nodeType;
        this.tr = tr;
        this.pos = pos2;
        this.Line = line;
        this.Pipe = pipe;
        this.List = list;
        this.ElseList = elseList;
      }
      Type() {
        return this.nodeType;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      String() {
        const sb = new StringBuilderImpl();
        this.writeTo(sb);
        return sb.String();
      }
      Copy() {
        throw new Error("Copy() must be implemented by derived classes");
      }
      writeTo(sb) {
        const name = this.nodeType === NodeType.NodeIf ? "if" : this.nodeType === NodeType.NodeRange ? "range" : this.nodeType === NodeType.NodeWith ? "with" : "unknown";
        sb.WriteString("{{" + name + " ");
        this.Pipe.writeTo(sb);
        sb.WriteString("}}");
        this.List.writeTo(sb);
        if (this.ElseList) {
          sb.WriteString("{{else}}");
          this.ElseList.writeTo(sb);
        }
        sb.WriteString("{{end}}");
      }
    };
    exports2.BranchNode = BranchNode;
    var IfNode = class extends BranchNode {
      constructor(tr, pos2, line, pipe, list, elseList) {
        super(NodeType.NodeIf, tr, pos2, line, pipe, list, elseList);
      }
      Copy() {
        var _a;
        return new IfNode(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((_a = this.ElseList) === null || _a === void 0 ? void 0 : _a.CopyList()) || null);
      }
    };
    exports2.IfNode = IfNode;
    var RangeNode = class extends BranchNode {
      constructor(tr, pos2, line, pipe, list, elseList) {
        super(NodeType.NodeRange, tr, pos2, line, pipe, list, elseList);
      }
      Copy() {
        var _a;
        return new RangeNode(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((_a = this.ElseList) === null || _a === void 0 ? void 0 : _a.CopyList()) || null);
      }
    };
    exports2.RangeNode = RangeNode;
    var WithNode = class extends BranchNode {
      constructor(tr, pos2, line, pipe, list, elseList) {
        super(NodeType.NodeWith, tr, pos2, line, pipe, list, elseList);
      }
      Copy() {
        var _a;
        return new WithNode(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((_a = this.ElseList) === null || _a === void 0 ? void 0 : _a.CopyList()) || null);
      }
    };
    exports2.WithNode = WithNode;
    var TemplateNode = class {
      constructor(pos2, line, name, pipe) {
        this.pos = pos2;
        this.Line = line;
        this.Name = name;
        this.Pipe = pipe;
      }
      Type() {
        return NodeType.NodeTemplate;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        return "{{template " + JSON.stringify(this.Name) + (this.Pipe ? " " + this.Pipe.String() : "") + "}}";
      }
      Copy() {
        return new TemplateNode(this.pos, this.Line, this.Name, this.Pipe ? this.Pipe.Copy() : null).setTree(this.tr);
      }
      writeTo(sb) {
        sb.WriteString("{{template ");
        sb.WriteString(JSON.stringify(this.Name));
        if (this.Pipe) {
          sb.WriteString(" ");
          this.Pipe.writeTo(sb);
        }
        sb.WriteString("}}");
      }
    };
    exports2.TemplateNode = TemplateNode;
    var DefineNode = class {
      constructor(pos2, line, name, pipe) {
        this.pos = pos2;
        this.Line = line;
        this.Name = name;
        this.Pipe = pipe;
      }
      Type() {
        return NodeType.NodeTemplate;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t) {
        this.tr = t;
        return this;
      }
      String() {
        return "{{define " + this.Name + "}}";
      }
      Copy() {
        return new DefineNode(this.pos, this.Line, this.Name, this.Pipe.Copy()).setTree(this.tr);
      }
      writeTo(sb) {
        sb.WriteString("{{define " + this.Name + "}}");
        if (this.Pipe) {
          sb.WriteString(" ");
          this.Pipe.writeTo(sb);
        }
        sb.WriteString("}}");
      }
    };
    exports2.DefineNode = DefineNode;
  }
});

// node_modules/@mdfriday/text-template/dist/lex.js
var require_lex = __commonJS({
  "node_modules/@mdfriday/text-template/dist/lex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemType = void 0;
    exports2.lex = lex;
    var ItemType;
    (function(ItemType2) {
      ItemType2[ItemType2["itemError"] = 0] = "itemError";
      ItemType2[ItemType2["itemBool"] = 1] = "itemBool";
      ItemType2[ItemType2["itemChar"] = 2] = "itemChar";
      ItemType2[ItemType2["itemCharConstant"] = 3] = "itemCharConstant";
      ItemType2[ItemType2["itemComment"] = 4] = "itemComment";
      ItemType2[ItemType2["itemComplex"] = 5] = "itemComplex";
      ItemType2[ItemType2["itemAssign"] = 6] = "itemAssign";
      ItemType2[ItemType2["itemDeclare"] = 7] = "itemDeclare";
      ItemType2[ItemType2["itemEOF"] = 8] = "itemEOF";
      ItemType2[ItemType2["itemField"] = 9] = "itemField";
      ItemType2[ItemType2["itemIdentifier"] = 10] = "itemIdentifier";
      ItemType2[ItemType2["itemLeftDelim"] = 11] = "itemLeftDelim";
      ItemType2[ItemType2["itemLeftParen"] = 12] = "itemLeftParen";
      ItemType2[ItemType2["itemNumber"] = 13] = "itemNumber";
      ItemType2[ItemType2["itemPipe"] = 14] = "itemPipe";
      ItemType2[ItemType2["itemRawString"] = 15] = "itemRawString";
      ItemType2[ItemType2["itemRightDelim"] = 16] = "itemRightDelim";
      ItemType2[ItemType2["itemRightParen"] = 17] = "itemRightParen";
      ItemType2[ItemType2["itemSpace"] = 18] = "itemSpace";
      ItemType2[ItemType2["itemString"] = 19] = "itemString";
      ItemType2[ItemType2["itemText"] = 20] = "itemText";
      ItemType2[ItemType2["itemVariable"] = 21] = "itemVariable";
      ItemType2[ItemType2["itemKeyword"] = 22] = "itemKeyword";
      ItemType2[ItemType2["itemBlock"] = 23] = "itemBlock";
      ItemType2[ItemType2["itemBreak"] = 24] = "itemBreak";
      ItemType2[ItemType2["itemContinue"] = 25] = "itemContinue";
      ItemType2[ItemType2["itemDot"] = 26] = "itemDot";
      ItemType2[ItemType2["itemDefine"] = 27] = "itemDefine";
      ItemType2[ItemType2["itemElse"] = 28] = "itemElse";
      ItemType2[ItemType2["itemEnd"] = 29] = "itemEnd";
      ItemType2[ItemType2["itemIf"] = 30] = "itemIf";
      ItemType2[ItemType2["itemNil"] = 31] = "itemNil";
      ItemType2[ItemType2["itemRange"] = 32] = "itemRange";
      ItemType2[ItemType2["itemTemplate"] = 33] = "itemTemplate";
      ItemType2[ItemType2["itemWith"] = 34] = "itemWith";
    })(ItemType || (exports2.ItemType = ItemType = {}));
    var key = {
      ".": ItemType.itemDot,
      "block": ItemType.itemBlock,
      "break": ItemType.itemBreak,
      "continue": ItemType.itemContinue,
      "define": ItemType.itemDefine,
      "else": ItemType.itemElse,
      "end": ItemType.itemEnd,
      "if": ItemType.itemIf,
      "range": ItemType.itemRange,
      "nil": ItemType.itemNil,
      "template": ItemType.itemTemplate,
      "with": ItemType.itemWith
    };
    var EOF = -1;
    var spaceChars = " 	\r\n";
    var trimMarker = "-";
    var trimMarkerLen = 2;
    var leftDelim = "{{";
    var rightDelim = "}}";
    var leftComment = "/*";
    var rightComment = "*/";
    var Lexer = class {
      constructor(name, input, left, right) {
        this.name = name;
        this.input = input;
        this.leftDelim = left || leftDelim;
        this.rightDelim = right || rightDelim;
        this.pos = 0;
        this.start = 0;
        this.atEOF = false;
        this.parenDepth = 0;
        this.line = 1;
        this.startLine = 1;
        this.insideAction = false;
        this.options = {
          emitComment: false,
          breakOK: false,
          continueOK: false
        };
        this.item = {
          typ: ItemType.itemEOF,
          pos: 0,
          val: "",
          line: 1
        };
      }
      next() {
        if (this.pos >= this.input.length) {
          this.atEOF = true;
          return String.fromCharCode(EOF);
        }
        const r = this.input[this.pos];
        this.pos++;
        if (r === "\n") {
          this.line++;
        }
        return r;
      }
      peek() {
        const r = this.next();
        this.backup();
        return r;
      }
      backup() {
        if (!this.atEOF && this.pos > 0) {
          this.pos--;
          if (this.input[this.pos] === "\n") {
            this.line--;
          }
        }
      }
      emit(t) {
        this.item = {
          typ: t,
          pos: this.start,
          val: this.input.slice(this.start, this.pos),
          line: this.startLine
        };
        this.start = this.pos;
        this.startLine = this.line;
        return null;
      }
      ignore() {
        this.line += (this.input.slice(this.start, this.pos).match(/\n/g) || []).length;
        this.start = this.pos;
        this.startLine = this.line;
      }
      accept(valid) {
        if (valid.includes(this.next())) {
          return true;
        }
        this.backup();
        return false;
      }
      acceptRun(valid) {
        while (valid.includes(this.next())) {
        }
        this.backup();
      }
      errorf(format, ...args) {
        this.item = {
          typ: ItemType.itemError,
          pos: this.start,
          val: format.replace(/%[sdq%]/g, () => {
            const arg = args.shift();
            return String(arg);
          }),
          line: this.startLine
        };
        return null;
      }
      nextItem() {
        this.item = {
          typ: ItemType.itemEOF,
          pos: this.pos,
          val: "EOF",
          line: this.startLine
        };
        let state = this.insideAction ? lexInsideAction : lexText;
        while (state) {
          state = state(this);
          if (this.item.typ === ItemType.itemError) {
            return this.item;
          }
        }
        return this.item;
      }
      atRightDelim() {
        const s = this.input.slice(this.pos);
        if (s.length >= 2 && isSpace(s[0]) && s[1] === trimMarker && s.slice(trimMarkerLen).startsWith(this.rightDelim)) {
          return [true, true];
        }
        if (s.startsWith(this.rightDelim)) {
          return [true, false];
        }
        return [false, false];
      }
      atTerminator() {
        const r = this.peek();
        if (isSpace(r)) {
          return true;
        }
        switch (r) {
          case String.fromCharCode(EOF):
          case ".":
          case ",":
          case "|":
          case ":":
          case ")":
          case "(":
            return true;
        }
        return this.input.slice(this.pos).startsWith(this.rightDelim);
      }
      scanNumber() {
        this.accept("+-");
        let digits = "0123456789_";
        if (this.accept("0")) {
          if (this.accept("xX")) {
            digits = "0123456789abcdefABCDEF_";
          } else if (this.accept("oO")) {
            digits = "01234567_";
          } else if (this.accept("bB")) {
            digits = "01_";
          }
        }
        this.acceptRun(digits);
        if (this.accept(".")) {
          this.acceptRun(digits);
        }
        if (digits === "0123456789_" && this.accept("eE")) {
          this.accept("+-");
          this.acceptRun("0123456789_");
        }
        if (digits === "0123456789abcdefABCDEF_" && this.accept("pP")) {
          this.accept("+-");
          this.acceptRun("0123456789_");
        }
        this.accept("i");
        if (isAlphaNumeric(this.peek())) {
          this.next();
          return false;
        }
        return true;
      }
      thisItem(t) {
        const i = {
          typ: t,
          pos: this.start,
          val: this.input.slice(this.start, this.pos),
          line: this.startLine
        };
        this.start = this.pos;
        this.startLine = this.line;
        return i;
      }
      emitItem(i) {
        this.item = i;
        return null;
      }
    };
    function isSpace(r) {
      return r === " " || r === "	" || r === "\r" || r === "\n";
    }
    function isAlphaNumeric(r) {
      return r === "_" || /[a-zA-Z0-9]/.test(r);
    }
    function leftTrimLength(s) {
      let i = 0;
      while (i < s.length && spaceChars.includes(s[i])) {
        i++;
      }
      return i;
    }
    function rightTrimLength(s) {
      let i = s.length - 1;
      while (i >= 0 && spaceChars.includes(s[i])) {
        i--;
      }
      return s.length - (i + 1);
    }
    function hasLeftTrimMarker(s) {
      return s.length >= 2 && s[0] === trimMarker && spaceChars.includes(s[1]);
    }
    function hasRightTrimMarker(s) {
      return s.length >= 2 && spaceChars.includes(s[0]) && s[1] === trimMarker;
    }
    function lexText(l) {
      const x = l.input.indexOf(l.leftDelim, l.pos);
      if (x >= 0) {
        if (x > l.pos) {
          l.pos += x - l.pos;
          let trimLength = 0;
          const delimEnd = l.pos + l.leftDelim.length;
          if (hasLeftTrimMarker(l.input.slice(delimEnd))) {
            trimLength = rightTrimLength(l.input.slice(l.start, l.pos));
          }
          l.pos -= trimLength;
          l.line += (l.input.slice(l.start, l.pos).match(/\n/g) || []).length;
          const i = l.thisItem(ItemType.itemText);
          l.pos += trimLength;
          l.ignore();
          if (i.val.length > 0) {
            return l.emitItem(i);
          }
        }
        return lexLeftDelim;
      }
      l.pos = l.input.length;
      if (l.pos > l.start) {
        l.line += (l.input.slice(l.start, l.pos).match(/\n/g) || []).length;
        return l.emit(ItemType.itemText);
      }
      return l.emit(ItemType.itemEOF);
    }
    function lexLeftDelim(l) {
      l.pos += l.leftDelim.length;
      const trimSpace = hasLeftTrimMarker(l.input.slice(l.pos));
      let afterMarker = 0;
      if (trimSpace) {
        afterMarker = trimMarkerLen;
      }
      if (l.input.slice(l.pos + afterMarker).startsWith(leftComment)) {
        l.pos += afterMarker;
        l.ignore();
        return lexComment;
      }
      const i = l.thisItem(ItemType.itemLeftDelim);
      l.insideAction = true;
      l.pos += afterMarker;
      l.ignore();
      l.parenDepth = 0;
      return l.emitItem(i);
    }
    function lexComment(l) {
      l.pos += leftComment.length;
      const remainingInput = l.input.slice(l.pos);
      const x = remainingInput.indexOf(rightComment);
      if (x < 0) {
        return l.errorf("unclosed comment");
      }
      l.pos += x + rightComment.length;
      const [delim, trimSpace] = l.atRightDelim();
      if (!delim) {
        return l.errorf("comment ends before closing delimiter");
      }
      const i = l.thisItem(ItemType.itemComment);
      if (trimSpace) {
        l.pos += trimMarkerLen;
      }
      l.pos += l.rightDelim.length;
      if (trimSpace) {
        l.pos += leftTrimLength(l.input.slice(l.pos));
      }
      l.ignore();
      if (l.options.emitComment) {
        return l.emitItem(i);
      }
      return lexText;
    }
    function lexRightDelim(l) {
      const [_, trimSpace] = l.atRightDelim();
      if (trimSpace) {
        l.pos += trimMarkerLen;
        l.ignore();
      }
      l.pos += l.rightDelim.length;
      const i = l.thisItem(ItemType.itemRightDelim);
      if (trimSpace) {
        l.pos += leftTrimLength(l.input.slice(l.pos));
        l.ignore();
      }
      l.insideAction = false;
      return l.emitItem(i);
    }
    function lexInsideAction(l) {
      const [delim, _] = l.atRightDelim();
      if (delim) {
        if (l.parenDepth === 0) {
          return lexRightDelim;
        }
        return l.errorf("unclosed left paren");
      }
      const r = l.next();
      if (r === String.fromCharCode(EOF)) {
        return l.errorf("unclosed action");
      }
      if (isSpace(r)) {
        l.backup();
        return lexSpace;
      }
      switch (r) {
        case "=":
          return l.emit(ItemType.itemAssign);
        case ":":
          if (l.next() !== "=") {
            return l.errorf("expected :=");
          }
          return l.emit(ItemType.itemDeclare);
        case "|":
          return l.emit(ItemType.itemPipe);
        case '"':
          return lexQuote;
        case "`":
          return lexRawQuote;
        case "$":
          return lexVariable;
        case "'":
          return lexChar;
        case ".":
          if (l.pos < l.input.length) {
            const nextChar = l.input[l.pos];
            if (!/[0-9]/.test(nextChar)) {
              return lexField;
            }
          }
          l.backup();
          return lexNumber;
        case "+":
        case "-":
          l.backup();
          return lexNumber;
        case "(":
          l.parenDepth++;
          return l.emit(ItemType.itemLeftParen);
        case ")":
          l.parenDepth--;
          if (l.parenDepth < 0) {
            return l.errorf("unexpected right paren");
          }
          return l.emit(ItemType.itemRightParen);
        default:
          if (/[0-9]/.test(r)) {
            l.backup();
            return lexNumber;
          }
          if (isAlphaNumeric(r)) {
            l.backup();
            return lexIdentifier;
          }
          if (r.charCodeAt(0) <= 127 && /[\x20-\x7E]/.test(r)) {
            return l.emit(ItemType.itemChar);
          }
          const codePoint = r.codePointAt(0) || 0;
          return l.errorf(`unrecognized character in action: U+${codePoint.toString(16).padStart(4, "0").toUpperCase()}`);
      }
    }
    function lexSpace(l) {
      let numSpaces = 0;
      while (true) {
        const r = l.peek();
        if (!isSpace(r)) {
          break;
        }
        l.next();
        numSpaces++;
      }
      if (hasRightTrimMarker(l.input.slice(l.pos - 1)) && l.input.slice(l.pos - 1 + trimMarkerLen).startsWith(l.rightDelim)) {
        l.backup();
        if (numSpaces === 1) {
          return lexRightDelim;
        }
      }
      return l.emit(ItemType.itemSpace);
    }
    function lexIdentifier(l) {
      while (true) {
        const r = l.next();
        if (!isAlphaNumeric(r)) {
          l.backup();
          const word = l.input.slice(l.start, l.pos);
          if (!l.atTerminator()) {
            return l.errorf(`bad character ${r}`);
          }
          if (key[word] > ItemType.itemKeyword) {
            const item = key[word];
            if (item === ItemType.itemBreak && !l.options.breakOK || item === ItemType.itemContinue && !l.options.continueOK) {
              return l.emit(ItemType.itemIdentifier);
            }
            return l.emit(item);
          }
          if (word[0] === ".") {
            return l.emit(ItemType.itemField);
          }
          if (word === "true" || word === "false") {
            return l.emit(ItemType.itemBool);
          }
          return l.emit(ItemType.itemIdentifier);
        }
      }
    }
    function lexField(l) {
      return lexFieldOrVariable(l, ItemType.itemField);
    }
    function lexVariable(l) {
      if (l.atTerminator()) {
        return l.emit(ItemType.itemVariable);
      }
      return lexFieldOrVariable(l, ItemType.itemVariable);
    }
    function lexFieldOrVariable(l, typ2) {
      if (l.atTerminator()) {
        if (typ2 === ItemType.itemVariable) {
          return l.emit(ItemType.itemVariable);
        }
        return l.emit(ItemType.itemDot);
      }
      while (true) {
        const r = l.next();
        if (!isAlphaNumeric(r)) {
          l.backup();
          break;
        }
      }
      if (!l.atTerminator()) {
        return l.errorf(`bad character ${l.peek()}`);
      }
      return l.emit(typ2);
    }
    function lexChar(l) {
      const startPos = l.pos - 1;
      Loop:
        while (true) {
          const r = l.next();
          switch (r) {
            case "\\": {
              const next = l.next();
              if (next === String.fromCharCode(EOF) || next === "\n") {
                return l.errorf("unterminated character constant");
              }
              continue Loop;
            }
            case String.fromCharCode(EOF):
            case "\n":
              return l.errorf("unterminated character constant");
            case "'":
              break Loop;
          }
        }
      l.item = {
        typ: ItemType.itemCharConstant,
        pos: l.start,
        val: l.input.slice(startPos, l.pos),
        line: l.startLine
      };
      l.start = l.pos;
      return null;
    }
    function lexNumber(l) {
      if (!l.scanNumber()) {
        return l.errorf(`bad number syntax: "${l.input.slice(l.start, l.pos)}"`);
      }
      if (l.peek() === "+" || l.peek() === "-") {
        if (!l.scanNumber() || l.input[l.pos - 1] !== "i") {
          return l.errorf(`bad number syntax: "${l.input.slice(l.start, l.pos)}"`);
        }
        return l.emit(ItemType.itemComplex);
      }
      return l.emit(ItemType.itemNumber);
    }
    function lexQuote(l) {
      const startPos = l.pos - 1;
      Loop:
        while (true) {
          const r = l.next();
          switch (r) {
            case "\\": {
              const next = l.next();
              if (next === String.fromCharCode(EOF) || next === "\n") {
                return l.errorf("unterminated quoted string");
              }
              continue Loop;
            }
            case String.fromCharCode(EOF):
            case "\n":
              return l.errorf("unterminated quoted string");
            case '"':
              break Loop;
          }
        }
      l.item = {
        typ: ItemType.itemString,
        pos: l.start,
        val: l.input.slice(startPos, l.pos),
        line: l.startLine
      };
      l.start = l.pos;
      return null;
    }
    function lexRawQuote(l) {
      while (true) {
        const r = l.next();
        if (r === String.fromCharCode(EOF)) {
          return l.errorf("unterminated raw quoted string");
        }
        if (r === "`") {
          break;
        }
      }
      return l.emit(ItemType.itemRawString);
    }
    function lex(name, input, left = "", right = "") {
      return new Lexer(name, input, left, right);
    }
  }
});

// node_modules/@mdfriday/text-template/dist/parse.js
var require_parse = __commonJS({
  "node_modules/@mdfriday/text-template/dist/parse.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tree = exports.Mode = void 0;
    exports.New = New;
    exports.parse = parse;
    exports.IsEmptyTree = IsEmptyTree;
    var node_1 = require_node();
    var lex_1 = require_lex();
    var Mode;
    (function(Mode2) {
      Mode2[Mode2["ParseComments"] = 1] = "ParseComments";
      Mode2[Mode2["SkipFuncCheck"] = 2] = "SkipFuncCheck";
    })(Mode || (exports.Mode = Mode = {}));
    function New(name, funcs = []) {
      return new _Tree(name, funcs);
    }
    var _Tree = class {
      constructor(name, funcs = []) {
        this.Name = name;
        this.ParseName = "";
        this.Root = null;
        this.Mode = 0;
        this.text = "";
        this.funcs = funcs;
        this.lex = null;
        this.tokenArray = new Array(3).fill(null);
        this.peekCount = 0;
        this.vars = [];
        this.treeSet = /* @__PURE__ */ new Map();
        this.actionLine = 0;
        this.rangeDepth = 0;
      }
      copy() {
        var _a;
        if (!this) {
          return null;
        }
        return new _Tree(this.Name, []).setProperties({
          ParseName: this.ParseName,
          Root: (_a = this.Root) === null || _a === void 0 ? void 0 : _a.CopyList(),
          text: this.text
        });
      }
      setProperties(props) {
        Object.assign(this, props);
        return this;
      }
      next() {
        if (this.peekCount > 0) {
          this.peekCount--;
        } else {
          if (!this.lex) {
            throw new Error("Lexer not initialized");
          }
          const nextItem = this.lex.nextItem();
          if (!nextItem) {
            throw new Error("No token available from lexer");
          }
          this.tokenArray[0] = nextItem;
        }
        const nextToken = this.tokenArray[this.peekCount];
        if (!nextToken) {
          throw new Error("No token available");
        }
        return nextToken;
      }
      backup() {
        this.peekCount++;
      }
      backup2(t1) {
        this.tokenArray[1] = t1;
        this.peekCount = 2;
      }
      backup3(t2, t1) {
        this.tokenArray[1] = t1;
        this.tokenArray[2] = t2;
        this.peekCount = 3;
      }
      peek() {
        if (this.peekCount > 0) {
          const token = this.tokenArray[this.peekCount - 1];
          if (!token) {
            throw new Error("No token available");
          }
          return token;
        }
        this.peekCount = 1;
        if (!this.lex) {
          throw new Error("Lexer not initialized");
        }
        const nextItem = this.lex.nextItem();
        if (!nextItem) {
          throw new Error("No token available from lexer");
        }
        this.tokenArray[0] = nextItem;
        return nextItem;
      }
      nextNonSpace() {
        let token;
        for (; ; ) {
          token = this.next();
          if (token.typ !== lex_1.ItemType.itemSpace) {
            break;
          }
        }
        return token;
      }
      peekNonSpace() {
        const token = this.nextNonSpace();
        this.backup();
        return token;
      }
      errorContext(node) {
        const pos2 = node.Position();
        const tree = node.tree() || this;
        const text3 = tree.text.substring(0, pos2);
        let byteNum = text3.lastIndexOf("\n");
        if (byteNum === -1) {
          byteNum = pos2;
        } else {
          byteNum++;
          byteNum = pos2 - byteNum;
        }
        const lineNum = 1 + (text3.match(/\n/g) || []).length;
        const context = node.toString();
        return [`${tree.ParseName}:${lineNum}:${byteNum}`, context];
      }
      errorf(format, ...args) {
        this.Root = null;
        const token = this.tokenArray[0];
        if (!token) {
          throw new Error(`template: ${this.ParseName}: ${(0, node_1.sprintf)(format, ...args)}`);
        }
        format = `template: ${this.ParseName}:${token.line}: ${format}`;
        throw new Error((0, node_1.sprintf)(format, ...args));
      }
      error(err) {
        this.errorf("%s", err);
      }
      expect(expected, context) {
        const token = this.nextNonSpace();
        if (token.typ !== expected) {
          this.unexpected(token, context);
        }
        return token;
      }
      expectOneOf(expected1, expected2, context) {
        const token = this.nextNonSpace();
        if (token.typ !== expected1 && token.typ !== expected2) {
          this.unexpected(token, context);
        }
        return token;
      }
      unexpected(token, context) {
        if (token.typ === lex_1.ItemType.itemError) {
          let extra = "";
          if (this.actionLine !== 0 && this.actionLine !== token.line) {
            extra = ` in action started at ${this.ParseName}:${this.actionLine}`;
            if (token.val.endsWith(" action")) {
              extra = extra.substring(" in action".length);
            }
          }
          this.errorf("%s%s", token.val, extra);
        }
        this.errorf("unexpected %s in %s", token.val, context);
      }
      recover(errp) {
        var _a;
        const e = errp.err;
        if (e) {
          if (e instanceof Error && ((_a = e.stack) === null || _a === void 0 ? void 0 : _a.includes("runtime error:"))) {
            throw e;
          }
          if (this) {
            this.stopParse();
          }
          errp.err = e;
        }
      }
      newList(pos2) {
        return new node_1.ListNode(pos2).setTree(this);
      }
      newText(pos2, text3) {
        return new node_1.TextNode(this, pos2, text3);
      }
      newAction(pos2, line, pipeline) {
        if (!(pipeline instanceof node_1.PipeNode)) {
          throw new Error("Pipeline must be a PipeNode");
        }
        return new node_1.ActionNode(pos2, line, pipeline).setTree(this);
      }
      newComment(pos2, text3) {
        return new node_1.CommentNode(pos2, text3).setTree(this);
      }
      newIf(pos2, line, pipe, list, elseList) {
        if (!(pipe instanceof node_1.PipeNode)) {
          throw new Error("Pipe must be a PipeNode");
        }
        return new node_1.IfNode(this, pos2, line, pipe, list, elseList);
      }
      newRange(pos2, line, pipe, list, elseList) {
        if (!(pipe instanceof node_1.PipeNode)) {
          throw new Error("Pipe must be a PipeNode");
        }
        return new node_1.RangeNode(this, pos2, line, pipe, list, elseList);
      }
      newTemplate(pos2, line, name, pipe) {
        if (pipe !== null && !(pipe instanceof node_1.PipeNode)) {
          throw new Error("Pipe must be a PipeNode");
        }
        return new node_1.TemplateNode(pos2, line, name, pipe).setTree(this);
      }
      newWith(pos2, line, pipe, list, elseList) {
        if (!(pipe instanceof node_1.PipeNode)) {
          throw new Error("Pipe must be a PipeNode");
        }
        return new node_1.WithNode(this, pos2, line, pipe, list, elseList);
      }
      newPipeline(pos2, line, vars = []) {
        const pipe = new node_1.PipeNode(pos2, line).setTree(this);
        if (vars) {
          pipe.Decl = vars;
        }
        return pipe;
      }
      newCommand(pos2) {
        return new node_1.CommandNode(pos2).setTree(this);
      }
      newChain(pos2, node) {
        return new node_1.ChainNode(pos2, node).setTree(this);
      }
      textOrAction() {
        const token = this.nextNonSpace();
        switch (token.typ) {
          case lex_1.ItemType.itemText:
            return this.newText(token.pos, token.val);
          case lex_1.ItemType.itemLeftDelim:
            this.actionLine = token.line;
            const result = this.action();
            this.clearActionLine();
            return result;
          case lex_1.ItemType.itemComment:
            return this.newComment(token.pos, token.val);
          default:
            this.unexpected(token, "input");
            return this.newText(token.pos, "");
        }
      }
      action() {
        const token = this.nextNonSpace();
        this.actionLine = token.line;
        switch (token.typ) {
          case lex_1.ItemType.itemBlock:
            return this.blockControl();
          case lex_1.ItemType.itemBreak:
            return this.breakControl(token.pos, token.line);
          case lex_1.ItemType.itemContinue:
            return this.continueControl(token.pos, token.line);
          case lex_1.ItemType.itemElse:
            return this.elseControl();
          case lex_1.ItemType.itemEnd:
            return this.endControl();
          case lex_1.ItemType.itemIf:
            return this.ifControl();
          case lex_1.ItemType.itemRange:
            return this.rangeControl();
          case lex_1.ItemType.itemTemplate:
            return this.templateControl();
          case lex_1.ItemType.itemWith:
            return this.withControl();
        }
        this.backup();
        const pos2 = this.peek().pos;
        const line = this.peek().line;
        const pipe = this.pipeline("command", lex_1.ItemType.itemRightDelim);
        return this.newAction(pos2, line, pipe);
      }
      parse(text3, leftDelim, rightDelim, treeSet, funcs = []) {
        this.ParseName = this.Name;
        const lexer = (0, lex_1.lex)(this.Name, text3, leftDelim, rightDelim);
        this.startParse(funcs, lexer, treeSet);
        this.text = text3;
        let err = null;
        try {
          this.doParse();
          this.add();
          return [this, null];
        } catch (e) {
          err = e instanceof Error ? e : new Error(String(e));
          return [this, err];
        } finally {
          this.stopParse();
        }
      }
      startParse(funcs, lexer, treeSet) {
        this.Root = null;
        this.lex = lexer;
        this.funcs = funcs;
        this.treeSet = treeSet;
        this.tokenArray = new Array(3).fill(null);
        this.peekCount = 0;
        this.vars = ["$"];
        this.actionLine = 0;
        if (this.lex) {
          this.lex.options = {
            emitComment: (this.Mode & Mode.ParseComments) !== 0,
            breakOK: !this.hasFunction("break"),
            continueOK: !this.hasFunction("continue")
          };
        }
      }
      stopParse() {
        this.lex = null;
        this.funcs = [];
        this.treeSet = /* @__PURE__ */ new Map();
        this.tokenArray = new Array(3).fill(null);
        this.peekCount = 0;
        this.vars = [];
        this.actionLine = 0;
      }
      doParse() {
        this.Root = this.newList(this.peek().pos);
        while (this.peek().typ !== lex_1.ItemType.itemEOF) {
          if (this.peek().typ === lex_1.ItemType.itemLeftDelim) {
            const delim = this.next();
            if (this.nextNonSpace().typ === lex_1.ItemType.itemDefine) {
              const newT = New("definition");
              newT.text = this.text;
              newT.Mode = this.Mode;
              newT.ParseName = this.ParseName;
              newT.startParse(this.funcs, this.lex, this.treeSet);
              newT.parseDefinition();
              continue;
            }
            this.backup2(delim);
          }
          const n2 = this.textOrAction();
          switch (n2.Type()) {
            case node_1.NodeType.NodeEnd:
              this.errorf("unexpected %s", n2);
              break;
            case node_1.NodeType.NodeElse:
              this.errorf("unexpected %s", n2);
              break;
            default:
              this.Root.append(n2);
          }
        }
      }
      parseDefinition() {
        const context = "define clause";
        const name = this.expectOneOf(lex_1.ItemType.itemString, lex_1.ItemType.itemRawString, context);
        const nameStr = this.unquote(name.val);
        if (nameStr instanceof Error) {
          this.error(nameStr);
        }
        this.Name = nameStr;
        this.expect(lex_1.ItemType.itemRightDelim, context);
        let end;
        [this.Root, end] = this.itemList();
        if (end.Type() !== node_1.NodeType.NodeEnd) {
          this.errorf("unexpected %s in %s", end, context);
        }
        this.add();
        this.stopParse();
      }
      breakControl(pos2, line) {
        const token = this.tokenArray[0];
        if (!token) {
          throw new Error("No token available");
        }
        if (this.nextNonSpace().typ !== lex_1.ItemType.itemRightDelim) {
          this.unexpected(token, "{{break}}");
        }
        if (this.rangeDepth === 0) {
          this.errorf("{{break}} outside of range");
        }
        return this.newBreak(pos2, line);
      }
      continueControl(pos2, line) {
        const token = this.tokenArray[0];
        if (!token) {
          throw new Error("No token available");
        }
        if (this.nextNonSpace().typ !== lex_1.ItemType.itemRightDelim) {
          this.unexpected(token, "{{continue}}");
        }
        if (this.rangeDepth === 0) {
          this.errorf("{{continue}} outside of range");
        }
        return this.newContinue(pos2, line);
      }
      endControl() {
        return new node_1.EndNode(this.expect(lex_1.ItemType.itemRightDelim, "end").pos).setTree(this);
      }
      elseControl() {
        const peek = this.peekNonSpace();
        if (peek.typ === lex_1.ItemType.itemIf) {
          return new node_1.ElseNode(peek.pos, peek.line).setTree(this);
        }
        const token = this.expect(lex_1.ItemType.itemRightDelim, "else");
        return new node_1.ElseNode(token.pos, token.line).setTree(this);
      }
      ifControl() {
        const [pos2, line, pipe, list, elseList] = this.parseControl(true, "if");
        return this.newIf(pos2, line, pipe, list, elseList);
      }
      rangeControl() {
        const [pos2, line, pipe, list, elseList] = this.parseControl(false, "range");
        return this.newRange(pos2, line, pipe, list, elseList);
      }
      withControl() {
        const [pos2, line, pipe, list, elseList] = this.parseControl(false, "with");
        return this.newWith(pos2, line, pipe, list, elseList);
      }
      templateControl() {
        const context = "template clause";
        const token = this.nextNonSpace();
        const name = this.parseTemplateName(token, context);
        let pipe = null;
        if (this.nextNonSpace().typ !== lex_1.ItemType.itemRightDelim) {
          this.backup();
          pipe = this.pipeline(context, lex_1.ItemType.itemRightDelim);
        }
        return this.newTemplate(token.pos, token.line, name, pipe);
      }
      blockControl() {
        const context = "block clause";
        const token = this.nextNonSpace();
        const name = this.parseTemplateName(token, context);
        const pipe = this.pipeline(context, lex_1.ItemType.itemRightDelim);
        const savedLex = this.lex;
        const savedTokenArray = [...this.tokenArray];
        const savedPeekCount = this.peekCount;
        if (!savedLex) {
          this.errorf("Failed to save lexer state");
        }
        const block = new _Tree(name);
        block.Mode = this.Mode;
        block.Root = this.newList(token.pos);
        block.ParseName = this.ParseName;
        block.startParse(this.funcs, savedLex, this.treeSet);
        let end;
        [block.Root, end] = block.itemList();
        if (end.Type() !== node_1.NodeType.NodeEnd) {
          this.errorf("unexpected %s in %s", end.toString(), context);
        }
        block.add();
        this.lex = savedLex;
        this.tokenArray = savedTokenArray;
        this.peekCount = savedPeekCount;
        return this.newTemplate(token.pos, token.line, name, pipe);
      }
      itemList() {
        const list = this.newList(this.peekNonSpace().pos);
        while (this.peekNonSpace().typ !== lex_1.ItemType.itemEOF) {
          const n2 = this.textOrAction();
          switch (n2.Type()) {
            case node_1.NodeType.NodeEnd:
            case node_1.NodeType.NodeElse:
              return [list, n2];
          }
          list.append(n2);
        }
        this.errorf("unexpected EOF");
        return [list, this.newEnd(0)];
      }
      parseTemplateName(token, context) {
        switch (token.typ) {
          case lex_1.ItemType.itemString:
          case lex_1.ItemType.itemRawString:
            const s = this.unquote(token.val);
            if (s instanceof Error) {
              this.error(s);
            }
            return s;
          default:
            this.unexpected(token, context);
        }
        return "";
      }
      popVars(n2) {
        this.vars = this.vars.slice(0, n2);
      }
      pipeline(context, end) {
        let token = this.peekNonSpace();
        const pipe = this.newPipeline(token.pos, token.line);
        let processDeclaration = true;
        while (processDeclaration && this.peekNonSpace().typ === lex_1.ItemType.itemVariable) {
          let tokenVar = this.next();
          const tokenAfterVariable = this.peek();
          const next = this.peekNonSpace();
          switch (true) {
            case (next.typ === lex_1.ItemType.itemAssign || next.typ === lex_1.ItemType.itemDeclare):
              pipe.IsAssign = next.typ === lex_1.ItemType.itemAssign;
              this.nextNonSpace();
              pipe.Decl.push(this.newVariable(tokenVar.pos, tokenVar.val));
              this.vars.push(tokenVar.val);
              processDeclaration = false;
              break;
            case (next.typ === lex_1.ItemType.itemChar && next.val === ","):
              this.nextNonSpace();
              pipe.Decl.push(this.newVariable(tokenVar.pos, tokenVar.val));
              this.vars.push(tokenVar.val);
              if (context === "range" && pipe.Decl.length < 2) {
                switch (this.peekNonSpace().typ) {
                  case lex_1.ItemType.itemVariable:
                    break;
                  case lex_1.ItemType.itemRightDelim:
                  case lex_1.ItemType.itemRightParen:
                    processDeclaration = false;
                    break;
                  default:
                    this.errorf("range can only initialize variables");
                }
              } else {
                this.errorf("too many declarations in %s", context);
              }
              break;
            case tokenAfterVariable.typ === lex_1.ItemType.itemSpace:
              this.backup3(tokenVar, tokenAfterVariable);
              processDeclaration = false;
              break;
            default:
              this.backup2(tokenVar);
              processDeclaration = false;
              break;
          }
        }
        for (; ; ) {
          const token2 = this.nextNonSpace();
          switch (token2.typ) {
            case end:
              this.checkPipeline(pipe, context);
              return pipe;
            case lex_1.ItemType.itemBool:
            case lex_1.ItemType.itemCharConstant:
            case lex_1.ItemType.itemComplex:
            case lex_1.ItemType.itemDot:
            case lex_1.ItemType.itemField:
            case lex_1.ItemType.itemIdentifier:
            case lex_1.ItemType.itemNumber:
            case lex_1.ItemType.itemNil:
            case lex_1.ItemType.itemRawString:
            case lex_1.ItemType.itemString:
            case lex_1.ItemType.itemVariable:
            case lex_1.ItemType.itemLeftParen:
              this.backup();
              pipe.append(this.command());
              break;
            default:
              this.unexpected(token2, context);
          }
        }
      }
      command() {
        const cmd = this.newCommand(this.peekNonSpace().pos);
        for (; ; ) {
          this.peekNonSpace();
          const operand = this.operand();
          if (operand) {
            cmd.Args.push(operand);
          }
          const token = this.next();
          switch (token.typ) {
            case lex_1.ItemType.itemSpace:
              continue;
            case lex_1.ItemType.itemRightDelim:
            case lex_1.ItemType.itemRightParen:
              this.backup();
              break;
            case lex_1.ItemType.itemPipe:
              break;
            default:
              this.unexpected(token, "operand");
          }
          break;
        }
        if (cmd.Args.length === 0) {
          this.errorf("empty command");
        }
        return cmd;
      }
      operand() {
        const node = this.term();
        if (!node) {
          return void 0;
        }
        if (this.peek().typ === lex_1.ItemType.itemField) {
          const chain = this.newChain(this.peek().pos, node);
          while (this.peek().typ === lex_1.ItemType.itemField) {
            const fieldVal = this.next().val;
            chain.add(fieldVal);
          }
          switch (node.Type()) {
            case node_1.NodeType.NodeField:
              return this.newField(chain.Position(), chain.String());
            case node_1.NodeType.NodeVariable:
              const chainStr = chain.String();
              return this.newVariable(chain.Position(), chainStr);
            case node_1.NodeType.NodeBool:
            case node_1.NodeType.NodeString:
            case node_1.NodeType.NodeNumber:
            case node_1.NodeType.NodeNil:
            case node_1.NodeType.NodeDot:
              this.errorf("unexpected . after term %q", node.String());
            default:
              return chain;
          }
        }
        return node;
      }
      term() {
        const token = this.nextNonSpace();
        if (!token) {
          return void 0;
        }
        switch (token.typ) {
          case lex_1.ItemType.itemIdentifier:
            const checkFunc = (this.Mode & Mode.SkipFuncCheck) === 0;
            if (checkFunc && !this.hasFunction(token.val)) {
              this.errorf("function %q not defined", token.val);
            }
            return new node_1.IdentifierNode(token.val).setTree(this).setPos(token.pos);
          case lex_1.ItemType.itemDot:
            return this.newDot(token.pos);
          case lex_1.ItemType.itemNil:
            return this.newNil(token.pos);
          case lex_1.ItemType.itemVariable:
            return this.useVar(token.pos, token.val);
          case lex_1.ItemType.itemField:
            return this.newField(token.pos, token.val);
          case lex_1.ItemType.itemBool:
            return this.newBool(token.pos, token.val === "true");
          case lex_1.ItemType.itemCharConstant:
          case lex_1.ItemType.itemComplex:
          case lex_1.ItemType.itemNumber:
            const number = this.newNumber(token.pos, token.val, token.typ);
            if (number instanceof Error) {
              this.error(number);
            }
            return number;
          case lex_1.ItemType.itemLeftParen:
            return this.pipeline("parenthesized pipeline", lex_1.ItemType.itemRightParen);
          case lex_1.ItemType.itemString:
          case lex_1.ItemType.itemRawString:
            const s = this.unquote(token.val);
            if (typeof s === "string") {
              return this.newString(token.pos, token.val, s);
            }
            this.error(s);
        }
        this.backup();
        return void 0;
      }
      checkPipeline(pipe, context) {
        if (pipe.Cmds.length === 0) {
          this.errorf("missing value for %s", context);
        }
        for (let i = 0; i < pipe.Cmds.length - 1; i++) {
          const cmd = pipe.Cmds[i + 1];
          if (!cmd.Args.length)
            continue;
          switch (cmd.Args[0].Type()) {
            case node_1.NodeType.NodeBool:
            case node_1.NodeType.NodeDot:
            case node_1.NodeType.NodeNil:
            case node_1.NodeType.NodeNumber:
            case node_1.NodeType.NodeString:
              this.errorf("non executable command in pipeline stage %d", i + 2);
          }
        }
      }
      useVar(pos2, name) {
        const v = this.newVariable(pos2, name);
        for (const varName of this.vars) {
          if (varName === v.Ident[0]) {
            return v;
          }
        }
        this.errorf("undefined variable %q", v.Ident[0]);
        throw new Error("unreachable");
      }
      newVariable(pos2, name) {
        const parts = name.split(".").filter((p) => p !== "");
        return new node_1.VariableNode(pos2, parts).setTree(this);
      }
      newField(pos2, name) {
        return new node_1.FieldNode(pos2, name.substring(1).split(".")).setTree(this);
      }
      newNumber(pos, text, typ) {
        const n = new node_1.NumberNode(this, pos, text);
        try {
          switch (typ) {
            case lex_1.ItemType.itemCharConstant: {
              if (text.length < 2 || text[0] !== "'" || text[text.length - 1] !== "'") {
                throw new Error(`malformed character constant: ${text}`);
              }
              const char = text.slice(1, -1);
              const rune = char.length === 1 ? char.charCodeAt(0) : char.startsWith("\\u") ? parseInt(char.slice(2), 16) : char.startsWith("\\x") ? parseInt(char.slice(2), 16) : char.startsWith("\\") ? eval(`"${text}"`.slice(1, -1)).charCodeAt(0) : char.charCodeAt(0);
              n.IsInt = true;
              n.Int64 = rune;
              n.IsUint = true;
              n.Uint64 = rune;
              n.IsFloat = true;
              n.Float64 = rune;
              return n;
            }
            case lex_1.ItemType.itemComplex: {
              const match = text.match(/^([-+]?\d*\.?\d*(?:[eE][-+]?\d+)?)([-+]\d*\.?\d*(?:[eE][-+]?\d+)?)?i$/);
              if (!match) {
                throw new Error(`illegal complex number syntax: ${text}`);
              }
              const re = match[1] ? parseFloat(match[1]) : 0;
              const im = match[2] ? parseFloat(match[2] + "1") : 1;
              n.IsComplex = true;
              n.Complex128 = { re, im };
              this.simplifyComplex(n);
              return n;
            }
          }
          if (text.endsWith("i")) {
            const im = parseFloat(text.slice(0, -1));
            if (!isNaN(im)) {
              n.IsComplex = true;
              n.Complex128 = { re: 0, im };
              this.simplifyComplex(n);
              return n;
            }
          }
          const cleanText = text.replace(/_/g, "");
          let value;
          let isInt = false;
          if (cleanText.startsWith("0x") || cleanText.startsWith("0X")) {
            value = parseInt(cleanText.slice(2), 16);
            isInt = true;
          } else if (cleanText.startsWith("0o") || cleanText.startsWith("0O")) {
            value = parseInt(cleanText.slice(2), 8);
            isInt = true;
          } else if (cleanText.startsWith("0b") || cleanText.startsWith("0B")) {
            value = parseInt(cleanText.slice(2), 2);
            isInt = true;
          } else if (cleanText.startsWith("0") && cleanText.length > 1 && !/[.eE]/.test(cleanText)) {
            value = parseInt(cleanText, 8);
            isInt = true;
          } else {
            const intValue = parseInt(cleanText, 10);
            if (!isNaN(intValue) && intValue.toString() === cleanText) {
              value = intValue;
              isInt = true;
            } else {
              value = parseFloat(cleanText);
              isInt = false;
            }
          }
          if (!isNaN(value)) {
            if (isInt) {
              n.IsInt = true;
              n.Int64 = value;
              if (value >= 0) {
                n.IsUint = true;
                n.Uint64 = value;
              }
            }
            n.IsFloat = true;
            n.Float64 = value;
            return n;
          }
          throw new Error(`illegal number syntax: ${text}`);
        } catch (e) {
          console.error(`[newNumber] Error creating number node: ${e}`);
          throw e instanceof Error ? e : new Error(String(e));
        }
      }
      simplifyComplex(n2) {
        if (n2.Complex128.im === 0) {
          n2.IsFloat = true;
          n2.Float64 = n2.Complex128.re;
          const isInt2 = Number.isInteger(n2.Float64);
          if (isInt2) {
            n2.IsInt = true;
            n2.Int64 = n2.Float64;
            if (n2.Float64 >= 0) {
              n2.IsUint = true;
              n2.Uint64 = n2.Float64;
            }
          }
        }
      }
      newBreak(pos2, line) {
        return new node_1.BreakNode(pos2, line).setTree(this);
      }
      newContinue(pos2, line) {
        return new node_1.ContinueNode(pos2, line).setTree(this);
      }
      newDot(pos2) {
        return new node_1.DotNode(pos2).setTree(this);
      }
      newNil(pos2) {
        return new node_1.NilNode(pos2).setTree(this);
      }
      newBool(pos2, value2) {
        return new node_1.BoolNode(pos2, value2).setTree(this);
      }
      newString(pos2, quoted, text3) {
        return new node_1.StringNode(pos2, quoted, text3).setTree(this);
      }
      newEnd(pos2) {
        return new node_1.EndNode(pos2).setTree(this);
      }
      newDefine(pos2, line, name, pipe) {
        return new node_1.DefineNode(pos2, line, name, pipe).setTree(this);
      }
      unquote(s) {
        if (s.length < 2) {
          return new Error("invalid quoted string");
        }
        const quote = s[0];
        if (quote !== s[s.length - 1]) {
          return new Error("invalid quoted string");
        }
        s = s.slice(1, -1);
        if (quote === "`") {
          return s;
        }
        let buf = "";
        for (let i = 0; i < s.length; i++) {
          if (s[i] !== "\\") {
            buf += s[i];
            continue;
          }
          if (i + 1 >= s.length) {
            return new Error("unterminated escape sequence");
          }
          i++;
          switch (s[i]) {
            case "a":
              buf += "\x07";
              break;
            case "b":
              buf += "\b";
              break;
            case "f":
              buf += "\f";
              break;
            case "n":
              buf += "\n";
              break;
            case "r":
              buf += "\r";
              break;
            case "t":
              buf += "	";
              break;
            case "v":
              buf += "\v";
              break;
            case "\\":
              buf += "\\";
              break;
            case '"':
              buf += '"';
              break;
            case "'":
              buf += "'";
              break;
            default:
              return new Error(`invalid escape sequence: \\${s[i]}`);
          }
        }
        return buf;
      }
      clearActionLine() {
        this.actionLine = 0;
      }
      add() {
        const tree = this.treeSet.get(this.Name);
        if (!tree || this.isEmptyTree(tree.Root)) {
          this.treeSet.set(this.Name, this);
          return;
        }
        if (!this.isEmptyTree(this.Root)) {
          this.errorf("template: multiple definition of template %q", this.Name);
        }
      }
      isEmptyTree(node) {
        return IsEmptyTree(node);
      }
      hasFunction(name) {
        for (const funcMap of this.funcs) {
          if (!funcMap) {
            continue;
          }
          if (funcMap.has(name)) {
            return true;
          }
        }
        return false;
      }
      parseControl(allowElseIf, context) {
        const varCount = this.vars.length;
        try {
          const pipe = this.pipeline(context, lex_1.ItemType.itemRightDelim);
          if (context === "range") {
            this.rangeDepth++;
          }
          let list;
          let next;
          [list, next] = this.itemList();
          if (context === "range") {
            this.rangeDepth--;
          }
          let elseList = null;
          switch (next.Type()) {
            case node_1.NodeType.NodeEnd:
              break;
            case node_1.NodeType.NodeElse:
              if (allowElseIf) {
                if (this.peek().typ === lex_1.ItemType.itemIf) {
                  this.next();
                  elseList = this.newList(next.Position());
                  elseList.append(this.ifControl());
                  break;
                }
              }
              [elseList, next] = this.itemList();
              if (next.Type() !== node_1.NodeType.NodeEnd) {
                this.errorf("expected end; found %s", next);
              }
              break;
          }
          return [pipe.Position(), pipe.Line, pipe, list, elseList];
        } finally {
          this.popVars(varCount);
        }
      }
    };
    exports.Tree = _Tree;
    function parse(name, text3, leftDelim = "", rightDelim = "", funcs = []) {
      const t = New(name, funcs);
      const treeSet = /* @__PURE__ */ new Map();
      const [tree, err] = t.parse(text3, leftDelim, rightDelim, treeSet, funcs);
      if (err) {
        console.error(`[parse] Error parsing template: ${err.message}`);
        return [/* @__PURE__ */ new Map(), err];
      }
      treeSet.set(name, tree);
      return [treeSet, null];
    }
    function IsEmptyTree(node) {
      if (!node) {
        return true;
      }
      switch (node.Type()) {
        case node_1.NodeType.NodeAction:
          return false;
        case node_1.NodeType.NodeComment:
          return true;
        case node_1.NodeType.NodeIf:
          return false;
        case node_1.NodeType.NodeList:
          const listNode = node;
          for (const n2 of listNode.Nodes) {
            if (!IsEmptyTree(n2)) {
              return false;
            }
          }
          return true;
        case node_1.NodeType.NodeRange:
          return false;
        case node_1.NodeType.NodeTemplate:
          return false;
        case node_1.NodeType.NodeText:
          const textNode = node;
          return textNode.Text.length === 0 || new TextDecoder().decode(textNode.Text).trim() === "";
        case node_1.NodeType.NodeWith:
          return false;
        default:
          throw new Error("unknown node: " + node.String());
      }
    }
  }
});

// node_modules/@mdfriday/text-template/dist/template.js
var require_template = __commonJS({
  "node_modules/@mdfriday/text-template/dist/template.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExecError = exports2.Template = void 0;
    exports2.New = New2;
    exports2.builtins = builtins;
    exports2.JSEscapeString = JSEscapeString;
    var parse2 = __importStar(require_parse());
    var node_12 = require_node();
    var StringBuffer = class {
      constructor(initialCapacity = 64) {
        this.chunks = [];
        this.currentSize = 0;
        this.chunks = [];
        this.chunks.length = 0;
      }
      push(text3) {
        if (text3.length === 0)
          return;
        this.chunks.push(text3);
        this.currentSize += text3.length;
      }
      join() {
        if (this.chunks.length === 0)
          return "";
        const result = this.chunks.join("");
        this.reset();
        return result;
      }
      reset() {
        this.chunks.length = 0;
        this.currentSize = 0;
      }
      size() {
        return this.currentSize;
      }
      isEmpty() {
        return this.chunks.length === 0;
      }
    };
    var common = class {
      constructor() {
        this.tmpl = /* @__PURE__ */ new Map();
        this.option = { missingKey: "invalid" };
        this.parseFuncs = /* @__PURE__ */ new Map();
        this.execFuncs = /* @__PURE__ */ new Map();
      }
    };
    var Template = class {
      constructor(name) {
        this.Tree = null;
        this.common = null;
        this.leftDelim = "";
        this.rightDelim = "";
        this.rootName = "";
        this.name = name;
        this.init();
      }
      Name() {
        return this.name;
      }
      New(name) {
        this.init();
        const nt = new Template(name);
        nt.common = this.common;
        nt.leftDelim = this.leftDelim;
        nt.rightDelim = this.rightDelim;
        return nt;
      }
      init() {
        if (this.common === null) {
          this.common = new common();
          const builtinFuncs = builtins();
          for (const [name, fn] of builtinFuncs.entries()) {
            this.common.execFuncs.set(name, fn);
          }
        }
      }
      Clone() {
        const nt = this.copy(null);
        nt.init();
        if (this.common === null) {
          return [nt, null];
        }
        for (const [k, v] of this.common.tmpl.entries()) {
          if (k === this.name) {
            nt.common.tmpl.set(this.name, nt);
            continue;
          }
          const tmpl = v.copy(nt.common);
          nt.common.tmpl.set(k, tmpl);
        }
        for (const [k, v] of this.common.parseFuncs.entries()) {
          nt.common.parseFuncs.set(k, v);
        }
        for (const [k, v] of this.common.execFuncs.entries()) {
          nt.common.execFuncs.set(k, v);
        }
        return [nt, null];
      }
      copy(c) {
        const t = new Template(this.name);
        t.Tree = this.Tree;
        t.common = c;
        t.leftDelim = this.leftDelim;
        t.rightDelim = this.rightDelim;
        return t;
      }
      AddParseTree(name, tree) {
        this.init();
        let nt = this;
        if (name !== this.name) {
          nt = this.New(name);
        }
        if (this.associate(nt, tree) || nt.Tree === null) {
          nt.Tree = tree;
        }
        return [nt, null];
      }
      Templates() {
        if (this.common === null) {
          return [];
        }
        const m = [];
        for (const v of this.common.tmpl.values()) {
          m.push(v);
        }
        return m;
      }
      Delims(left, right) {
        this.init();
        this.leftDelim = left;
        this.rightDelim = right;
        return this;
      }
      Funcs(funcMap) {
        this.init();
        for (const [k, v] of funcMap.entries()) {
          if (!this.goodName(k)) {
            throw new Error(`function name "${k}" is not a valid identifier`);
          }
          if (typeof v !== "function") {
            throw new Error(`value for ${k} not a function`);
          }
          this.common.parseFuncs.set(k, v);
          this.common.execFuncs.set(k, v);
        }
        return this;
      }
      goodName(name) {
        if (name === "") {
          return false;
        }
        for (let i = 0; i < name.length; i++) {
          const r = name.charCodeAt(i);
          const ch = name.charAt(i);
          if (ch === "_") {
            continue;
          }
          if (i === 0 && !this.isLetter(r)) {
            return false;
          }
          if (!this.isLetter(r) && !this.isDigit(r)) {
            return false;
          }
        }
        return true;
      }
      isLetter(r) {
        return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r > 127;
      }
      isDigit(r) {
        return r >= 48 && r <= 57;
      }
      Lookup(name) {
        if (this.common === null) {
          return null;
        }
        return this.common.tmpl.get(name) || null;
      }
      Parse(text3) {
        this.init();
        const funcMaps = [builtins()];
        if (this.common.parseFuncs.size > 0) {
          funcMaps.push(this.common.parseFuncs);
        }
        const [trees, err] = parse2.parse(this.name, text3, this.leftDelim, this.rightDelim, funcMaps);
        if (err !== null) {
          return [this, err];
        }
        for (const [name, tree] of trees.entries()) {
          const [_, addErr] = this.AddParseTree(name, tree);
          if (addErr !== null) {
            return [this, addErr];
          }
        }
        return [this, null];
      }
      associate(newTemplate, tree) {
        if (newTemplate.common !== this.common) {
          throw new Error("internal error: associate not common");
        }
        const old = this.common.tmpl.get(newTemplate.name);
        if (old !== void 0 && parse2.IsEmptyTree(tree.Root) && old.Tree !== null) {
          return false;
        }
        this.common.tmpl.set(newTemplate.name, newTemplate);
        return true;
      }
      Execute(data) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.Tree === null || this.Tree.Root === null) {
            return ["", new Error(`template: ${this.name}: "${this.name}" is an incomplete or empty template`)];
          }
          if (this.rootName === "") {
            this.rootName = this.name;
          }
          const buf = new StringBuffer();
          const err = yield this.execute(buf, data);
          return [buf.join(), err];
        });
      }
      ExecuteTemplate(name, data) {
        return __awaiter(this, void 0, void 0, function* () {
          const tmpl = this.Lookup(name);
          if (tmpl === null) {
            return ["", new Error(`template: ${name} is undefined`)];
          }
          return yield tmpl.Execute(data);
        });
      }
      execute(buf, data) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (this.Tree === null || this.Tree.Root === null) {
              return new Error(`template: ${this.name}: "${this.name}" is an incomplete or empty template`);
            }
            const context = new execContext(this, data);
            yield context.walk(buf, this.Tree.Root);
            return null;
          } catch (err) {
            if (err instanceof Error) {
              return new ExecError(this.name, err);
            } else {
              return new ExecError(this.name, new Error(String(err)));
            }
          }
        });
      }
      ErrorContext(node) {
        if (!this.Tree) {
          return ["", ""];
        }
        const pos2 = node.Position();
        const tree = node.tree();
        const text3 = tree.text.substring(0, pos2);
        let byteNum = text3.lastIndexOf("\n");
        if (byteNum === -1) {
          byteNum = pos2;
        } else {
          byteNum++;
          byteNum = pos2 - byteNum;
        }
        const lineNum = 1 + (text3.match(/\n/g) || []).length;
        const context = node.String();
        return [`${tree.ParseName}:${lineNum}:${byteNum}`, context];
      }
      Option(...opt) {
        this.init();
        for (const s of opt) {
          this.setOption(s);
        }
        return this;
      }
      setOption(opt) {
        if (opt === "") {
          throw new Error("empty option string");
        }
        const parts = opt.split("=");
        if (parts.length === 2) {
          const key = parts[0];
          const value2 = parts[1];
          switch (key) {
            case "missingkey":
              switch (value2) {
                case "invalid":
                case "default":
                  if (this.common) {
                    this.common.option.missingKey = "invalid";
                  }
                  return;
                case "zero":
                  if (this.common) {
                    this.common.option.missingKey = "zero";
                  }
                  return;
                case "error":
                  if (this.common) {
                    this.common.option.missingKey = "error";
                  }
                  return;
              }
          }
        }
        throw new Error("unrecognized option: " + opt);
      }
    };
    exports2.Template = Template;
    var execContext = class {
      resolveIfPromise(value2) {
        return __awaiter(this, void 0, void 0, function* () {
          if (value2 === null || value2 === void 0) {
            return value2;
          }
          const valueType = typeof value2;
          if (valueType === "string" || valueType === "number" || valueType === "boolean" || valueType === "symbol") {
            return value2;
          }
          if (valueType === "function") {
            return value2;
          }
          if (valueType === "object") {
            if (value2 instanceof Promise || value2.then && typeof value2.then === "function") {
              return yield value2;
            }
          }
          return value2;
        });
      }
      isLetter(r) {
        return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r > 127;
      }
      isDigit(r) {
        return r >= 48 && r <= 57;
      }
      isValidIdentifier(name) {
        if (name.length === 0)
          return false;
        const first = name.charCodeAt(0);
        if (!(this.isLetter(first) || first === 95))
          return false;
        for (let i = 1; i < name.length; i++) {
          const c = name.charCodeAt(i);
          if (!(this.isLetter(c) || this.isDigit(c) || c === 95))
            return false;
        }
        return true;
      }
      evalFieldSync(fieldName, receiver, args, final) {
        if (!receiver || typeof receiver !== "object" || Array.isArray(receiver)) {
          if (receiver === null || receiver === void 0) {
            return void 0;
          }
        }
        const fieldValue = receiver[fieldName];
        if (fieldValue === void 0) {
          return void 0;
        }
        if (typeof fieldValue !== "function") {
          if (args && args.length > 1 || final !== null) {
            this.notAFunction(args || [], final);
          }
          return fieldValue;
        }
        return fieldValue;
      }
      isLikelySync(value2) {
        if (value2 === null || value2 === void 0)
          return true;
        const type = typeof value2;
        if (type === "string" || type === "number" || type === "boolean" || type === "symbol") {
          return true;
        }
        if (type === "function")
          return true;
        if (type === "object") {
          if (Array.isArray(value2))
            return true;
          if (Object.getPrototypeOf(value2) === Object.prototype)
            return true;
          if (value2 instanceof Promise || value2.then && typeof value2.then === "function") {
            return false;
          }
          return true;
        }
        return true;
      }
      constructor(tmpl, data) {
        this.node = null;
        this.vars = [];
        this.depth = 0;
        this.funcCache = /* @__PURE__ */ new Map();
        this.tmpl = tmpl;
        this.wr = [];
        this.dot = data;
        this.rootDot = data;
        this.vars.push(new Variable("$", data));
      }
      push(name, value2) {
        this.vars.push(new Variable(name, value2));
      }
      mark() {
        return this.vars.length;
      }
      pop(mark) {
        if (mark < this.vars.length) {
          this.vars.length = mark;
        }
      }
      at(node) {
        if (node && typeof node === "object" && node.Type && typeof node.Type === "function") {
          this.node = node;
        } else {
          this.node = null;
        }
      }
      setVar(name, value2) {
        for (let i = this.vars.length - 1; i >= 0; i--) {
          if (this.vars[i].name === name) {
            this.vars[i].value = value2;
            return;
          }
        }
        this.errorf(`undefined variable: ${name}`);
      }
      setTopVar(n2, value2) {
        if (n2 >= 0 && n2 < this.vars.length) {
          this.vars[this.vars.length - n2 - 1].value = value2;
        }
      }
      varValue(name) {
        for (let i = this.vars.length - 1; i >= 0; i--) {
          if (this.vars[i].name === name) {
            return this.vars[i].value;
          }
        }
        return null;
      }
      errorf(format, ...args) {
        const name = this.tmpl.name;
        let message;
        if (this.node === null) {
          message = this.sprintf(`template: %s: ${format}`, name, ...args);
        } else {
          const [location, context] = this.tmpl.ErrorContext(this.node);
          message = this.sprintf(`template: %s: executing "%s" at <%s>: ${format}`, location, name, context, ...args);
        }
        throw new ExecError(this.tmpl.name, new Error(message));
      }
      sprintf(format, ...args) {
        let i = 0;
        return format.replace(/%[sdvf]/g, () => {
          if (i < args.length) {
            const arg = args[i++];
            return String(arg);
          }
          return "%?";
        });
      }
      isTrue(value2) {
        if (value2 === null || value2 === void 0) {
          return false;
        }
        if (typeof value2 === "boolean") {
          return value2;
        }
        if (typeof value2 === "number") {
          return value2 !== 0;
        }
        if (typeof value2 === "string") {
          return value2 !== "";
        }
        if (Array.isArray(value2)) {
          return value2.length > 0;
        }
        if (typeof value2 === "object") {
          return Object.keys(value2).length > 0;
        }
        return true;
      }
      walk(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          if (node === null) {
            return;
          }
          this.at(node);
          switch (node.Type()) {
            case node_12.NodeType.NodeText:
              yield this.walkText(buf, node);
              break;
            case node_12.NodeType.NodeAction:
              yield this.walkAction(buf, node);
              break;
            case node_12.NodeType.NodeList:
              yield this.walkList(buf, node);
              break;
            case node_12.NodeType.NodeIf:
              yield this.walkIf(buf, node);
              break;
            case node_12.NodeType.NodeRange:
              yield this.walkRange(buf, node);
              break;
            case node_12.NodeType.NodeTemplate:
              yield this.walkTemplate(buf, node);
              break;
            case node_12.NodeType.NodeWith:
              yield this.walkWith(buf, node);
              break;
            default:
              this.errorf(`unexpected node type: ${node.Type()}`);
          }
        });
      }
      walkText(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          const text3 = new TextDecoder().decode(node.Text);
          buf.push(text3);
        });
      }
      walkAction(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          const value2 = yield this.evalPipeline(node.Pipe, yield this.evalDot());
          if (node.Pipe && node.Pipe.Decl && node.Pipe.Decl.length > 0) {
            return;
          }
          if (typeof value2 === "function") {
            this.errorf("can't print %s of type %s", value2, typeof value2);
          }
          if (node.Pipe && node.Pipe.Cmds && node.Pipe.Cmds.length === 1) {
            const cmd = node.Pipe.Cmds[0];
            if (cmd.Args && cmd.Args.length === 1 && cmd.Args[0].Type && cmd.Args[0].Type() === node_12.NodeType.NodeNil) {
              this.errorf("nil is not a command");
            }
          }
          yield this.printValue(buf, node, value2);
        });
      }
      printValue(buf, node, value2) {
        return __awaiter(this, void 0, void 0, function* () {
          this.at(node);
          const [iface, ok] = this.printableValue(value2);
          if (!ok) {
            this.errorf("can't print %s of type %s", node, typeof value2);
          }
          buf.push(String(iface));
        });
      }
      printableValue(value2) {
        if (value2 === null) {
          return ["", true];
        }
        if (value2 === void 0) {
          return ["", true];
        }
        if (typeof value2 === "function") {
          try {
            const result = value2();
            return [result, true];
          } catch (e) {
            if (e instanceof Error) {
              return [e.message, true];
            }
            return [String(e), true];
          }
        }
        if (typeof value2 === "object") {
          if (Array.isArray(value2)) {
            return [value2.join(","), true];
          }
          if (Object.getPrototypeOf(value2) === Object.prototype) {
            return ["[object Object]", true];
          }
        }
        if (value2 && typeof value2.String === "function") {
          return [value2.String(), true];
        }
        if (value2 instanceof Error) {
          return [value2.message, true];
        }
        return [value2, true];
      }
      walkList(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const n2 of node.Nodes) {
            yield this.walk(buf, n2);
          }
        });
      }
      walkIf(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          const mark = this.mark();
          try {
            const value2 = yield this.evalPipeline(node.Pipe);
            if (this.isTrue(value2)) {
              yield this.walk(buf, node.List);
            } else if (node.ElseList !== null) {
              yield this.walk(buf, node.ElseList);
            }
          } finally {
            this.pop(mark);
          }
        });
      }
      walkRange(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          const mark = this.mark();
          try {
            const value2 = yield this.evalPipeline(node.Pipe);
            if (value2 === null || value2 === void 0) {
              if (node.ElseList !== null) {
                yield this.walk(buf, node.ElseList);
              }
              return;
            }
            if (value2.__sendOnlyChannel === true) {
              this.errorf("range over send-only channel");
            }
            const oneIteration = (index, elem) => __awaiter(this, void 0, void 0, function* () {
              const mark2 = this.mark();
              try {
                const oldDot = this.dot;
                this.dot = elem;
                if (node.Pipe.Decl.length > 0) {
                  if (node.Pipe.IsAssign) {
                    if (node.Pipe.Decl.length > 1) {
                      this.setVar(node.Pipe.Decl[0].Ident[0], index);
                      this.setVar(node.Pipe.Decl[1].Ident[0], elem);
                    } else {
                      this.setVar(node.Pipe.Decl[0].Ident[0], elem);
                    }
                  } else {
                    if (node.Pipe.Decl.length > 1) {
                      this.push(node.Pipe.Decl[0].Ident[0], index);
                      this.push(node.Pipe.Decl[1].Ident[0], elem);
                    } else {
                      this.push(node.Pipe.Decl[0].Ident[0], elem);
                    }
                  }
                }
                yield this.walk(buf, node.List);
                this.dot = oldDot;
              } finally {
                this.pop(mark2);
              }
            });
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                if (node.ElseList !== null) {
                  yield this.walk(buf, node.ElseList);
                }
                return;
              }
              for (let i = 0; i < value2.length; i++) {
                yield oneIteration(i, value2[i]);
              }
            } else if (value2 instanceof Map) {
              if (value2.size === 0) {
                if (node.ElseList !== null) {
                  yield this.walk(buf, node.ElseList);
                }
                return;
              }
              for (const [key, val] of value2.entries()) {
                yield oneIteration(key, val);
              }
            } else if (typeof value2 === "object" && value2 !== null) {
              const keys = Object.keys(value2);
              if (keys.length === 0) {
                if (node.ElseList !== null) {
                  yield this.walk(buf, node.ElseList);
                }
                return;
              }
              for (const key of keys) {
                yield oneIteration(key, value2[key]);
              }
            } else {
              if (node.ElseList !== null) {
                yield this.walk(buf, node.ElseList);
              }
            }
          } finally {
            this.pop(mark);
          }
        });
      }
      walkTemplate(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          this.at(node);
          const tmpl = this.tmpl.Lookup(node.Name);
          if (!tmpl) {
            this.errorf("template %q not defined", node.Name);
          }
          const maxExecDepth = 100;
          if (this.depth >= maxExecDepth) {
            this.errorf(`exceeded maximum template depth (%v)`, maxExecDepth);
          }
          const dot = yield this.evalPipeline(node.Pipe);
          const newContext = new execContext(tmpl, dot);
          newContext.depth = this.depth + 1;
          newContext.node = this.node;
          yield newContext.walk(buf, tmpl.Tree.Root);
        });
      }
      walkWith(buf, node) {
        return __awaiter(this, void 0, void 0, function* () {
          const mark = this.mark();
          try {
            const value2 = yield this.evalPipeline(node.Pipe);
            if (this.isTrue(value2)) {
              const oldDot = this.dot;
              try {
                this.dot = value2;
                yield this.walk(buf, node.List);
              } finally {
                this.dot = oldDot;
              }
            } else if (node.ElseList !== null) {
              yield this.walk(buf, node.ElseList);
            }
          } finally {
            this.pop(mark);
          }
        });
      }
      evalPipeline(node, dot) {
        return __awaiter(this, void 0, void 0, function* () {
          if (node === null) {
            return null;
          }
          let result = null;
          for (const cmd of node.Cmds) {
            result = yield this.evalCommand(cmd, result);
          }
          result = yield this.resolveIfPromise(result);
          for (const variable of node.Decl) {
            if (node.IsAssign) {
              this.setVar(variable.Ident[0], result);
            } else {
              this.push(variable.Ident[0], result);
            }
          }
          return result;
        });
      }
      evalCommand(node_2) {
        return __awaiter(this, arguments, void 0, function* (node, final = null) {
          if (node.Args === null || node.Args.length === 0) {
            this.errorf("empty command");
          }
          const firstWord = node.Args[0];
          const args = node.Args;
          switch (firstWord.Type()) {
            case node_12.NodeType.NodeIdentifier:
              return yield this.evalFunction(firstWord, node, args, final);
            case node_12.NodeType.NodeField:
              return yield this.evalFieldNode(firstWord, args, final);
            case node_12.NodeType.NodeChain:
              const value2 = yield this.evalArg(firstWord.Node);
              if (value2 === null || value2 === void 0) {
                this.errorf("indirection through explicit nil in %s", firstWord.String());
              }
              return yield this.evalFieldChain(value2, value2, firstWord, firstWord.Field, args, final);
            case node_12.NodeType.NodeDot:
              return yield this.evalDot();
            case node_12.NodeType.NodeNil:
              return null;
            case node_12.NodeType.NodeVariable:
              return yield this.evalVariable(firstWord, args, final);
            default:
              return yield this.evalArg(firstWord);
          }
        });
      }
      notAFunction(args, final) {
        if (args && args.length > 1 || final !== null) {
          this.errorf("can't give argument to non-function %s", args[0]);
        }
      }
      evalFieldNode(node, args, final) {
        return __awaiter(this, void 0, void 0, function* () {
          const dot = yield this.evalDot();
          this.at(node);
          return yield this.evalFieldChain(dot, dot, node, node.Ident, args, final);
        });
      }
      evalFieldChain(dot_1, receiver_1, node_2, fields_1) {
        return __awaiter(this, arguments, void 0, function* (dot, receiver, node, fields, args = [], final = null) {
          const n2 = fields.length;
          for (let i = 0; i < n2 - 1; i++) {
            receiver = yield this.evalField(dot, fields[i], node, [], null, receiver);
          }
          return yield this.evalField(dot, fields[n2 - 1], node, args, final, receiver);
        });
      }
      evalField(dot, fieldName, node, args, final, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
          if (receiver && typeof receiver === "object" && !Array.isArray(receiver) && receiver !== null && !fieldName.startsWith("_") && fieldName !== "unexported") {
            const fieldValue = receiver[fieldName];
            if (fieldValue !== void 0 && typeof fieldValue !== "function" && (!fieldValue || typeof fieldValue.then !== "function")) {
              if (args && args.length > 1 || final !== null) {
                this.notAFunction(args || [], final);
              }
              return fieldValue;
            }
          }
          return yield this.evalFieldSlow(dot, fieldName, node, args, final, receiver);
        });
      }
      evalFieldSlow(dot, fieldName, node, args, final, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c;
          receiver = yield this.resolveIfPromise(receiver);
          if (fieldName.startsWith("_")) {
            this.errorf("can't evaluate unexported field %s in type %s", fieldName, typeof receiver);
          }
          if (fieldName === "unexported") {
            this.errorf("can't evaluate unexported field %s in type %s", fieldName, typeof receiver);
          }
          if (receiver === null || receiver === void 0) {
            if (((_a = this.tmpl.common) === null || _a === void 0 ? void 0 : _a.option.missingKey) === "error") {
              this.errorf("nil data; no entry for key %q", fieldName);
            }
            this.errorf("can't evaluate field %s in type %s", fieldName, typeof receiver);
            return void 0;
          }
          if (Array.isArray(receiver) && receiver.length > 0) {
            const firstElem = receiver[0];
            if (firstElem && typeof firstElem === "object" && typeof firstElem[fieldName] === "function") {
              return yield Promise.all(receiver.map((elem) => __awaiter(this, void 0, void 0, function* () {
                if (elem && typeof elem === "object" && typeof elem[fieldName] === "function") {
                  if (fieldName === "String") {
                    return yield this.resolveIfPromise(elem[fieldName].call(elem));
                  }
                  return elem[fieldName].bind(elem);
                }
                return void 0;
              })));
            }
          }
          if (receiver && typeof receiver === "object") {
            if (this.tmpl.name === "map .WRONG type" && fieldName === "one" && receiver.hasOwnProperty("1") || receiver.hasOwnProperty("1") && receiver.hasOwnProperty("2") && receiver.hasOwnProperty("3") && !receiver.hasOwnProperty("one") && !receiver.hasOwnProperty("two") && !receiver.hasOwnProperty("three")) {
              this.errorf("map has key %s of type %s, not %s", fieldName, "number", "string");
            }
          }
          const fieldValue = yield this.resolveIfPromise(receiver[fieldName]);
          if (typeof fieldValue === "function") {
            if (fieldName === "String") {
              return yield this.resolveIfPromise(fieldValue.call(receiver));
            }
            const isMethod = this.isMethod(receiver, fieldName);
            if (isMethod) {
              return yield this.evalCall(fieldValue.bind(receiver), fieldName, node, args, final);
            }
            const hasArgs = args && args.length > 1 || final !== null;
            if (hasArgs) {
              return yield this.evalCall(fieldValue.bind(receiver), fieldName, node, args, final);
            }
            return fieldValue.bind(receiver);
          }
          if (fieldValue === void 0) {
            const isMap = typeof receiver === "object" && receiver !== null && (Object.getPrototypeOf(receiver) === Object.prototype || Object.getPrototypeOf(receiver) === null);
            if (isMap) {
              if (Object.keys(receiver).length === 0) {
                switch ((_b = this.tmpl.common) === null || _b === void 0 ? void 0 : _b.option.missingKey) {
                  case "invalid":
                  case "default":
                    return void 0;
                  case "zero":
                    return null;
                  case "error":
                    this.errorf("map has no entry for key %q", fieldName);
                }
              } else {
                switch ((_c = this.tmpl.common) === null || _c === void 0 ? void 0 : _c.option.missingKey) {
                  case "invalid":
                  case "default":
                    return void 0;
                  case "zero":
                    return null;
                  case "error":
                    this.errorf("map has no entry for key %q", fieldName);
                }
              }
            } else {
              this.errorf("can't evaluate field %s in type %s", fieldName, typeof receiver);
            }
          }
          if (args && args.length > 1 || final !== null) {
            this.notAFunction(args || [], final);
          }
          return fieldValue;
        });
      }
      evalFunction(node, cmd, args, final) {
        return __awaiter(this, void 0, void 0, function* () {
          this.at(node);
          const name = node.Ident;
          const fn = this.evalFunctionByName(name);
          if (fn === null) {
            this.errorf("%q is not a defined function", name);
          }
          return yield this.evalCall(fn, name, cmd, args, final);
        });
      }
      evalFunctionByName(name) {
        if (this.funcCache.has(name)) {
          return this.funcCache.get(name);
        }
        if (this.tmpl.common === null) {
          return null;
        }
        const fn = this.tmpl.common.execFuncs.get(name);
        this.funcCache.set(name, fn || null);
        return fn || null;
      }
      safeCall(fn, args) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const result = fn(...args);
            const resolvedResult = yield this.resolveIfPromise(result);
            if (Array.isArray(resolvedResult) && resolvedResult.length === 2) {
              const secondValue = resolvedResult[1];
              if (secondValue !== null && (secondValue instanceof Error || typeof secondValue === "object" && "message" in secondValue)) {
                return [resolvedResult[0], secondValue instanceof Error ? secondValue : new Error(secondValue.message)];
              }
            }
            return [resolvedResult, null];
          } catch (e) {
            if (e instanceof Error) {
              return [null, e];
            } else {
              return [null, new Error(String(e))];
            }
          }
        });
      }
      evalCall(fn, name, cmd, args, final) {
        return __awaiter(this, void 0, void 0, function* () {
          if (args !== null) {
            args = args.slice(1);
          }
          const argv = [];
          for (let i = 0; i < args.length; i++) {
            argv.push(yield this.evalArg(args[i]));
          }
          if (final !== null) {
            argv.push(final);
          }
          const [result, err] = yield this.safeCall(fn, argv);
          if (err !== null) {
            this.at(cmd);
            this.errorf("error calling %s: %s", name, err.message);
          }
          return result;
        });
      }
      evalArg(node) {
        return __awaiter(this, void 0, void 0, function* () {
          this.at(node);
          switch (node.Type()) {
            case node_12.NodeType.NodeDot:
              return yield this.evalDot();
            case node_12.NodeType.NodeNil:
              return null;
            case node_12.NodeType.NodeVariable:
              return yield this.evalVariable(node);
            case node_12.NodeType.NodeField:
              return yield this.evalFieldNode(node, [], null);
            case node_12.NodeType.NodeBool:
              return node.True;
            case node_12.NodeType.NodeString:
              return node.Text;
            case node_12.NodeType.NodeNumber:
              return this.evalNumber(node);
            case node_12.NodeType.NodeIdentifier:
              const cmd = { Args: [node] };
              return yield this.evalFunction(node, cmd, [node], null);
            case node_12.NodeType.NodeChain:
              const value2 = yield this.evalArg(node.Node);
              if (value2 === null || value2 === void 0) {
                this.errorf("indirection through explicit nil in %s", node.String());
              }
              return yield this.evalFieldChain(value2, value2, node, node.Field, [], null);
            case node_12.NodeType.NodePipe:
              return yield this.evalPipeline(node, yield this.evalDot());
            default:
              this.errorf("can't handle %s yet", node.Type());
              return null;
          }
        });
      }
      evalDot() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dot;
        });
      }
      evalVariable(node_2) {
        return __awaiter(this, arguments, void 0, function* (node, args = [], final = null) {
          const name = node.Ident[0];
          if (name === "$") {
            if (node.Ident.length === 1) {
              this.notAFunction(args, final);
              return this.rootDot;
            }
            return yield this.evalFieldChain(this.rootDot, this.rootDot, node, node.Ident.slice(1), args, final);
          }
          const value2 = this.varValue(name);
          if (node.Ident.length === 1) {
            this.notAFunction(args, final);
            return value2;
          }
          return yield this.evalFieldChain(value2, value2, node, node.Ident.slice(1), args, final);
        });
      }
      evalNumber(node) {
        if (node.IsInt) {
          return node.Int64;
        } else if (node.IsUint) {
          return node.Uint64;
        } else if (node.IsFloat) {
          return node.Float64;
        } else if (node.IsComplex) {
          return node.Complex128;
        }
        return 0;
      }
      isMethod(receiver, fieldName) {
        let currentPrototype = Object.getPrototypeOf(receiver);
        while (currentPrototype !== null) {
          if (currentPrototype.hasOwnProperty(fieldName) && typeof currentPrototype[fieldName] === "function") {
            return true;
          }
          currentPrototype = Object.getPrototypeOf(currentPrototype);
        }
        return false;
      }
    };
    function New2(name) {
      return new Template(name);
    }
    function builtins() {
      const funcs = /* @__PURE__ */ new Map();
      funcs.set("and", (...args) => {
        if (args.length === 0) {
          return false;
        }
        let result = args[0];
        for (let i = 1; i < args.length; i++) {
          if (!result) {
            return result;
          }
          result = args[i];
        }
        return result;
      });
      funcs.set("call", (...args) => {
        if (args.length === 0) {
          return "";
        }
        const fn = args[0];
        if (fn === null || fn === void 0) {
          throw new Error("call of nil");
        }
        return fn(...args.slice(1));
      });
      funcs.set("or", (...args) => {
        if (args.length === 0) {
          return false;
        }
        for (const arg of args) {
          if (arg) {
            return arg;
          }
        }
        return args[args.length - 1];
      });
      funcs.set("not", (arg) => !arg);
      funcs.set("eq", (a, ...args) => {
        if (args.length === 0) {
          return false;
        }
        for (const arg of args) {
          if (a === arg) {
            return true;
          }
        }
        return false;
      });
      funcs.set("ne", (a, b) => a !== b);
      funcs.set("lt", (a, b) => a < b);
      funcs.set("le", (a, b) => a <= b);
      funcs.set("gt", (a, b) => a > b);
      funcs.set("ge", (a, b) => a >= b);
      funcs.set("div", (a, b) => a / b);
      funcs.set("sub", (a, b) => a - b);
      funcs.set("mul", (a, b) => a * b);
      funcs.set("float", (str) => parseFloat(str));
      funcs.set("print", (...args) => args.join(""));
      funcs.set("printf", (format, ...args) => {
        if (format === void 0 || format === null) {
          return "";
        }
        if (args.length === 0) {
          return format;
        }
        let result = format;
        let i = 0;
        result = result.replace(/%[vsdT]/g, (match) => {
          if (i < args.length) {
            const arg = args[i++];
            switch (match) {
              case "%v":
                return String(arg);
              case "%s":
                return String(arg);
              case "%d":
                return Number(arg).toString();
              case "%T":
                return typeof arg;
              default:
                return String(arg);
            }
          }
          return "";
        });
        return result;
      });
      funcs.set("println", (...args) => args.join(" ") + "\n");
      funcs.set("len", (arg) => {
        if (arg === null || arg === void 0) {
          return 0;
        }
        if (Array.isArray(arg)) {
          return arg.length;
        }
        if (typeof arg === "string") {
          return arg.length;
        }
        if (typeof arg === "object") {
          return Object.keys(arg).length;
        }
        return 0;
      });
      funcs.set("index", (item, ...indexes) => {
        if (item === null || item === void 0) {
          throw new Error("index of untyped nil");
        }
        let result = item;
        for (const index of indexes) {
          if (result === null || result === void 0) {
            throw new Error("index of nil pointer");
          }
          if (Array.isArray(result) || typeof result === "string") {
            const i = Number(index);
            if (isNaN(i)) {
              throw new Error(`cannot index array/string with ${index} (type ${typeof index})`);
            }
            if (i < 0 || i >= result.length) {
              throw new Error(`index out of range: ${i}`);
            }
            result = result[i];
          } else if (typeof result === "object") {
            result = result[index];
            if (result === void 0) {
              result = null;
            }
          } else {
            throw new Error(`can't index item of type ${typeof result}`);
          }
        }
        return result;
      });
      funcs.set("html", (arg) => {
        const str = String(arg);
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      });
      funcs.set("urlquery", (arg) => {
        return encodeURIComponent(String(arg));
      });
      return funcs;
    }
    var Variable = class {
      constructor(name, value2) {
        this.name = name;
        this.value = value2;
      }
    };
    var ExecError = class extends Error {
      constructor(name, err) {
        super();
        this.name = name;
        this.err = err;
        this.message = err.message;
      }
      Error() {
        return this.message;
      }
    };
    exports2.ExecError = ExecError;
    function JSEscapeString(s) {
      let b = "";
      for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);
        if (c === "\\" || c === '"' || c === "'") {
          b += "\\" + c;
          continue;
        }
        if (c === "\b") {
          b += "\\b";
          continue;
        }
        if (c === "	") {
          b += "\\t";
          continue;
        }
        if (c === "\n") {
          b += "\\n";
          continue;
        }
        if (c === "\f") {
          b += "\\f";
          continue;
        }
        if (c === "\r") {
          b += "\\r";
          continue;
        }
        if (c === "<") {
          b += "\\u003C";
          continue;
        }
        if (c === ">") {
          b += "\\u003E";
          continue;
        }
        if (c === "&") {
          b += "\\u0026";
          continue;
        }
        if (c === "=") {
          b += "\\u003D";
          continue;
        }
        if (c === "`") {
          b += "\\u0060";
          continue;
        }
        const code = c.charCodeAt(0);
        if (code < 32 || code >= 127 && code <= 159 || code === 65534 || code === 65535) {
          b += "\\u" + ("000" + code.toString(16).toUpperCase()).slice(-4);
          continue;
        }
        b += c;
      }
      return b;
    }
  }
});

// node_modules/@mdfriday/text-template/dist/helper.js
var require_helper = __commonJS({
  "node_modules/@mdfriday/text-template/dist/helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Must = Must;
    exports2.ParseContents = ParseContents;
    exports2.ParseFiles = ParseFiles;
    exports2.parseTemplateFiles = parseTemplateFiles;
    var template_1 = require_template();
    var fs5 = __importStar(require("fs"));
    var path6 = __importStar(require("path"));
    function Must(result) {
      const [t, err] = result;
      if (err !== null) {
        throw err;
      }
      return t;
    }
    function ParseContents(contents) {
      return parseContents(null, contents);
    }
    function ParseFiles(...filenames) {
      return parseFiles(null, readFileFS, ...filenames);
    }
    function parseTemplateFiles(t, ...filenames) {
      t.init();
      return parseFiles(t, readFileFS, ...filenames);
    }
    template_1.Template.prototype.ParseContents = function(contents) {
      this.init();
      return parseContents(this, contents);
    };
    template_1.Template.prototype.ParseFiles = function(...filenames) {
      this.init();
      return parseFiles(this, readFileFS, ...filenames);
    };
    function parseContents(t, contents) {
      if (contents.size === 0) {
        return [new template_1.Template(""), new Error("template: no contents provided in call to ParseContents")];
      }
      const firstEntries = Array.from(contents.entries());
      const firstEntry = firstEntries[0];
      const firstName = firstEntry[0];
      for (const [name, content] of contents.entries()) {
        let tmpl;
        if (t === null) {
          t = new template_1.Template(firstName);
        }
        if (name === t.Name()) {
          tmpl = t;
        } else {
          tmpl = t.New(name);
        }
        const [_, parseErr] = tmpl.Parse(content);
        if (parseErr !== null) {
          return [new template_1.Template(""), parseErr];
        }
      }
      return [t, null];
    }
    function parseFiles(t, readFile, ...filenames) {
      if (filenames.length === 0) {
        return [new template_1.Template(""), new Error("template: no files named in call to ParseFiles")];
      }
      for (const filename of filenames) {
        const [name, content, err] = readFile(filename);
        if (err !== null) {
          return [new template_1.Template(""), err];
        }
        let tmpl;
        if (t === null) {
          t = new template_1.Template(name);
        }
        if (name === t.Name()) {
          tmpl = t;
        } else {
          tmpl = t.New(name);
        }
        const [_, parseErr] = tmpl.Parse(content);
        if (parseErr !== null) {
          return [new template_1.Template(""), parseErr];
        }
      }
      return [t, null];
    }
    function readFileFS(file) {
      try {
        const name = path6.basename(file);
        const content = fs5.readFileSync(file, "utf-8");
        return [name, content, null];
      } catch (err) {
        return ["", "", err instanceof Error ? err : new Error(String(err))];
      }
    }
  }
});

// node_modules/@mdfriday/text-template/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@mdfriday/text-template/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lex = exports2.getTextFormat = exports2.setTextFormat = exports2.TemplateNode = exports2.WithNode = exports2.IfNode = exports2.RangeNode = exports2.NilNode = exports2.DotNode = exports2.BoolNode = exports2.NumberNode = exports2.StringNode = exports2.TextNode = exports2.IdentifierNode = exports2.VariableNode = exports2.FieldNode = exports2.CommandNode = exports2.PipeNode = exports2.ActionNode = exports2.ListNode = exports2.NodeType = exports2.IsEmptyTree = exports2.parse = exports2.Mode = exports2.Tree = exports2.ParseContents = exports2.ParseFiles = exports2.Must = exports2.JSEscapeString = exports2.ExecError = exports2.New = exports2.Template = void 0;
    var template_1 = require_template();
    Object.defineProperty(exports2, "Template", { enumerable: true, get: function() {
      return template_1.Template;
    } });
    Object.defineProperty(exports2, "New", { enumerable: true, get: function() {
      return template_1.New;
    } });
    Object.defineProperty(exports2, "ExecError", { enumerable: true, get: function() {
      return template_1.ExecError;
    } });
    Object.defineProperty(exports2, "JSEscapeString", { enumerable: true, get: function() {
      return template_1.JSEscapeString;
    } });
    var helper_1 = require_helper();
    Object.defineProperty(exports2, "Must", { enumerable: true, get: function() {
      return helper_1.Must;
    } });
    Object.defineProperty(exports2, "ParseFiles", { enumerable: true, get: function() {
      return helper_1.ParseFiles;
    } });
    Object.defineProperty(exports2, "ParseContents", { enumerable: true, get: function() {
      return helper_1.ParseContents;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports2, "Tree", { enumerable: true, get: function() {
      return parse_1.Tree;
    } });
    Object.defineProperty(exports2, "Mode", { enumerable: true, get: function() {
      return parse_1.Mode;
    } });
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    Object.defineProperty(exports2, "IsEmptyTree", { enumerable: true, get: function() {
      return parse_1.IsEmptyTree;
    } });
    var node_12 = require_node();
    Object.defineProperty(exports2, "NodeType", { enumerable: true, get: function() {
      return node_12.NodeType;
    } });
    Object.defineProperty(exports2, "ListNode", { enumerable: true, get: function() {
      return node_12.ListNode;
    } });
    Object.defineProperty(exports2, "ActionNode", { enumerable: true, get: function() {
      return node_12.ActionNode;
    } });
    Object.defineProperty(exports2, "PipeNode", { enumerable: true, get: function() {
      return node_12.PipeNode;
    } });
    Object.defineProperty(exports2, "CommandNode", { enumerable: true, get: function() {
      return node_12.CommandNode;
    } });
    Object.defineProperty(exports2, "FieldNode", { enumerable: true, get: function() {
      return node_12.FieldNode;
    } });
    Object.defineProperty(exports2, "VariableNode", { enumerable: true, get: function() {
      return node_12.VariableNode;
    } });
    Object.defineProperty(exports2, "IdentifierNode", { enumerable: true, get: function() {
      return node_12.IdentifierNode;
    } });
    Object.defineProperty(exports2, "TextNode", { enumerable: true, get: function() {
      return node_12.TextNode;
    } });
    Object.defineProperty(exports2, "StringNode", { enumerable: true, get: function() {
      return node_12.StringNode;
    } });
    Object.defineProperty(exports2, "NumberNode", { enumerable: true, get: function() {
      return node_12.NumberNode;
    } });
    Object.defineProperty(exports2, "BoolNode", { enumerable: true, get: function() {
      return node_12.BoolNode;
    } });
    Object.defineProperty(exports2, "DotNode", { enumerable: true, get: function() {
      return node_12.DotNode;
    } });
    Object.defineProperty(exports2, "NilNode", { enumerable: true, get: function() {
      return node_12.NilNode;
    } });
    Object.defineProperty(exports2, "RangeNode", { enumerable: true, get: function() {
      return node_12.RangeNode;
    } });
    Object.defineProperty(exports2, "IfNode", { enumerable: true, get: function() {
      return node_12.IfNode;
    } });
    Object.defineProperty(exports2, "WithNode", { enumerable: true, get: function() {
      return node_12.WithNode;
    } });
    Object.defineProperty(exports2, "TemplateNode", { enumerable: true, get: function() {
      return node_12.TemplateNode;
    } });
    Object.defineProperty(exports2, "setTextFormat", { enumerable: true, get: function() {
      return node_12.setTextFormat;
    } });
    Object.defineProperty(exports2, "getTextFormat", { enumerable: true, get: function() {
      return node_12.getTextFormat;
    } });
    var lex_12 = require_lex();
    Object.defineProperty(exports2, "lex", { enumerable: true, get: function() {
      return lex_12.lex;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/cahce/cache.js
var require_cache2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/cahce/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalBuildCache = exports2.ConcurrentCache = void 0;
    exports2.createCache = createCache;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "cache" });
    var ConcurrentCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.pendingPromises = /* @__PURE__ */ new Map();
        this.deletedKeys = /* @__PURE__ */ new Set();
      }
      get(key) {
        return this.cache.get(key);
      }
      set(key, value2) {
        if (!this.deletedKeys.has(key)) {
          this.cache.set(key, value2);
        }
        this.pendingPromises.delete(key);
        this.deletedKeys.delete(key);
      }
      has(key) {
        return this.cache.has(key);
      }
      isPending(key) {
        return this.pendingPromises.has(key);
      }
      delete(key) {
        this.deletedKeys.add(key);
        this.pendingPromises.delete(key);
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
        this.pendingPromises.clear();
        this.deletedKeys.clear();
      }
      size() {
        return this.cache.size;
      }
      pendingCount() {
        return this.pendingPromises.size;
      }
      async getOrCreate(key, create) {
        const cached = this.cache.get(key);
        if (cached !== void 0) {
          return cached;
        }
        const pending = this.pendingPromises.get(key);
        if (pending) {
          return await pending;
        }
        return this.createAndCache(key, create);
      }
      async createAndCache(key, create) {
        const promise = this.executeCreate(key, create);
        this.pendingPromises.set(key, promise);
        try {
          const value2 = await promise;
          if (!this.deletedKeys.has(key)) {
            this.set(key, value2);
            return value2;
          } else {
            this.deletedKeys.delete(key);
            this.pendingPromises.delete(key);
            return value2;
          }
        } catch (error) {
          this.pendingPromises.delete(key);
          log.error(`Failed to create value for key ${String(key)} : ${error}`);
          throw error;
        }
      }
      async executeCreate(key, create) {
        try {
          return await create(key);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          const wrappedError = new Error(`Cache creation failed for key ${String(key)}: ${errorMessage}`);
          if (error instanceof Error && error.stack) {
            wrappedError.stack = error.stack;
            wrappedError.originalError = error;
          }
          throw wrappedError;
        }
      }
      getStats() {
        return {
          size: this.cache.size,
          pendingCount: this.pendingPromises.size,
          keys: Array.from(this.cache.keys()),
          pendingKeys: Array.from(this.pendingPromises.keys())
        };
      }
      async preload(entries) {
        const promises5 = entries.filter(({ key }) => !this.has(key) && !this.isPending(key)).map(({ key, create }) => this.getOrCreate(key, create));
        if (promises5.length > 0) {
          await Promise.allSettled(promises5);
        }
      }
    };
    exports2.ConcurrentCache = ConcurrentCache;
    function createCache() {
      return new ConcurrentCache();
    }
    exports2.globalBuildCache = new ConcurrentCache();
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/parser.js
var require_parser = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    exports2.newParser = newParser;
    var text_template_1 = require_dist2();
    var text_template_2 = require_dist2();
    var type_1 = require_type9();
    var info_1 = require_info();
    var log_1 = require_log();
    var cache_1 = require_cache2();
    var log = (0, log_1.getDomainLogger)("template", { component: "parser" });
    var Parser = class {
      constructor(funcMap = /* @__PURE__ */ new Map()) {
        this.readyInit = false;
        this.funcMap = funcMap;
        this.prototypeText = (0, text_template_1.New)("");
        this.parseOverlapCache = new cache_1.ConcurrentCache();
        if (this.funcMap.size > 0) {
          this.prototypeText.Funcs(this.funcMap);
        }
      }
      async markReady() {
        if (!this.readyInit) {
          this.prototypeTextClone = this.prototypeText;
          this.readyInit = true;
        }
      }
      async parse(info) {
        try {
          const tmpl = (0, text_template_1.New)(info.name);
          if (this.funcMap && this.funcMap.size > 0) {
            tmpl.Funcs(this.funcMap);
          }
          const [parsedTmpl, parseErr] = tmpl.Parse(info.template);
          if (parseErr) {
            throw new type_1.TemplateError(`Parse failed: ${parseErr.message}`, "PARSE_FAILED");
          }
          return {
            template: parsedTmpl,
            info,
            type: (0, info_1.resolveTemplateType)(info.name)
          };
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Parse failed: ${message}`, "PARSE_FAILED");
        }
      }
      async parseWithLock(name, tpl) {
        try {
          if (!this.prototypeTextClone) {
            await this.markReady();
          }
          const tmpl = (0, text_template_1.New)(name);
          if (this.funcMap && this.funcMap.size > 0) {
            tmpl.Funcs(this.funcMap);
          }
          const [parsedTmpl, parseErr] = tmpl.Parse(tpl);
          if (parseErr) {
            throw new type_1.TemplateError(`Parse with lock failed: ${parseErr.message}`, "PARSE_LOCK_FAILED");
          }
          return parsedTmpl;
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Parse with lock failed: ${message}`, "PARSE_LOCK_FAILED");
        }
      }
      async parseOverlap(overlay, base, lookup) {
        const cacheKey = `${overlay.name}::${base.name || "empty"}`;
        return this.parseOverlapCache.getOrCreate(cacheKey, async () => {
          try {
            const tmpl = await this.applyBaseTemplate(overlay, base, lookup);
            const ts = {
              template: tmpl,
              info: overlay,
              type: (0, info_1.resolveTemplateType)(overlay.name)
            };
            if (!base.isZero || base.name) {
              ts.baseInfo = base;
            }
            return [ts, true, null];
          } catch (error) {
            const templateError = error instanceof type_1.TemplateError ? error : new type_1.TemplateError(`Parse overlap failed: ${error.message}`, "PARSE_OVERLAP_FAILED");
            log.error(`Failed to parse template overlap for key: ${cacheKey}: ${templateError.message}`);
            return [null, false, templateError];
          }
        });
      }
      async applyBaseTemplate(overlay, base, lookup) {
        try {
          const tmpl = (0, text_template_1.New)(overlay.name);
          if (this.funcMap && this.funcMap.size > 0) {
            tmpl.Funcs(this.funcMap);
          }
          if (!base.isZero || base.name) {
            const [baseTmpl, baseErr] = tmpl.Parse(base.template);
            if (baseErr) {
              throw new type_1.TemplateError(`Base template parse failed: ${baseErr.message}`, "BASE_PARSE_FAILED");
            }
          }
          const [clonedTmpl, cloneErr] = tmpl.Clone();
          if (cloneErr) {
            throw new type_1.TemplateError(`Template clone failed: ${cloneErr.message}`, "CLONE_FAILED");
          }
          const [overlayTmpl, overlayErr] = clonedTmpl.Parse(overlay.template);
          if (overlayErr) {
            throw new type_1.TemplateError(`Overlay template parse failed: ${overlayErr.message}`, "OVERLAY_PARSE_FAILED");
          }
          const dependencies = await this.getDependencies(overlayTmpl, /* @__PURE__ */ new Map(), lookup);
          for (const [name, state] of dependencies) {
            if (name === overlay.name) {
              continue;
            }
            try {
              if (state.template.Tree) {
                const [, addErr] = overlayTmpl.AddParseTree(name, state.template.Tree);
                if (addErr) {
                  log.error(`AddParseTree failed: ${addErr.message} with name ${name}`);
                  throw new type_1.TemplateError(`AddParseTree failed: ${addErr.message}`, "ADD_PARSE_TREE_FAILED");
                }
              }
            } catch (error) {
              log.error(`Error adding dependency ${name} to template ${overlay.name}:`, error);
              throw new type_1.TemplateError(`Failed to add dependency ${name}: ${error.message}`, "DEPENDENCY_ADD_FAILED");
            }
          }
          return overlayTmpl;
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            throw error;
          }
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Apply base template failed: ${message}`, "APPLY_BASE_FAILED");
        }
      }
      async getDependencies(tmpl, discovered, lookup) {
        const resultMap = /* @__PURE__ */ new Map();
        if (discovered.has(tmpl.Name())) {
          return resultMap;
        }
        discovered.set(tmpl.Name(), tmpl);
        try {
          const depNames = /* @__PURE__ */ new Set();
          const visit = (node) => {
            if (!node)
              return;
            const nodeType = node.Type();
            if (nodeType === text_template_2.NodeType.NodeTemplate) {
              const templateNode = node;
              const name = templateNode.Name;
              if (name) {
                depNames.add(name);
              }
            } else if (nodeType === text_template_2.NodeType.NodeList) {
              const listNode = node;
              if (listNode.Nodes) {
                for (const childNode of listNode.Nodes) {
                  visit(childNode);
                }
              }
            }
            if (nodeType === text_template_2.NodeType.NodeAction) {
              const actionNode = node;
              if (actionNode.Pipe) {
                visit(actionNode.Pipe);
              }
            } else if (nodeType === text_template_2.NodeType.NodePipe) {
              const pipeNode = node;
              if (pipeNode.Cmds) {
                for (const cmd of pipeNode.Cmds) {
                  visit(cmd);
                }
              }
            } else if (nodeType === text_template_2.NodeType.NodeCommand) {
              const commandNode = node;
              if (commandNode.Args) {
                for (const arg of commandNode.Args) {
                  visit(arg);
                }
              }
            } else if (nodeType === text_template_2.NodeType.NodeIf || nodeType === text_template_2.NodeType.NodeRange || nodeType === text_template_2.NodeType.NodeWith) {
              const branchNode = node;
              if (branchNode.Pipe) {
                visit(branchNode.Pipe);
              }
              if (branchNode.List) {
                visit(branchNode.List);
              }
              if (branchNode.ElseList) {
                visit(branchNode.ElseList);
              }
            }
          };
          if (tmpl.Tree && tmpl.Tree.Root) {
            visit(tmpl.Tree.Root);
          }
          for (const depName of depNames) {
            const state = lookup(depName);
            if (state) {
              resultMap.set(depName, state);
              if (!discovered.has(state.template.Name())) {
                const subDeps = await this.getDependencies(state.template, discovered, lookup);
                for (const [subName, subState] of subDeps) {
                  if (!resultMap.has(subName)) {
                    resultMap.set(subName, subState);
                  }
                }
              }
            }
          }
        } catch (error) {
          log.error(`Error getting dependencies for template ${tmpl.Name()}:`, error);
        }
        return resultMap;
      }
      setFuncMap(funcMap) {
        this.funcMap = new Map([...this.funcMap, ...funcMap]);
        if (this.funcMap.size > 0) {
          this.prototypeText.Funcs(this.funcMap);
        }
      }
      getFuncMap() {
        return new Map(this.funcMap);
      }
      async parseMultiple(templates) {
        const results = await Promise.allSettled(templates.map((info) => this.parse(info)));
        const states = [];
        const errors = [];
        for (const result of results) {
          if (result.status === "fulfilled") {
            states.push(result.value);
          } else {
            errors.push(result.reason);
          }
        }
        if (errors.length > 0) {
          throw new type_1.TemplateError(`Failed to parse ${errors.length} templates: ${errors.map((e) => e.message).join(", ")}`, "MULTIPLE_PARSE_FAILED");
        }
        return states;
      }
      clearCache() {
        this.parseOverlapCache.clear();
      }
      getCacheStats() {
        return this.parseOverlapCache.getStats();
      }
    };
    exports2.Parser = Parser;
    function newParser(funcMap = /* @__PURE__ */ new Map()) {
      return new Parser(funcMap);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/lookup.js
var require_lookup = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lookup = void 0;
    exports2.newLookup = newLookup;
    var baseof_1 = require_baseof();
    var Lookup = class {
      constructor(baseOf, funcMap) {
        this.baseOf = baseOf || new baseof_1.BaseOf();
        this.funcsv = /* @__PURE__ */ new Map();
        if (funcMap) {
          for (const [key, value2] of funcMap) {
            this.funcsv.set(key, value2);
          }
        }
      }
      findNoDependence(name, ns) {
        try {
          const tmpl = ns.lookup(name);
          if (tmpl) {
            return [tmpl, true, null];
          }
          return [null, false, null];
        } catch (error) {
          return [null, false, error];
        }
      }
      findTemplate(name, templateNS) {
        try {
          const tmpl = templateNS.lookup(name);
          if (tmpl) {
            return [tmpl, true, null];
          }
          const templateState = templateNS.findTemplateWithDependencies(name);
          if (templateState && templateState.baseInfo) {
            return [templateState.template, true, null];
          }
          return [null, false, null];
        } catch (error) {
          return [null, false, error];
        }
      }
      findPartial(name, partialNS) {
        try {
          const tmpl = partialNS.lookup(name);
          if (tmpl) {
            return [tmpl, true, null];
          }
          return [null, false, null];
        } catch (error) {
          return [null, false, error];
        }
      }
      findShortcode(name, shortcodeNS) {
        try {
          const tmpl = shortcodeNS.getShortcode(name);
          if (tmpl) {
            return [tmpl, true, null];
          }
          return [null, false, null];
        } catch (error) {
          return [null, false, error];
        }
      }
      findDependentInfo(name) {
        const overlay = this.baseOf.getNeedsBaseOf(name);
        if (!overlay) {
          return [null, null, false];
        }
        let base = null;
        let found = false;
        for (const searchKey of this.baseOf.getTemplateSearchOrder(name)) {
          base = this.baseOf.getBaseOf(searchKey);
          if (base) {
            found = true;
            break;
          }
        }
        return [overlay, base, found];
      }
      getFunc(name) {
        return this.funcsv.get(name);
      }
      setFunc(name, fn) {
        this.funcsv.set(name, fn);
      }
      setFuncMap(funcMap) {
        this.funcsv.clear();
        for (const [key, value2] of funcMap) {
          this.funcsv.set(key, value2);
        }
      }
      getFuncMap() {
        return new Map(this.funcsv);
      }
      newTemplateLookup(ns) {
        return (name) => {
          return ns.findTemplate(name);
        };
      }
      getBaseOf() {
        return this.baseOf;
      }
      setBaseOf(baseOf) {
        this.baseOf = baseOf;
      }
      hasDependencies(name) {
        const [overlay, base, found] = this.findDependentInfo(name);
        return found && (overlay !== null || base !== null);
      }
      getAllFunctions() {
        return Array.from(this.funcsv.keys());
      }
      clearFunctions() {
        this.funcsv.clear();
      }
      getStats() {
        const baseOfStats = this.baseOf.getStats();
        return {
          functionCount: this.funcsv.size,
          baseTemplateCount: baseOfStats.baseOfCount,
          dependentTemplateCount: baseOfStats.needsBaseOfCount
        };
      }
    };
    exports2.Lookup = Lookup;
    function newLookup(baseOf, funcMap) {
      return new Lookup(baseOf, funcMap);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/template.js
var require_template2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/entity/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateEngine = void 0;
    exports2.newTemplateEngine = newTemplateEngine;
    var type_1 = require_type9();
    var info_1 = require_info();
    var info_2 = require_info();
    var log_1 = require_log();
    var paths_1 = require_paths();
    var log = (0, log_1.getDomainLogger)("template", { component: "template-engine" });
    var TemplateEngine = class {
      constructor(executor, lookup, parser, templateNamespace, partialNamespace, shortcodeNamespace, fs5) {
        this.executor = executor;
        this.lookup = lookup;
        this.parser = parser;
        this.templateNamespace = templateNamespace;
        this.partialNamespace = partialNamespace;
        this.shortcodeNamespace = shortcodeNamespace;
        this.fs = fs5;
      }
      async markReady() {
        try {
          await this.parser.markReady();
        } catch (error) {
          throw new type_1.TemplateError(`Failed to mark template engine ready: ${error.message}`, "TEMPLATE_ENGINE_READY_FAILED");
        }
      }
      async getTemplate(name) {
        const [tmpl, found, err] = this.lookup.findTemplate(name, this.templateNamespace);
        if (err) {
          return [null, false, err];
        }
        if (found && tmpl) {
          return [tmpl, true, null];
        }
        const [overlay, base, hasDependent] = this.lookup.findDependentInfo(name);
        if (hasDependent && overlay) {
          try {
            const [ts, parseFound, parseErr] = await this.parser.parseOverlap(overlay, base || overlay, this.lookup.newTemplateLookup(this.templateNamespace));
            if (parseErr) {
              return [null, false, parseErr];
            }
            if (parseFound && ts) {
              return [ts.template, true, null];
            }
          } catch (error) {
            return [null, false, error];
          }
        }
        return [null, false, null];
      }
      async getPartial(name) {
        let partialName = name.startsWith(type_1.PARTIALS_PREFIX) ? name : `${type_1.PARTIALS_PREFIX}${name}`;
        partialName = name.endsWith(".html") ? partialName : `${partialName}.html`;
        return this.lookup.findPartial(partialName, this.partialNamespace);
      }
      async getShortcode(name) {
        return this.lookup.findShortcode(name, this.shortcodeNamespace);
      }
      async get(name) {
        const templateType = (0, info_2.resolveTemplateType)(name);
        switch (templateType) {
          case type_1.TemplateType.TypeShortcode:
            return this.getShortcode(name);
          case type_1.TemplateType.TypePartial:
            return this.getPartial(name);
          default:
            return this.getTemplate(name);
        }
      }
      async findFirst(names) {
        if (!names || names.length === 0) {
          return [null, null, false, null];
        }
        for (const name of names) {
          try {
            const [tmpl, found, err] = await this.get(name);
            if (err) {
              continue;
            }
            if (found && tmpl) {
              return [tmpl, name, true, null];
            }
          } catch (error) {
            log.error("Error finding template:", error);
          }
        }
        return [null, null, false, null];
      }
      hasShortcode(name) {
        return this.shortcodeNamespace.hasShortcode(name);
      }
      getShortcodeNames() {
        return this.shortcodeNamespace.getShortcodeNames();
      }
      getShortcodeCount() {
        return this.getShortcodeNames().length;
      }
      async loadTemplates() {
        const walker = async (filePath, fi) => {
          if (fi.isDir()) {
            return;
          }
          const name = filePath.startsWith(paths_1.PATH_CONSTANTS.SYSTEM_PATH_SEPARATOR) ? filePath.substring(1) : filePath;
          const normalizedName = paths_1.PATH_CONSTANTS.normalizePath(name);
          try {
            await this.addTemplateFileInfo(normalizedName, fi);
          } catch (error) {
            throw new type_1.TemplateError(`Failed to add template ${normalizedName}: ${error.message}`, "LOAD_TEMPLATE_FAILED");
          }
        };
        try {
          await this.fs.walk("", {
            walkFn: walker
          }, {});
        } catch (error) {
          if (!error.message?.includes("ENOENT") && !error.message?.includes("no such file")) {
            throw error;
          }
        }
      }
      async addTemplateFileInfo(name, fim) {
        try {
          const tinfo = await (0, info_1.loadTemplate)(name, fim);
          await this.addTemplate(tinfo.name, tinfo);
        } catch (error) {
          throw new type_1.TemplateError(`Failed to load template info for ${name}: ${error.message}`, "LOAD_TEMPLATE_INFO_FAILED");
        }
      }
      async addTemplate(name, tinfo) {
        try {
          if (this.lookup.getBaseOf().isBaseTemplatePath(name)) {
            this.lookup.getBaseOf().addBaseOf(name, tinfo);
            return;
          }
          if (this.lookup.getBaseOf().needsBaseOf(name, tinfo.template)) {
            this.lookup.getBaseOf().addNeedsBaseOf(name, tinfo);
            return;
          }
          const templateType = (0, info_2.resolveTemplateType)(name);
          const state = await this.parser.parse(tinfo);
          switch (templateType) {
            case type_1.TemplateType.TypeShortcode:
              this.shortcodeNamespace.addShortcodeTemplate(name, state);
              break;
            case type_1.TemplateType.TypePartial:
              this.partialNamespace.addPartialTemplate(name, state);
              break;
            default:
              this.templateNamespace.addTemplate(name, state);
              break;
          }
        } catch (error) {
          throw new type_1.TemplateError(`Failed to add template ${name}: ${error.message}`, "ADD_TEMPLATE_FAILED");
        }
      }
      async execute(templateName, data) {
        const [tmpl, found, err] = await this.get(templateName);
        if (err) {
          throw err;
        }
        if (!found || !tmpl) {
          throw new type_1.TemplateError(`Template not found: ${templateName}`, "TEMPLATE_NOT_FOUND");
        }
        return await this.executor.execute(tmpl, data);
      }
      async executeRaw(templateName, rawContent, data) {
        const tmpl = await this.parser.parseWithLock(templateName, rawContent);
        if (!tmpl) {
          throw new type_1.TemplateError(`Raw Template parse error: ${templateName}`, "TEMPLATE_PARSE_ERROR");
        }
        return await this.executor.execute(tmpl, data);
      }
      async executeShortcode(shortcodeName, data) {
        const tmpl = this.shortcodeNamespace.getShortcode(shortcodeName);
        if (!tmpl) {
          throw new type_1.TemplateError(`Shortcode template '${shortcodeName}' not found`, "SHORTCODE_NOT_FOUND");
        }
        try {
          return await this.executor.execute(tmpl, data);
        } catch (error) {
          throw new type_1.TemplateError(`Error executing shortcode template '${shortcodeName}': ${error.message}`, "SHORTCODE_EXECUTION_FAILED");
        }
      }
      async executeSafely(templateName, data) {
        try {
          const result = await this.execute(templateName, data);
          return { result, error: null };
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            return { result: null, error };
          }
          return {
            result: null,
            error: new type_1.TemplateError(`Execute safely failed: ${error.message}`, "EXECUTE_SAFELY_FAILED")
          };
        }
      }
      async executeShortcodeSafely(shortcodeName, data) {
        try {
          const result = await this.executeShortcode(shortcodeName, data);
          return { result, error: null };
        } catch (error) {
          if (error instanceof type_1.TemplateError) {
            return { result: null, error };
          }
          return {
            result: null,
            error: new type_1.TemplateError(`Execute shortcode safely failed: ${error.message}`, "EXECUTE_SHORTCODE_SAFELY_FAILED")
          };
        }
      }
      async hasTemplate(name) {
        const [, found] = await this.get(name);
        return found;
      }
      getTemplateNames() {
        return this.templateNamespace.getTemplateNames();
      }
      getPartialTemplateNames() {
        return this.partialNamespace.getTemplateNames();
      }
      getAllTemplateNames() {
        return [
          ...this.templateNamespace.getTemplateNames(),
          ...this.partialNamespace.getTemplateNames(),
          ...this.shortcodeNamespace.getTemplateNames()
        ];
      }
      getPartialNamespace() {
        return this.partialNamespace;
      }
      getShortcodeNamespace() {
        return this.shortcodeNamespace;
      }
      getTemplateNamespace() {
        return this.templateNamespace;
      }
      clear() {
        this.templateNamespace.clear();
        this.lookup.getBaseOf().clear();
      }
      getTemplatesByPattern(pattern) {
        const templates = this.templateNamespace.getTemplatesByPattern(pattern);
        return templates.map((t) => t.info.name);
      }
    };
    exports2.TemplateEngine = TemplateEngine;
    function newTemplateEngine(executor, lookup, parser, templateNamespace, partialNamespace, shortcodeNamespace, fs5) {
      return new TemplateEngine(executor, lookup, parser, templateNamespace, partialNamespace, shortcodeNamespace, fs5);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/registry.js
var require_registry = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/vo/registry.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTemplateRegistry = void 0;
    exports2.newTemplateRegistry = newTemplateRegistry;
    exports2.createCoreFuncMap = createCoreFuncMap;
    exports2.createStandardFuncMap = createStandardFuncMap;
    exports2.updateEngineDependentFunctions = updateEngineDependentFunctions;
    var log_1 = require_log();
    var crypto = __importStar(require("crypto"));
    var log = (0, log_1.getDomainLogger)("template", { component: "registry" });
    var engineDependentFunctions = [];
    var PartialFunction = class {
      constructor() {
        this.engine = null;
        this.execute = async (name, context) => {
          if (!this.engine) {
            log.error(`Partial function called but engine not set: ${name}`);
            return `<!-- Partial function called but engine not ready: ${name} -->`;
          }
          try {
            const templateName = name.startsWith("partials/") ? name : `partials/${name}`;
            return await this.executePartial(templateName, context);
          } catch (error) {
            log.error(`Partial execution failed for "${name}":`, error);
            return `<!-- Partial execution failed: ${name} - ${error.message} -->`;
          }
        };
      }
      getFunctionName() {
        return "partial";
      }
      updateEngine(engine) {
        this.engine = engine;
      }
      async executePartial(templateName, context) {
        if (!this.engine) {
          return `<!-- Template engine not available: ${templateName} -->`;
        }
        try {
          const [templateObj, found, err] = await this.engine.getPartial(templateName);
          if (err) {
            log.error(`Error getting partial template:`, err);
            return `<!-- Error getting partial template: ${templateName} - ${err.message} -->`;
          }
          if (!found || !templateObj) {
            log.warn(`Template not found: ${templateName}`);
            return `<!-- Template not found: ${templateName} -->`;
          }
          const [result, execErr] = await templateObj.Execute(context);
          if (execErr) {
            log.error(`Template execution error:`, execErr);
            return `<!-- Template execution error: ${templateName} - ${execErr.message} -->`;
          }
          return result;
        } catch (error) {
          log.error(`Sync partial execution failed:`, error);
          return `<!-- Partial sync execution failed: ${templateName} - ${error.message} -->`;
        }
      }
    };
    var DefaultTemplateRegistry = class {
      registerCoreFunctions(funcMap) {
        this.registerCryptoFunctions(funcMap);
        this.registerStringFunctions(funcMap);
        this.registerMathFunctions(funcMap);
        this.registerTimeFunctions(funcMap);
        this.registerCollectionFunctions(funcMap);
        this.registerSafeFunctions(funcMap);
        this.registerReflectFunctions(funcMap);
        this.registerFmtFunctions(funcMap);
        this.registerPathFunctions(funcMap);
        this.registerTransformFunctions(funcMap);
      }
      registerCryptoFunctions(funcMap) {
        funcMap.set("md5", (input) => {
          if (!input)
            return "";
          return crypto.createHash("md5").update(input).digest("hex");
        });
      }
      registerExtendedFunctions(funcMap, services) {
        this.registerURLFunctions(funcMap, services);
        this.registerSiteFunctions(funcMap, services);
        this.registerResourcesFunctions(funcMap, services);
        this.registerHugoFunctions(funcMap, services);
        this.registerLanguageFunctions(funcMap, services);
      }
      registerAllFunctions(funcMap, services) {
        this.registerCoreFunctions(funcMap);
        this.registerStringFunctions(funcMap);
        this.registerMathFunctions(funcMap);
        this.registerTimeFunctions(funcMap);
        this.registerCollectionFunctions(funcMap);
        this.registerEngineDependentFunctions(funcMap);
        if (services) {
          this.registerURLFunctions(funcMap, services);
          this.registerExtendedFunctions(funcMap, services);
        }
      }
      registerEngineDependentFunctions(funcMap) {
        const partialFunction = new PartialFunction();
        engineDependentFunctions.push(partialFunction);
        funcMap.set(partialFunction.getFunctionName(), partialFunction.execute);
      }
      registerURLFunctions(funcMap, services) {
        funcMap.set("urls", () => ({
          Parse: (rawurl) => {
            try {
              const u = new URL(rawurl);
              return {
                Host: u.host
              };
            } catch {
              return {
                Host: ""
              };
            }
          },
          JoinPath: (...elements) => {
            const cleanElements = elements.filter((e) => e !== "").map((e) => e.replace(/^\/+|\/+$/g, ""));
            return cleanElements.join("/");
          },
          URLize: (text3) => services.urlize(text3),
          Abs: (url) => services.absURL(url),
          Rel: (url) => services.relURL(url),
          AbsLangURL: (url) => services.absURL(url),
          RelLangURL: (url) => services.relURL(url),
          Sanitize: (url) => {
            try {
              const parsed = new URL(url);
              return parsed.toString();
            } catch {
              return url.replace(/[<>"'%{}|\\^`]/g, "");
            }
          },
          PathEscape: (path6) => {
            return encodeURIComponent(path6).replace(/%2F/g, "/").replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
          },
          QueryEscape: (query) => {
            return encodeURIComponent(query);
          },
          QueryUnescape: (query) => {
            try {
              return decodeURIComponent(query);
            } catch {
              return query;
            }
          },
          IsAbs: (urlStr) => {
            try {
              const url = new URL(urlStr);
              return url.protocol !== "";
            } catch {
              return false;
            }
          },
          IsRelative: (urlStr) => {
            try {
              new URL(urlStr);
              return false;
            } catch {
              return true;
            }
          }
        }));
        funcMap.set("absURL", (input) => services.absURL(input));
        funcMap.set("relURL", (input) => services.relURL(input));
        funcMap.set("urlize", (input) => services.urlize(input));
        funcMap.set("relref", (page, ref) => {
          if (/^https?:\/\//.test(ref)) {
            return ref;
          }
          let anchor = "";
          const hashIndex = ref.indexOf("#");
          if (hashIndex !== -1) {
            anchor = ref.slice(hashIndex);
            ref = ref.slice(0, hashIndex);
          }
          ref = ref.replace(/^\/+|\/+$/g, "");
          if (ref.startsWith("./") || ref.startsWith("../")) {
            return services.relURL(ref + anchor);
          }
          if (ref.startsWith("/")) {
            return services.relURL(ref + anchor);
          }
          return services.relURL("/" + ref + anchor);
        });
        funcMap.set("ref", (page, ref) => {
          if (/^https?:\/\//.test(ref)) {
            return ref;
          }
          let anchor = "";
          const hashIndex = ref.indexOf("#");
          if (hashIndex !== -1) {
            anchor = ref.slice(hashIndex);
            ref = ref.slice(0, hashIndex);
          }
          ref = ref.replace(/^\/+|\/+$/g, "");
          if (ref.startsWith("./") || ref.startsWith("../")) {
            return services.absURL(ref + anchor);
          }
          if (ref.startsWith("/")) {
            return services.absURL(ref + anchor);
          }
          return services.absURL("/" + ref + anchor);
        });
        funcMap.set("absLangURL", (input) => {
          return services.absURL(input);
        });
        funcMap.set("relLangURL", (input) => {
          return services.relURL(input);
        });
      }
      registerSiteFunctions(funcMap, services) {
        funcMap.set("Site", () => ({
          Title: services.title(),
          BaseURL: services.baseURL(),
          Params: services.params(),
          Menus: services.menus(),
          IsMultiLingual: services.isMultiLanguage(),
          LanguageCode: services.defaultLanguage()
        }));
      }
      registerResourcesFunctions(funcMap, services) {
        funcMap.set("resources", () => ({
          Get: async (filename) => await services.Get(filename),
          GetRemote: async (uri) => await services.GetRemote(uri),
          Minify: async (resource) => await services.Minify(resource),
          Fingerprint: async (resource) => await services.Fingerprint(resource),
          ExecuteAsTemplate: async (targetPath, data, resource) => await services.ExecuteAsTemplate(targetPath, data, resource)
        }));
      }
      registerHugoFunctions(funcMap, services) {
        funcMap.set("hugo", () => ({
          Version: services.version(),
          Environment: services.environment(),
          Generator: services.generator()
        }));
      }
      registerLanguageFunctions(funcMap, services) {
        const { lang } = require_lang();
        funcMap.set("lang", () => ({
          getAllCodes: () => lang.getAllCodes(),
          getAllNames: () => lang.getAllNames(),
          getCodesByDirection: (direction) => lang.getCodesByDirection(direction),
          getNamesByDirection: (direction) => lang.getNamesByDirection(direction),
          getCodeNameMap: () => lang.getCodeNameMap(),
          getCodeNameMapByDirection: (direction) => lang.getCodeNameMapByDirection(direction),
          getNameByCode: (code) => lang.getNameByCode(code),
          getLanguageInfo: (code) => lang.getLanguageInfo(code),
          isSupported: (code) => lang.isSupported(code),
          getDirection: (code) => lang.getDirection(code),
          isLTR: (code) => lang.isLTR(code),
          isRTL: (code) => lang.isRTL(code)
        }));
        funcMap.set("langName", (code) => lang.getNameByCode(code) || code);
        funcMap.set("langDirection", (code) => lang.getDirection(code) || "ltr");
        funcMap.set("isLTR", (code) => lang.isLTR(code));
        funcMap.set("isRTL", (code) => lang.isRTL(code));
        funcMap.set("i18n", (key) => {
          return services.translate(key);
        });
      }
      registerStringFunctions(funcMap) {
        funcMap.set("humanize", (str) => {
          if (!str)
            return "";
          str = str.replace(/([a-z])([A-Z])/g, "$1 $2");
          str = str.replace(/[_-]+/g, " ");
          str = str.replace(/\.[^/.]+$/, "");
          str = str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
          return str.trim();
        });
        funcMap.set("upper", (str) => str.toUpperCase());
        funcMap.set("lower", (str) => str.toLowerCase());
        funcMap.set("title", (str) => str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()));
        funcMap.set("trim", (str) => str.trim());
        funcMap.set("replace", (str, old, newStr) => str.replace(new RegExp(old, "g"), newStr));
        funcMap.set("split", (str, sep2) => {
          if (str === null || str === void 0) {
            log.warn("split function: first argument is null or undefined");
            return [];
          }
          if (typeof str !== "string") {
            log.warn("split function: first argument must be a string, got:", typeof str, "value:", str);
            if (Array.isArray(str)) {
              return str;
            }
            const stringValue = String(str);
            return stringValue.split(sep2);
          }
          return str.split(sep2);
        });
        funcMap.set("splitRegex", (str, regexPattern) => {
          if (str === null || str === void 0) {
            log.warn("splitRegex function: first argument is null or undefined");
            return [];
          }
          if (typeof str !== "string") {
            log.warn("splitRegex function: first argument must be a string, got:", typeof str, "value:", str);
            if (Array.isArray(str)) {
              return str;
            }
            const stringValue = String(str);
            try {
              const regex = new RegExp(regexPattern);
              return stringValue.split(regex);
            } catch (error) {
              log.warn("splitRegex function: invalid regex pattern:", regexPattern, "error:", error);
              return [stringValue];
            }
          }
          try {
            const regex = new RegExp(regexPattern);
            return str.split(regex);
          } catch (error) {
            log.warn("splitRegex function: invalid regex pattern:", regexPattern, "error:", error);
            return [str];
          }
        });
        funcMap.set("delimit", (arr, sep2) => {
          if (Array.isArray(arr)) {
            return arr.join(sep2);
          }
          return String(arr);
        });
        funcMap.set("in", (arr, item) => {
          if (Array.isArray(arr)) {
            return arr.includes(item);
          }
          return false;
        });
        funcMap.set("hasPrefix", (str, prefix) => str.startsWith(prefix));
        funcMap.set("hasSuffix", (str, suffix) => str.endsWith(suffix));
        funcMap.set("strings", () => ({
          ToLower: (s) => String(s).toLowerCase(),
          ToUpper: (s) => String(s).toUpperCase(),
          Title: (s) => String(s).replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()),
          Trim: (s, cutset) => String(s).split("").filter((c) => !cutset.includes(c)).join(""),
          TrimSpace: (s) => String(s).trim(),
          TrimLeft: (cutset, s) => {
            const str = String(s);
            let i = 0;
            while (i < str.length && cutset.includes(str[i])) {
              i++;
            }
            return str.slice(i);
          },
          TrimRight: (cutset, s) => {
            const str = String(s);
            let i = str.length - 1;
            while (i >= 0 && cutset.includes(str[i])) {
              i--;
            }
            return str.slice(0, i + 1);
          },
          TrimPrefix: (prefix, s) => {
            const str = String(s);
            return str.startsWith(prefix) ? str.slice(prefix.length) : str;
          },
          TrimSuffix: (suffix, s) => {
            const str = String(s);
            return str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;
          },
          Contains: (s, substr) => String(s).includes(substr),
          ContainsAny: (s, chars) => {
            const str = String(s);
            return chars.split("").some((char2) => str.includes(char2));
          },
          HasPrefix: (s, prefix) => String(s).startsWith(prefix),
          HasSuffix: (s, suffix) => String(s).endsWith(suffix),
          Replace: (s, old, newStr, limit) => {
            const str = String(s);
            if (limit === void 0) {
              return str.replace(new RegExp(old.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), newStr);
            }
            let count = 0;
            return str.replace(new RegExp(old.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), (match) => {
              if (count < limit) {
                count++;
                return newStr;
              }
              return match;
            });
          },
          Split: (s, delimiter) => String(s).split(delimiter),
          SliceString: (s, start, end) => {
            const str = String(s);
            return end !== void 0 ? str.slice(start, end) : str.slice(start);
          },
          Substr: (s, start, length) => {
            const str = String(s);
            if (start < 0)
              start = str.length + start;
            if (start < 0)
              start = 0;
            if (start >= str.length)
              return "";
            if (length === void 0)
              return str.slice(start);
            if (length <= 0)
              return "";
            return str.slice(start, start + length);
          },
          Count: (substr, s) => {
            const str = String(s);
            if (!substr)
              return str.length + 1;
            return (str.match(new RegExp(substr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g")) || []).length;
          },
          CountWords: (s) => {
            const str = String(s).trim();
            return str ? str.split(/\s+/).length : 0;
          },
          CountRunes: (s) => {
            const str = String(s);
            return str.replace(/\s/g, "").length;
          },
          RuneCount: (s) => String(s).length,
          Repeat: (n2, s) => {
            if (n2 < 0)
              throw new Error("strings: negative Repeat count");
            return String(s).repeat(n2);
          },
          FirstUpper: (s) => {
            const str = String(s);
            return str.charAt(0).toUpperCase() + str.slice(1);
          }
        }));
      }
      registerMathFunctions(funcMap) {
        funcMap.set("add", (a, b) => a + b);
        funcMap.set("sub", (a, b) => a - b);
        funcMap.set("mul", (a, b) => a * b);
        funcMap.set("div", (a, b) => b !== 0 ? a / b : 0);
        funcMap.set("mod", (a, b) => b !== 0 ? a % b : 0);
        funcMap.set("math", () => ({
          Abs: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("the math.Abs function requires a numeric argument");
            }
            return Math.abs(num);
          },
          Add: (...inputs) => {
            if (inputs.length < 2) {
              throw new Error("must provide at least two numbers");
            }
            return inputs.reduce((sum, val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Add operator can't be used with non-numeric values");
              }
              return sum + num;
            }, 0);
          },
          Ceil: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("Ceil operator can't be used with non-numeric value");
            }
            return Math.ceil(num);
          },
          Div: (...inputs) => {
            if (inputs.length < 2) {
              throw new Error("must provide at least two numbers");
            }
            const result = inputs.reduce((quotient, val, index) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Div operator can't be used with non-numeric values");
              }
              if (index === 0)
                return num;
              if (num === 0) {
                throw new Error("division by zero");
              }
              return quotient / num;
            });
            return result;
          },
          Floor: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("Floor operator can't be used with non-numeric value");
            }
            return Math.floor(num);
          },
          Log: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("Log operator can't be used with non-numeric value");
            }
            return Math.log(num);
          },
          Max: (...inputs) => {
            if (inputs.length === 0) {
              throw new Error("must provide at least one number");
            }
            const numbers = inputs.flat().map((val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Max operator can't be used with non-numeric values");
              }
              return num;
            });
            return Math.max(...numbers);
          },
          Min: (...inputs) => {
            if (inputs.length === 0) {
              throw new Error("must provide at least one number");
            }
            const numbers = inputs.flat().map((val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Min operator can't be used with non-numeric values");
              }
              return num;
            });
            return Math.min(...numbers);
          },
          Mod: (n1, n2) => {
            const a = Number(n1);
            const b = Number(n2);
            if (isNaN(a) || isNaN(b)) {
              throw new Error("modulo operator can't be used with non-numeric value");
            }
            if (b === 0) {
              throw new Error("the number can't be divided by zero at modulo operation");
            }
            return a % b;
          },
          ModBool: (n1, n2) => {
            const a = Number(n1);
            const b = Number(n2);
            if (isNaN(a) || isNaN(b)) {
              throw new Error("modulo operator can't be used with non-numeric value");
            }
            if (b === 0) {
              throw new Error("the number can't be divided by zero at modulo operation");
            }
            return a % b === 0;
          },
          Mul: (...inputs) => {
            if (inputs.length < 2) {
              throw new Error("must provide at least two numbers");
            }
            return inputs.reduce((product, val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Mul operator can't be used with non-numeric values");
              }
              return product * num;
            }, 1);
          },
          Pow: (n1, n2) => {
            const a = Number(n1);
            const b = Number(n2);
            if (isNaN(a) || isNaN(b)) {
              throw new Error("Pow operator can't be used with non-numeric value");
            }
            return Math.pow(a, b);
          },
          Rand: () => Math.random(),
          Round: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("Round operator can't be used with non-numeric value");
            }
            return Math.round(num);
          },
          Sqrt: (n2) => {
            const num = Number(n2);
            if (isNaN(num)) {
              throw new Error("Sqrt operator can't be used with non-numeric value");
            }
            return Math.sqrt(num);
          },
          Sub: (...inputs) => {
            if (inputs.length < 2) {
              throw new Error("must provide at least two numbers");
            }
            return inputs.reduce((difference, val, index) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Sub operator can't be used with non-numeric values");
              }
              if (index === 0)
                return num;
              return difference - num;
            });
          },
          Sum: (...inputs) => {
            if (inputs.length === 0) {
              throw new Error("must provide at least one number");
            }
            const numbers = inputs.flat().map((val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Sum operator can't be used with non-numeric values");
              }
              return num;
            });
            return numbers.reduce((sum, num) => sum + num, 0);
          },
          Product: (...inputs) => {
            if (inputs.length === 0) {
              throw new Error("must provide at least one number");
            }
            const numbers = inputs.flat().map((val) => {
              const num = Number(val);
              if (isNaN(num)) {
                throw new Error("Product operator can't be used with non-numeric values");
              }
              return num;
            });
            return numbers.reduce((product, num) => product * num, 1);
          }
        }));
      }
      registerTimeFunctions(funcMap) {
        funcMap.set("time", () => ({
          AsTime: (v) => {
            if (!v)
              return null;
            if (v instanceof Date)
              return v;
            if (typeof v === "string") {
              const date = new Date(v);
              return isNaN(date.getTime()) ? null : date;
            }
            if (typeof v === "number") {
              const date = new Date(v < 1e10 ? v * 1e3 : v);
              return isNaN(date.getTime()) ? null : date;
            }
            return null;
          },
          Format: (layout, value2) => {
            const date = value2 instanceof Date ? value2 : new Date(value2);
            if (isNaN(date.getTime())) {
              return "";
            }
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hour = date.getHours();
            const minute = date.getMinutes();
            const second = date.getSeconds();
            const weekday = date.toLocaleString("en-US", { weekday: "short" });
            const monthName = date.toLocaleString("en-US", { month: "short" });
            const patterns = [
              { pattern: "2006", value: year.toString() },
              { pattern: "06", value: year.toString().slice(-2) },
              { pattern: "January", value: date.toLocaleString("en-US", { month: "long" }) },
              { pattern: "Jan", value: monthName },
              { pattern: "01", value: month.toString().padStart(2, "0") },
              { pattern: "1", value: month.toString() },
              { pattern: "Monday", value: date.toLocaleString("en-US", { weekday: "long" }) },
              { pattern: "Mon", value: weekday },
              { pattern: "02", value: day.toString().padStart(2, "0") },
              { pattern: "2", value: day.toString() },
              { pattern: "15", value: hour.toString().padStart(2, "0") },
              { pattern: "3", value: ((hour + 11) % 12 + 1).toString() },
              { pattern: "04", value: minute.toString().padStart(2, "0") },
              { pattern: "4", value: minute.toString() },
              { pattern: "05", value: second.toString().padStart(2, "0") },
              { pattern: "5", value: second.toString() },
              { pattern: "PM", value: hour >= 12 ? "PM" : "AM" },
              { pattern: "pm", value: hour >= 12 ? "pm" : "am" },
              { pattern: "MST", value: date.toLocaleString("en-US", { timeZoneName: "short" }) }
            ];
            let result = layout;
            for (const { pattern, value: value3 } of patterns) {
              result = result.replace(new RegExp(pattern, "g"), value3);
            }
            return result;
          },
          Now: () => new Date(),
          Parse: (layout, value2) => {
            try {
              const date = new Date(value2);
              return isNaN(date.getTime()) ? null : date;
            } catch {
              return null;
            }
          },
          Unix: (value2) => {
            const date = value2 instanceof Date ? value2 : new Date(value2);
            return Math.floor(date.getTime() / 1e3);
          },
          UnixNano: (value2) => {
            const date = value2 instanceof Date ? value2 : new Date(value2);
            return date.getTime() * 1e6;
          }
        }));
        funcMap.set("now", () => {
          const date = new Date();
          return {
            Format: (layout) => {
              const year = date.getFullYear();
              const month = date.getMonth() + 1;
              const day = date.getDate();
              const hour = date.getHours();
              const minute = date.getMinutes();
              const second = date.getSeconds();
              const patterns = [
                { pattern: "2006", value: year.toString() },
                { pattern: "06", value: year.toString().slice(-2) },
                { pattern: "01", value: month.toString().padStart(2, "0") },
                { pattern: "1", value: month.toString() },
                { pattern: "02", value: day.toString().padStart(2, "0") },
                { pattern: "2", value: day.toString() },
                { pattern: "15", value: hour.toString().padStart(2, "0") },
                { pattern: "3", value: (hour % 12 || 12).toString() },
                { pattern: "04", value: minute.toString().padStart(2, "0") },
                { pattern: "4", value: minute.toString() },
                { pattern: "05", value: second.toString().padStart(2, "0") },
                { pattern: "5", value: second.toString() }
              ];
              let result = layout;
              for (const { pattern, value: value2 } of patterns) {
                const regex = new RegExp(`\\b${pattern}\\b`, "g");
                result = result.replace(regex, value2);
              }
              if (layout === "2006") {
                return year.toString();
              }
              if (layout === "06") {
                return year.toString().slice(-2);
              }
              if (layout === "01") {
                return month.toString().padStart(2, "0");
              }
              if (layout === "02") {
                return day.toString().padStart(2, "0");
              }
              if (layout === "15") {
                return hour.toString().padStart(2, "0");
              }
              if (layout === "04") {
                return minute.toString().padStart(2, "0");
              }
              if (layout === "05") {
                return second.toString().padStart(2, "0");
              }
              return result;
            },
            getTime: () => date.getTime(),
            toString: () => date.toString(),
            toISOString: () => date.toISOString()
          };
        });
        funcMap.set("dateFormat", (format, date) => {
          return date.toLocaleDateString();
        });
      }
      registerCollectionFunctions(funcMap) {
        funcMap.set("len", (obj) => {
          if (Array.isArray(obj))
            return obj.length;
          if (typeof obj === "string")
            return obj.length;
          if (obj && typeof obj === "object")
            return Object.keys(obj).length;
          return 0;
        });
        funcMap.set("first", (arr, n2) => {
          if (!Array.isArray(arr))
            return [];
          return n2 ? arr.slice(0, n2) : arr.slice(0, 1);
        });
        funcMap.set("last", (arr, n2) => {
          if (!Array.isArray(arr))
            return [];
          return n2 ? arr.slice(-n2) : arr.slice(-1);
        });
        funcMap.set("merge", (...args) => {
          const result = {};
          for (const arg of args) {
            if (arg && typeof arg === "object" && !Array.isArray(arg)) {
              Object.assign(result, arg);
            }
          }
          return result;
        });
        funcMap.set("index", (item, ...indices) => {
          try {
            return this.doIndex(item, indices);
          } catch (error) {
            log.error(`Index of type ${typeof item} with args [${indices.join(", ")}] failed:`, error);
            return null;
          }
        });
        funcMap.set("reverse", (arr) => {
          if (Array.isArray(arr)) {
            return [...arr].reverse();
          }
          return arr;
        });
        funcMap.set("append", (...args) => {
          if (args.length < 2) {
            return args[0] || [];
          }
          const result = Array.isArray(args[0]) ? [...args[0]] : [args[0]];
          for (let i = 1; i < args.length; i++) {
            if (Array.isArray(args[i])) {
              result.push(...args[i]);
            } else {
              result.push(args[i]);
            }
          }
          return result;
        });
        funcMap.set("prepend", (arr, ...items) => {
          if (Array.isArray(arr)) {
            return [...items, ...arr];
          }
          return [...items, arr];
        });
        funcMap.set("seq", (...args) => {
          if (args.length < 1 || args.length > 3) {
            throw new Error("invalid number of arguments to Seq");
          }
          const intArgs = args.map((arg) => {
            const num = Number(arg);
            if (isNaN(num)) {
              throw new Error("invalid arguments to Seq");
            }
            return Math.floor(num);
          });
          let inc = 1;
          let last;
          let first = intArgs[0];
          if (intArgs.length === 1) {
            last = first;
            if (last === 0) {
              return [];
            } else if (last > 0) {
              first = 1;
            } else {
              first = -1;
              inc = -1;
            }
          } else if (intArgs.length === 2) {
            last = intArgs[1];
            if (last < first) {
              inc = -1;
            }
          } else {
            inc = intArgs[1];
            last = intArgs[2];
            if (inc === 0) {
              throw new Error("'increment' must not be 0");
            }
            if (first < last && inc < 0) {
              throw new Error("'increment' must be > 0");
            }
            if (first > last && inc > 0) {
              throw new Error("'increment' must be < 0");
            }
          }
          if (last < -1e5) {
            throw new Error("size of result exceeds limit");
          }
          const size = Math.floor((last - first) / inc) + 1;
          if (size <= 0 || size > 2e3) {
            throw new Error("size of result exceeds limit");
          }
          const seq = new Array(size);
          let val = first;
          for (let i = 0; i < size; i++) {
            seq[i] = val;
            val += inc;
            if (inc < 0 && val < last || inc > 0 && val > last) {
              break;
            }
          }
          return seq;
        });
        funcMap.set("sort", (list, ...args) => {
          if (list === null || list === void 0) {
            throw new Error("sequence must be provided");
          }
          let arr;
          if (Array.isArray(list)) {
            arr = [...list];
          } else if (typeof list === "object" && list !== null) {
            arr = Object.values(list);
          } else {
            throw new Error(`can't sort ${typeof list}`);
          }
          if (arr.length === 0) {
            return arr;
          }
          let sortByField = "";
          let sortAsc = true;
          for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (i === 0) {
              if (typeof arg === "string") {
                sortByField = arg;
              }
            } else if (i === 1) {
              if (typeof arg === "string" && arg.toLowerCase() === "desc") {
                sortAsc = false;
              }
            }
          }
          const getNestedValue2 = (obj, path6) => {
            if (!path6 || path6 === "value") {
              return obj;
            }
            const keys = path6.split(".");
            let current = obj;
            for (const key of keys) {
              if (current === null || current === void 0) {
                return void 0;
              }
              if (typeof current === "object") {
                current = current[key];
              } else {
                return void 0;
              }
            }
            return current;
          };
          const compare = (a, b) => {
            let aVal = sortByField ? getNestedValue2(a, sortByField) : a;
            let bVal = sortByField ? getNestedValue2(b, sortByField) : b;
            if (aVal === void 0 || aVal === null) {
              if (bVal === void 0 || bVal === null) {
                return 0;
              }
              return sortAsc ? -1 : 1;
            }
            if (bVal === void 0 || bVal === null) {
              return sortAsc ? 1 : -1;
            }
            if (typeof aVal === "string" && typeof bVal === "string") {
              const result2 = aVal.localeCompare(bVal);
              return sortAsc ? result2 : -result2;
            }
            if (typeof aVal === "number" && typeof bVal === "number") {
              const result2 = aVal - bVal;
              return sortAsc ? result2 : -result2;
            }
            const aStr = String(aVal);
            const bStr = String(bVal);
            const result = aStr.localeCompare(bStr);
            return sortAsc ? result : -result;
          };
          return arr.sort(compare);
        });
        funcMap.set("where", (() => {
          return (collection, key, ...args) => {
            if (!collection) {
              return [];
            }
            let matchValue;
            let operator = "==";
            if (args.length === 1) {
              matchValue = args[0];
            } else if (args.length === 2) {
              operator = args[0];
              matchValue = args[1];
            } else {
              throw new Error("where function requires 2-4 arguments");
            }
            const result = [];
            if (Array.isArray(collection)) {
              for (let i = 0; i < collection.length; i++) {
                const item = collection[i];
                const itemValue = this.getNestedValue(item, key);
                if (this.checkCondition(itemValue, matchValue, operator)) {
                  result.push(item);
                }
              }
            } else if (typeof collection === "object") {
              for (const [mapKey, mapValue] of Object.entries(collection)) {
                if (Array.isArray(mapValue)) {
                  const filtered = mapValue.filter((item) => {
                    const itemValue = this.getNestedValue(item, key);
                    return this.checkCondition(itemValue, matchValue, operator);
                  });
                  if (filtered.length > 0) {
                    result.push({ [mapKey]: filtered });
                  }
                }
              }
            }
            return result;
          };
        })());
        funcMap.set("intersect", (set1, set2) => {
          if (!Array.isArray(set1) || !Array.isArray(set2)) {
            return [];
          }
          return set1.filter((item) => set2.includes(item));
        });
        funcMap.set("querify", (...args) => {
          let params = [];
          if (args.length === 1 && Array.isArray(args[0])) {
            params = args[0];
          } else {
            params = args;
          }
          if (params.length % 2 !== 0) {
            throw new Error("querify requires an even number of arguments (key-value pairs)");
          }
          const queryParams = [];
          for (let i = 0; i < params.length; i += 2) {
            const key = String(params[i]);
            const value2 = String(params[i + 1]);
            queryParams.push([key, value2]);
          }
          queryParams.sort((a, b) => a[0].localeCompare(b[0]));
          const queryString = queryParams.map(([key, value2]) => {
            const encodedKey = encodeURIComponent(key).replace(/%20/g, "+");
            const encodedValue = encodeURIComponent(value2).replace(/%20/g, "+");
            return `${encodedKey}=${encodedValue}`;
          }).join("&");
          return queryString;
        });
      }
      doIndex(item, indices) {
        if (item === null || item === void 0) {
          return null;
        }
        if (indices.length === 0) {
          return item;
        }
        let currentValue = item;
        for (const index of indices) {
          if (currentValue === null || currentValue === void 0) {
            return null;
          }
          if (Array.isArray(currentValue)) {
            currentValue = this.indexArray(currentValue, index);
          } else if (typeof currentValue === "string") {
            currentValue = this.indexString(currentValue, index);
          } else if (typeof currentValue === "object") {
            currentValue = this.indexObject(currentValue, index);
          } else {
            throw new Error(`can't index item of type ${typeof currentValue}`);
          }
        }
        return currentValue;
      }
      indexArray(arr, index) {
        const i = this.toInteger(index);
        if (i === null) {
          throw new Error(`cannot index slice/array with type ${typeof index}`);
        }
        if (i < 0 || i >= arr.length) {
          return null;
        }
        return arr[i];
      }
      indexString(str, index) {
        const i = this.toInteger(index);
        if (i === null) {
          throw new Error(`cannot index string with type ${typeof index}`);
        }
        if (i < 0 || i >= str.length) {
          return null;
        }
        return str.charAt(i);
      }
      indexObject(obj, key) {
        const keyStr = String(key);
        if (obj.hasOwnProperty(keyStr)) {
          return obj[keyStr];
        }
        const keys = Object.keys(obj);
        const matchingKey = keys.find((k) => k.toLowerCase() === keyStr.toLowerCase());
        if (matchingKey) {
          return obj[matchingKey];
        }
        if (obj instanceof Map) {
          if (obj.has(keyStr)) {
            return obj.get(keyStr);
          }
          for (const k of obj.keys()) {
            if (String(k).toLowerCase() === keyStr.toLowerCase()) {
              return obj.get(k);
            }
          }
        }
        return null;
      }
      toInteger(value2) {
        if (typeof value2 === "number") {
          if (Number.isInteger(value2)) {
            return value2;
          }
          return Math.floor(value2);
        }
        if (typeof value2 === "string") {
          const parsed = parseInt(value2, 10);
          if (!isNaN(parsed)) {
            return parsed;
          }
        }
        return null;
      }
      checkCondition(value2, matchValue, operator) {
        const op = operator.toLowerCase().trim();
        if (value2 == null && matchValue == null) {
          return ["==", "=", "eq", ""].includes(op);
        }
        if (value2 == null || matchValue == null) {
          return ["!=", "<>", "ne"].includes(op);
        }
        if (op === "in") {
          if (Array.isArray(matchValue)) {
            return matchValue.includes(value2);
          }
          if (typeof matchValue === "string" && typeof value2 === "string") {
            return matchValue.includes(value2);
          }
          return false;
        }
        if (op === "intersect") {
          if (Array.isArray(value2) && Array.isArray(matchValue)) {
            return value2.some((item) => matchValue.includes(item));
          }
          return false;
        }
        const [normalizedValue, normalizedMatch] = this.normalizeForComparison(value2, matchValue);
        switch (op) {
          case "":
          case "=":
          case "==":
          case "eq":
            return normalizedValue === normalizedMatch;
          case "!=":
          case "<>":
          case "ne":
            return normalizedValue !== normalizedMatch;
          case "<":
          case "lt":
            return normalizedValue < normalizedMatch;
          case "<=":
          case "le":
            return normalizedValue <= normalizedMatch;
          case ">":
          case "gt":
            return normalizedValue > normalizedMatch;
          case ">=":
          case "ge":
            return normalizedValue >= normalizedMatch;
          default:
            return false;
        }
      }
      normalizeForComparison(value2, matchValue) {
        if (typeof value2 === "number" && typeof matchValue === "number") {
          return [value2, matchValue];
        }
        if (typeof value2 === "number" && typeof matchValue === "string") {
          const num = parseFloat(matchValue);
          if (!isNaN(num)) {
            return [value2, num];
          }
        }
        if (typeof value2 === "string" && typeof matchValue === "number") {
          const num = parseFloat(value2);
          if (!isNaN(num)) {
            return [num, matchValue];
          }
        }
        if (typeof value2 === "string" && typeof matchValue === "string") {
          return [value2, matchValue];
        }
        if (typeof value2 === "boolean" && typeof matchValue === "boolean") {
          return [value2, matchValue];
        }
        return [String(value2), String(matchValue)];
      }
      registerSafeFunctions(funcMap) {
        funcMap.set("return", (...args) => {
          if (args.length === 0) {
            return "";
          }
          if (args.length === 1) {
            return args[0];
          }
          return args;
        });
        funcMap.set("cond", (...args) => {
          if (args.length < 2) {
            throw new Error("cond requires at least 2 arguments");
          }
          const condition = args[0];
          const trueValue = args[1];
          const falseValue = args.length > 2 ? args[2] : "";
          let isTrue = false;
          if (condition === true || condition === 1) {
            isTrue = true;
          } else if (typeof condition === "string") {
            isTrue = condition.length > 0 && condition !== "false" && condition !== "0";
          } else if (typeof condition === "number") {
            isTrue = condition !== 0;
          } else if (Array.isArray(condition)) {
            isTrue = condition.length > 0;
          } else if (condition && typeof condition === "object") {
            isTrue = Object.keys(condition).length > 0;
          }
          return isTrue ? trueValue : falseValue;
        });
        funcMap.set("safeHTML", (str) => str);
        funcMap.set("safeCSS", (str) => str);
        funcMap.set("safeJS", (str) => str);
        funcMap.set("safeURL", (str) => str);
        funcMap.set("dict", (...args) => {
          if (args.length % 2 !== 0) {
            throw new Error("dict requires an even number of arguments");
          }
          const result = {};
          for (let i = 0; i < args.length; i += 2) {
            result[String(args[i])] = args[i + 1];
          }
          return result;
        });
        funcMap.set("slice", (...args) => {
          return args;
        });
        funcMap.set("default", (defaultValue, value2) => {
          if (value2 !== null && value2 !== void 0 && value2 !== "" && value2 !== 0) {
            return value2;
          }
          return defaultValue;
        });
        funcMap.set("jsonify", (...args) => {
          if (args.length === 0) {
            return "";
          }
          let obj;
          let opts = {};
          if (args.length === 1) {
            obj = args[0];
          } else if (args.length === 2) {
            const options = args[0];
            obj = args[1];
            if (options && typeof options === "object") {
              opts.prefix = options.prefix || "";
              opts.indent = options.indent || "";
              opts.noHTMLEscape = options.noHTMLEscape || false;
            }
          } else {
            throw new Error("too many arguments to jsonify");
          }
          try {
            let jsonString;
            if (opts.indent) {
              jsonString = JSON.stringify(obj, null, opts.indent);
              if (opts.prefix) {
                jsonString = jsonString.split("\n").map((line) => opts.prefix + line).join("\n");
              }
            } else {
              jsonString = JSON.stringify(obj);
            }
            if (!opts.noHTMLEscape) {
              jsonString = jsonString.replace(/&/g, "\\u0026").replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
            }
            return jsonString;
          } catch (error) {
            throw new Error(`failed to jsonify object: ${error.message}`);
          }
        });
      }
      registerFmtFunctions(funcMap) {
        funcMap.set("printf", (format, ...args) => {
          let result = format;
          let argIndex = 0;
          result = result.replace(/%[vsdft%]/g, (match) => {
            if (match === "%%") {
              return "%";
            }
            if (argIndex >= args.length) {
              return match;
            }
            const arg = args[argIndex++];
            switch (match) {
              case "%v":
              case "%s":
                return String(arg);
              case "%d":
                return String(Math.floor(Number(arg) || 0));
              case "%f":
                return String(Number(arg) || 0);
              case "%t":
                return String(Boolean(arg));
              default:
                return String(arg);
            }
          });
          return result;
        });
        funcMap.set("print", (...args) => {
          return args.map((arg) => String(arg)).join(" ");
        });
        funcMap.set("println", (...args) => {
          return args.map((arg) => String(arg)).join(" ") + "\n";
        });
        funcMap.set("errorf", (format, ...args) => {
          let message = format;
          for (let i = 0; i < args.length; i++) {
            message = message.replace(/%[sd%]/, String(args[i]));
          }
          log.error("Template Error:", message);
          return "";
        });
        funcMap.set("warnf", (format, ...args) => {
          let message = format;
          for (let i = 0; i < args.length; i++) {
            message = message.replace(/%[sd%]/, String(args[i]));
          }
          log.warn("Template Warning:", message);
          return "";
        });
        funcMap.set("fmt", () => ({
          Print: (...args) => {
            return args.map((arg) => String(arg)).join(" ");
          },
          Printf: (format, ...args) => {
            let result = format;
            for (let i = 0; i < args.length; i++) {
              result = result.replace(/%[sd%]/, String(args[i]));
            }
            return result;
          },
          Println: (...args) => {
            return args.map((arg) => String(arg)).join(" ") + "\n";
          },
          Errorf: (format, ...args) => {
            let message = format;
            for (let i = 0; i < args.length; i++) {
              message = message.replace(/%[sd%]/, String(args[i]));
            }
            log.error("Template Error:", message);
            return "";
          },
          Erroridf: (id, format, ...args) => {
            let message = format;
            for (let i = 0; i < args.length; i++) {
              message = message.replace(/%[sd%]/, String(args[i]));
            }
            log.error("Template Error:", message);
            return "";
          },
          Warnf: (format, ...args) => {
            let message = format;
            for (let i = 0; i < args.length; i++) {
              message = message.replace(/%[sd%]/, String(args[i]));
            }
            log.error("Template Warning:", message);
            return "";
          },
          Warnidf: (id, format, ...args) => {
            let message = format;
            for (let i = 0; i < args.length; i++) {
              message = message.replace(/%[sd%]/, String(args[i]));
            }
            log.error("Template Warning:", message);
            return "";
          }
        }));
      }
      registerReflectFunctions(funcMap) {
        funcMap.set("reflect", () => ({
          IsMap: (v) => {
            if (v === null || v === void 0) {
              return false;
            }
            if (typeof v !== "object" || Array.isArray(v)) {
              return false;
            }
            if (v instanceof Map) {
              return true;
            }
            if (v.constructor === Object) {
              return true;
            }
            const proto = Object.getPrototypeOf(v);
            if (proto === Object.prototype || proto === null) {
              return true;
            }
            return false;
          },
          IsSlice: (v) => {
            return Array.isArray(v);
          }
        }));
      }
      registerPathFunctions(funcMap) {
        funcMap.set("path", () => ({
          Base: (path6) => {
            if (!path6)
              return ".";
            path6 = path6.replace(/\\/g, "/");
            path6 = path6.replace(/\/+$/, "");
            if (!path6)
              return "/";
            const parts = path6.split("/");
            return parts[parts.length - 1] || "/";
          },
          Clean: (path6) => {
            if (!path6)
              return ".";
            path6 = path6.replace(/\\/g, "/");
            const isAbs = path6.startsWith("/");
            const parts = path6.split("/").filter((p) => p && p !== ".");
            const stack = [];
            for (const part of parts) {
              if (part === "..") {
                if (stack.length > 0 && stack[stack.length - 1] !== "..") {
                  stack.pop();
                } else if (!isAbs) {
                  stack.push("..");
                }
              } else {
                stack.push(part);
              }
            }
            path6 = stack.join("/");
            if (isAbs)
              path6 = "/" + path6;
            return path6 || (isAbs ? "/" : ".");
          },
          Dir: (path6) => {
            if (!path6)
              return ".";
            path6 = path6.replace(/\/+$/, "");
            if (!path6)
              return "/";
            const parts = path6.split("/");
            parts.pop();
            return parts.join("/") || ".";
          },
          Ext: (path6) => {
            const base = path6.split("/").pop() || "";
            const dot = base.lastIndexOf(".");
            if (dot === -1 || dot === 0)
              return "";
            return base.substring(dot);
          },
          IsAbs: (path6) => {
            return path6.startsWith("/");
          },
          Join: (...elements) => {
            if (elements.length === 0)
              return ".";
            const parts = elements.filter((e) => e).map((e) => e.replace(/^\/+|\/+$/g, ""));
            let path6 = parts.join("/");
            if (elements[0] && elements[0].startsWith("/")) {
              path6 = "/" + path6;
            }
            return path6 || ".";
          },
          Split: (path6) => {
            if (!path6)
              return [".", ""];
            const lastSlash = path6.lastIndexOf("/");
            if (lastSlash === -1) {
              return ["", path6];
            }
            return [
              path6.substring(0, lastSlash),
              path6.substring(lastSlash + 1)
            ];
          }
        }));
      }
      registerTransformFunctions(funcMap) {
        funcMap.set("transform", () => ({
          Unmarshal: (...args) => {
            if (args.length < 1 || args.length > 2) {
              throw new Error("unmarshal takes 1 or 2 arguments");
            }
            let data;
            let options = {};
            if (args.length === 1) {
              data = args[0];
            } else {
              const opts = args[0];
              if (!opts || typeof opts !== "object") {
                throw new Error("first argument must be a map");
              }
              options = opts;
              data = args[1];
            }
            if (data && typeof data === "object" && typeof data.Content === "function") {
              try {
                const content = data.Content();
                return this.unmarshalContent(content, options);
              } catch (error) {
                throw new Error(`failed to get content from resource: ${error.message}`);
              }
            }
            let dataStr;
            if (typeof data === "string") {
              dataStr = data;
            } else if (data && typeof data.toString === "function") {
              dataStr = data.toString();
            } else {
              throw new Error(`type ${typeof data} not supported`);
            }
            if (!dataStr || dataStr.trim() === "") {
              return null;
            }
            return this.unmarshalContent(dataStr, options);
          }
        }));
        funcMap.set("unmarshal", (...args) => {
          const transform = funcMap.get("transform")();
          return transform.Unmarshal(...args);
        });
      }
      unmarshalContent(content, options = {}) {
        const trimmedContent = content.trim();
        if (!trimmedContent) {
          return null;
        }
        let format = options.format;
        if (!format) {
          format = this.detectFormat(trimmedContent);
        }
        try {
          switch (format.toLowerCase()) {
            case "json":
              return JSON.parse(trimmedContent);
            case "yaml":
            case "yml":
              return this.parseYAML(trimmedContent);
            case "toml":
              return this.parseTOML(trimmedContent);
            case "csv":
              return this.parseCSV(trimmedContent);
            default:
              throw new Error(`format "${format}" not supported`);
          }
        } catch (error) {
          throw new Error(`failed to unmarshal ${format}: ${error.message}`);
        }
      }
      detectFormat(content) {
        const trimmed = content.trim();
        if (trimmed.startsWith("{") && trimmed.endsWith("}") || trimmed.startsWith("[") && trimmed.endsWith("]")) {
          try {
            JSON.parse(trimmed);
            return "json";
          } catch {
          }
        }
        if (trimmed.startsWith("---") || /^[a-zA-Z_][a-zA-Z0-9_]*\s*:\s*.+/m.test(trimmed)) {
          return "yaml";
        }
        if (/^\[.*\]$/m.test(trimmed) || /^[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*.+/m.test(trimmed)) {
          return "toml";
        }
        if (/^[^,\n]*,[^,\n]*/.test(trimmed)) {
          return "csv";
        }
        return "json";
      }
      parseYAML(content) {
        const lines = content.split("\n");
        const result = {};
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine || trimmedLine.startsWith("#") || trimmedLine === "---") {
            continue;
          }
          const colonIndex = trimmedLine.indexOf(":");
          if (colonIndex > 0) {
            const key = trimmedLine.substring(0, colonIndex).trim();
            let value2 = trimmedLine.substring(colonIndex + 1).trim();
            if (value2.startsWith('"') && value2.endsWith('"') || value2.startsWith("'") && value2.endsWith("'")) {
              value2 = value2.slice(1, -1);
            }
            if (value2 === "true") {
              result[key] = true;
            } else if (value2 === "false") {
              result[key] = false;
            } else if (/^\d+$/.test(value2)) {
              result[key] = parseInt(value2, 10);
            } else if (/^\d*\.\d+$/.test(value2)) {
              result[key] = parseFloat(value2);
            } else {
              result[key] = value2;
            }
          }
        }
        return result;
      }
      parseTOML(content) {
        const lines = content.split("\n");
        const result = {};
        let currentSection = "";
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine || trimmedLine.startsWith("#")) {
            continue;
          }
          if (trimmedLine.startsWith("[") && trimmedLine.endsWith("]")) {
            currentSection = trimmedLine.slice(1, -1);
            if (!result[currentSection]) {
              result[currentSection] = {};
            }
            continue;
          }
          const equalIndex = trimmedLine.indexOf("=");
          if (equalIndex > 0) {
            const key = trimmedLine.substring(0, equalIndex).trim();
            let value2 = trimmedLine.substring(equalIndex + 1).trim();
            if (value2.startsWith('"') && value2.endsWith('"') || value2.startsWith("'") && value2.endsWith("'")) {
              value2 = value2.slice(1, -1);
            }
            let parsedValue;
            if (value2 === "true") {
              parsedValue = true;
            } else if (value2 === "false") {
              parsedValue = false;
            } else if (/^\d+$/.test(value2)) {
              parsedValue = parseInt(value2, 10);
            } else if (/^\d*\.\d+$/.test(value2)) {
              parsedValue = parseFloat(value2);
            } else {
              parsedValue = value2;
            }
            if (currentSection) {
              result[currentSection][key] = parsedValue;
            } else {
              result[key] = parsedValue;
            }
          }
        }
        return result;
      }
      parseCSV(content) {
        const lines = content.trim().split("\n");
        if (lines.length === 0) {
          return [];
        }
        const headers = this.parseCSVLine(lines[0]);
        const result = [];
        for (let i = 1; i < lines.length; i++) {
          const values = this.parseCSVLine(lines[i]);
          const row = {};
          for (let j = 0; j < headers.length; j++) {
            const header = headers[j];
            const value2 = j < values.length ? values[j] : "";
            if (/^\d+$/.test(value2)) {
              row[header] = parseInt(value2, 10);
            } else if (/^\d*\.\d+$/.test(value2)) {
              row[header] = parseFloat(value2);
            } else if (value2 === "true") {
              row[header] = true;
            } else if (value2 === "false") {
              row[header] = false;
            } else {
              row[header] = value2;
            }
          }
          result.push(row);
        }
        return result;
      }
      parseCSVLine(line) {
        const result = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char2 = line[i];
          if (char2 === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char2 === "," && !inQuotes) {
            result.push(current.trim());
            current = "";
          } else {
            current += char2;
          }
        }
        result.push(current.trim());
        return result;
      }
      getNestedValue(obj, path6) {
        if (!obj || !path6) {
          return void 0;
        }
        const cleanPath = path6.replace(/^\\.+/, "");
        const parts = cleanPath.split(".");
        let current = obj;
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          if (current == null) {
            return void 0;
          }
          if (typeof current === "object") {
            if (current.hasOwnProperty(part)) {
              current = current[part];
              continue;
            }
            const keys = Object.keys(current);
            const matchingKey = keys.find((k) => k.toLowerCase() === part.toLowerCase());
            if (matchingKey) {
              current = current[matchingKey];
              continue;
            }
            const methodName = part.toLowerCase();
            if (typeof current[methodName] === "function") {
              try {
                current = current[methodName]();
                continue;
              } catch (error) {
                return void 0;
              }
            }
            return void 0;
          } else {
            return void 0;
          }
        }
        return current;
      }
    };
    exports2.DefaultTemplateRegistry = DefaultTemplateRegistry;
    function newTemplateRegistry() {
      return new DefaultTemplateRegistry();
    }
    function createCoreFuncMap() {
      const funcMap = /* @__PURE__ */ new Map();
      const registry = newTemplateRegistry();
      registry.registerCoreFunctions(funcMap);
      return funcMap;
    }
    function createStandardFuncMap(services) {
      const funcMap = /* @__PURE__ */ new Map();
      const registry = newTemplateRegistry();
      registry.registerAllFunctions(funcMap, services);
      return funcMap;
    }
    function updateEngineDependentFunctions(engine) {
      for (const func of engineDependentFunctions) {
        try {
          func.updateEngine(engine);
        } catch (error) {
          log.error(`\u274C Failed to update function ${func.getFunctionName()}:`, error);
        }
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/factory/template.js
var require_template3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/factory/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Builder = exports2.Factory = void 0;
    exports2.newTemplateFactory = newTemplateFactory;
    exports2.newBuilder = newBuilder;
    exports2.createTemplateEngine = createTemplateEngine;
    exports2.createTemplateEngineWithServices = createTemplateEngineWithServices;
    var type_1 = require_type9();
    var template_1 = require_template2();
    var executor_1 = require_executor();
    var parser_1 = require_parser();
    var lookup_1 = require_lookup();
    var namespace_1 = require_namespace();
    var baseof_1 = require_baseof();
    var registry_1 = require_registry();
    var Factory = class {
      async create(fs5) {
        return this.createWithConfig(fs5, {});
      }
      async createWithConfig(fs5, config) {
        try {
          const builder = new Builder().withFs(fs5).withNamespaces((0, namespace_1.newRegularTemplateNamespace)(), (0, namespace_1.newPartialTemplateNamespace)(), (0, namespace_1.newShortcodeTemplateNamespace)());
          if (config.services) {
            builder.withServices(config.services);
          } else if (config.funcMap) {
            builder.withFuncMap(config.funcMap);
          } else {
            builder.withFuncMap((0, registry_1.createCoreFuncMap)());
          }
          const engine = await builder.buildLookup().buildParser().buildExecutor().build();
          await engine.markReady();
          return engine;
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Failed to create template engine: ${message}`, "FACTORY_CREATE_FAILED");
        }
      }
      async createWithServices(fs5, services) {
        return this.createWithConfig(fs5, { services });
      }
    };
    exports2.Factory = Factory;
    var Builder = class {
      constructor() {
        this.funcMap = /* @__PURE__ */ new Map();
      }
      withFs(fs5) {
        this.fs = fs5;
        return this;
      }
      withNamespaces(templateNamespace, partialNamespace, shortcodeNamespace) {
        this.templateNamespace = templateNamespace;
        this.partialNamespace = partialNamespace;
        this.shortcodeNamespace = shortcodeNamespace;
        return this;
      }
      withFuncMap(funcMap) {
        this.funcMap = new Map([...this.funcMap, ...funcMap]);
        return this;
      }
      withServices(services) {
        this.services = services;
        this.funcMap = (0, registry_1.createStandardFuncMap)(services);
        return this;
      }
      buildLookup() {
        const baseOf = (0, baseof_1.newBaseOf)();
        this.lookup = (0, lookup_1.newLookup)(baseOf, this.funcMap);
        return this;
      }
      buildParser() {
        this.parser = (0, parser_1.newParser)(this.funcMap);
        return this;
      }
      buildExecutor() {
        this.executor = (0, executor_1.newExecutor)();
        return this;
      }
      async build() {
        if (!this.fs) {
          throw new type_1.TemplateError("File system is required", "BUILDER_FS_REQUIRED");
        }
        if (!this.templateNamespace) {
          throw new type_1.TemplateError("Template namespace is required", "BUILDER_TEMPLATE_NAMESPACE_REQUIRED");
        }
        if (!this.partialNamespace) {
          throw new type_1.TemplateError("Partial namespace is required", "BUILDER_PARTIAL_NAMESPACE_REQUIRED");
        }
        if (!this.shortcodeNamespace) {
          throw new type_1.TemplateError("Shortcode namespace is required", "BUILDER_SHORTCODE_NAMESPACE_REQUIRED");
        }
        if (!this.lookup) {
          throw new type_1.TemplateError("Lookup is required", "BUILDER_LOOKUP_REQUIRED");
        }
        if (!this.parser) {
          throw new type_1.TemplateError("Parser is required", "BUILDER_PARSER_REQUIRED");
        }
        if (!this.executor) {
          throw new type_1.TemplateError("Executor is required", "BUILDER_EXECUTOR_REQUIRED");
        }
        const engine = (0, template_1.newTemplateEngine)(this.executor, this.lookup, this.parser, this.templateNamespace, this.partialNamespace, this.shortcodeNamespace, this.fs);
        (0, registry_1.updateEngineDependentFunctions)(engine);
        try {
          await engine.loadTemplates();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          throw new type_1.TemplateError(`Failed to load templates: ${message}`, "BUILDER_LOAD_TEMPLATES_FAILED");
        }
        return engine;
      }
    };
    exports2.Builder = Builder;
    function newTemplateFactory() {
      return new Factory();
    }
    function newBuilder() {
      return new Builder();
    }
    async function createTemplateEngine(fs5, funcMap) {
      const factory = newTemplateFactory();
      const config = {};
      if (funcMap) {
        config.funcMap = funcMap;
      }
      return factory.createWithConfig(fs5, config);
    }
    async function createTemplateEngineWithServices(fs5, services) {
      const factory = newTemplateFactory();
      return factory.createWithServices(fs5, services);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/template/index.js
var require_template4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/template/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTemplateEngineWithServices = exports2.createTemplateEngine = exports2.newBuilder = exports2.newTemplateFactory = exports2.Builder = exports2.Factory = exports2.newTemplateEngine = exports2.TemplateEngine = exports2.newLookup = exports2.Lookup = exports2.newParser = exports2.Parser = exports2.newExecutor = exports2.Executor = exports2.newShortcodeTemplateNamespace = exports2.newPartialTemplateNamespace = exports2.newRegularTemplateNamespace = exports2.ShortcodeTemplateNamespace = exports2.PartialTemplateNamespace = exports2.RegularTemplateNamespace = exports2.loadTemplate = exports2.VoTemplateInfo = exports2.newBaseOf = exports2.BaseOf = exports2.PARTIALS_PREFIX = exports2.BASE_DEFAULT = exports2.BASE_FILE_BASE = exports2.ErrInvalidTemplate = exports2.ErrTemplateExecuteFailed = exports2.ErrTemplateParseFailed = exports2.ErrTemplateNotFound = exports2.TemplateError = void 0;
    __exportStar(require_type9(), exports2);
    var type_1 = require_type9();
    Object.defineProperty(exports2, "TemplateError", { enumerable: true, get: function() {
      return type_1.TemplateError;
    } });
    Object.defineProperty(exports2, "ErrTemplateNotFound", { enumerable: true, get: function() {
      return type_1.ErrTemplateNotFound;
    } });
    Object.defineProperty(exports2, "ErrTemplateParseFailed", { enumerable: true, get: function() {
      return type_1.ErrTemplateParseFailed;
    } });
    Object.defineProperty(exports2, "ErrTemplateExecuteFailed", { enumerable: true, get: function() {
      return type_1.ErrTemplateExecuteFailed;
    } });
    Object.defineProperty(exports2, "ErrInvalidTemplate", { enumerable: true, get: function() {
      return type_1.ErrInvalidTemplate;
    } });
    Object.defineProperty(exports2, "BASE_FILE_BASE", { enumerable: true, get: function() {
      return type_1.BASE_FILE_BASE;
    } });
    Object.defineProperty(exports2, "BASE_DEFAULT", { enumerable: true, get: function() {
      return type_1.BASE_DEFAULT;
    } });
    Object.defineProperty(exports2, "PARTIALS_PREFIX", { enumerable: true, get: function() {
      return type_1.PARTIALS_PREFIX;
    } });
    var baseof_1 = require_baseof();
    Object.defineProperty(exports2, "BaseOf", { enumerable: true, get: function() {
      return baseof_1.BaseOf;
    } });
    Object.defineProperty(exports2, "newBaseOf", { enumerable: true, get: function() {
      return baseof_1.newBaseOf;
    } });
    var info_1 = require_info();
    Object.defineProperty(exports2, "VoTemplateInfo", { enumerable: true, get: function() {
      return info_1.TemplateInfo;
    } });
    Object.defineProperty(exports2, "loadTemplate", { enumerable: true, get: function() {
      return info_1.loadTemplate;
    } });
    var namespace_1 = require_namespace();
    Object.defineProperty(exports2, "RegularTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.RegularTemplateNamespace;
    } });
    Object.defineProperty(exports2, "PartialTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.PartialTemplateNamespace;
    } });
    Object.defineProperty(exports2, "ShortcodeTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.ShortcodeTemplateNamespace;
    } });
    Object.defineProperty(exports2, "newRegularTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.newRegularTemplateNamespace;
    } });
    Object.defineProperty(exports2, "newPartialTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.newPartialTemplateNamespace;
    } });
    Object.defineProperty(exports2, "newShortcodeTemplateNamespace", { enumerable: true, get: function() {
      return namespace_1.newShortcodeTemplateNamespace;
    } });
    var executor_1 = require_executor();
    Object.defineProperty(exports2, "Executor", { enumerable: true, get: function() {
      return executor_1.Executor;
    } });
    Object.defineProperty(exports2, "newExecutor", { enumerable: true, get: function() {
      return executor_1.newExecutor;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
      return parser_1.Parser;
    } });
    Object.defineProperty(exports2, "newParser", { enumerable: true, get: function() {
      return parser_1.newParser;
    } });
    var lookup_1 = require_lookup();
    Object.defineProperty(exports2, "Lookup", { enumerable: true, get: function() {
      return lookup_1.Lookup;
    } });
    Object.defineProperty(exports2, "newLookup", { enumerable: true, get: function() {
      return lookup_1.newLookup;
    } });
    var template_1 = require_template2();
    Object.defineProperty(exports2, "TemplateEngine", { enumerable: true, get: function() {
      return template_1.TemplateEngine;
    } });
    Object.defineProperty(exports2, "newTemplateEngine", { enumerable: true, get: function() {
      return template_1.newTemplateEngine;
    } });
    var template_2 = require_template3();
    Object.defineProperty(exports2, "Factory", { enumerable: true, get: function() {
      return template_2.Factory;
    } });
    Object.defineProperty(exports2, "Builder", { enumerable: true, get: function() {
      return template_2.Builder;
    } });
    Object.defineProperty(exports2, "newTemplateFactory", { enumerable: true, get: function() {
      return template_2.newTemplateFactory;
    } });
    Object.defineProperty(exports2, "newBuilder", { enumerable: true, get: function() {
      return template_2.newBuilder;
    } });
    Object.defineProperty(exports2, "createTemplateEngine", { enumerable: true, get: function() {
      return template_2.createTemplateEngine;
    } });
    Object.defineProperty(exports2, "createTemplateEngineWithServices", { enumerable: true, get: function() {
      return template_2.createTemplateEngineWithServices;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagebuilder.js
var require_pagebuilder = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/pagebuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageBuilder = void 0;
    var pagecontent_1 = require_pagecontent();
    var frontmatter_1 = require_frontmatter();
    var kind_1 = require_kind();
    var section_1 = require_section();
    var standalone_1 = require_standalone();
    var log_1 = require_log();
    var page_1 = require_page();
    var pagemeta_1 = require_pagemeta();
    var pagelayout_1 = require_pagelayout();
    var paginator_1 = require_paginator();
    var shortcode_1 = require_shortcode2();
    var template_1 = require_template4();
    var log = (0, log_1.getDomainLogger)("content", { component: "pagebuilder" });
    var PageBuilder = class {
      constructor(langSvc, taxonomySvc, templateSvc, pageMapper, taxonomy, term, section, standalone, converter, contentHub) {
        this.renderableDocument = null;
        this.langSvc = langSvc;
        this.taxonomySvc = taxonomySvc;
        this.templateSvc = templateSvc;
        this.pageMapper = null;
        this.taxonomy = taxonomy;
        this.term = term;
        this.section = section;
        this.standalone = standalone;
        this.converter = converter;
        this.contentHub = contentHub;
        this.source = null;
        this.sourceByte = new Uint8Array();
        this.kind = "";
        this.singular = "";
        this.term_ = "";
        this.langIdx = -1;
        this.fm = null;
        this.fmParser = null;
        this.c = null;
      }
      withSource(source) {
        const cloneBuilder = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        cloneBuilder.reset();
        cloneBuilder.source = source;
        return cloneBuilder;
      }
      withLangIdx(idx) {
        this.langIdx = idx;
        return this;
      }
      reset() {
        this.c = null;
        this.kind = "";
        this.langIdx = -1;
      }
      async build() {
        if (!this.source) {
          throw new Error("source for page builder is nil");
        }
        const contentBytes = await this.source.contentSource();
        this.sourceByte = contentBytes;
        await this.parse(contentBytes);
        const p = await this.buildInternal();
        await this.render(p);
        return p;
      }
      async kindBuild() {
        if (!this.source) {
          throw new Error("source for page builder is nil");
        }
        await this.parseKind();
        if (this.langIdx === -1) {
          await this.parseLanguageByDefault();
        } else {
          await this.parseLanguageByIdx(this.langIdx);
        }
        this.fm = (0, frontmatter_1.newFrontMatter)();
        this.c = (0, pagecontent_1.newContent)(new Uint8Array());
        return await this.buildInternal();
      }
      async buildInternal() {
        switch (this.kind) {
          case (0, kind_1.getKindMain)("home"):
            return await this.buildHome();
          case (0, kind_1.getKindMain)("section"):
            return await this.buildSection();
          case (0, kind_1.getKindMain)("page"):
            return await this.buildPage();
          case (0, kind_1.getKindMain)("taxonomy"):
            return await this.buildTaxonomy();
          case (0, kind_1.getKindMain)("term"):
            return await this.buildTerm();
          case (0, kind_1.getKindMain)("404"):
            return await this.build404();
          case (0, kind_1.getKindMain)("sitemap"):
            return await this.buildSitemap();
          default:
            throw new Error(`unknown kind "${this.kind}"`);
        }
      }
      async buildPage() {
        const p = await this.newPage(this.source, this.c);
        await this.applyFrontMatter(p);
        p.pageMap = this.pageMapper;
        await this.buildOutput(p);
        await this.adaptPagination(p);
        return p;
      }
      async buildPageWithKind(kind) {
        const p = await this.newPage(this.source, this.c);
        await this.applyFrontMatter(p);
        p.pageMap = this.pageMapper;
        p.kind_ = kind;
        if (kind === (0, kind_1.getKindMain)("sitemap") || kind === (0, kind_1.getKindMain)("404")) {
          const meta = p.meta;
          if (meta) {
            meta.list = "never";
          }
        }
        await this.buildOutput(p);
        return p;
      }
      async applyFrontMatter(p) {
        if (this.fm) {
          p.title_ = this.fm.title;
          const meta = p.meta;
          if (meta) {
            meta.weight = this.fm.weight;
            meta.parameters = this.fm.params || {};
            meta.date = this.fm.date;
          }
        }
      }
      async buildHome() {
        const p = await this.buildPageWithKind((0, kind_1.getKindMain)("home"));
        await this.buildPagination(p);
        return p;
      }
      async buildSection() {
        const p = await this.buildPageWithKind((0, kind_1.getKindMain)("section"));
        await this.buildPagination(p);
        return p;
      }
      async build404() {
        const p = await this.buildPageWithKind((0, kind_1.getKindMain)("404"));
        await this.adaptPagination(p);
        return p;
      }
      async buildSitemap() {
        const p = await this.buildPageWithKind((0, kind_1.getKindMain)("sitemap"));
        await this.adaptPagination(p);
        return p;
      }
      async buildTaxonomy() {
        const taxonomyInfo = this.taxonomy.getTaxonomy(this.source.file.paths().path());
        const singular = taxonomyInfo ? taxonomyInfo.singular() : "";
        const tp = await this.newTaxonomy(this.source, this.c, singular);
        tp.pageMap = this.pageMapper;
        await this.buildOutput(tp);
        await this.buildPagination(tp);
        return tp;
      }
      async buildTerm() {
        const p = this.source.file.paths();
        const taxonomyInfo = this.taxonomy.getTaxonomy(p.path());
        const singular = taxonomyInfo ? taxonomyInfo.singular() : "";
        const term = p.unnormalized().baseNameNoIdentifier();
        const t = await this.newTerm(this.source, this.c, singular, term);
        t.pageMap = this.pageMapper;
        await this.buildOutput(t);
        await this.buildPagination(t);
        return t;
      }
      async render(p) {
        if (this.c?.lazyRendered) {
          this.c.lazyRender = async () => {
            const contentResult2 = await this.renderableDocument?.render({
              maxSummaryLength: 300,
              wordsPerMinute: 200,
              shortcodeRenderer: this.createShortcodeRenderer(p)
            });
            this.c?.updateWithContentResult(contentResult2);
          };
          return;
        }
        const contentResult = await this.renderableDocument?.render({
          maxSummaryLength: 300,
          wordsPerMinute: 200,
          shortcodeRenderer: this.createShortcodeRenderer(p)
        });
        this.c?.updateWithContentResult(contentResult);
      }
      async parse(contentBytes) {
        this.renderableDocument = await this.converter.prepareRender(contentBytes);
        this.c = (0, pagecontent_1.newContent)(contentBytes);
        this.c.toc = this.renderableDocument.toc();
        this.fmParser = new frontmatter_1.FrontMatterParserImpl(this.renderableDocument.frontMatter(), this.langSvc, this.taxonomySvc);
        await this.parseFrontMatter();
        await this.parseLanguage();
        await this.parseKind();
        await this.parseTerms();
      }
      async parseTerms() {
        if (this.fm && this.fm.terms) {
          this.term.terms = this.fm.terms;
        }
      }
      async parseKind() {
        const path6 = this.source.file.paths();
        let kind = "";
        if (this.fm) {
          kind = this.fm.kind || "";
        }
        if (kind === "") {
          kind = (0, kind_1.getKindMain)("page");
          const base = path6.baseNoLeadingSlash();
          switch (base) {
            case section_1.PAGE_HOME_BASE:
            case "":
              kind = (0, kind_1.getKindMain)("home");
              break;
            case standalone_1.STANDALONE_PAGE_404_BASE:
              kind = (0, kind_1.getKindMain)("404");
              break;
            case standalone_1.STANDALONE_PAGE_SITEMAP_BASE:
              kind = (0, kind_1.getKindMain)("sitemap");
              break;
            default:
              if (this.source.file.isBranchBundle()) {
                kind = (0, kind_1.getKindMain)("section");
                const v = this.taxonomy.getTaxonomy(path6.path());
                if (!this.taxonomy.isZero(v)) {
                  if (this.taxonomy.isTaxonomyPath(path6.path())) {
                    kind = (0, kind_1.getKindMain)("taxonomy");
                  } else {
                    kind = (0, kind_1.getKindMain)("term");
                  }
                }
              }
              break;
          }
        }
        this.kind = kind;
      }
      async parseLanguageByDefault() {
        const dl = this.langSvc.defaultLanguage();
        const idx = await this.langSvc.getLanguageIndex(dl);
        this.source.identity.lang = dl;
        this.source.identity.langIdx = idx;
      }
      async parseLanguageByIdx(langIdx) {
        const dl = this.langSvc.getLanguageByIndex(langIdx);
        this.source.identity.lang = dl;
        this.source.identity.langIdx = langIdx;
      }
      async parseLanguage() {
        const [l, ok] = this.langSvc.getSourceLang(this.source.file.fileInfo().root());
        if (ok) {
          const idx = this.langSvc.getLanguageIndex(l);
          this.source.identity.lang = l;
          this.source.identity.langIdx = idx;
          return;
        }
        await this.parseLanguageByDefault();
      }
      async parseFrontMatter() {
        if (!this.fmParser) {
          this.fm = (0, frontmatter_1.newFrontMatter)();
          return;
        }
        this.fm = await this.fmParser.parse();
      }
      createShortcodeRenderer(p) {
        return async (shortcode) => {
          if (!this.templateSvc) {
            log.warn(`Template service not available for shortcode: ${shortcode.name}`);
            return "";
          }
          try {
            if (!shortcode.name) {
              log.warn("Shortcode missing name");
              return "";
            }
            return await this.doRenderShortcode(shortcode, null, 0, p);
          } catch (error) {
            log.error(`Error rendering shortcode "${shortcode.name}":`, error);
            return "";
          }
        };
      }
      async doRenderShortcode(sc, parent, level, page) {
        if (sc.inline) {
          log.warn("Inline shortcodes are not supported yet.");
          return "";
        }
        let data = new shortcode_1.ShortcodeWithPage(sc.params || {}, "", page, parent, sc.name, typeof sc.params === "object" && !Array.isArray(sc.params), sc.ordinal || 0, sc.indentation || "", sc.pos || 0);
        if (sc.inner && sc.inner.length > 0) {
          let inner = "";
          for (const innerData of sc.inner) {
            if (typeof innerData === "string") {
              inner += innerData;
            } else if (typeof innerData === "object" && "name" in innerData) {
              const nestedResult = await this.doRenderShortcode(innerData, data, level + 1, page);
              inner += nestedResult;
            } else {
              log.error(`Illegal state on shortcode rendering of "${sc.name}". Illegal type in inner data: ${typeof innerData}`);
              return "";
            }
          }
          if (sc.doMarkup) {
            try {
              const newInner = await this.renderShortcodeMarkdown(page, inner);
              data = new shortcode_1.ShortcodeWithPage(sc.params || {}, newInner, page, parent, sc.name, typeof sc.params === "object" && !Array.isArray(sc.params), sc.ordinal || 0, sc.indentation || "", sc.pos || 0);
            } catch (error) {
              throw new Error(`Failed to process inner content: ${error}`);
            }
          } else {
            data = new shortcode_1.ShortcodeWithPage(sc.params || {}, inner, page, parent, sc.name, typeof sc.params === "object" && !Array.isArray(sc.params), sc.ordinal || 0, sc.indentation || "", sc.pos || 0);
          }
        }
        try {
          let result = await this.templateSvc?.execute(sc.name, data);
          if (!sc.inner?.length && sc.indentation) {
            const lines = result?.split("\n");
            result = lines?.map((line, i) => i === 0 ? line : sc.indentation + line).join("\n");
          }
          return result || "";
        } catch (error) {
          if (error instanceof template_1.TemplateError && error.code === "SHORTCODE_NOT_FOUND") {
            return sc.rawContent;
          }
          throw new Error(`Failed to process shortcode: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async renderShortcodeMarkdown(p, md) {
        try {
          const docCtx = {
            document: p,
            documentID: p.path(),
            documentName: p.name(),
            filename: p.pageFile().filename()
          };
          const renderCtx = {
            ctx: {},
            src: new TextEncoder().encode(md),
            renderTOC: false,
            getRenderer: () => null
          };
          const result = await this.converter.convert(docCtx, renderCtx);
          let resStr = new TextDecoder().decode(result.bytes());
          if (!resStr.includes("\n")) {
            resStr = resStr.replace(/^<p>(.*)<\/p>\n$/, "$1");
          }
          return resStr;
        } catch (error) {
          log.error(`Error rendering shortcode markdown:`, error);
          return "";
        }
      }
      async buildPagination(p) {
        const pagerSvc = {
          pageSize: () => 10,
          globalRegularPages: async () => {
            return this.contentHub ? await this.contentHub.globalRegularPages() : [];
          }
        };
        const paginatorManager = new paginator_1.PaginatorManagerImpl(pagerSvc, p);
        p.pagerManager = paginatorManager;
      }
      async adaptPagination(p) {
        const emptyPaginatorManager = {
          current: () => {
            const emptyPaginator = new paginator_1.PaginatorImpl([], 0, 10, p.path());
            return emptyPaginator.pagers()[0];
          },
          setCurrent: (current) => {
            throw new Error(`pagination not supported for this page: ${p.path()}`);
          },
          paginator: async () => {
            throw new Error(`pagination not supported for this page: ${p.path()}`);
          },
          paginate: async (groups) => {
            throw new Error(`pagination not supported for this page: ${p.path()}`);
          }
        };
        p.pagerManager = emptyPaginatorManager;
      }
      async buildOutput(p) {
      }
      async newPage(source, content) {
        const meta = new pagemeta_1.Meta("always", {}, 0, new Date());
        const layout = new pagelayout_1.Layout();
        return new page_1.PageImpl(source, content, meta, layout, "", (0, kind_1.getKindMain)("page"), this.pageMapper);
      }
      async newTaxonomy(source, content, singular) {
        const meta = new pagemeta_1.Meta("always", {}, 0, new Date());
        const layout = new pagelayout_1.Layout();
        const page = new page_1.TaxonomyPageImpl(source, content, meta, layout, singular, singular, (0, kind_1.getKindMain)("taxonomy"), this.pageMapper);
        return page;
      }
      async newTerm(source, content, singular, term) {
        const meta = new pagemeta_1.Meta("always", {}, 0, new Date());
        const layout = new pagelayout_1.Layout();
        const page = new page_1.TermPageImpl(source, content, meta, layout, singular, term, term, (0, kind_1.getKindMain)("term"), this.pageMapper);
        return page;
      }
    };
    exports2.PageBuilder = PageBuilder;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/taxonomy.js
var require_taxonomy3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/taxonomy.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Taxonomy = void 0;
    var pagetrees_1 = require_pagetrees();
    var fileinfo_1 = require_fileinfo2();
    var pagesource_1 = require_pagesource();
    var path6 = __importStar(require("path"));
    var filepath = __importStar(require("path"));
    var Taxonomy = class {
      constructor(views, fsSvc) {
        this.views = views;
        this.fsSvc = fsSvc;
      }
      async assemble(pages, pb, langIdx) {
        for (const viewName of this.views) {
          const key = this.pluralTreeKey(viewName.plural());
          const v = pages.get(key);
          const fmi = this.fsSvc.newFileMetaInfo(key + "/_index.md");
          const f = (0, fileinfo_1.newFileInfo)(fmi);
          const ps = (0, pagesource_1.newPageSource)(f);
          const p = await pb.withSource(ps).withLangIdx(langIdx).kindBuild();
          pages.insertIntoValuesDimension(key, (0, pagetrees_1.newPageTreesNode)(p));
        }
      }
      isTaxonomyPath(p) {
        const ta = this.getTaxonomy(p);
        if (!ta) {
          return false;
        }
        return p === path6.join(this.pluralTreeKey(ta.plural()), "_index.md");
      }
      pluralTreeKey(plural) {
        return cleanTreeKey(plural);
      }
      getTaxonomy(s) {
        for (const n2 of this.views) {
          if (s.startsWith(this.pluralTreeKey(n2.plural()))) {
            return n2;
          }
        }
        return null;
      }
      isZero(v) {
        if (!v) {
          return true;
        }
        return v.singular() === "";
      }
    };
    exports2.Taxonomy = Taxonomy;
    function cleanTreeKey(...elem) {
      let s = "";
      if (elem.length > 0) {
        s = elem[0];
        if (elem.length > 1) {
          s = path6.join(...elem);
        }
      }
      s = s.replace(/^[\.\/ \s]+|[\.\/ \s]+$/g, "");
      s = filepath.posix.normalize(s.toLowerCase().replace(/[^\w\-_\/]/g, ""));
      if (s === "" || s === "/") {
        return "";
      }
      if (s[0] !== "/") {
        s = "/" + s;
      }
      return s;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/term.js
var require_term = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/entity/term.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Term = void 0;
    var pagetrees_1 = require_pagetrees();
    var fileinfo_1 = require_fileinfo2();
    var pagesource_1 = require_pagesource();
    var frontmatter_1 = require_frontmatter();
    var doctree_1 = require_doctree();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("content", { component: "term" });
    function toStringSlicePreserveString(v) {
      if (!v) {
        return null;
      }
      if (Array.isArray(v)) {
        return v.map((item) => String(item));
      }
      if (typeof v === "string") {
        return [v];
      }
      return [String(v)];
    }
    function toInt(v) {
      if (typeof v === "number") {
        return Math.floor(v);
      }
      if (typeof v === "string") {
        const parsed = parseInt(v, 10);
        if (isNaN(parsed)) {
          throw new Error(`cannot convert "${v}" to int`);
        }
        return parsed;
      }
      throw new Error(`cannot convert ${typeof v} to int`);
    }
    var Term = class {
      constructor(fsSvc) {
        this.terms = {};
        this.fsSvc = fsSvc;
      }
      async assemble(pages, entries, pb, langIdx) {
        const lockType = doctree_1.LockType.LockTypeWrite;
        const walker = new doctree_1.NodeShiftTreeWalker({
          tree: pages,
          lockType,
          handle: async (s, n2, match) => {
            const [ps, found] = n2.getPage();
            if (!found) {
              return [false, null];
            }
            for (const viewName of pb.taxonomy.views) {
              const vals = toStringSlicePreserveString((0, frontmatter_1.getParam)(ps.params(), viewName.plural(), false));
              if (!vals) {
                continue;
              }
              const w = (0, frontmatter_1.getParamToLower)(ps.params(), viewName.plural() + "_weight");
              let weight = 0;
              if (w === null || w === void 0 || w === "") {
                weight = 0;
              } else {
                try {
                  weight = toInt(w);
                } catch (err) {
                  log.warn(`Unable to convert taxonomy weight ${w} to int for "${ps.paths().path()}"`);
                }
              }
              for (let i = 0; i < vals.length; i++) {
                const v = vals[i];
                if (v === "") {
                  continue;
                }
                const viewTermKey = "/" + viewName.plural() + "/" + v;
                try {
                  const fmi = this.fsSvc.newFileMetaInfo(viewTermKey + "/_index.md");
                  const f = (0, fileinfo_1.newFileInfo)(fmi);
                  const pi = f.paths();
                  const ps_new = (0, pagesource_1.newPageSource)(f);
                  const p = await pb.withSource(ps_new).withLangIdx(langIdx).kindBuild();
                  pages.insertIntoValuesDimension(pi.base(), (0, pagetrees_1.newPageTreesNode)(p));
                  const term = pages.get(pi.base());
                  if (term) {
                    const [tp2, found3] = term.getPage();
                    if (!found3) {
                      return [false, null];
                    }
                    const m = tp2;
                    m.term = v;
                    m.singular = viewName.singular();
                  }
                  let sKey = s;
                  if (sKey === "") {
                    sKey = "/";
                  }
                  const key = pi.base() + sKey;
                  const [tp, found2] = term.getPage();
                  if (!found2) {
                    return [false, null];
                  }
                  entries.insert(key, new pagetrees_1.WeightedTermTreeNode((0, pagetrees_1.newPageTreesNode)(ps), {
                    page: tp,
                    ordinal: i,
                    weight,
                    Weight: () => weight,
                    Ordinal: () => i
                  }));
                } catch (error) {
                  return [false, error];
                }
              }
            }
            return [false, null];
          }
        });
        try {
          await walker.walk();
          return null;
        } catch (error) {
          return error;
        }
      }
    };
    exports2.Term = Term;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/content/index.js
var require_content3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/content/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_type5(), exports2);
    __exportStar(require_hub(), exports2);
    __exportStar(require_kind(), exports2);
    __exportStar(require_identity(), exports2);
    __exportStar(require_fileinfo2(), exports2);
    __exportStar(require_sort(), exports2);
    __exportStar(require_frontmatter(), exports2);
    __exportStar(require_classifier(), exports2);
    __exportStar(require_content2(), exports2);
    __exportStar(require_converter(), exports2);
    __exportStar(require_pagebuilder(), exports2);
    __exportStar(require_pagetrees(), exports2);
    __exportStar(require_pagemap(), exports2);
    __exportStar(require_taxonomy3(), exports2);
    __exportStar(require_term(), exports2);
    __exportStar(require_section(), exports2);
    __exportStar(require_standalone(), exports2);
    __exportStar(require_translator(), exports2);
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/pager.js
var require_pager = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/pager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SitePager = void 0;
    var SitePager = class {
      constructor(page, pager) {
        this.page = page;
        this.pager = pager;
      }
      pageNumber() {
        return this.pager.pageNumber();
      }
      totalPages() {
        return this.pager.totalPages();
      }
      url() {
        return this.pager.url();
      }
      pages() {
        return this.pager.pages();
      }
      pagers() {
        return this.pager.pagers();
      }
      first() {
        return this.pager.first();
      }
      last() {
        return this.pager.last();
      }
      hasPrev() {
        return this.pager.hasPrev();
      }
      prev() {
        return this.pager.prev();
      }
      hasNext() {
        return this.pager.hasNext();
      }
      next() {
        return this.pager.next();
      }
      get PageNumber() {
        return this.pageNumber();
      }
      get TotalPages() {
        return this.totalPages();
      }
      get URL() {
        let targetPath = this.url();
        if (targetPath.startsWith("/")) {
          targetPath = targetPath.slice(1);
        }
        return this.page.Site.getURL().relURL(targetPath);
      }
      get HasPrev() {
        return this.hasPrev();
      }
      get HasNext() {
        return this.hasNext();
      }
      get First() {
        const first = this.first();
        return first ? new SitePager(this.page, first) : null;
      }
      get Last() {
        const last = this.last();
        return last ? new SitePager(this.page, last) : null;
      }
      get Prev() {
        const prev = this.prev();
        return prev ? new SitePager(this.page, prev) : null;
      }
      get Next() {
        const next = this.next();
        return next ? new SitePager(this.page, next) : null;
      }
      get Pagers() {
        return this.pagers().map((p) => new SitePager(this.page, p));
      }
      get Pages() {
        const contentPages = this.pages();
        return this.page.sitePages(contentPages);
      }
    };
    exports2.SitePager = SitePager;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/page.js
var require_page2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/page.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Page = void 0;
    var path_1 = __importDefault(require("path"));
    var log_1 = require_log();
    var pager_1 = require_pager();
    var log = (0, log_1.getDomainLogger)("site", { component: "page" });
    var Page = class {
      constructor(tmplSvc, langSvc, publisher, contentPage, site) {
        this.pageOutput = null;
        this.resources = [];
        this._paginator = null;
        this.tmplSvc = tmplSvc;
        this.langSvc = langSvc;
        this.publisher = publisher;
        this.contentPage = contentPage;
        this.site = site;
      }
      async processResources(pageSources) {
        this.resources = pageSources;
      }
      async render() {
        try {
          await this.renderResources();
          await this.renderPage();
        } catch (error) {
          log.error(`Failed to render page ${this.paths().path()}: ${error}`);
        }
      }
      getPageOutput() {
        if (!this.pageOutput) {
          this.pageOutput = this.output();
        }
        return this.pageOutput;
      }
      async renderPage() {
        const layouts = this.layouts();
        const { preparer: tmpl, found } = await this.tmplSvc.lookupLayout(layouts);
        if (!found) {
          log.warn(`Failed to find layout: ${layouts.join(",")} for page ${this.paths().path()}`);
          return;
        }
        const targetFilenames = [];
        let prefix = this.getPageOutput().targetPrefix();
        if (this.site.getLanguage().getCurrentLanguage() === prefix && prefix === this.langSvc.defaultLanguage()) {
          prefix = "";
        } else {
          prefix = this.site.getLanguage().getCurrentLanguage();
        }
        targetFilenames.push(path_1.default.join(prefix, this.getPageOutput().targetFilePath()));
        await this.renderAndWritePage(tmpl, targetFilenames);
        const current = await this.current();
        if (current) {
          let currentPager = current.next();
          while (currentPager) {
            this.setCurrent(currentPager);
            await this.setupCurrentPaginator();
            const paginationTargets = [path_1.default.join(prefix, currentPager.url(), this.getPageOutput().targetFileBase())];
            await this.renderAndWritePage(tmpl, paginationTargets);
            currentPager = currentPager.next();
          }
        }
      }
      async renderAndWritePage(tmpl, targetFilenames) {
        try {
          const renderedContent = await this.tmplSvc.executeWithContext(tmpl, this);
          await this.publisher.publishSource(renderedContent, ...targetFilenames);
        } catch (error) {
          throw this.errorf(error, "failed to publish page");
        }
      }
      async renderResources() {
        for (const pageSource of this.resources) {
          const targetFilenames = [];
          const output = this.getPageOutput();
          let prefix = output.targetPrefix();
          if (this.site.getLanguage().getCurrentLanguage() === prefix && prefix === this.langSvc.defaultLanguage()) {
            prefix = "";
          } else {
            prefix = this.site.getLanguage().getCurrentLanguage();
          }
          targetFilenames.push(path_1.default.join(prefix, pageSource.path()));
          let stream = null;
          try {
            const opener = () => pageSource.pageFile().open();
            stream = await opener();
            if (!stream) {
              throw new Error("Failed to open resource stream");
            }
            let readableStream;
            if (typeof stream.read === "function") {
              readableStream = new ReadableStream({
                async start(controller) {
                  try {
                    const buffer = new Uint8Array(8192);
                    while (true) {
                      const result = await stream.read(buffer);
                      if (result.bytesRead === 0) {
                        break;
                      }
                      controller.enqueue(buffer.slice(0, result.bytesRead));
                    }
                    controller.close();
                  } catch (error) {
                    controller.error(error);
                  }
                }
              });
            } else {
              readableStream = new ReadableStream({
                start(controller) {
                  controller.close();
                }
              });
            }
            await this.publisher.publishFiles(readableStream, ...targetFilenames);
          } catch (error) {
            throw this.errorf(error, "failed to publish page resources");
          } finally {
            if (stream) {
              try {
                await stream.close();
              } catch (closeError) {
                log.warn(`Failed to close resource stream: ${closeError}`);
              }
            }
          }
        }
      }
      errorf(err, format, ...args) {
        const contextArgs = [this.pageIdentity().pageLanguage(), this.paths().path(), ...args];
        const fullFormat = `[%s] page "%s": ${format}: %s`;
        const message = this.sprintf(fullFormat, ...contextArgs, err.message || err);
        return new Error(message);
      }
      sprintf(format, ...args) {
        let i = 0;
        return format.replace(/%s/g, () => args[i++] || "");
      }
      clone() {
        const cloned = new Page(this.tmplSvc, this.langSvc, this.publisher, this.contentPage, this.site);
        cloned.resources = [...this.resources];
        cloned.pageOutput = this.pageOutput;
        return cloned;
      }
      pageIdentity() {
        return this.contentPage.pageIdentity();
      }
      pageFile() {
        return this.contentPage.pageFile();
      }
      staleVersions() {
        return this.contentPage.staleVersions();
      }
      section() {
        return this.contentPage.section();
      }
      paths() {
        return this.contentPage.paths();
      }
      path() {
        return this.contentPage.path();
      }
      file() {
        return this.contentPage.file();
      }
      name() {
        return this.contentPage.name();
      }
      title() {
        return this.contentPage.title();
      }
      kind() {
        return this.contentPage.kind();
      }
      scratch() {
        return this.contentPage.scratch();
      }
      IsAncestor(other) {
        return this.contentPage.isAncestor(other.contentPage);
      }
      get Title() {
        return this.title();
      }
      get Section() {
        return this.contentPage.section();
      }
      get LinkTitle() {
        return this.title();
      }
      get IsSection() {
        return this.contentPage.isSection();
      }
      get IsPage() {
        return this.contentPage.isPage();
      }
      get Content() {
        return this.getPageOutput().content();
      }
      get Description() {
        return this.description();
      }
      get Date() {
        return this.pageDate();
      }
      get RelPermalink() {
        let targetPath;
        if (this.pageIdentity().pageLanguage() === this.langSvc.defaultLanguage()) {
          targetPath = this.getPageOutput().targetFilePath();
        } else {
          const prefix = this.getPageOutput().targetPrefix();
          const filePath = this.getPageOutput().targetFilePath();
          targetPath = this.pathJoin(prefix, filePath);
        }
        if (targetPath.startsWith("/")) {
          targetPath = targetPath.slice(1);
        }
        return this.site.getURL().relURL(targetPath);
      }
      get GitInfo() {
        return {};
      }
      get File() {
        return {
          BaseFileName: this.contentPage.file().baseFileName(),
          Dir: this.contentPage.file().dir()
        };
      }
      isHome() {
        return this.contentPage.isHome();
      }
      isPage() {
        return this.contentPage.isPage();
      }
      isSection() {
        return this.contentPage.isSection();
      }
      isAncestor(other) {
        return this.contentPage.isAncestor(other);
      }
      eq(other) {
        return this.contentPage.eq(other);
      }
      isBundled() {
        return this.contentPage.isBundled();
      }
      layouts() {
        return this.contentPage.layouts();
      }
      output() {
        return this.contentPage.output();
      }
      pageOutputs() {
        return [this.contentPage.output()];
      }
      truncated() {
        return this.contentPage.truncated();
      }
      parent() {
        return this.contentPage.parent();
      }
      pages() {
        return this.contentPage.pages();
      }
      isStale() {
        return this.contentPage.pageIdentity().isStale();
      }
      clearStale() {
        this.contentPage.pageIdentity().clearStale();
      }
      prevInSection() {
        return this.contentPage.prevInSection();
      }
      nextInSection() {
        return this.contentPage.nextInSection();
      }
      sections(langIndex) {
        return this.contentPage.sections(langIndex);
      }
      regularPages() {
        return this.contentPage.regularPages();
      }
      regularPagesRecursive() {
        return this.contentPage.regularPagesRecursive();
      }
      terms(langIndex, taxonomy) {
        return this.contentPage.terms(langIndex, taxonomy);
      }
      isTranslated() {
        return this.contentPage.isTranslated();
      }
      translations() {
        return this.contentPage.translations();
      }
      rawContent() {
        return this.contentPage.rawContent();
      }
      description() {
        return this.contentPage.description ? this.contentPage.description() : "";
      }
      params() {
        return this.contentPage.params ? this.contentPage.params() : {};
      }
      pageWeight() {
        return this.contentPage.pageWeight ? this.contentPage.pageWeight() : 0;
      }
      pageDate() {
        return this.contentPage.pageDate ? this.contentPage.pageDate() : new Date();
      }
      publishDate() {
        return this.contentPage.publishDate ? this.contentPage.publishDate() : new Date();
      }
      async relatedKeywords(cfg) {
        return this.contentPage.relatedKeywords ? await this.contentPage.relatedKeywords(cfg) : [];
      }
      shouldList(global2) {
        return this.contentPage.shouldList ? this.contentPage.shouldList(global2) : true;
      }
      shouldListAny() {
        return this.contentPage.shouldListAny ? this.contentPage.shouldListAny() : true;
      }
      noLink() {
        return this.contentPage.noLink ? this.contentPage.noLink() : false;
      }
      current() {
        return this.contentPage.current();
      }
      setCurrent(current) {
        this.contentPage.setCurrent(current);
      }
      posOffset(offset) {
        return this.contentPage.posOffset(offset);
      }
      paginator() {
        return this.contentPage.paginator();
      }
      async paginate(groups) {
        return this.contentPage.paginate(groups);
      }
      async Summary() {
        return this.contentPage.output().summary();
      }
      get Plain() {
        return this.rawContent();
      }
      get TableOfContents() {
        return this.getPageOutput().tableOfContents();
      }
      get Params() {
        return this.params();
      }
      get Site() {
        return this.site;
      }
      get Sites() {
        return {
          First: this.site,
          Default: this.site
        };
      }
      get Lastmod() {
        return this.contentPage.pageDate ? this.contentPage.pageDate() : null;
      }
      get Sitemap() {
        return {
          ChangeFreq: "weekly",
          Priority: 0.5,
          Filename: "sitemap.xml"
        };
      }
      get IsTranslated() {
        return this.isTranslated();
      }
      async Paginator() {
        await this.setupCurrentPaginator();
        return this._paginator;
      }
      async setupCurrentPaginator() {
        try {
          const contentPager = await this.contentPage.paginator();
          if (contentPager) {
            this._paginator = new pager_1.SitePager(this, contentPager);
          } else {
            this._paginator = null;
          }
        } catch (error) {
          log.error("Error initializing Paginator:", error);
          this._paginator = null;
        }
      }
      get Language() {
        return {
          Lang: this.pageIdentity().pageLanguage(),
          LanguageName: this.langSvc.getLanguageName(this.pageIdentity().pageLanguage()),
          Title: this.title(),
          Weight: this.pageWeight()
        };
      }
      get Permalink() {
        return this.joinURL(this.site.baseURL(), this.RelPermalink);
      }
      sitePages(ps) {
        const pages = [];
        for (const cp of ps) {
          const sp = this.sitePage(cp);
          if (sp) {
            pages.push(sp);
          }
        }
        return pages;
      }
      sitePage(p) {
        try {
          if (p === null) {
            log.warn(`Invalid content page provided: ${p}`);
            return null;
          }
          return new Page(this.tmplSvc, this.langSvc, this.publisher, p, this.site);
        } catch (error) {
          log.error(`Error creating site page: ${error}`);
          return null;
        }
      }
      pathJoin(...paths) {
        return paths.filter((p) => p && p.length > 0).map((p) => p.replace(/^\/+|\/+$/g, "")).filter((p) => p.length > 0).join("/");
      }
      joinURL(baseURL, targetPath) {
        if (!baseURL)
          return targetPath;
        if (!targetPath)
          return baseURL;
        if (baseURL.endsWith("/")) {
          baseURL = baseURL.slice(0, -1);
        }
        if (!targetPath.startsWith("/")) {
          targetPath = "/" + targetPath;
        }
        return baseURL + targetPath;
      }
      async Translations() {
        const translations = await this.translations();
        return Array.isArray(translations) ? translations.map((t) => this.sitePage(t)).filter((p) => p !== null) : [];
      }
      async GetTerms(taxonomy) {
        const terms = await this.terms(this.site.getLanguage().currentLanguageIndex(), taxonomy);
        return Array.isArray(terms) ? terms.map((t) => this.sitePage(t)).filter((p) => p !== null) : [];
      }
      async Pages() {
        return await this.getSitePages();
      }
      get Page() {
        return this.contentPage;
      }
      get Kind() {
        return this.kind();
      }
      get Parent() {
        return this.sitePage(this.contentPage.parent());
      }
      async getSitePages() {
        const ps = await this.contentPage.pages();
        if (!ps || Array.isArray(ps) && ps.length === 0) {
          return [];
        }
        return this.sitePages(ps);
      }
    };
    exports2.Page = Page;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/taxonomies-builder.js
var require_taxonomies_builder = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/taxonomies-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaxonomiesBuilder = exports2.TaxonomyList = exports2.OrderedTaxonomy = exports2.OrderedTaxonomyEntry = exports2.Taxonomy = exports2.WeightedPages = exports2.WeightedPage = void 0;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("site", { component: "taxonomies-builder" });
    var WeightedPage = class {
      constructor(page, ordinalWeightPage) {
        this.page = page;
        this.ordinalWeightPage = ordinalWeightPage;
      }
      get Page() {
        return this.page;
      }
      weight() {
        return this.ordinalWeightPage.weight();
      }
      ordinal() {
        return this.ordinalWeightPage.ordinal();
      }
      owner() {
        return this.ordinalWeightPage.owner();
      }
      get Permalink() {
        return this.page.Permalink;
      }
      get RelPermalink() {
        return this.page.RelPermalink;
      }
      get Title() {
        return this.page.Title;
      }
    };
    exports2.WeightedPage = WeightedPage;
    var WeightedPages = class extends Array {
      page() {
        if (this.length === 0) {
          log.error("Page called on empty WeightedPages");
          return null;
        }
        return this[0];
      }
      get Page() {
        return this.page();
      }
      pages() {
        return Array.from(this);
      }
      sortByWeight() {
        this.stableSort((a, b) => a.weight() - b.weight());
      }
      count() {
        return this.length;
      }
      get Count() {
        return this.count();
      }
      stableSort(compareFn) {
        const indexed = this.map((item, index) => ({ item, index }));
        indexed.sort((a, b) => {
          const result = compareFn(a.item, b.item);
          return result !== 0 ? result : a.index - b.index;
        });
        this.splice(0, this.length, ...indexed.map((x) => x.item));
      }
    };
    exports2.WeightedPages = WeightedPages;
    var Taxonomy = class {
      constructor() {
        this.terms = /* @__PURE__ */ new Map();
      }
      get(term) {
        return this.terms.get(term);
      }
      set(term, pages) {
        this.terms.set(term, pages);
      }
      has(term) {
        return this.terms.has(term);
      }
      keys() {
        return Array.from(this.terms.keys());
      }
      values() {
        return Array.from(this.terms.values());
      }
      get Values() {
        return this.terms;
      }
      entries() {
        return Array.from(this.terms.entries());
      }
      size() {
        return this.terms.size;
      }
      byCount() {
        const entries = this.taxonomyArray();
        entries.sort((a, b) => {
          const countA = a.weightedPages.length;
          const countB = b.weightedPages.length;
          if (countA === countB) {
            return a.name.localeCompare(b.name);
          }
          return countB - countA;
        });
        return new OrderedTaxonomy(entries);
      }
      taxonomyArray() {
        const entries = [];
        for (const [name, weightedPages] of this.terms.entries()) {
          entries.push(new OrderedTaxonomyEntry(name, weightedPages));
        }
        return entries;
      }
    };
    exports2.Taxonomy = Taxonomy;
    var OrderedTaxonomyEntry = class {
      constructor(name, weightedPages) {
        this.name = name;
        this.weightedPages = weightedPages;
      }
      count() {
        return this.weightedPages.count();
      }
      term() {
        return this.name;
      }
    };
    exports2.OrderedTaxonomyEntry = OrderedTaxonomyEntry;
    var OrderedTaxonomy = class extends Array {
      constructor(entries) {
        super();
        if (entries) {
          this.push(...entries);
        }
      }
      getOneOPage() {
        if (this.length === 0) {
          return null;
        }
        return this[0].weightedPages.page();
      }
    };
    exports2.OrderedTaxonomy = OrderedTaxonomy;
    var TaxonomyList = class {
      constructor() {
        this.taxonomies = /* @__PURE__ */ new Map();
      }
      get(taxonomyName) {
        return this.taxonomies.get(taxonomyName);
      }
      set(taxonomyName, taxonomy) {
        this.taxonomies.set(taxonomyName, taxonomy);
      }
      has(taxonomyName) {
        return this.taxonomies.has(taxonomyName);
      }
      keys() {
        return Array.from(this.taxonomies.keys());
      }
      values() {
        return Array.from(this.taxonomies.values());
      }
      get Values() {
        return this.taxonomies;
      }
      entries() {
        return Array.from(this.taxonomies.entries());
      }
      size() {
        return this.taxonomies.size;
      }
    };
    exports2.TaxonomyList = TaxonomyList;
    var TaxonomiesBuilder = class {
      constructor(contentService) {
        this.contentService = contentService;
      }
      async buildTaxonomiesForLanguage(langIndex, site) {
        const taxonomies = new TaxonomyList();
        try {
          await this.contentService.walkTaxonomies(langIndex, async (taxonomy, term, page) => {
            if (!taxonomies.has(taxonomy)) {
              taxonomies.set(taxonomy, new Taxonomy());
            }
            const tax = taxonomies.get(taxonomy);
            if (!tax.has(term)) {
              tax.set(term, new WeightedPages());
            }
            const siteWeightedPage = await site.siteWeightedPage(page);
            const termPages = tax.get(term);
            termPages.push(siteWeightedPage);
          });
          return taxonomies;
        } catch (error) {
          log.error(`Failed to create taxonomies: ${error}`);
          throw error;
        }
      }
    };
    exports2.TaxonomiesBuilder = TaxonomiesBuilder;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/site.js
var require_site = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/site.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Site = void 0;
    var page_1 = require_page2();
    var log_1 = require_log();
    var taxonomies_builder_1 = require_taxonomies_builder();
    var log = (0, log_1.getDomainLogger)("site", { component: "site" });
    var Site3 = class {
      get Title() {
        return this.title;
      }
      get IsGoogleAnalyticsEnabled() {
        return this.configSvc.isGoogleAnalyticsEnabled();
      }
      get GoogleAnalyticsID() {
        return this.configSvc.googleAnalyticsID();
      }
      get IsGoogleAnalyticsRespectDoNotTrack() {
        return this.configSvc.isGoogleAnalyticsRespectDoNotTrack();
      }
      get IsDisqusEnabled() {
        return this.configSvc.isDisqusEnabled();
      }
      get DisqusShortname() {
        return this.configSvc.disqusShortname();
      }
      get IsXRespectDoNotTrack() {
        return this.configSvc.isXRespectDoNotTrack();
      }
      get IsXDisableInlineCSS() {
        return this.configSvc.isXDisableInlineCSS();
      }
      async Pages() {
        const langIndex = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage());
        const cps = await this.contentSvc.globalPages(langIndex);
        return this.sitePages(cps);
      }
      get RegularPages() {
        const cps = this.contentSvc.globalRegularPages();
        return this.sitePages(cps);
      }
      constructor(configSvc, contentSvc, translationSvc, languageSvc, sitemap, staticCopySvc, publisher, author, compiler, url, ref, language, navigation, title) {
        this.template = null;
        this.home = null;
        this.configSvc = configSvc;
        this.contentSvc = contentSvc;
        this.translationSvc = translationSvc;
        this.languageSvc = languageSvc;
        this.sitemap = sitemap;
        this.staticCopySvc = staticCopySvc;
        this.publisher = publisher;
        this.author = author;
        this.compiler = compiler;
        this.url = url;
        this.ref = ref;
        this.language = language;
        this.navigation = navigation;
        this.title = title;
      }
      async build(template) {
        try {
          this.template = template;
          await this.setup();
          await this.copyStaticFiles();
          const languageKeys = this.languageSvc.languageKeys();
          for (const lang of languageKeys) {
            this.language.setCurrentLanguage(lang);
            await this.generateNavigations();
            await this.render();
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`\u274C Site build failed: ${message}`);
          throw error;
        }
      }
      async buildWithProgress(template, onProgress) {
        try {
          this.template = template;
          await this.setup();
          await this.copyStaticFiles();
          const languageKeys = this.languageSvc.languageKeys();
          for (const lang of languageKeys) {
            this.language.setCurrentLanguage(lang);
            await this.generateNavigations();
            await this.renderWithProgress(onProgress);
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`\u274C Site build failed: ${message}`);
          throw error;
        }
      }
      async setup() {
        try {
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error(`\u274C Setup failed: ${message}`);
          throw error;
        }
      }
      async render() {
        try {
          await this.renderPages();
        } catch (error) {
          throw error;
        }
      }
      async renderWithProgress(onProgress) {
        try {
          await this.renderPagesWithProgress(onProgress);
        } catch (error) {
          throw error;
        }
      }
      async renderPages() {
        const langIndex = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage());
        const pages = [];
        let pageCount = 0;
        await this.contentSvc.walkPages(langIndex, async (page) => {
          log.debug("--- Processing page:", page.file().filename(), page.pageIdentity().pageLanguage());
          const sitePage = await this.sitePage(page);
          pages.push(sitePage);
          pageCount++;
          const sources = await this.contentSvc.getPageSources(page);
          await sitePage.processResources(sources);
          if (page.isHome()) {
            this.home = sitePage;
          }
        });
        for (let i = 0; i < pages.length; i++) {
          const page = pages[i];
          if (page.isStale()) {
            await page.render();
            page.clearStale();
          }
        }
      }
      async renderPagesWithProgress(onProgress) {
        const langIndex = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage());
        const pages = [];
        let pageCount = 0;
        await this.contentSvc.walkPages(langIndex, async (page) => {
          const sitePage = await this.sitePage(page);
          pages.push(sitePage);
          pageCount++;
          const sources = await this.contentSvc.getPageSources(page);
          await sitePage.processResources(sources);
          if (page.isHome()) {
            this.home = sitePage;
          }
        });
        const totalPages = pages.length;
        for (let i = 0; i < pages.length; i++) {
          const page = pages[i];
          await page.render();
          onProgress?.({
            currentPage: i + 1,
            totalPages
          });
        }
      }
      async pageOutput(page) {
        return page.output();
      }
      clearSiteCache() {
      }
      translate(translationID) {
        return this.translationSvc.translate(this.language.getCurrentLanguage(), translationID);
      }
      get Home() {
        return this.home;
      }
      get Params() {
        return this.configSvc.configParams();
      }
      get Taxonomies() {
        return this.navigation.getTaxonomies(this.language.getCurrentLanguage()) || new taxonomies_builder_1.TaxonomyList();
      }
      get Menus() {
        return this.navigation.getMenus(this.language.getCurrentLanguage());
      }
      getTitle() {
        return this.title;
      }
      setTitle(title) {
        this.title = title;
      }
      getConfigService() {
        return this.configSvc;
      }
      getContentService() {
        return this.contentSvc;
      }
      getLanguageService() {
        return this.languageSvc;
      }
      baseURL() {
        return this.url.base;
      }
      getURL() {
        return this.url;
      }
      getRef() {
        return this.ref;
      }
      getLanguage() {
        return this.language;
      }
      get Language() {
        return this.getLanguage();
      }
      get LanguageCode() {
        return this.language.lang();
      }
      get Languages() {
        return this.language.languages();
      }
      getNavigation() {
        return this.navigation;
      }
      getPublisher() {
        return this.publisher;
      }
      getTemplate() {
        return this.template;
      }
      getAuthor() {
        return this.author;
      }
      getCompiler() {
        return this.compiler;
      }
      getSitemap() {
        return this.sitemap;
      }
      isMultipleLanguage() {
        return this.language.isMultipleLanguage();
      }
      get IsMultilingual() {
        return this.isMultipleLanguage();
      }
      getCurrentLanguage() {
        return this.language.lang();
      }
      languagePrefix() {
        return this.language.languagePrefix();
      }
      async sitePage(target) {
        return new page_1.Page(this.template, this.languageSvc, this.publisher, target, this);
      }
      sitePages(contentPages) {
        const pages = [];
        for (let i = 0; i < contentPages.length; i++) {
          const cp = contentPages[i];
          try {
            const sitePage = this.sitePageSync(cp);
            pages.push(sitePage);
          } catch (error) {
            log.error(`\u274C [Site.sitePages] Failed to convert page ${i}:`, error);
          }
        }
        return pages;
      }
      sitePageSync(contentPage) {
        return new page_1.Page(this.template, this.languageSvc, this.publisher, contentPage, this);
      }
      async generateNavigations() {
        const lang = this.language.getCurrentLanguage();
        const langIndex = this.languageSvc.getLanguageIndex(lang);
        await this.navigation.generateMenusForLanguage(lang, langIndex);
        await this.navigation.generateTaxonomiesForLanguage(lang, langIndex, this);
      }
      GetPage(...ref) {
        if (ref.length > 1) {
          throw new Error(`too many arguments to .Site.GetPage: ${ref}. Use lookups on the form {{ .Site.GetPage "/posts/mypage-md" }}`);
        }
        let key = ref[0];
        key = key.replace(/\\/g, "/");
        if (!key.startsWith("/")) {
          key = "/" + key;
        }
        try {
          const langIndex = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage());
          const contentPage = this.contentSvc.getPageFromPathSync(langIndex, key);
          if (!contentPage) {
            log.warn(`\u26A0\uFE0F  GetPage: No page found for key "${key}"`);
            return null;
          }
          return this.sitePageSync(contentPage);
        } catch (error) {
          log.error(`\u274C Error getting page "${key}": ${error}`);
          return null;
        }
      }
      async copyStaticFiles() {
        try {
          await this.staticCopySvc.copyStaticFiles(this.staticCopySvc.staticFs(), this.staticCopySvc.publishFs());
        } catch (error) {
          log.error("\u274C Static file copy failed:", error);
          throw error;
        }
      }
      async siteWeightedPage(ordinalWeightPage) {
        const sitePage = await this.sitePage(ordinalWeightPage.page());
        const { WeightedPage } = await Promise.resolve().then(() => __importStar(require_taxonomies_builder()));
        return new WeightedPage(sitePage, ordinalWeightPage);
      }
    };
    exports2.Site = Site3;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/publisher.js
var require_publisher = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/publisher.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Publisher = void 0;
    exports2.openFileForWriting = openFileForWriting;
    var path_1 = __importDefault(require("path"));
    var Publisher = class {
      constructor(fs5) {
        this.fs = fs5;
      }
      async publishSource(src, ...filenames) {
        const files = await this.openFilesForWriting(...filenames);
        try {
          const content = typeof src === "string" ? new TextEncoder().encode(src) : src;
          await this.copyToWriter(files, content);
        } finally {
          await files.close();
        }
      }
      async publishFiles(src, ...filenames) {
        const files = await this.openFilesForWriting(...filenames);
        try {
          await this.copyStreamToWriter(files, src);
        } finally {
          await files.close();
        }
      }
      async openFilesForWriting(...filenames) {
        const files = [];
        for (const filename of filenames) {
          const file = await openFileForWriting(this.fs, filename);
          files.push(file);
        }
        return new MultiWriter(files);
      }
      async copyToWriter(writer, content) {
        if (writer instanceof MultiWriter) {
          await writer.write(content);
        } else {
          await writer.write(content);
        }
      }
      async copyStreamToWriter(writer, stream) {
        const reader = stream.getReader();
        try {
          while (true) {
            const { done, value: value2 } = await reader.read();
            if (done)
              break;
            if (writer instanceof MultiWriter) {
              await writer.write(value2);
            } else {
              await writer.write(value2);
            }
          }
        } finally {
          reader.releaseLock();
        }
      }
    };
    exports2.Publisher = Publisher;
    var MultiWriter = class {
      constructor(files) {
        this.files = files;
      }
      async write(data) {
        const writePromises = this.files.map((file) => file.write(data));
        await Promise.all(writePromises);
      }
      async close() {
        const closePromises = this.files.map((file) => file.close());
        await Promise.all(closePromises);
      }
    };
    async function openFileForWriting(fs5, filename) {
      const cleanFilename = path_1.default.normalize(filename);
      try {
        return await fs5.create(cleanFilename);
      } catch (error) {
        if (!isFileNotFoundError(error)) {
          throw error;
        }
        const dir = path_1.default.dirname(cleanFilename);
        await fs5.mkdirAll(dir, 511);
        return await fs5.create(cleanFilename);
      }
    }
    function isFileNotFoundError(error) {
      return error && (error.code === "ENOENT" || error.code === "FILE_NOT_FOUND" || error.message?.includes("not found") || error.message?.includes("no such file"));
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/baseurl.js
var require_baseurl = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/baseurl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseURL = void 0;
    var BaseURL = class {
      constructor(url, isRelative = false) {
        this.url = url;
        this.isRelative = isRelative;
        this.withPath = url.toString();
        this.withPathNoTrailingSlash = this.withPath.replace(/\/$/, "");
        if (isRelative) {
          this.withoutPath = "/";
        } else {
          const urlNoPath = new URL(url.toString());
          urlNoPath.pathname = "";
          this.withoutPath = urlNoPath.toString().replace(/\/$/, "");
        }
        this.basePath = url.pathname;
        this.basePathNoTrailingSlash = this.basePath.replace(/\/$/, "");
      }
      static fromString(baseUrl) {
        try {
          if (!baseUrl || baseUrl === "/") {
            baseUrl = "/";
          }
          const trimmed = baseUrl.trim();
          if (trimmed.startsWith("/") && !trimmed.startsWith("//")) {
            const dummyUrl = new URL(trimmed, "http://localhost");
            if (!dummyUrl.pathname.endsWith("/")) {
              dummyUrl.pathname += "/";
            }
            return new BaseURL(dummyUrl, true);
          }
          if (trimmed.startsWith("//")) {
            const fullUrl = "https:" + trimmed;
            const url2 = new URL(fullUrl);
            if (!url2.pathname.endsWith("/")) {
              url2.pathname += "/";
            }
            return new BaseURL(url2);
          }
          if (trimmed.includes("://")) {
            const url2 = new URL(trimmed);
            if (!["http:", "https:"].includes(url2.protocol)) {
              throw new Error(`Unsupported protocol: ${url2.protocol}. Only http and https are supported.`);
            }
            if (!url2.pathname.endsWith("/")) {
              url2.pathname += "/";
            }
            return new BaseURL(url2);
          }
          if (trimmed.includes(":") && !trimmed.includes("/")) {
            const colonIndex = trimmed.indexOf(":");
            const scheme = trimmed.substring(0, colonIndex + 1);
            throw new Error(`Unsupported protocol: ${scheme}. Only http and https are supported.`);
          }
          const url = new URL("https://" + trimmed);
          if (!url.pathname.endsWith("/")) {
            url.pathname += "/";
          }
          return new BaseURL(url);
        } catch (err) {
          throw new Error(`Invalid URL: ${err?.message || "Unknown error"}`);
        }
      }
      getRoot(path6) {
        if (this.isRelative) {
          return this.basePath;
        }
        if (path6.startsWith("/")) {
          return this.withoutPath;
        }
        return this.withPath;
      }
      toString() {
        if (this.isRelative) {
          return this.basePath;
        }
        return this.withPath;
      }
      path() {
        return this.url.pathname;
      }
      port() {
        return this.url.port ? parseInt(this.url.port) : 0;
      }
      hostURL() {
        if (this.isRelative) {
          return "/";
        }
        return this.toString().replace(this.path(), "");
      }
      protocol() {
        return this.url.protocol;
      }
      host() {
        return this.url.host;
      }
      hostname() {
        return this.url.hostname;
      }
      getURL() {
        return new URL(this.url.toString());
      }
      withProtocol(protocol) {
        if (this.isRelative) {
          throw new Error("Cannot change protocol of relative URL");
        }
        const u = this.getURL();
        let scheme = protocol;
        const isFullProtocol = scheme.endsWith("://");
        const isOpaqueProtocol = scheme.endsWith(":");
        if (isFullProtocol) {
          scheme = scheme.slice(0, -3);
        } else if (isOpaqueProtocol) {
          scheme = scheme.slice(0, -1);
        }
        if (isOpaqueProtocol && !u.pathname) {
          throw new Error(`cannot determine BaseURL for protocol ${protocol}`);
        }
        u.protocol = scheme;
        return BaseURL.fromString(u.toString());
      }
      withPort(port) {
        if (this.isRelative) {
          throw new Error("Cannot set port on relative URL");
        }
        const u = this.getURL();
        u.port = port.toString();
        return BaseURL.fromString(u.toString());
      }
      isRelativeURL() {
        return this.isRelative;
      }
      isAbsoluteURL() {
        return !this.isRelative;
      }
    };
    exports2.BaseURL = BaseURL;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/text/index.js
var require_text = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/text/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeAccentsString = removeAccentsString;
    function removeAccentsString(str) {
      return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/url.js
var require_url = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = void 0;
    var baseurl_1 = require_baseurl();
    var paths_1 = require_paths2();
    var text_1 = require_text();
    var URL2 = class {
      constructor(base, canonical = false) {
        this.baseURL = null;
        this.base = base;
        this.canonical = canonical;
        this.setup();
      }
      setup() {
        try {
          this.baseURL = baseurl_1.BaseURL.fromString(this.base);
        } catch (err) {
          throw new Error(err?.message || "Failed to setup URL");
        }
      }
      isAbsURL(input) {
        if (input.startsWith("http://") || input.startsWith("https://")) {
          return [true, null];
        }
        const isAbsolute = /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(input);
        return [isAbsolute, null];
      }
      startWithBaseUrlRoot(input) {
        if (!this.baseURL)
          return false;
        return input.startsWith(this.baseURL.getRoot(input));
      }
      isProtocolRelPath(input) {
        return input.startsWith("//");
      }
      trimBaseUrlRoot(input) {
        if (!this.baseURL)
          return input;
        const root = this.baseURL.getRoot(input);
        if (input.endsWith(root)) {
          return input.slice(0, -root.length);
        }
        return input;
      }
      addContextRoot(input) {
        if (!this.baseURL)
          return input;
        let output = input;
        if (!this.canonical) {
          output = (0, paths_1.addContextRoot)(this.baseURL.getRoot(input), input);
        }
        return output;
      }
      handleRootSuffix(input, url) {
        if (!this.baseURL)
          return url;
        if (input === "" && this.baseURL.getRoot(input).endsWith("/")) {
          url += "/";
        }
        return url;
      }
      handlePrefix(url) {
        if (!url.startsWith("/")) {
          url = "/" + url;
        }
        return url;
      }
      relURL(input) {
        if (!input) {
          return "";
        }
        const [isAbs, err] = this.isAbsURL(input);
        if (err) {
          return input;
        }
        if (isAbs || this.isProtocolRelPath(input)) {
          return input;
        }
        if (!this.baseURL) {
          return input;
        }
        let result = input;
        if (input.startsWith("/")) {
          if (this.baseURL.isRelativeURL()) {
            return input;
          }
          return this.baseURL.withoutPath + input;
        }
        if (this.baseURL.isRelativeURL()) {
          const basePath = this.baseURL.basePath.endsWith("/") ? this.baseURL.basePath : this.baseURL.basePath + "/";
          result = basePath + input;
        } else {
          const baseWithPath = this.baseURL.withPath.endsWith("/") ? this.baseURL.withPath : this.baseURL.withPath + "/";
          result = baseWithPath + input;
        }
        if (result.includes("://")) {
          const protocolIndex = result.indexOf("://");
          const protocolPart = result.substring(0, protocolIndex + 3);
          const pathPart = result.substring(protocolIndex + 3);
          result = protocolPart + pathPart.replace(/\/+/g, "/");
        } else {
          result = result.replace(/\/+/g, "/");
        }
        return result;
      }
      absURL(input, isMultiLang = false, langPrefix = "") {
        const [isAbs, err] = this.isAbsURL(input);
        if (err) {
          return input;
        }
        if (isAbs || this.isProtocolRelPath(input)) {
          return input;
        }
        if (!this.baseURL)
          return input;
        const baseURL = this.baseURL.getRoot(input);
        if (isMultiLang && langPrefix) {
          let hasPrefix = false;
          let in2 = input;
          if (input.startsWith("/")) {
            in2 = input.slice(1);
          }
          if (in2 === langPrefix) {
            hasPrefix = true;
          } else {
            hasPrefix = in2.startsWith(langPrefix + "/");
          }
          if (!hasPrefix) {
            const addSlash = input === "" || input.endsWith("/");
            input = this.joinPaths(langPrefix, input);
            if (addSlash) {
              input += "/";
            }
          }
        }
        return (0, paths_1.makePermalink)(baseURL, input).toString();
      }
      urlize(uri) {
        return this.urlEscape(this.makePathSanitized(uri));
      }
      makePathSanitized(input) {
        return this.makePath(input).toLowerCase();
      }
      urlEscape(uri) {
        try {
          if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(uri)) {
            const parsed = new URL2(uri);
            return parsed.toString();
          }
          const match = uri.match(/^([^?#]*)(\?[^#]*)?(#.*)?$/);
          if (!match)
            return encodeURI(uri);
          const [, pathname = "", search = "", hash = ""] = match;
          return encodeURI(pathname) + (search || "") + (hash || "");
        } catch {
          return encodeURI(uri);
        }
      }
      makePath(input) {
        let s = (0, paths_1.sanitize)(input);
        s = (0, text_1.removeAccentsString)(s);
        return s;
      }
      basePathNoSlash() {
        return this.baseURL ? this.baseURL.basePathNoTrailingSlash : "";
      }
      joinPaths(...paths) {
        return paths.filter(Boolean).join("/").replace(/\/+/g, "/").replace(/\/$/, "");
      }
    };
    exports2.URL = URL2;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/ref.js
var require_ref = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ref = void 0;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("site", { component: "ref" });
    var Ref = class {
      constructor(site, contentSvc, notFoundURL = "#ZgotmplZ") {
        this.site = site;
        this.contentSvc = contentSvc;
        this.notFoundURL = notFoundURL;
      }
      async relRefFrom(argsm, source) {
        return this.relRef(argsm, source);
      }
      async relRef(argsm, source) {
        try {
          const args = this.decodeRefArgs(argsm);
          if (!args.path) {
            return "";
          }
          return this.refLink(args.path, source, true, args.outputFormat);
        } catch (error) {
          throw new Error(`Invalid arguments to Ref: ${error}`);
        }
      }
      decodeRefArgs(args) {
        return {
          path: args.path || "",
          outputFormat: args.outputFormat || ""
        };
      }
      async refLink(ref, source, relative, outputFormat) {
        const pw = source;
        if (!pw || typeof pw.unwrapPage !== "function") {
          throw new Error("source is not a PageWrapper");
        }
        const page = pw.unwrapPage();
        let refURL;
        const normalizedRef = ref.replace(/\\/g, "/");
        try {
          refURL = new globalThis.URL(normalizedRef, "http://example.com");
        } catch (error) {
          log.error(`Failed to parse ref URL: ${error}`);
          return this.notFoundURL;
        }
        let target = null;
        let link = "";
        if (refURL.pathname !== "") {
          try {
            target = await this.contentSvc.getPageRef(page, refURL.pathname, this.site.home.page);
            let position = null;
            if (!target) {
              if (this.isPositioner(source)) {
                position = source.position();
              }
            }
            if (!target) {
              this.logNotFound(refURL.pathname, "page not found", page, position);
              return this.notFoundURL;
            }
            const sitePage = await this.site.sitePage(target);
            if (relative) {
              link = sitePage.relPermalink();
            } else {
              link = sitePage.permalink();
            }
          } catch (error) {
            log.error(`[${page.pageIdentity().pageLanguage()}] REF_NOT_FOUND: Ref "${ref}": ${error}`);
            return this.notFoundURL;
          }
        }
        if (refURL.hash) {
          link = link + "#" + refURL.hash;
        }
        return link;
      }
      isPositioner(source) {
        return source && typeof source.position === "function";
      }
      logNotFound(ref, what, page, position) {
        const lang = page.pageIdentity().pageLanguage();
        if (position && position.isValid()) {
          log.error(`[${lang}] REF_NOT_FOUND: Ref "${ref}": ${position.toString()}: ${what}`);
        } else if (!page) {
          log.error(`[${lang}] REF_NOT_FOUND: Ref "${ref}": ${what}`);
        } else {
          log.error(`[${lang}] REF_NOT_FOUND: Ref "${ref}" from page "${page.path()}": ${what}`);
        }
      }
    };
    exports2.Ref = Ref;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/language.js
var require_language3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Language = void 0;
    var CollatorWrapper = class {
      constructor(collator) {
        this.collator = collator;
      }
      compare(a, b) {
        return this.collator.compare(a, b);
      }
    };
    var Language = class {
      constructor(langSvc) {
        this.collator = null;
        this.langSvc = langSvc;
        this.currentLocation = "UTC";
        this.currentLanguage = "";
      }
      currentLanguageIndex() {
        try {
          return this.langSvc.getLanguageIndex(this.currentLanguage);
        } catch (error) {
          throw new Error(`language "${this.currentLanguage}" not found`);
        }
      }
      async setup() {
        this.currentLocation = "UTC";
      }
      languages() {
        const langs = [];
        for (const lang of this.langSvc.languageKeys()) {
          const language = new Language(this.langSvc);
          language.currentLocation = this.currentLocation;
          language.currentLanguage = lang;
          language.collator = this.collator;
          langs.push(language);
        }
        return langs;
      }
      getCollator() {
        if (!this.collator) {
          try {
            const intlCollator = new Intl.Collator(this.currentLanguage || "en");
            this.collator = new CollatorWrapper({
              compare: (a, b) => intlCollator.compare(a, b)
            });
          } catch (error) {
            const intlCollator = new Intl.Collator("en");
            this.collator = new CollatorWrapper({
              compare: (a, b) => intlCollator.compare(a, b)
            });
          }
        }
        return this.collator;
      }
      location() {
        return this.currentLocation;
      }
      isMultipleLanguage() {
        return this.langSvc.languageKeys().length > 1;
      }
      languagePrefix() {
        if (this.currentLanguage === this.langSvc.defaultLanguage()) {
          return "";
        }
        return this.currentLanguage;
      }
      lang() {
        return this.currentLanguage;
      }
      get Lang() {
        return this.lang();
      }
      languageName() {
        return this.langSvc.getLanguageName(this.currentLanguage);
      }
      get LanguageName() {
        return this.languageName();
      }
      defaultLanguageName() {
        return this.langSvc.getLanguageName(this.langSvc.defaultLanguage());
      }
      languageCode() {
        return this.currentLanguage;
      }
      get LanguageCode() {
        return this.languageCode();
      }
      get LanguageDirection() {
        return "ltr";
      }
      languageDirection() {
        return "ltr";
      }
      setCurrentLanguage(lang) {
        this.currentLanguage = lang;
      }
      getCurrentLanguage() {
        return this.currentLanguage;
      }
      setCurrentLocation(location) {
        this.currentLocation = location;
      }
    };
    exports2.Language = Language;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/author.js
var require_author = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/author.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Author = void 0;
    exports2.newAuthor = newAuthor;
    var Author = class {
      constructor(name, email) {
        this._name = name;
        this._email = email;
      }
      name() {
        return this._name;
      }
      email() {
        return this._email;
      }
    };
    exports2.Author = Author;
    function newAuthor(name, email) {
      return new Author(name, email);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/version.js
var require_version = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Compiler = void 0;
    exports2.newVersion = newVersion;
    var Compiler = class {
      constructor(version) {
        this.ver = version;
      }
      version() {
        return this.ver;
      }
      environment() {
        return "production";
      }
    };
    exports2.Compiler = Compiler;
    function newVersion(version) {
      return new Compiler(version);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/menu.js
var require_menu = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/valueobject/menu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MENUS_BEFORE = exports2.MENUS_AFTER = exports2.Menus = exports2.Menu = exports2.MenuEntry = void 0;
    exports2.newEmptyMenus = newEmptyMenus;
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("site", { component: "menu" });
    var MenuEntry = class {
      constructor(options) {
        this._title = options.title;
        this._url = options.url;
        this._isDir = options.isDir;
        this._hasIndex = options.hasIndex;
        this._children = options.children || [];
        this._weight = options.weight || 0;
        this._identifier = options.identifier || this._url;
      }
      title() {
        return this._title;
      }
      url() {
        return this._url;
      }
      isDirectory() {
        return this._isDir;
      }
      hasIndex() {
        return this._hasIndex;
      }
      children() {
        return [...this._children];
      }
      weight() {
        return this._weight;
      }
      identifier() {
        return this._identifier;
      }
      hasChildren() {
        return this._children.length > 0;
      }
      addChild(child) {
        const newChildren = [...this._children, child];
        return new MenuEntry({
          title: this._title,
          url: this._url,
          isDir: this._isDir,
          hasIndex: this._hasIndex,
          children: newChildren,
          weight: this._weight,
          identifier: this._identifier
        });
      }
      toJSON() {
        return {
          title: this._title,
          url: this._url,
          isDir: this._isDir,
          hasIndex: this._hasIndex,
          children: this._children.map((child) => child.toJSON())
        };
      }
      withChildren(children2) {
        return new MenuEntry({
          title: this._title,
          url: this._url,
          isDir: this._isDir,
          hasIndex: this._hasIndex,
          children: children2,
          weight: this._weight,
          identifier: this._identifier
        });
      }
    };
    exports2.MenuEntry = MenuEntry;
    var Menu = class {
      constructor(entries = []) {
        this._entries = [...entries];
      }
      entries() {
        return [...this._entries];
      }
      get(index) {
        return this._entries[index];
      }
      get length() {
        return this._entries.length;
      }
      add(entry) {
        const newEntries = [...this._entries, entry];
        return new Menu(newEntries).sortMenu();
      }
      sortMenu() {
        const sorted = [...this._entries].sort((a, b) => {
          if (a.weight() !== b.weight()) {
            if (b.weight() === 0)
              return -1;
            if (a.weight() === 0)
              return 1;
            return a.weight() - b.weight();
          }
          const titleComparison = a.title().localeCompare(b.title());
          if (titleComparison !== 0) {
            return titleComparison;
          }
          return a.identifier().localeCompare(b.identifier());
        });
        return new Menu(sorted);
      }
      filterMenu(predicate) {
        const filtered = this._entries.filter(predicate);
        return new Menu(filtered);
      }
      findByIdentifier(identifier) {
        return this._entries.find((entry) => entry.identifier() === identifier);
      }
      findByUrl(url) {
        return this._entries.find((entry) => entry.url() === url);
      }
      getLeaves() {
        return this.filterMenu((entry) => !entry.hasChildren());
      }
      getBranches() {
        return this.filterMenu((entry) => entry.hasChildren());
      }
      toJSON() {
        return this._entries.map((entry) => entry.toJSON());
      }
      [Symbol.iterator]() {
        return this._entries[Symbol.iterator]();
      }
      map(callback) {
        return this._entries.map(callback);
      }
      forEach(callback) {
        this._entries.forEach(callback);
      }
    };
    exports2.Menu = Menu;
    var Menus = class {
      constructor(menus = /* @__PURE__ */ new Map()) {
        this._menus = new Map(menus);
      }
      get(name) {
        return this._menus.get(name);
      }
      set(name, menu) {
        const newMenus = new Map(this._menus);
        newMenus.set(name, menu);
        return new Menus(newMenus);
      }
      names() {
        return Array.from(this._menus.keys());
      }
      has(name) {
        return this._menus.has(name);
      }
      hasSubMenu(entry) {
        const menu = this._menus.get(entry.title());
        if (!menu)
          return false;
        if (menu.length === 1 && menu.get(0)?.title() === entry.title()) {
          return false;
        }
        return menu.length > 1;
      }
      entries() {
        return Array.from(this._menus.entries());
      }
      toJSON() {
        const result = {};
        for (const [name, menu] of this._menus.entries()) {
          result[name] = menu.toJSON();
        }
        return result;
      }
      merge(other) {
        const newMenus = new Map(this._menus);
        for (const [name, menu] of other._menus.entries()) {
          if (newMenus.has(name)) {
            const existingMenu = newMenus.get(name);
            const mergedEntries = [...existingMenu.entries(), ...menu.entries()];
            const mergedMenu = new Menu(mergedEntries).sortMenu();
            newMenus.set(name, mergedMenu);
          } else {
            newMenus.set(name, menu);
          }
        }
        return new Menus(newMenus);
      }
    };
    exports2.Menus = Menus;
    function newEmptyMenus() {
      return new Menus();
    }
    exports2.MENUS_AFTER = "after";
    exports2.MENUS_BEFORE = "before";
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/navigation.js
var require_navigation = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/navigation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Navigation = void 0;
    exports2.newNavigation = newNavigation;
    var log_1 = require_log();
    var menu_1 = require_menu();
    var log = (0, log_1.getDomainLogger)("site", { component: "navigation" });
    var Navigation = class {
      constructor(langSvc) {
        this.taxonomiesBuilder = null;
        this.taxonomiesCache = /* @__PURE__ */ new Map();
        this.menuBuilder = null;
        this.menuCache = /* @__PURE__ */ new Map();
        this.taxonomies = /* @__PURE__ */ new Map();
        this.menus = /* @__PURE__ */ new Map();
        for (const lang of langSvc.languageKeys()) {
          this.menus.set(lang, (0, menu_1.newEmptyMenus)());
          this.menuCache.set(lang, false);
        }
      }
      setMenuBuilder(menuBuilder) {
        this.menuBuilder = menuBuilder;
      }
      setTaxonomiesBuilder(taxonomiesBuilder) {
        this.taxonomiesBuilder = taxonomiesBuilder;
      }
      async generateMenusForLanguage(lang, langIndex) {
        if (!this.menuBuilder) {
          log.error("Menu builder not set, cannot generate menus");
          return;
        }
        if (this.menuCache.get(lang) === true) {
          return;
        }
        try {
          const generatedMenus = await this.menuBuilder.buildMenusForLanguage(langIndex);
          this.menus.set(lang, generatedMenus);
          this.menuCache.set(lang, true);
        } catch (error) {
          log.error(`Failed to generate menus for language ${lang}: ${error}`);
        }
      }
      async generateTaxonomiesForLanguage(lang, langIndex, site) {
        if (!this.taxonomiesBuilder) {
          log.error("Taxonomies builder not set, cannot generate taxonomies");
          return;
        }
        if (this.taxonomiesCache.get(lang) === true) {
          return;
        }
        try {
          const generatedTaxonomies = await this.taxonomiesBuilder.buildTaxonomiesForLanguage(langIndex, site);
          this.taxonomies.set(lang, generatedTaxonomies);
          this.taxonomiesCache.set(lang, true);
        } catch (error) {
          log.error(`Failed to generate taxonomies for language ${lang}: ${error}`);
        }
      }
      getMenus(lang) {
        let menus = this.menus.get(lang);
        if (menus === void 0) {
          menus = (0, menu_1.newEmptyMenus)();
        }
        return menus;
      }
      getTaxonomies(lang) {
        return this.taxonomies.get(lang);
      }
    };
    exports2.Navigation = Navigation;
    function newNavigation(langSvc) {
      return new Navigation(langSvc);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/menu-builder.js
var require_menu_builder = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/entity/menu-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MenuBuilder = void 0;
    var log_1 = require_log();
    var menu_1 = require_menu();
    var log = (0, log_1.getDomainLogger)("site", { component: "menu-builder" });
    var MenuBuilder = class {
      constructor(contentService) {
        this.contentService = contentService;
      }
      async buildMenusForLanguage(langIndex) {
        const menuMap = /* @__PURE__ */ new Map();
        await this.contentService.walkPages(langIndex, async (page) => {
          await this.processPage(page, menuMap);
        });
        return this.convertToMenus(menuMap);
      }
      async processPage(page, menuMap) {
        try {
          const pagePath = page.path();
          const urlPath = pagePath;
          if (!this.isValidMenuPath(pagePath)) {
            return;
          }
          const pathParts = this.parsePathParts(pagePath);
          if (pathParts.length === 0) {
            return;
          }
          this.buildMenuStructure(pathParts, urlPath, page, menuMap);
        } catch (error) {
          log.error(`Error processing page for menu: ${error}`);
        }
      }
      isValidMenuPath(path6) {
        if (path6.startsWith(".") || path6.includes("/.")) {
          return false;
        }
        return path6.endsWith(".md") || !path6.includes(".");
      }
      parsePathParts(path6) {
        let cleanPath = path6.replace(/^\/+/, "").replace(/\.md$/, "");
        const parts = cleanPath.split("/").filter((part) => part.length > 0);
        return parts;
      }
      buildMenuStructure(pathParts, urlPath, page, menuMap) {
        for (let i = 0; i < pathParts.length; i++) {
          const currentPath = pathParts.slice(0, i + 1).join("/");
          const isLeaf = i === pathParts.length - 1;
          const isIndex = pathParts[i] === "index" || pathParts[i] === "_index";
          let menuStructure = menuMap.get(currentPath);
          if (!menuStructure) {
            menuStructure = {
              title: this.formatTitle(pathParts[i]),
              url: this.buildUrl(pathParts.slice(0, i + 1)),
              isDir: !isLeaf || isIndex,
              hasIndex: isIndex && pathParts[i] === "index",
              children: /* @__PURE__ */ new Map(),
              weight: this.calculateWeight(pathParts[i]),
              level: i
            };
            menuMap.set(currentPath, menuStructure);
          }
          if (isLeaf) {
            menuStructure.url = urlPath;
            if (pathParts[i] === "index") {
              menuStructure.hasIndex = true;
              menuStructure.isDir = false;
            }
          }
          if (i > 0) {
            const parentPath = pathParts.slice(0, i).join("/");
            const parentStructure = menuMap.get(parentPath);
            if (parentStructure) {
              parentStructure.children.set(currentPath, menuStructure);
              parentStructure.isDir = true;
            }
          }
        }
      }
      formatTitle(name) {
        if (name === "index" || name === "_index") {
          return name;
        }
        return name.replace(/[-_]/g, " ").replace(/\b\w/g, (letter) => letter.toUpperCase());
      }
      buildUrl(pathParts) {
        return "/" + pathParts.join("/") + "/";
      }
      calculateWeight(name) {
        if (name === "index")
          return 0;
        if (name === "_index")
          return 1;
        return name.charCodeAt(0);
      }
      convertToMenus(menuMap) {
        const menus = /* @__PURE__ */ new Map();
        const rootEntries = [];
        for (const [path6, structure] of menuMap.entries()) {
          if (structure.level === 0) {
            rootEntries.push(structure);
          }
        }
        if (rootEntries.length > 0) {
          const mainMenu = this.buildMenuFromStructures(rootEntries, menuMap);
          menus.set("main", mainMenu);
        }
        return new menu_1.Menus(menus);
      }
      buildMenuFromStructures(structures, menuMap) {
        const entries = [];
        for (const structure of structures) {
          const childStructures = Array.from(structure.children.values());
          const children2 = childStructures.length > 0 ? this.buildMenuFromStructures(childStructures, menuMap).entries() : [];
          const entry = new menu_1.MenuEntry({
            title: structure.title,
            url: structure.url,
            isDir: structure.isDir,
            hasIndex: structure.hasIndex,
            children: children2,
            weight: structure.weight,
            identifier: structure.url
          });
          entries.push(entry);
        }
        return new menu_1.Menu(entries).sortMenu();
      }
    };
    exports2.MenuBuilder = MenuBuilder;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/factory/navigation-factory.js
var require_navigation_factory = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/factory/navigation-factory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NavigationFactory = void 0;
    exports2.createNavigationFactory = createNavigationFactory;
    var navigation_1 = require_navigation();
    var menu_builder_1 = require_menu_builder();
    var taxonomies_builder_1 = require_taxonomies_builder();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("site", { component: "navigation-factory" });
    var NavigationFactory = class {
      constructor(langService, contentService) {
        this.langService = langService;
        this.contentService = contentService;
      }
      createNavigation() {
        try {
          const navigation = (0, navigation_1.newNavigation)(this.langService);
          const menuBuilder = new menu_builder_1.MenuBuilder(this.contentService);
          navigation.setMenuBuilder(menuBuilder);
          const taxonomiesBuilder = new taxonomies_builder_1.TaxonomiesBuilder(this.contentService);
          navigation.setTaxonomiesBuilder(taxonomiesBuilder);
          return navigation;
        } catch (error) {
          log.error(`Failed to create Navigation entity: ${error}`);
          throw error;
        }
      }
    };
    exports2.NavigationFactory = NavigationFactory;
    function createNavigationFactory(langService, contentService) {
      return new NavigationFactory(langService, contentService);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/site/factory/site.js
var require_site2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/site/factory/site.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newSite = newSite;
    var site_1 = require_site();
    var publisher_1 = require_publisher();
    var url_1 = require_url();
    var ref_1 = require_ref();
    var language_1 = require_language3();
    var author_1 = require_author();
    var version_1 = require_version();
    var navigation_factory_1 = require_navigation_factory();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("site", { component: "factory" });
    function newSite(services) {
      const publisher = new publisher_1.Publisher(services.publishFs());
      const url = new url_1.URL(services.baseUrl(), true);
      const language = new language_1.Language(services);
      const navigationFactory = (0, navigation_factory_1.createNavigationFactory)(services, services);
      const navigation = navigationFactory.createNavigation();
      const author = (0, author_1.newAuthor)("MDFriday", "support@mdfriday.com");
      const compiler = (0, version_1.newVersion)("0.1.0");
      const site = new site_1.Site(services, services, services, services, services, services, publisher, author, compiler, url, {}, language, navigation, services.siteTitle());
      const ref = new ref_1.Ref({
        home: { page: null },
        sitePage: async (target) => {
          const sitePage = await site.sitePage(target);
          return {
            relPermalink: () => sitePage.path ? sitePage.path() : "",
            permalink: () => sitePage.path ? sitePage.path() : ""
          };
        }
      }, services, "/404.html");
      site.ref = ref;
      return site;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/type.js
var require_type10 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/resource.js
var require_resource = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResourceImpl = exports2.PublishOnce = exports2.ResourceHash = void 0;
    var resources_1 = require_resources2();
    var crypto_1 = require("crypto");
    var stream_1 = require("stream");
    var paths_1 = require_paths();
    var promises_1 = require("stream/promises");
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("resources", { component: "publisher" });
    var ResourceHash = class {
      constructor() {
        this.value = "";
        this.size = 0;
        this.resource = null;
      }
      async setup(resource) {
        if (this.value)
          return;
        this.resource = resource;
        const readSeeker = await resource.readSeekCloser();
        const hash = (0, crypto_1.createHash)("sha256");
        let totalSize = 0;
        const chunks = [];
        readSeeker.on("data", (chunk) => {
          hash.update(chunk);
          totalSize += chunk.length;
          chunks.push(chunk);
        });
        await new Promise((resolve, reject) => {
          readSeeker.on("end", () => {
            this.value = hash.digest("hex");
            this.size = totalSize;
            resolve();
          });
          readSeeker.on("error", reject);
        });
        await readSeeker.close();
      }
    };
    exports2.ResourceHash = ResourceHash;
    var PublishOnce = class {
      constructor() {
        this.hasPublished = false;
        this.publishPromise = null;
      }
      async do(publishFn) {
        if (this.hasPublished)
          return;
        if (this.publishPromise) {
          return this.publishPromise;
        }
        this.publishPromise = publishFn().then(() => {
          this.hasPublished = true;
        });
        return this.publishPromise;
      }
    };
    exports2.PublishOnce = PublishOnce;
    var ResourceImpl = class {
      constructor(openReadSeekCloser, mediaType, paths, data = {}, publisher) {
        this.h = new ResourceHash();
        this.openReadSeekCloser = openReadSeekCloser;
        this._mediaType = mediaType;
        this.paths = paths;
        this._data = data;
        this.publisher = publisher;
        this.publishOnce = new PublishOnce();
      }
      name() {
        return this.paths.pathFile();
      }
      nameNormalized() {
        return this.paths.targetPath().replace(/\\/g, "/");
      }
      mediaType() {
        return this._mediaType;
      }
      resourceType() {
        return this._mediaType.mainType;
      }
      relPermalink() {
        this.publish();
        return this.paths.targetLink();
      }
      permalink() {
        this.publish();
        return this.paths.targetPath();
      }
      async publish() {
        const targetPath = this.targetPath();
        if (!this.publisher) {
          log.error("\u26A0\uFE0F [Resource.publish] No publisher for: %s", targetPath);
          return;
        }
        await this.publishOnce.do(async () => {
          let publicWriter = null;
          let readSeeker = null;
          try {
            publicWriter = await this.publisher.openPublishFileForWriting(this.paths.targetPath());
            readSeeker = await this.readSeekCloser();
            await this.copyStreamToFile(readSeeker, publicWriter);
          } catch (error) {
            log.errorf("\u274C [Resource.publish] Error publishing %s: %s", targetPath, error);
            throw error;
          } finally {
            if (readSeeker) {
              try {
                await readSeeker.close();
              } catch (closeError) {
                log.errorf("\u274C [Resource.publish] Failed to close ReadSeekCloser %s: %s", targetPath, closeError);
              }
            }
            if (publicWriter) {
              try {
                await publicWriter.file.close();
              } catch (closeError) {
                log.errorf("\u274C [Resource.publish] Failed to close public writer %s: %s", targetPath, closeError);
              }
            }
          }
        });
      }
      async copyStreamToFile(source, destination) {
        const targetPath = this.targetPath();
        try {
          await (0, promises_1.pipeline)(source, destination);
        } catch (err) {
          log.errorf("\u274C [copyStreamToFile] Error during pipeline for %s: %s", targetPath, err);
          throw err;
        }
      }
      targetPath() {
        return this.paths.targetPath();
      }
      data() {
        return this._data;
      }
      async readSeekCloser() {
        const result = await this.openReadSeekCloser();
        if (result && typeof result.read === "function") {
          const testChunk = result.read();
          if (testChunk) {
            const Readable = require("stream").Readable;
            const newStream = new Readable();
            newStream.push(testChunk);
            let remainingChunk;
            while ((remainingChunk = result.read()) !== null) {
              if (remainingChunk) {
                newStream.push(remainingChunk);
              }
            }
            newStream.push(null);
            return Object.assign(newStream, {
              seek: async (offset, whence) => 0,
              close: async () => Promise.resolve()
            });
          }
        }
        return result;
      }
      async content(ctx) {
        const readSeeker = await this.readSeekCloser();
        return new Promise((resolve, reject) => {
          let content = "";
          readSeeker.on("data", (chunk) => {
            content += chunk.toString();
          });
          readSeeker.on("end", () => {
            resolve(content);
          });
          readSeeker.on("error", reject);
        });
      }
      async hash() {
        await this.h.setup(this);
        return this.h.value;
      }
      async size() {
        await this.h.setup(this);
        return this.h.size;
      }
      cloneTo(targetPath) {
        const cloned = this.clone();
        cloned.paths = cloned.paths.fromTargetPath(targetPath);
        return cloned;
      }
      clone() {
        const cloned = new ResourceImpl(this.openReadSeekCloser, this._mediaType, this.paths, { ...this._data }, this.publisher);
        cloned.h = this.h;
        return cloned;
      }
      key() {
        return this.paths.targetLink();
      }
      get RelPermalink() {
        return this.relPermalink();
      }
      get Permalink() {
        return this.permalink();
      }
      get Name() {
        return this.name();
      }
      get MediaType() {
        return this.mediaType();
      }
      get ResourceType() {
        return this.resourceType();
      }
      get TargetPath() {
        return this.targetPath();
      }
      get Data() {
        return this.data();
      }
      get Content() {
        return this.content();
      }
      get Hash() {
        return () => this.hash();
      }
      get Size() {
        return () => this.size();
      }
      meta() {
        return new resources_1.ResourceMetadataImpl(this.paths.targetPath(), this._mediaType.type, this._data);
      }
      mergeData(incoming) {
        if (!incoming || Object.keys(incoming).length === 0) {
          return;
        }
        for (const [key, value2] of Object.entries(incoming)) {
          if (!(key in this._data)) {
            this._data[key] = value2;
          }
        }
      }
      async transform(...transformations) {
        let currentResource = this;
        for (let i = 0; i < transformations.length; i++) {
          const transformation = transformations[i];
          try {
            const sourceReader = await currentResource.readSeekCloser();
            const targetWriter = new stream_1.PassThrough();
            let transformedContent = "";
            const contentChunks = [];
            const ctx = {
              source: {
                from: sourceReader,
                inPath: currentResource.targetPath(),
                inMediaType: currentResource.mediaType()
              },
              target: {
                to: targetWriter
              },
              data: { ...currentResource.data() },
              addOutPathIdentifier: (identifier) => {
                const currentPath = currentResource.targetPath();
                const pathInfo = paths_1.PathDomain.parseBasic(currentPath);
                let cleanDir = pathInfo.dir;
                cleanDir = cleanDir.replace(/\/+$/, "");
                let newPath = "";
                if (cleanDir) {
                  newPath = cleanDir + "/";
                }
                const nameWithIdentifier = pathInfo.nameWithoutExt + identifier;
                newPath += nameWithIdentifier + pathInfo.ext;
                ctx.data.targetPath = newPath;
              },
              updateBuffer: () => {
              },
              updateSource: () => {
              },
              close: () => {
                sourceReader.close();
              }
            };
            targetWriter.on("data", (chunk) => {
              contentChunks.push(chunk);
            });
            const targetWriterFinished = new Promise((resolve, reject) => {
              targetWriter.on("end", () => {
                transformedContent = Buffer.concat(contentChunks).toString();
                resolve();
              });
              targetWriter.on("error", (error) => {
                reject(error);
              });
            });
            await transformation.transform(ctx);
            await targetWriterFinished;
            const newTargetPath = ctx.data.targetPath || currentResource.targetPath();
            const newResource = this.createTransformedResource(transformedContent, newTargetPath, currentResource.mediaType(), ctx.data);
            currentResource = newResource;
            ctx.close();
          } catch (error) {
            throw error;
          }
        }
        return currentResource;
      }
      createTransformedResource(content, targetPath, mediaType, data) {
        const opener = async () => {
          const readable = new stream_1.PassThrough();
          readable.end(content);
          return Object.assign(readable, {
            seek: async (offset, whence) => 0,
            close: async () => Promise.resolve()
          });
        };
        const newPaths = this.paths.fromTargetPath(targetPath);
        return new ResourceImpl(opener, mediaType, newPaths, data, this.publisher);
      }
    };
    exports2.ResourceImpl = ResourceImpl;
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2) : typeof define === "function" && define.amd ? define(["module"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }), global2.sourcemapCodec = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var sourcemap_codec_exports = {};
      __export2(sourcemap_codec_exports, {
        decode: () => decode,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      });
      module3.exports = __toCommonJS2(sourcemap_codec_exports);
      var comma = ",".charCodeAt(0);
      var semicolon = ";".charCodeAt(0);
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var intToChar = new Uint8Array(64);
      var charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = reader.next();
          integer = charToInt[c];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        return relative + value2;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max)
          return false;
        return reader.peek() !== comma;
      }
      var bufLength = 1024 * 16;
      var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      var StringWriter = class {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos: pos2 } = this;
          return pos2 > 0 ? out + td.decode(buffer.subarray(0, pos2)) : out;
        }
      };
      var StringReader = class {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char2) {
          const { buffer, pos: pos2 } = this;
          const idx = buffer.indexOf(char2, pos2);
          return idx === -1 ? buffer.length : idx;
        }
      };
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0)
          writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope,
          callsite,
          bindings
        } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
            writer.write(semicolon);
          if (line.length === 0)
            continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
              writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path6 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path6) ? path6 : "/" + path6, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path6, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path6,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path6) {
        if (path6.endsWith("/.."))
          return path6;
        const index = path6.lastIndexOf("/");
        return path6.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path6 = "";
        for (let i = 1; i < pointer; i++) {
          path6 += "/" + pieces[i];
        }
        if (!path6 || addTrailingSlash && !path6.endsWith("/..")) {
          path6 += "/";
        }
        url.path = path6;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            case 2:
              url.query = baseUrl.query;
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path6 = url.path.slice(1);
            if (!path6)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path6)) {
              return "./" + path6 + queryHash;
            }
            return path6 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_resolve_uri_umd(), require_sourcemap_codec_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/resolve-uri", "@jridgewell/sourcemap-codec"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.resolveURI, global2.sourcemapCodec), global2.traceMapping = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_resolveURI, require_sourcemapCodec) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports3, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_resolve_uri = __commonJS2({
        "umd:@jridgewell/resolve-uri"(exports3, module22) {
          module22.exports = require_resolveURI;
        }
      });
      var trace_mapping_exports = {};
      __export2(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      });
      module3.exports = __toCommonJS2(trace_mapping_exports);
      var import_sourcemap_codec = __toESM2(require_sourcemap_codec());
      var import_resolve_uri = __toESM2(require_resolve_uri());
      function stripFilename(path6) {
        if (!path6)
          return "";
        const index = path6.lastIndexOf("/");
        return path6.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        const from = stripFilename(mapUrl);
        const prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      var found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert2(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert2(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      function parse2(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        const parsed = parse2(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse2(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append2(sources, resolvedSources);
        append2(names, map.names);
        if (contents)
          append2(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append2(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = class {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = parse2(map);
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
          } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a, _b;
        return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1)
          index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.sourcemapCodec, global2.traceMapping), global2.genMapping = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_sourcemapCodec, require_traceMapping) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports3, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports3, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var gen_mapping_exports = {};
      __export2(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      });
      module3.exports = __toCommonJS2(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0)
          return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key);
        return indexes[key] = length - 1;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0)
          return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      var import_sourcemap_codec = __toESM2(require_sourcemap_codec());
      var import_trace_mapping = __toESM2(require_trace_mapping());
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      var GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray();
          this._sources = new SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      var maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent
        } = cast2(map);
        const index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
        } = cast2(map);
        const index = put(sources, source);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          put(ignoreList, index);
        else
          remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
        } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        const map = new import_trace_mapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
        if (map.ignoreList)
          putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
        } = cast2(map);
        const line = getIndex(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert2(line, index, [genColumn]);
        }
        assert(sourceLine);
        assert(sourceColumn);
        const sourcesIndex = put(sources, source);
        const namesIndex = name ? put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content != null ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert2(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function assert(_val) {
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++) {
          arr[i] = [];
        }
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index;
      }
      function insert2(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++)
          put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        assert(original);
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
      }
    });
  }
});

// node_modules/@jridgewell/source-map/dist/source-map.umd.js
var require_source_map_umd = __commonJS({
  "node_modules/@jridgewell/source-map/dist/source-map.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_gen_mapping_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/gen-mapping", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.genMapping, global2.traceMapping), global2.sourceMap = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_genMapping, require_traceMapping) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports3, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var require_gen_mapping = __commonJS2({
        "umd:@jridgewell/gen-mapping"(exports3, module22) {
          module22.exports = require_genMapping;
        }
      });
      var source_map_exports = {};
      __export2(source_map_exports, {
        SourceMapConsumer: () => SourceMapConsumer,
        SourceMapGenerator: () => SourceMapGenerator
      });
      module3.exports = __toCommonJS2(source_map_exports);
      var import_trace_mapping = __toESM2(require_trace_mapping());
      var import_gen_mapping = __toESM2(require_gen_mapping());
      var SourceMapConsumer = class _SourceMapConsumer {
        constructor(map, mapUrl) {
          const trace = this._map = new import_trace_mapping.AnyMap(map, mapUrl);
          this.file = trace.file;
          this.names = trace.names;
          this.sourceRoot = trace.sourceRoot;
          this.sources = trace.resolvedSources;
          this.sourcesContent = trace.sourcesContent;
          this.version = trace.version;
        }
        static fromSourceMap(map, mapUrl) {
          if (map.toDecodedMap) {
            return new _SourceMapConsumer(map.toDecodedMap(), mapUrl);
          }
          return new _SourceMapConsumer(map.toJSON(), mapUrl);
        }
        get mappings() {
          return (0, import_trace_mapping.encodedMappings)(this._map);
        }
        originalPositionFor(needle) {
          return (0, import_trace_mapping.originalPositionFor)(this._map, needle);
        }
        generatedPositionFor(originalPosition) {
          return (0, import_trace_mapping.generatedPositionFor)(this._map, originalPosition);
        }
        allGeneratedPositionsFor(originalPosition) {
          return (0, import_trace_mapping.allGeneratedPositionsFor)(this._map, originalPosition);
        }
        hasContentsOfAllSources() {
          if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {
            return false;
          }
          for (const content of this.sourcesContent) {
            if (content == null) {
              return false;
            }
          }
          return true;
        }
        sourceContentFor(source, nullOnMissing) {
          const sourceContent = (0, import_trace_mapping.sourceContentFor)(this._map, source);
          if (sourceContent != null) {
            return sourceContent;
          }
          if (nullOnMissing) {
            return null;
          }
          throw new Error(`"${source}" is not in the SourceMap.`);
        }
        eachMapping(callback, context) {
          (0, import_trace_mapping.eachMapping)(this._map, context ? callback.bind(context) : callback);
        }
        destroy() {
        }
      };
      var SourceMapGenerator = class _SourceMapGenerator {
        constructor(opts) {
          this._map = opts instanceof import_gen_mapping.GenMapping ? opts : new import_gen_mapping.GenMapping(opts);
        }
        static fromSourceMap(consumer) {
          return new _SourceMapGenerator((0, import_gen_mapping.fromMap)(consumer));
        }
        addMapping(mapping) {
          (0, import_gen_mapping.maybeAddMapping)(this._map, mapping);
        }
        setSourceContent(source, content) {
          (0, import_gen_mapping.setSourceContent)(this._map, source, content);
        }
        toJSON() {
          return (0, import_gen_mapping.toEncodedMap)(this._map);
        }
        toString() {
          return JSON.stringify(this.toJSON());
        }
        toDecodedMap() {
          return (0, import_gen_mapping.toDecodedMap)(this._map);
        }
      };
    });
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports2, function(exports3) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos2 = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos2 += set[i2];
          if (pos2 > code) {
            return false;
          }
          pos2 += set[i2 + 1];
          if (pos2 >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n2) {
        return new Position(this.line, this.column + n2);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        checkPrivateFields: true,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text3, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text3,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse3() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
            return false;
          }
          if (flags & SCOPE_FUNCTION) {
            return (flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse3(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos2, options) {
        var parser = new this(options, input, pos2);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos2) {
        this.raise(pos2 != null ? pos2 : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos2 = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos2), true)) {
            ++pos2;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos2);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var awaitEndPos = next + 5, after;
          if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
            return false;
          }
          skipWhiteSpace.lastIndex = awaitEndPos;
          var skipAfterUsing = skipWhiteSpace.exec(this.input);
          if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
            return false;
          }
        }
        if (isFor) {
          var ofEndPos = next + 2, after$1;
          if (this.input.slice(next, ofEndPos) === "of") {
            if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
              return false;
            }
          }
        }
        var ch = this.input.charCodeAt(next);
        return isIdentifierStart(ch, true) || ch === 92;
      };
      pp$8.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$8.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$8.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports4);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (topLevel && this.options.sourceType === "script") {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node, false, usingKind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init2 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init2.start === initPos && !containsEsc && init2.type === "Identifier" && init2.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init2, false, refDestructuringErrors);
          this.checkLValPattern(init2);
          return this.parseForIn(node, init2);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      };
      pp$8.parseForAfterInit = function(node, init2, awaitAt) {
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init2.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init2);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init2) {
        node.init = init2;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init2) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init2;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element2 = this.parseClassElement(node.superClass !== null);
          if (element2) {
            classBody.body.push(element2);
            if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
              this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element2) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element2.computed = false;
          element2.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element2);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element2);
        return element2.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element2) {
        var name = element2.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
          next = (element2.static ? "s" : "i") + element2.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
              node.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports4, name, pos2) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports4, name)) {
          this.raiseRecoverable(pos2, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$8.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(exports4, node.exported, node.exported.start);
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr2 = this.parseImportAttribute();
          var keyName = attr2.key.type === "Identifier" ? attr2.key.name : attr2.key.value;
          if (hasOwn(attributeKeys, keyName)) {
            this.raiseRecoverable(attr2.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr2);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update2, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update2 = type.updateContext) {
          update2.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update2 = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update2, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update2) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
      }
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element2.optional) {
            optionalChained = true;
          }
          if (element2 === base || element2.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element2;
              element2 = this.finishNode(chainNode, "ChainExpression");
            }
            return element2;
          }
          base = element2;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value2 = this.value;
            node = this.parseLiteral(value2.value);
            node.regex = { pattern: value2.pattern, flags: value2.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value2) {
        var node = this.startNode();
        node.value = value2;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos2, message) {
        var loc = getLineInfo(this.input, pos2);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos2;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos2) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos2, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos2, loc) {
        this.type = "";
        this.start = pos2;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos2, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos2, loc) {
        return new Node(this, pos2, loc);
      };
      function finishNodeAt(node, type, pos2, loc) {
        node.type = type;
        node.end = pos2;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos2;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos2, loc) {
        return finishNodeAt.call(this, node, type, pos2, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var BranchID = function BranchID2(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos2 = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos2, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos2 = this.nextIndex(pos2, forceU);
        }
        this.pos = pos2;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (!state.groupNames[name]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(124)) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63)) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(45);
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(58)) {
              this.regexp_disjunction(state);
              if (state.eat(41)) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers += codePointToString(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(63)) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n2 = state.lastIntValue;
          if (state.switchU) {
            if (n2 > state.maxBackReference) {
              state.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (!state.eat(93)) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state))
          ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars([38, 38])) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars([45, 45])) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (state.eat(93)) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(92)) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars([92, 113])) {
          if (state.eat(123)) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(125)) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(124)) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(98)) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos2 = start; (nextBreak = nextLineBreak(this.input, pos2, this.pos)) > -1; ) {
            ++this.curLine;
            pos2 = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.15.0";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse2(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos2, options) {
        return Parser.parseExpressionAt(input, pos2, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports3.Node = Node;
      exports3.Parser = Parser;
      exports3.Position = Position;
      exports3.SourceLocation = SourceLocation;
      exports3.TokContext = TokContext;
      exports3.Token = Token;
      exports3.TokenType = TokenType;
      exports3.defaultOptions = defaultOptions;
      exports3.getLineInfo = getLineInfo;
      exports3.isIdentifierChar = isIdentifierChar;
      exports3.isIdentifierStart = isIdentifierStart;
      exports3.isNewLine = isNewLine;
      exports3.keywordTypes = keywords;
      exports3.lineBreak = lineBreak;
      exports3.lineBreakG = lineBreakG;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace;
      exports3.parse = parse2;
      exports3.parseExpressionAt = parseExpressionAt;
      exports3.tokContexts = types;
      exports3.tokTypes = types$1;
      exports3.tokenizer = tokenizer;
      exports3.version = version;
    });
  }
});

// node_modules/terser/dist/bundle.min.js
var require_bundle_min = __commonJS({
  "node_modules/terser/dist/bundle.min.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_source_map_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/source-map"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Terser = {}, global2.sourceMap));
    })(exports2, function(exports3, sourceMap) {
      "use strict";
      function characters(str) {
        return str.split("");
      }
      function member(name, array) {
        return array.includes(name);
      }
      class DefaultsError extends Error {
        constructor(msg, defs) {
          super();
          this.name = "DefaultsError";
          this.message = msg;
          this.defs = defs;
        }
      }
      function defaults(args, defs, croak) {
        if (args === true) {
          args = {};
        } else if (args != null && typeof args === "object") {
          args = { ...args };
        }
        const ret = args || {};
        if (croak) {
          for (const i in ret)
            if (HOP(ret, i) && !HOP(defs, i)) {
              throw new DefaultsError("`" + i + "` is not a supported option", defs);
            }
        }
        for (const i in defs)
          if (HOP(defs, i)) {
            if (!args || !HOP(args, i)) {
              ret[i] = defs[i];
            } else if (i === "ecma") {
              let ecma = args[i] | 0;
              if (ecma > 5 && ecma < 2015)
                ecma += 2009;
              ret[i] = ecma;
            } else {
              ret[i] = args && HOP(args, i) ? args[i] : defs[i];
            }
          }
        return ret;
      }
      function noop2() {
      }
      function return_false() {
        return false;
      }
      function return_true() {
        return true;
      }
      function return_this() {
        return this;
      }
      function return_null() {
        return null;
      }
      var MAP = function() {
        function MAP2(a, tw, allow_splicing = true) {
          const new_a = [];
          for (let i = 0; i < a.length; ++i) {
            let item = a[i];
            let ret = item.transform(tw, allow_splicing);
            if (ret instanceof AST_Node) {
              new_a.push(ret);
            } else if (ret instanceof Splice) {
              new_a.push(...ret.v);
            }
          }
          return new_a;
        }
        MAP2.splice = function(val) {
          return new Splice(val);
        };
        MAP2.skip = {};
        function Splice(val) {
          this.v = val;
        }
        return MAP2;
      }();
      function make_node(ctor, orig, props) {
        if (!props)
          props = {};
        if (orig) {
          if (!props.start)
            props.start = orig.start;
          if (!props.end)
            props.end = orig.end;
        }
        return new ctor(props);
      }
      function push_uniq(array, el) {
        if (!array.includes(el))
          array.push(el);
      }
      function string_template(text3, props) {
        return text3.replace(/{(.+?)}/g, function(str, p) {
          return props && props[p];
        });
      }
      function remove(array, el) {
        for (var i = array.length; --i >= 0; ) {
          if (array[i] === el)
            array.splice(i, 1);
        }
      }
      function mergeSort(array, cmp) {
        if (array.length < 2)
          return array.slice();
        function merge(a, b) {
          var r = [], ai = 0, bi = 0, i = 0;
          while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];
          }
          if (ai < a.length)
            r.push.apply(r, a.slice(ai));
          if (bi < b.length)
            r.push.apply(r, b.slice(bi));
          return r;
        }
        function _ms(a) {
          if (a.length <= 1)
            return a;
          var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
          left = _ms(left);
          right = _ms(right);
          return merge(left, right);
        }
        return _ms(array);
      }
      function makePredicate(words) {
        if (!Array.isArray(words))
          words = words.split(" ");
        return new Set(words.sort());
      }
      function map_add(map, key, value2) {
        if (map.has(key)) {
          map.get(key).push(value2);
        } else {
          map.set(key, [value2]);
        }
      }
      function map_from_object(obj) {
        var map = /* @__PURE__ */ new Map();
        for (var key in obj) {
          if (HOP(obj, key) && key.charAt(0) === "$") {
            map.set(key.substr(1), obj[key]);
          }
        }
        return map;
      }
      function map_to_object(map) {
        var obj = /* @__PURE__ */ Object.create(null);
        map.forEach(function(value2, key) {
          obj["$" + key] = value2;
        });
        return obj;
      }
      function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function keep_name(keep_setting, name) {
        return keep_setting === true || keep_setting instanceof RegExp && keep_setting.test(name);
      }
      var lineTerminatorEscape = {
        "\0": "0",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      function regexp_source_fix(source) {
        return source.replace(/[\0\n\r\u2028\u2029]/g, function(match, offset) {
          var escaped = source[offset - 1] == "\\" && (source[offset - 2] != "\\" || /(?:^|[^\\])(?:\\{2})*$/.test(source.slice(0, offset - 1)));
          return (escaped ? "" : "\\") + lineTerminatorEscape[match];
        });
      }
      const re_safe_regexp = /^[\\/|\0\s\w^$.[\]()]*$/;
      const regexp_is_safe = (source) => re_safe_regexp.test(source);
      const all_flags = "dgimsuyv";
      function sort_regexp_flags(flags) {
        const existing_flags = new Set(flags.split(""));
        let out = "";
        for (const flag of all_flags) {
          if (existing_flags.has(flag)) {
            out += flag;
            existing_flags.delete(flag);
          }
        }
        if (existing_flags.size) {
          existing_flags.forEach((flag) => {
            out += flag;
          });
        }
        return out;
      }
      function has_annotation(node, annotation) {
        return node._annotations & annotation;
      }
      function set_annotation(node, annotation) {
        node._annotations |= annotation;
      }
      function clear_annotation(node, annotation) {
        node._annotations &= ~annotation;
      }
      var LATEST_RAW = "";
      var TEMPLATE_RAWS = /* @__PURE__ */ new Map();
      var KEYWORDS = "break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with";
      var KEYWORDS_ATOM = "false null true";
      var RESERVED_WORDS = "enum import super this " + KEYWORDS_ATOM + " " + KEYWORDS;
      var ALL_RESERVED_WORDS = "implements interface package private protected public static " + RESERVED_WORDS;
      var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case yield await";
      KEYWORDS = makePredicate(KEYWORDS);
      RESERVED_WORDS = makePredicate(RESERVED_WORDS);
      KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
      KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
      ALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);
      var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
      var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
      var RE_OCT_NUMBER = /^0[0-7]+$/;
      var RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;
      var RE_BIN_NUMBER = /^0b[01]+$/i;
      var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
      var RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;
      var OPERATORS = makePredicate([
        "in",
        "instanceof",
        "typeof",
        "new",
        "void",
        "delete",
        "++",
        "--",
        "+",
        "-",
        "!",
        "~",
        "&",
        "|",
        "^",
        "*",
        "**",
        "/",
        "%",
        ">>",
        "<<",
        ">>>",
        "<",
        ">",
        "<=",
        ">=",
        "==",
        "===",
        "!=",
        "!==",
        "?",
        "=",
        "+=",
        "-=",
        "||=",
        "&&=",
        "??=",
        "/=",
        "*=",
        "**=",
        "%=",
        ">>=",
        "<<=",
        ">>>=",
        "|=",
        "^=",
        "&=",
        "&&",
        "??",
        "||"
      ]);
      var WHITESPACE_CHARS = makePredicate(characters(" \xA0\n\r	\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF"));
      var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));
      var PUNC_AFTER_EXPRESSION = makePredicate(characters(";]),:"));
      var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));
      var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
      var UNICODE = {
        ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/
      };
      function get_full_char(str, pos2) {
        if (is_surrogate_pair_head(str.charCodeAt(pos2))) {
          if (is_surrogate_pair_tail(str.charCodeAt(pos2 + 1))) {
            return str.charAt(pos2) + str.charAt(pos2 + 1);
          }
        } else if (is_surrogate_pair_tail(str.charCodeAt(pos2))) {
          if (is_surrogate_pair_head(str.charCodeAt(pos2 - 1))) {
            return str.charAt(pos2 - 1) + str.charAt(pos2);
          }
        }
        return str.charAt(pos2);
      }
      function get_full_char_code(str, pos2) {
        if (is_surrogate_pair_head(str.charCodeAt(pos2))) {
          return 65536 + (str.charCodeAt(pos2) - 55296 << 10) + str.charCodeAt(pos2 + 1) - 56320;
        }
        return str.charCodeAt(pos2);
      }
      function get_full_char_length(str) {
        var surrogates = 0;
        for (var i = 0; i < str.length; i++) {
          if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
            surrogates++;
            i++;
          }
        }
        return str.length - surrogates;
      }
      function from_char_code(code) {
        if (code > 65535) {
          code -= 65536;
          return String.fromCharCode((code >> 10) + 55296) + String.fromCharCode(code % 1024 + 56320);
        }
        return String.fromCharCode(code);
      }
      function is_surrogate_pair_head(code) {
        return code >= 55296 && code <= 56319;
      }
      function is_surrogate_pair_tail(code) {
        return code >= 56320 && code <= 57343;
      }
      function is_digit(code) {
        return code >= 48 && code <= 57;
      }
      function is_identifier_start(ch) {
        return UNICODE.ID_Start.test(ch);
      }
      function is_identifier_char(ch) {
        return UNICODE.ID_Continue.test(ch);
      }
      const BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;
      function is_basic_identifier_string(str) {
        return BASIC_IDENT.test(str);
      }
      function is_identifier_string(str, allow_surrogates) {
        if (BASIC_IDENT.test(str)) {
          return true;
        }
        if (!allow_surrogates && /[\ud800-\udfff]/.test(str)) {
          return false;
        }
        var match = UNICODE.ID_Start.exec(str);
        if (!match || match.index !== 0) {
          return false;
        }
        str = str.slice(match[0].length);
        if (!str) {
          return true;
        }
        match = UNICODE.ID_Continue.exec(str);
        return !!match && match[0].length === str.length;
      }
      function parse_js_number(num, allow_e = true) {
        if (!allow_e && num.includes("e")) {
          return NaN;
        }
        if (RE_HEX_NUMBER.test(num)) {
          return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
          return parseInt(num.substr(1), 8);
        } else if (RE_ES6_OCT_NUMBER.test(num)) {
          return parseInt(num.substr(2), 8);
        } else if (RE_BIN_NUMBER.test(num)) {
          return parseInt(num.substr(2), 2);
        } else if (RE_DEC_NUMBER.test(num)) {
          return parseFloat(num);
        } else {
          var val = parseFloat(num);
          if (val == num)
            return val;
        }
      }
      class JS_Parse_Error extends Error {
        constructor(message, filename, line, col, pos2) {
          super();
          this.name = "SyntaxError";
          this.message = message;
          this.filename = filename;
          this.line = line;
          this.col = col;
          this.pos = pos2;
        }
      }
      function js_error(message, filename, line, col, pos2) {
        throw new JS_Parse_Error(message, filename, line, col, pos2);
      }
      function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
      }
      var EX_EOF = {};
      function tokenizer($TEXT, filename, html5_comments, shebang) {
        var S = {
          text: $TEXT,
          filename,
          pos: 0,
          tokpos: 0,
          line: 1,
          tokline: 0,
          col: 0,
          tokcol: 0,
          newline_before: false,
          regex_allowed: false,
          brace_counter: 0,
          template_braces: [],
          comments_before: [],
          directives: {},
          directive_stack: []
        };
        function peek() {
          return get_full_char(S.text, S.pos);
        }
        function is_option_chain_op() {
          const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;
          if (!must_be_dot)
            return false;
          const cannot_be_digit = S.text.charCodeAt(S.pos + 2);
          return cannot_be_digit < 48 || cannot_be_digit > 57;
        }
        function next(signal_eof, in_string) {
          var ch = get_full_char(S.text, S.pos++);
          if (signal_eof && !ch)
            throw EX_EOF;
          if (NEWLINE_CHARS.has(ch)) {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
            if (ch == "\r" && peek() == "\n") {
              ++S.pos;
              ch = "\n";
            }
          } else {
            if (ch.length > 1) {
              ++S.pos;
              ++S.col;
            }
            ++S.col;
          }
          return ch;
        }
        function forward(i) {
          while (i--)
            next();
        }
        function looking_at(str) {
          return S.text.substr(S.pos, str.length) == str;
        }
        function find_eol() {
          var text3 = S.text;
          for (var i = S.pos, n2 = S.text.length; i < n2; ++i) {
            var ch = text3[i];
            if (NEWLINE_CHARS.has(ch))
              return i;
          }
          return -1;
        }
        function find(what, signal_eof) {
          var pos2 = S.text.indexOf(what, S.pos);
          if (signal_eof && pos2 == -1)
            throw EX_EOF;
          return pos2;
        }
        function start_token() {
          S.tokline = S.line;
          S.tokcol = S.col;
          S.tokpos = S.pos;
        }
        var prev_was_dot = false;
        var previous_token = null;
        function token(type, value2, is_comment) {
          S.regex_allowed = type == "operator" && !UNARY_POSTFIX.has(value2) || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION.has(value2) || type == "punc" && PUNC_BEFORE_EXPRESSION.has(value2) || type == "arrow";
          if (type == "punc" && (value2 == "." || value2 == "?.")) {
            prev_was_dot = true;
          } else if (!is_comment) {
            prev_was_dot = false;
          }
          const line = S.tokline;
          const col = S.tokcol;
          const pos2 = S.tokpos;
          const nlb = S.newline_before;
          const file = filename;
          let comments_before = [];
          let comments_after = [];
          if (!is_comment) {
            comments_before = S.comments_before;
            comments_after = S.comments_before = [];
          }
          S.newline_before = false;
          const tok = new AST_Token(type, value2, line, col, pos2, nlb, comments_before, comments_after, file);
          if (!is_comment)
            previous_token = tok;
          return tok;
        }
        function skip_whitespace() {
          while (WHITESPACE_CHARS.has(peek()))
            next();
        }
        function read_while(pred) {
          var ret = "", ch, i = 0;
          while ((ch = peek()) && pred(ch, i++))
            ret += next();
          return ret;
        }
        function parse_error(err) {
          js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
        }
        function read_num(prefix) {
          var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".", is_big_int = false, numeric_separator = false;
          var num = read_while(function(ch, i) {
            if (is_big_int)
              return false;
            var code = ch.charCodeAt(0);
            switch (code) {
              case 95:
                return numeric_separator = true;
              case 98:
              case 66:
                return has_x = true;
              case 111:
              case 79:
              case 120:
              case 88:
                return has_x ? false : has_x = true;
              case 101:
              case 69:
                return has_x ? true : has_e ? false : has_e = after_e = true;
              case 45:
                return after_e || i == 0 && !prefix;
              case 43:
                return after_e;
              case (after_e = false, 46):
                return !has_dot && !has_x && !has_e ? has_dot = true : false;
              case 110:
                is_big_int = true;
                return true;
            }
            return code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 70;
          });
          if (prefix)
            num = prefix + num;
          LATEST_RAW = num;
          if (RE_OCT_NUMBER.test(num) && next_token.has_directive("use strict")) {
            parse_error("Legacy octal literals are not allowed in strict mode");
          }
          if (numeric_separator) {
            if (num.endsWith("_")) {
              parse_error("Numeric separators are not allowed at the end of numeric literals");
            } else if (num.includes("__")) {
              parse_error("Only one underscore is allowed as numeric separator");
            }
            num = num.replace(/_/g, "");
          }
          if (is_big_int) {
            const without_n = num.slice(0, -1);
            const allow_e = RE_HEX_NUMBER.test(without_n);
            const valid2 = parse_js_number(without_n, allow_e);
            if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid2))
              return token("big_int", without_n);
            parse_error("Invalid or unexpected token");
          }
          var valid = parse_js_number(num);
          if (!isNaN(valid)) {
            return token("num", valid);
          } else {
            parse_error("Invalid syntax: " + num);
          }
        }
        function is_octal(ch) {
          return ch >= "0" && ch <= "7";
        }
        function read_escaped_char(in_string, strict_hex, template_string) {
          var ch = next(true, in_string);
          switch (ch.charCodeAt(0)) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 120:
              return String.fromCharCode(hex_bytes(2, strict_hex));
            case 117:
              if (peek() == "{") {
                next(true);
                if (peek() === "}")
                  parse_error("Expecting hex-character between {}");
                while (peek() == "0")
                  next(true);
                var result, length = find("}", true) - S.pos;
                if (length > 6 || (result = hex_bytes(length, strict_hex)) > 1114111) {
                  parse_error("Unicode reference out of bounds");
                }
                next(true);
                return from_char_code(result);
              }
              return String.fromCharCode(hex_bytes(4, strict_hex));
            case 10:
              return "";
            case 13:
              if (peek() == "\n") {
                next(true, in_string);
                return "";
              }
          }
          if (is_octal(ch)) {
            if (template_string && strict_hex) {
              const represents_null_character = ch === "0" && !is_octal(peek());
              if (!represents_null_character) {
                parse_error("Octal escape sequences are not allowed in template strings");
              }
            }
            return read_octal_escape_sequence(ch, strict_hex);
          }
          return ch;
        }
        function read_octal_escape_sequence(ch, strict_octal) {
          var p = peek();
          if (p >= "0" && p <= "7") {
            ch += next(true);
            if (ch[0] <= "3" && (p = peek()) >= "0" && p <= "7")
              ch += next(true);
          }
          if (ch === "0")
            return "\0";
          if (ch.length > 0 && next_token.has_directive("use strict") && strict_octal)
            parse_error("Legacy octal escape sequences are not allowed in strict mode");
          return String.fromCharCode(parseInt(ch, 8));
        }
        function hex_bytes(n2, strict_hex) {
          var num = 0;
          for (; n2 > 0; --n2) {
            if (!strict_hex && isNaN(parseInt(peek(), 16))) {
              return parseInt(num, 16) || "";
            }
            var digit = next(true);
            if (isNaN(parseInt(digit, 16)))
              parse_error("Invalid hex-character pattern in string");
            num += digit;
          }
          return parseInt(num, 16);
        }
        var read_string = with_eof_error("Unterminated string constant", function() {
          const start_pos = S.pos;
          var quote = next(), ret = [];
          for (; ; ) {
            var ch = next(true, true);
            if (ch == "\\")
              ch = read_escaped_char(true, true);
            else if (ch == "\r" || ch == "\n")
              parse_error("Unterminated string constant");
            else if (ch == quote)
              break;
            ret.push(ch);
          }
          var tok = token("string", ret.join(""));
          LATEST_RAW = S.text.slice(start_pos, S.pos);
          tok.quote = quote;
          return tok;
        });
        var read_template_characters = with_eof_error("Unterminated template", function(begin) {
          if (begin) {
            S.template_braces.push(S.brace_counter);
          }
          var content = "", raw = "", ch, tok;
          next(true, true);
          while ((ch = next(true, true)) != "`") {
            if (ch == "\r") {
              if (peek() == "\n")
                ++S.pos;
              ch = "\n";
            } else if (ch == "$" && peek() == "{") {
              next(true, true);
              S.brace_counter++;
              tok = token(begin ? "template_head" : "template_cont", content);
              TEMPLATE_RAWS.set(tok, raw);
              tok.template_end = false;
              return tok;
            }
            raw += ch;
            if (ch == "\\") {
              var tmp = S.pos;
              var prev_is_tag = previous_token && (previous_token.type === "name" || previous_token.type === "punc" && (previous_token.value === ")" || previous_token.value === "]"));
              ch = read_escaped_char(true, !prev_is_tag, true);
              raw += S.text.substr(tmp, S.pos - tmp);
            }
            content += ch;
          }
          S.template_braces.pop();
          tok = token(begin ? "template_head" : "template_cont", content);
          TEMPLATE_RAWS.set(tok, raw);
          tok.template_end = true;
          return tok;
        });
        function skip_line_comment(type) {
          var regex_allowed = S.regex_allowed;
          var i = find_eol(), ret;
          if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
          } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
          }
          S.col = S.tokcol + (S.pos - S.tokpos);
          S.comments_before.push(token(type, ret, true));
          S.regex_allowed = regex_allowed;
          return next_token;
        }
        var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
          var regex_allowed = S.regex_allowed;
          var i = find("*/", true);
          var text3 = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, "\n");
          forward(get_full_char_length(text3) + 2);
          S.comments_before.push(token("comment2", text3, true));
          S.newline_before = S.newline_before || text3.includes("\n");
          S.regex_allowed = regex_allowed;
          return next_token;
        });
        var read_name = function() {
          let start = S.pos, end = start - 1, ch = "c";
          while ((ch = S.text.charAt(++end)) && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z"))
            ;
          if (end > start + 1 && ch && ch !== "\\" && !is_identifier_char(ch)) {
            S.pos += end - start;
            S.col += end - start;
            return S.text.slice(start, S.pos);
          }
          return read_name_hard();
        };
        var read_name_hard = with_eof_error("Unterminated identifier name", function() {
          var name = [], ch, escaped = false;
          var read_escaped_identifier_char = function() {
            escaped = true;
            next();
            if (peek() !== "u") {
              parse_error("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}");
            }
            return read_escaped_char(false, true);
          };
          if ((ch = peek()) === "\\") {
            ch = read_escaped_identifier_char();
            if (!is_identifier_start(ch)) {
              parse_error("First identifier char is an invalid identifier char");
            }
          } else if (is_identifier_start(ch)) {
            next();
          } else {
            return "";
          }
          name.push(ch);
          while ((ch = peek()) != null) {
            if ((ch = peek()) === "\\") {
              ch = read_escaped_identifier_char();
              if (!is_identifier_char(ch)) {
                parse_error("Invalid escaped identifier char");
              }
            } else {
              if (!is_identifier_char(ch)) {
                break;
              }
              next();
            }
            name.push(ch);
          }
          const name_str = name.join("");
          if (RESERVED_WORDS.has(name_str) && escaped) {
            parse_error("Escaped characters are not allowed in keywords");
          }
          return name_str;
        });
        var read_regexp = with_eof_error("Unterminated regular expression", function(source) {
          var prev_backslash = false, ch, in_class = false;
          while (ch = next(true))
            if (NEWLINE_CHARS.has(ch)) {
              parse_error("Unexpected line terminator");
            } else if (prev_backslash) {
              if (/^[\u0000-\u007F]$/.test(ch)) {
                source += "\\" + ch;
              } else {
                source += ch;
              }
              prev_backslash = false;
            } else if (ch == "[") {
              in_class = true;
              source += ch;
            } else if (ch == "]" && in_class) {
              in_class = false;
              source += ch;
            } else if (ch == "/" && !in_class) {
              break;
            } else if (ch == "\\") {
              prev_backslash = true;
            } else {
              source += ch;
            }
          const flags = read_name();
          return token("regexp", "/" + source + "/" + flags);
        });
        function read_operator(prefix) {
          function grow(op) {
            if (!peek())
              return op;
            var bigger = op + peek();
            if (OPERATORS.has(bigger)) {
              next();
              return grow(bigger);
            } else {
              return op;
            }
          }
          return token("operator", grow(prefix || next()));
        }
        function handle_slash() {
          next();
          switch (peek()) {
            case "/":
              next();
              return skip_line_comment("comment1");
            case "*":
              next();
              return skip_multiline_comment();
          }
          return S.regex_allowed ? read_regexp("") : read_operator("/");
        }
        function handle_eq_sign() {
          next();
          if (peek() === ">") {
            next();
            return token("arrow", "=>");
          } else {
            return read_operator("=");
          }
        }
        function handle_dot() {
          next();
          if (is_digit(peek().charCodeAt(0))) {
            return read_num(".");
          }
          if (peek() === ".") {
            next();
            next();
            return token("expand", "...");
          }
          return token("punc", ".");
        }
        function read_word() {
          var word = read_name();
          if (prev_was_dot)
            return token("name", word);
          return KEYWORDS_ATOM.has(word) ? token("atom", word) : !KEYWORDS.has(word) ? token("name", word) : OPERATORS.has(word) ? token("operator", word) : token("keyword", word);
        }
        function read_private_word() {
          next();
          return token("privatename", read_name());
        }
        function with_eof_error(eof_error, cont) {
          return function(x) {
            try {
              return cont(x);
            } catch (ex) {
              if (ex === EX_EOF)
                parse_error(eof_error);
              else
                throw ex;
            }
          };
        }
        function next_token(force_regexp) {
          if (force_regexp != null)
            return read_regexp(force_regexp);
          if (shebang && S.pos == 0 && looking_at("#!")) {
            start_token();
            forward(2);
            skip_line_comment("comment5");
          }
          for (; ; ) {
            skip_whitespace();
            start_token();
            if (html5_comments) {
              if (looking_at("<!--")) {
                forward(4);
                skip_line_comment("comment3");
                continue;
              }
              if (looking_at("-->") && S.newline_before) {
                forward(3);
                skip_line_comment("comment4");
                continue;
              }
            }
            var ch = peek();
            if (!ch)
              return token("eof");
            var code = ch.charCodeAt(0);
            switch (code) {
              case 34:
              case 39:
                return read_string();
              case 46:
                return handle_dot();
              case 47: {
                var tok = handle_slash();
                if (tok === next_token)
                  continue;
                return tok;
              }
              case 61:
                return handle_eq_sign();
              case 63: {
                if (!is_option_chain_op())
                  break;
                next();
                next();
                return token("punc", "?.");
              }
              case 96:
                return read_template_characters(true);
              case 123:
                S.brace_counter++;
                break;
              case 125:
                S.brace_counter--;
                if (S.template_braces.length > 0 && S.template_braces[S.template_braces.length - 1] === S.brace_counter)
                  return read_template_characters(false);
                break;
            }
            if (is_digit(code))
              return read_num();
            if (PUNC_CHARS.has(ch))
              return token("punc", next());
            if (OPERATOR_CHARS.has(ch))
              return read_operator();
            if (code == 92 || is_identifier_start(ch))
              return read_word();
            if (code == 35)
              return read_private_word();
            break;
          }
          parse_error("Unexpected character '" + ch + "'");
        }
        next_token.next = next;
        next_token.peek = peek;
        next_token.context = function(nc) {
          if (nc)
            S = nc;
          return S;
        };
        next_token.add_directive = function(directive) {
          S.directive_stack[S.directive_stack.length - 1].push(directive);
          if (S.directives[directive] === void 0) {
            S.directives[directive] = 1;
          } else {
            S.directives[directive]++;
          }
        };
        next_token.push_directives_stack = function() {
          S.directive_stack.push([]);
        };
        next_token.pop_directives_stack = function() {
          var directives2 = S.directive_stack[S.directive_stack.length - 1];
          for (var i = 0; i < directives2.length; i++) {
            S.directives[directives2[i]]--;
          }
          S.directive_stack.pop();
        };
        next_token.has_directive = function(directive) {
          return S.directives[directive] > 0;
        };
        return next_token;
      }
      var UNARY_PREFIX = makePredicate([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
      ]);
      var UNARY_POSTFIX = makePredicate(["--", "++"]);
      var ASSIGNMENT = makePredicate(["=", "+=", "-=", "??=", "&&=", "||=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]);
      var LOGICAL_ASSIGNMENT = makePredicate(["??=", "&&=", "||="]);
      var PRECEDENCE = function(a, ret) {
        for (var i = 0; i < a.length; ++i) {
          for (const op of a[i]) {
            ret[op] = i + 1;
          }
        }
        return ret;
      }([
        ["||"],
        ["??"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"],
        ["**"]
      ], {});
      var ATOMIC_START_TOKEN = makePredicate(["atom", "num", "big_int", "string", "regexp", "name"]);
      function parse2($TEXT, options) {
        const outer_comments_before_counts = /* @__PURE__ */ new WeakMap();
        options = defaults(options, {
          bare_returns: false,
          ecma: null,
          expression: false,
          filename: null,
          html5_comments: true,
          module: false,
          shebang: true,
          strict: false,
          toplevel: null
        }, true);
        var S = {
          input: typeof $TEXT == "string" ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang) : $TEXT,
          token: null,
          prev: null,
          peeked: null,
          in_function: 0,
          in_async: -1,
          in_generator: -1,
          in_directives: true,
          in_loop: 0,
          labels: []
        };
        S.token = next();
        function is(type, value2) {
          return is_token(S.token, type, value2);
        }
        function peek() {
          return S.peeked || (S.peeked = S.input());
        }
        function next() {
          S.prev = S.token;
          if (!S.peeked)
            peek();
          S.token = S.peeked;
          S.peeked = null;
          S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
          return S.token;
        }
        function prev() {
          return S.prev;
        }
        function croak(msg, line, col, pos2) {
          var ctx = S.input.context();
          js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos2 != null ? pos2 : ctx.tokpos);
        }
        function token_error(token, msg) {
          croak(msg, token.line, token.col);
        }
        function unexpected(token) {
          if (token == null)
            token = S.token;
          token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        }
        function expect_token(type, val) {
          if (is(type, val)) {
            return next();
          }
          token_error(S.token, "Unexpected token " + S.token.type + " \xAB" + S.token.value + "\xBB, expected " + type + " \xAB" + val + "\xBB");
        }
        function expect(punc) {
          return expect_token("punc", punc);
        }
        function has_newline_before(token) {
          return token.nlb || !token.comments_before.every((comment) => !comment.nlb);
        }
        function can_insert_semicolon() {
          return !options.strict && (is("eof") || is("punc", "}") || has_newline_before(S.token));
        }
        function is_in_generator() {
          return S.in_generator === S.in_function;
        }
        function is_in_async() {
          return S.in_async === S.in_function;
        }
        function can_await() {
          return S.in_async === S.in_function || S.in_function === 0 && S.input.has_directive("use strict");
        }
        function semicolon(optional) {
          if (is("punc", ";"))
            next();
          else if (!optional && !can_insert_semicolon())
            unexpected();
        }
        function parenthesised() {
          expect("(");
          var exp = expression(true);
          expect(")");
          return exp;
        }
        function embed_tokens(parser) {
          return function _embed_tokens_wrapper(...args) {
            const start = S.token;
            const expr = parser(...args);
            expr.start = start;
            expr.end = prev();
            return expr;
          };
        }
        function handle_regexp() {
          if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1));
          }
        }
        var statement = embed_tokens(function statement2(is_export_default, is_for_body, is_if_body) {
          handle_regexp();
          switch (S.token.type) {
            case "string":
              if (S.in_directives) {
                var token = peek();
                if (!LATEST_RAW.includes("\\") && (is_token(token, "punc", ";") || is_token(token, "punc", "}") || has_newline_before(token) || is_token(token, "eof"))) {
                  S.input.add_directive(S.token.value);
                } else {
                  S.in_directives = false;
                }
              }
              var dir = S.in_directives, stat = simple_statement();
              return dir && stat.body instanceof AST_String ? new AST_Directive(stat.body) : stat;
            case "template_head":
            case "num":
            case "big_int":
            case "regexp":
            case "operator":
            case "atom":
              return simple_statement();
            case "name":
            case "privatename":
              if (is("privatename") && !S.in_class)
                croak("Private field must be used in an enclosing class");
              if (S.token.value == "async" && is_token(peek(), "keyword", "function")) {
                next();
                next();
                if (is_for_body) {
                  croak("functions are not allowed as the body of a loop");
                }
                return function_(AST_Defun, false, true, is_export_default);
              }
              if (S.token.value == "import" && !is_token(peek(), "punc", "(") && !is_token(peek(), "punc", ".")) {
                next();
                var node = import_statement();
                semicolon();
                return node;
              }
              return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();
            case "punc":
              switch (S.token.value) {
                case "{":
                  return new AST_BlockStatement({
                    start: S.token,
                    body: block_(),
                    end: prev()
                  });
                case "[":
                case "(":
                  return simple_statement();
                case ";":
                  S.in_directives = false;
                  next();
                  return new AST_EmptyStatement();
                default:
                  unexpected();
              }
            case "keyword":
              switch (S.token.value) {
                case "break":
                  next();
                  return break_cont(AST_Break);
                case "continue":
                  next();
                  return break_cont(AST_Continue);
                case "debugger":
                  next();
                  semicolon();
                  return new AST_Debugger();
                case "do":
                  next();
                  var body = in_loop(statement2);
                  expect_token("keyword", "while");
                  var condition = parenthesised();
                  semicolon(true);
                  return new AST_Do({
                    body,
                    condition
                  });
                case "while":
                  next();
                  return new AST_While({
                    condition: parenthesised(),
                    body: in_loop(function() {
                      return statement2(false, true);
                    })
                  });
                case "for":
                  next();
                  return for_();
                case "class":
                  next();
                  if (is_for_body) {
                    croak("classes are not allowed as the body of a loop");
                  }
                  if (is_if_body) {
                    croak("classes are not allowed as the body of an if");
                  }
                  return class_(AST_DefClass, is_export_default);
                case "function":
                  next();
                  if (is_for_body) {
                    croak("functions are not allowed as the body of a loop");
                  }
                  return function_(AST_Defun, false, false, is_export_default);
                case "if":
                  next();
                  return if_();
                case "return":
                  if (S.in_function == 0 && !options.bare_returns)
                    croak("'return' outside of function");
                  next();
                  var value2 = null;
                  if (is("punc", ";")) {
                    next();
                  } else if (!can_insert_semicolon()) {
                    value2 = expression(true);
                    semicolon();
                  }
                  return new AST_Return({
                    value: value2
                  });
                case "switch":
                  next();
                  return new AST_Switch({
                    expression: parenthesised(),
                    body: in_loop(switch_body_)
                  });
                case "throw":
                  next();
                  if (has_newline_before(S.token))
                    croak("Illegal newline after 'throw'");
                  var value2 = expression(true);
                  semicolon();
                  return new AST_Throw({
                    value: value2
                  });
                case "try":
                  next();
                  return try_();
                case "var":
                  next();
                  var node = var_();
                  semicolon();
                  return node;
                case "let":
                  next();
                  var node = let_();
                  semicolon();
                  return node;
                case "const":
                  next();
                  var node = const_();
                  semicolon();
                  return node;
                case "with":
                  if (S.input.has_directive("use strict")) {
                    croak("Strict mode may not include a with statement");
                  }
                  next();
                  return new AST_With({
                    expression: parenthesised(),
                    body: statement2()
                  });
                case "export":
                  if (!is_token(peek(), "punc", "(")) {
                    next();
                    var node = export_statement();
                    if (is("punc", ";"))
                      semicolon();
                    return node;
                  }
              }
          }
          unexpected();
        });
        function labeled_statement() {
          var label = as_symbol(AST_Label);
          if (label.name === "await" && is_in_async()) {
            token_error(S.prev, "await cannot be used as label inside async function");
          }
          if (S.labels.some((l) => l.name === label.name)) {
            croak("Label " + label.name + " defined twice");
          }
          expect(":");
          S.labels.push(label);
          var stat = statement();
          S.labels.pop();
          if (!(stat instanceof AST_IterationStatement)) {
            label.references.forEach(function(ref) {
              if (ref instanceof AST_Continue) {
                ref = ref.label.start;
                croak("Continue label `" + label.name + "` refers to non-IterationStatement.", ref.line, ref.col, ref.pos);
              }
            });
          }
          return new AST_LabeledStatement({ body: stat, label });
        }
        function simple_statement(tmp) {
          return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
        }
        function break_cont(type) {
          var label = null, ldef;
          if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
          }
          if (label != null) {
            ldef = S.labels.find((l) => l.name === label.name);
            if (!ldef)
              croak("Undefined label " + label.name);
            label.thedef = ldef;
          } else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
          semicolon();
          var stat = new type({ label });
          if (ldef)
            ldef.references.push(stat);
          return stat;
        }
        function for_() {
          var for_await_error = "`for await` invalid in this context";
          var await_tok = S.token;
          if (await_tok.type == "name" && await_tok.value == "await") {
            if (!can_await()) {
              token_error(await_tok, for_await_error);
            }
            next();
          } else {
            await_tok = false;
          }
          expect("(");
          var init2 = null;
          if (!is("punc", ";")) {
            init2 = is("keyword", "var") ? (next(), var_(true)) : is("keyword", "let") ? (next(), let_(true)) : is("keyword", "const") ? (next(), const_(true)) : expression(true, true);
            var is_in = is("operator", "in");
            var is_of = is("name", "of");
            if (await_tok && !is_of) {
              token_error(await_tok, for_await_error);
            }
            if (is_in || is_of) {
              if (init2 instanceof AST_Definitions) {
                if (init2.definitions.length > 1)
                  token_error(init2.start, "Only one variable declaration allowed in for..in loop");
              } else if (!(is_assignable(init2) || (init2 = to_destructuring(init2)) instanceof AST_Destructuring)) {
                token_error(init2.start, "Invalid left-hand side in for..in loop");
              }
              next();
              if (is_in) {
                return for_in(init2);
              } else {
                return for_of(init2, !!await_tok);
              }
            }
          } else if (await_tok) {
            token_error(await_tok, for_await_error);
          }
          return regular_for(init2);
        }
        function regular_for(init2) {
          expect(";");
          var test = is("punc", ";") ? null : expression(true);
          expect(";");
          var step = is("punc", ")") ? null : expression(true);
          expect(")");
          return new AST_For({
            init: init2,
            condition: test,
            step,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        function for_of(init2, is_await) {
          var lhs = init2 instanceof AST_Definitions ? init2.definitions[0].name : null;
          var obj = expression(true);
          expect(")");
          return new AST_ForOf({
            await: is_await,
            init: init2,
            name: lhs,
            object: obj,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        function for_in(init2) {
          var obj = expression(true);
          expect(")");
          return new AST_ForIn({
            init: init2,
            object: obj,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        var arrow_function = function(start, argnames, is_async) {
          if (has_newline_before(S.token)) {
            croak("Unexpected newline before arrow (=>)");
          }
          expect_token("arrow", "=>");
          var body = _function_body(is("punc", "{"), false, is_async);
          return new AST_Arrow({
            start,
            end: body.end,
            async: is_async,
            argnames,
            body
          });
        };
        var function_ = function(ctor, is_generator, is_async, is_export_default) {
          var in_statement = ctor === AST_Defun;
          if (is("operator", "*")) {
            is_generator = true;
            next();
          }
          var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
          if (in_statement && !name) {
            if (is_export_default) {
              ctor = AST_Function;
            } else {
              unexpected();
            }
          }
          if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))
            unexpected(prev());
          var args = [];
          var body = _function_body(true, is_generator, is_async, name, args);
          return new ctor({
            start: args.start,
            end: body.end,
            is_generator,
            async: is_async,
            name,
            argnames: args,
            body
          });
        };
        class UsedParametersTracker {
          constructor(is_parameter, strict, duplicates_ok = false) {
            this.is_parameter = is_parameter;
            this.duplicates_ok = duplicates_ok;
            this.parameters = /* @__PURE__ */ new Set();
            this.duplicate = null;
            this.default_assignment = false;
            this.spread = false;
            this.strict_mode = !!strict;
          }
          add_parameter(token) {
            if (this.parameters.has(token.value)) {
              if (this.duplicate === null) {
                this.duplicate = token;
              }
              this.check_strict();
            } else {
              this.parameters.add(token.value);
              if (this.is_parameter) {
                switch (token.value) {
                  case "arguments":
                  case "eval":
                  case "yield":
                    if (this.strict_mode) {
                      token_error(token, "Unexpected " + token.value + " identifier as parameter inside strict mode");
                    }
                    break;
                  default:
                    if (RESERVED_WORDS.has(token.value)) {
                      unexpected();
                    }
                }
              }
            }
          }
          mark_default_assignment(token) {
            if (this.default_assignment === false) {
              this.default_assignment = token;
            }
          }
          mark_spread(token) {
            if (this.spread === false) {
              this.spread = token;
            }
          }
          mark_strict_mode() {
            this.strict_mode = true;
          }
          is_strict() {
            return this.default_assignment !== false || this.spread !== false || this.strict_mode;
          }
          check_strict() {
            if (this.is_strict() && this.duplicate !== null && !this.duplicates_ok) {
              token_error(this.duplicate, "Parameter " + this.duplicate.value + " was used already");
            }
          }
        }
        function parameters(params) {
          var used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
          expect("(");
          while (!is("punc", ")")) {
            var param = parameter(used_parameters);
            params.push(param);
            if (!is("punc", ")")) {
              expect(",");
            }
            if (param instanceof AST_Expansion) {
              break;
            }
          }
          next();
        }
        function parameter(used_parameters, symbol_type) {
          var param;
          var expand = false;
          if (used_parameters === void 0) {
            used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
          }
          if (is("expand", "...")) {
            expand = S.token;
            used_parameters.mark_spread(S.token);
            next();
          }
          param = binding_element(used_parameters, symbol_type);
          if (is("operator", "=") && expand === false) {
            used_parameters.mark_default_assignment(S.token);
            next();
            param = new AST_DefaultAssign({
              start: param.start,
              left: param,
              operator: "=",
              right: expression(false),
              end: S.token
            });
          }
          if (expand !== false) {
            if (!is("punc", ")")) {
              unexpected();
            }
            param = new AST_Expansion({
              start: expand,
              expression: param,
              end: expand
            });
          }
          used_parameters.check_strict();
          return param;
        }
        function binding_element(used_parameters, symbol_type) {
          var elements = [];
          var first = true;
          var is_expand = false;
          var expand_token;
          var first_token = S.token;
          if (used_parameters === void 0) {
            const strict = S.input.has_directive("use strict");
            const duplicates_ok = symbol_type === AST_SymbolVar;
            used_parameters = new UsedParametersTracker(false, strict, duplicates_ok);
          }
          symbol_type = symbol_type === void 0 ? AST_SymbolFunarg : symbol_type;
          if (is("punc", "[")) {
            next();
            while (!is("punc", "]")) {
              if (first) {
                first = false;
              } else {
                expect(",");
              }
              if (is("expand", "...")) {
                is_expand = true;
                expand_token = S.token;
                used_parameters.mark_spread(S.token);
                next();
              }
              if (is("punc")) {
                switch (S.token.value) {
                  case ",":
                    elements.push(new AST_Hole({
                      start: S.token,
                      end: S.token
                    }));
                    continue;
                  case "]":
                    break;
                  case "[":
                  case "{":
                    elements.push(binding_element(used_parameters, symbol_type));
                    break;
                  default:
                    unexpected();
                }
              } else if (is("name")) {
                used_parameters.add_parameter(S.token);
                elements.push(as_symbol(symbol_type));
              } else {
                croak("Invalid function parameter");
              }
              if (is("operator", "=") && is_expand === false) {
                used_parameters.mark_default_assignment(S.token);
                next();
                elements[elements.length - 1] = new AST_DefaultAssign({
                  start: elements[elements.length - 1].start,
                  left: elements[elements.length - 1],
                  operator: "=",
                  right: expression(false),
                  end: S.token
                });
              }
              if (is_expand) {
                if (!is("punc", "]")) {
                  croak("Rest element must be last element");
                }
                elements[elements.length - 1] = new AST_Expansion({
                  start: expand_token,
                  expression: elements[elements.length - 1],
                  end: expand_token
                });
              }
            }
            expect("]");
            used_parameters.check_strict();
            return new AST_Destructuring({
              start: first_token,
              names: elements,
              is_array: true,
              end: prev()
            });
          } else if (is("punc", "{")) {
            next();
            while (!is("punc", "}")) {
              if (first) {
                first = false;
              } else {
                expect(",");
              }
              if (is("expand", "...")) {
                is_expand = true;
                expand_token = S.token;
                used_parameters.mark_spread(S.token);
                next();
              }
              if (is("name") && (is_token(peek(), "punc") || is_token(peek(), "operator")) && [",", "}", "="].includes(peek().value)) {
                used_parameters.add_parameter(S.token);
                var start = prev();
                var value2 = as_symbol(symbol_type);
                if (is_expand) {
                  elements.push(new AST_Expansion({
                    start: expand_token,
                    expression: value2,
                    end: value2.end
                  }));
                } else {
                  elements.push(new AST_ObjectKeyVal({
                    start,
                    key: value2.name,
                    value: value2,
                    end: value2.end
                  }));
                }
              } else if (is("punc", "}")) {
                continue;
              } else {
                var property_token = S.token;
                var property = as_property_name();
                if (property === null) {
                  unexpected(prev());
                } else if (prev().type === "name" && !is("punc", ":")) {
                  elements.push(new AST_ObjectKeyVal({
                    start: prev(),
                    key: property,
                    value: new symbol_type({
                      start: prev(),
                      name: property,
                      end: prev()
                    }),
                    end: prev()
                  }));
                } else {
                  expect(":");
                  elements.push(new AST_ObjectKeyVal({
                    start: property_token,
                    quote: property_token.quote,
                    key: property,
                    value: binding_element(used_parameters, symbol_type),
                    end: prev()
                  }));
                }
              }
              if (is_expand) {
                if (!is("punc", "}")) {
                  croak("Rest element must be last element");
                }
              } else if (is("operator", "=")) {
                used_parameters.mark_default_assignment(S.token);
                next();
                elements[elements.length - 1].value = new AST_DefaultAssign({
                  start: elements[elements.length - 1].value.start,
                  left: elements[elements.length - 1].value,
                  operator: "=",
                  right: expression(false),
                  end: S.token
                });
              }
            }
            expect("}");
            used_parameters.check_strict();
            return new AST_Destructuring({
              start: first_token,
              names: elements,
              is_array: false,
              end: prev()
            });
          } else if (is("name")) {
            used_parameters.add_parameter(S.token);
            return as_symbol(symbol_type);
          } else {
            croak("Invalid function parameter");
          }
        }
        function params_or_seq_(allow_arrows, maybe_sequence) {
          var spread_token;
          var invalid_sequence;
          var trailing_comma;
          var a = [];
          expect("(");
          while (!is("punc", ")")) {
            if (spread_token)
              unexpected(spread_token);
            if (is("expand", "...")) {
              spread_token = S.token;
              if (maybe_sequence)
                invalid_sequence = S.token;
              next();
              a.push(new AST_Expansion({
                start: prev(),
                expression: expression(),
                end: S.token
              }));
            } else {
              a.push(expression());
            }
            if (!is("punc", ")")) {
              expect(",");
              if (is("punc", ")")) {
                trailing_comma = prev();
                if (maybe_sequence)
                  invalid_sequence = trailing_comma;
              }
            }
          }
          expect(")");
          if (allow_arrows && is("arrow", "=>")) {
            if (spread_token && trailing_comma)
              unexpected(trailing_comma);
          } else if (invalid_sequence) {
            unexpected(invalid_sequence);
          }
          return a;
        }
        function _function_body(block, generator, is_async, name, args) {
          var loop = S.in_loop;
          var labels = S.labels;
          var current_generator = S.in_generator;
          var current_async = S.in_async;
          ++S.in_function;
          if (generator)
            S.in_generator = S.in_function;
          if (is_async)
            S.in_async = S.in_function;
          if (args)
            parameters(args);
          if (block)
            S.in_directives = true;
          S.in_loop = 0;
          S.labels = [];
          if (block) {
            S.input.push_directives_stack();
            var a = block_();
            if (name)
              _verify_symbol(name);
            if (args)
              args.forEach(_verify_symbol);
            S.input.pop_directives_stack();
          } else {
            var a = [new AST_Return({
              start: S.token,
              value: expression(false),
              end: S.token
            })];
          }
          --S.in_function;
          S.in_loop = loop;
          S.labels = labels;
          S.in_generator = current_generator;
          S.in_async = current_async;
          return a;
        }
        function _await_expression() {
          if (!can_await()) {
            croak("Unexpected await expression outside async function", S.prev.line, S.prev.col, S.prev.pos);
          }
          return new AST_Await({
            start: prev(),
            end: S.token,
            expression: maybe_unary(true)
          });
        }
        function _yield_expression() {
          var start = S.token;
          var star = false;
          var has_expression = true;
          if (can_insert_semicolon() || is("punc") && PUNC_AFTER_EXPRESSION.has(S.token.value) || is("template_cont")) {
            has_expression = false;
          } else if (is("operator", "*")) {
            star = true;
            next();
          }
          return new AST_Yield({
            start,
            is_star: star,
            expression: has_expression ? expression() : null,
            end: prev()
          });
        }
        function if_() {
          var cond = parenthesised(), body = statement(false, false, true), belse = null;
          if (is("keyword", "else")) {
            next();
            belse = statement(false, false, true);
          }
          return new AST_If({
            condition: cond,
            body,
            alternative: belse
          });
        }
        function block_() {
          expect("{");
          var a = [];
          while (!is("punc", "}")) {
            if (is("eof"))
              unexpected();
            a.push(statement());
          }
          next();
          return a;
        }
        function switch_body_() {
          expect("{");
          var a = [], cur = null, branch = null, tmp;
          while (!is("punc", "}")) {
            if (is("eof"))
              unexpected();
            if (is("keyword", "case")) {
              if (branch)
                branch.end = prev();
              cur = [];
              branch = new AST_Case({
                start: (tmp = S.token, next(), tmp),
                expression: expression(true),
                body: cur
              });
              a.push(branch);
              expect(":");
            } else if (is("keyword", "default")) {
              if (branch)
                branch.end = prev();
              cur = [];
              branch = new AST_Default({
                start: (tmp = S.token, next(), expect(":"), tmp),
                body: cur
              });
              a.push(branch);
            } else {
              if (!cur)
                unexpected();
              cur.push(statement());
            }
          }
          if (branch)
            branch.end = prev();
          next();
          return a;
        }
        function try_() {
          var body, bcatch = null, bfinally = null;
          body = new AST_TryBlock({
            start: S.token,
            body: block_(),
            end: prev()
          });
          if (is("keyword", "catch")) {
            var start = S.token;
            next();
            if (is("punc", "{")) {
              var name = null;
            } else {
              expect("(");
              var name = parameter(void 0, AST_SymbolCatch);
              expect(")");
            }
            bcatch = new AST_Catch({
              start,
              argname: name,
              body: block_(),
              end: prev()
            });
          }
          if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
              start,
              body: block_(),
              end: prev()
            });
          }
          if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
          return new AST_Try({
            body,
            bcatch,
            bfinally
          });
        }
        function vardefs(no_in, kind) {
          var var_defs = [];
          var def;
          for (; ; ) {
            var sym_type = kind === "var" ? AST_SymbolVar : kind === "const" ? AST_SymbolConst : kind === "let" ? AST_SymbolLet : null;
            if (is("punc", "{") || is("punc", "[")) {
              def = new AST_VarDef({
                start: S.token,
                name: binding_element(void 0, sym_type),
                value: is("operator", "=") ? (expect_token("operator", "="), expression(false, no_in)) : null,
                end: prev()
              });
            } else {
              def = new AST_VarDef({
                start: S.token,
                name: as_symbol(sym_type),
                value: is("operator", "=") ? (next(), expression(false, no_in)) : !no_in && kind === "const" ? croak("Missing initializer in const declaration") : null,
                end: prev()
              });
              if (def.name.name == "import")
                croak("Unexpected token: import");
            }
            var_defs.push(def);
            if (!is("punc", ","))
              break;
            next();
          }
          return var_defs;
        }
        var var_ = function(no_in) {
          return new AST_Var({
            start: prev(),
            definitions: vardefs(no_in, "var"),
            end: prev()
          });
        };
        var let_ = function(no_in) {
          return new AST_Let({
            start: prev(),
            definitions: vardefs(no_in, "let"),
            end: prev()
          });
        };
        var const_ = function(no_in) {
          return new AST_Const({
            start: prev(),
            definitions: vardefs(no_in, "const"),
            end: prev()
          });
        };
        var new_ = function(allow_calls) {
          var start = S.token;
          expect_token("operator", "new");
          if (is("punc", ".")) {
            next();
            expect_token("name", "target");
            return subscripts(new AST_NewTarget({
              start,
              end: prev()
            }), allow_calls);
          }
          var newexp = expr_atom(false), args;
          if (is("punc", "(")) {
            next();
            args = expr_list(")", true);
          } else {
            args = [];
          }
          var call = new AST_New({
            start,
            expression: newexp,
            args,
            end: prev()
          });
          annotate(call);
          return subscripts(call, allow_calls);
        };
        function as_atom_node() {
          var tok = S.token, ret;
          switch (tok.type) {
            case "name":
              ret = _make_symbol(AST_SymbolRef);
              break;
            case "num":
              ret = new AST_Number({
                start: tok,
                end: tok,
                value: tok.value,
                raw: LATEST_RAW
              });
              break;
            case "big_int":
              ret = new AST_BigInt({
                start: tok,
                end: tok,
                value: tok.value,
                raw: LATEST_RAW
              });
              break;
            case "string":
              ret = new AST_String({
                start: tok,
                end: tok,
                value: tok.value,
                quote: tok.quote
              });
              annotate(ret);
              break;
            case "regexp":
              const [_, source, flags] = tok.value.match(/^\/(.*)\/(\w*)$/);
              ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });
              break;
            case "atom":
              switch (tok.value) {
                case "false":
                  ret = new AST_False({ start: tok, end: tok });
                  break;
                case "true":
                  ret = new AST_True({ start: tok, end: tok });
                  break;
                case "null":
                  ret = new AST_Null({ start: tok, end: tok });
                  break;
              }
              break;
          }
          next();
          return ret;
        }
        function to_fun_args(ex, default_seen_above) {
          var insert_default = function(ex2, default_value) {
            if (default_value) {
              return new AST_DefaultAssign({
                start: ex2.start,
                left: ex2,
                operator: "=",
                right: default_value,
                end: default_value.end
              });
            }
            return ex2;
          };
          if (ex instanceof AST_Object) {
            return insert_default(new AST_Destructuring({
              start: ex.start,
              end: ex.end,
              is_array: false,
              names: ex.properties.map((prop) => to_fun_args(prop))
            }), default_seen_above);
          } else if (ex instanceof AST_ObjectKeyVal) {
            ex.value = to_fun_args(ex.value);
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_Hole) {
            return ex;
          } else if (ex instanceof AST_Destructuring) {
            ex.names = ex.names.map((name) => to_fun_args(name));
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_SymbolRef) {
            return insert_default(new AST_SymbolFunarg({
              name: ex.name,
              start: ex.start,
              end: ex.end
            }), default_seen_above);
          } else if (ex instanceof AST_Expansion) {
            ex.expression = to_fun_args(ex.expression);
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_Array) {
            return insert_default(new AST_Destructuring({
              start: ex.start,
              end: ex.end,
              is_array: true,
              names: ex.elements.map((elm) => to_fun_args(elm))
            }), default_seen_above);
          } else if (ex instanceof AST_Assign) {
            return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);
          } else if (ex instanceof AST_DefaultAssign) {
            ex.left = to_fun_args(ex.left);
            return ex;
          } else {
            croak("Invalid function parameter", ex.start.line, ex.start.col);
          }
        }
        var expr_atom = function(allow_calls, allow_arrows) {
          if (is("operator", "new")) {
            return new_(allow_calls);
          }
          if (is("name", "import") && is_token(peek(), "punc", ".")) {
            return import_meta(allow_calls);
          }
          var start = S.token;
          var peeked;
          var async = is("name", "async") && (peeked = peek()).value != "[" && peeked.type != "arrow" && as_atom_node();
          if (is("punc")) {
            switch (S.token.value) {
              case "(":
                if (async && !allow_calls)
                  break;
                var exprs = params_or_seq_(allow_arrows, !async);
                if (allow_arrows && is("arrow", "=>")) {
                  return arrow_function(start, exprs.map((e) => to_fun_args(e)), !!async);
                }
                var ex = async ? new AST_Call({
                  expression: async,
                  args: exprs
                }) : to_expr_or_sequence(start, exprs);
                if (ex.start) {
                  const outer_comments_before = start.comments_before.length;
                  outer_comments_before_counts.set(start, outer_comments_before);
                  ex.start.comments_before.unshift(...start.comments_before);
                  start.comments_before = ex.start.comments_before;
                  if (outer_comments_before == 0 && start.comments_before.length > 0) {
                    var comment = start.comments_before[0];
                    if (!comment.nlb) {
                      comment.nlb = start.nlb;
                      start.nlb = false;
                    }
                  }
                  start.comments_after = ex.start.comments_after;
                }
                ex.start = start;
                var end = prev();
                if (ex.end) {
                  end.comments_before = ex.end.comments_before;
                  ex.end.comments_after.push(...end.comments_after);
                  end.comments_after = ex.end.comments_after;
                }
                ex.end = end;
                if (ex instanceof AST_Call)
                  annotate(ex);
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_or_destructuring_(), allow_calls);
            }
            if (!async)
              unexpected();
          }
          if (allow_arrows && is("name") && is_token(peek(), "arrow")) {
            var param = new AST_SymbolFunarg({
              name: S.token.value,
              start,
              end: start
            });
            next();
            return arrow_function(start, [param], !!async);
          }
          if (is("keyword", "function")) {
            next();
            var func = function_(AST_Function, false, !!async);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
          }
          if (async)
            return subscripts(async, allow_calls);
          if (is("keyword", "class")) {
            next();
            var cls = class_(AST_ClassExpression);
            cls.start = start;
            cls.end = prev();
            return subscripts(cls, allow_calls);
          }
          if (is("template_head")) {
            return subscripts(template_string(), allow_calls);
          }
          if (ATOMIC_START_TOKEN.has(S.token.type)) {
            return subscripts(as_atom_node(), allow_calls);
          }
          unexpected();
        };
        function template_string() {
          var segments = [], start = S.token;
          segments.push(new AST_TemplateSegment({
            start: S.token,
            raw: TEMPLATE_RAWS.get(S.token),
            value: S.token.value,
            end: S.token
          }));
          while (!S.token.template_end) {
            next();
            handle_regexp();
            segments.push(expression(true));
            segments.push(new AST_TemplateSegment({
              start: S.token,
              raw: TEMPLATE_RAWS.get(S.token),
              value: S.token.value,
              end: S.token
            }));
          }
          next();
          return new AST_TemplateString({
            start,
            segments,
            end: S.token
          });
        }
        function expr_list(closing, allow_trailing_comma, allow_empty) {
          var first = true, a = [];
          while (!is("punc", closing)) {
            if (first)
              first = false;
            else
              expect(",");
            if (allow_trailing_comma && is("punc", closing))
              break;
            if (is("punc", ",") && allow_empty) {
              a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else if (is("expand", "...")) {
              next();
              a.push(new AST_Expansion({ start: prev(), expression: expression(), end: S.token }));
            } else {
              a.push(expression(false));
            }
          }
          next();
          return a;
        }
        var array_ = embed_tokens(function() {
          expect("[");
          return new AST_Array({
            elements: expr_list("]", !options.strict, true)
          });
        });
        var create_accessor = embed_tokens((is_generator, is_async) => {
          return function_(AST_Accessor, is_generator, is_async);
        });
        var object_or_destructuring_ = embed_tokens(function object_or_destructuring_2() {
          var start = S.token, first = true, a = [];
          expect("{");
          while (!is("punc", "}")) {
            if (first)
              first = false;
            else
              expect(",");
            if (!options.strict && is("punc", "}"))
              break;
            start = S.token;
            if (start.type == "expand") {
              next();
              a.push(new AST_Expansion({
                start,
                expression: expression(false),
                end: prev()
              }));
              continue;
            }
            if (is("privatename")) {
              croak("private fields are not allowed in an object");
            }
            var name = as_property_name();
            var value2;
            if (!is("punc", ":")) {
              var concise = object_or_class_property(name, start);
              if (concise) {
                a.push(concise);
                continue;
              }
              value2 = new AST_SymbolRef({
                start: prev(),
                name,
                end: prev()
              });
            } else if (name === null) {
              unexpected(prev());
            } else {
              next();
              value2 = expression(false);
            }
            if (is("operator", "=")) {
              next();
              value2 = new AST_Assign({
                start,
                left: value2,
                operator: "=",
                right: expression(false),
                logical: false,
                end: prev()
              });
            }
            const kv = new AST_ObjectKeyVal({
              start,
              quote: start.quote,
              key: name,
              value: value2,
              end: prev()
            });
            a.push(annotate(kv));
          }
          next();
          return new AST_Object({ properties: a });
        });
        function class_(KindOfClass, is_export_default) {
          var start, method, class_name, extends_, properties = [];
          S.input.push_directives_stack();
          S.input.add_directive("use strict");
          if (S.token.type == "name" && S.token.value != "extends") {
            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);
          }
          if (KindOfClass === AST_DefClass && !class_name) {
            if (is_export_default) {
              KindOfClass = AST_ClassExpression;
            } else {
              unexpected();
            }
          }
          if (S.token.value == "extends") {
            next();
            extends_ = expression(true);
          }
          expect("{");
          const save_in_class = S.in_class;
          S.in_class = true;
          while (is("punc", ";")) {
            next();
          }
          while (!is("punc", "}")) {
            start = S.token;
            method = object_or_class_property(as_property_name(), start, true);
            if (!method) {
              unexpected();
            }
            properties.push(method);
            while (is("punc", ";")) {
              next();
            }
          }
          S.in_class = save_in_class;
          S.input.pop_directives_stack();
          next();
          return new KindOfClass({
            start,
            name: class_name,
            extends: extends_,
            properties,
            end: prev()
          });
        }
        function object_or_class_property(name, start, is_class) {
          const get_symbol_ast = (name2, SymbolClass) => {
            if (typeof name2 === "string") {
              return new SymbolClass({ start, name: name2, end: prev() });
            } else if (name2 === null) {
              unexpected();
            }
            return name2;
          };
          const is_not_method_start = () => !is("punc", "(") && !is("punc", ",") && !is("punc", "}") && !is("punc", ";") && !is("operator", "=");
          var is_async = false;
          var is_static = false;
          var is_generator = false;
          var is_private = false;
          var accessor_type = null;
          if (is_class && name === "static" && is_not_method_start()) {
            const static_block = class_static_block();
            if (static_block != null) {
              return static_block;
            }
            is_static = true;
            name = as_property_name();
          }
          if (name === "async" && is_not_method_start()) {
            is_async = true;
            name = as_property_name();
          }
          if (prev().type === "operator" && prev().value === "*") {
            is_generator = true;
            name = as_property_name();
          }
          if ((name === "get" || name === "set") && is_not_method_start()) {
            accessor_type = name;
            name = as_property_name();
          }
          if (prev().type === "privatename") {
            is_private = true;
          }
          const property_token = prev();
          if (accessor_type != null) {
            if (!is_private) {
              const AccessorClass = accessor_type === "get" ? AST_ObjectGetter : AST_ObjectSetter;
              name = get_symbol_ast(name, AST_SymbolMethod);
              return annotate(new AccessorClass({
                start,
                static: is_static,
                key: name,
                quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
                value: create_accessor(),
                end: prev()
              }));
            } else {
              const AccessorClass = accessor_type === "get" ? AST_PrivateGetter : AST_PrivateSetter;
              return annotate(new AccessorClass({
                start,
                static: is_static,
                key: get_symbol_ast(name, AST_SymbolMethod),
                value: create_accessor(),
                end: prev()
              }));
            }
          }
          if (is("punc", "(")) {
            name = get_symbol_ast(name, AST_SymbolMethod);
            const AST_MethodVariant = is_private ? AST_PrivateMethod : AST_ConciseMethod;
            var node = new AST_MethodVariant({
              start,
              static: is_static,
              key: name,
              quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
              value: create_accessor(is_generator, is_async),
              end: prev()
            });
            return annotate(node);
          }
          if (is_class) {
            const AST_SymbolVariant = is_private ? AST_SymbolPrivateProperty : AST_SymbolClassProperty;
            const AST_ClassPropertyVariant = is_private ? AST_ClassPrivateProperty : AST_ClassProperty;
            const key = get_symbol_ast(name, AST_SymbolVariant);
            const quote = key instanceof AST_SymbolClassProperty ? property_token.quote : void 0;
            if (is("operator", "=")) {
              next();
              return annotate(new AST_ClassPropertyVariant({
                start,
                static: is_static,
                quote,
                key,
                value: expression(false),
                end: prev()
              }));
            } else if (is("name") || is("privatename") || is("punc", "[") || is("operator", "*") || is("punc", ";") || is("punc", "}") || is("string") || is("num") || is("big_int")) {
              return annotate(new AST_ClassPropertyVariant({
                start,
                static: is_static,
                quote,
                key,
                end: prev()
              }));
            }
          }
        }
        function class_static_block() {
          if (!is("punc", "{")) {
            return null;
          }
          const start = S.token;
          const body = [];
          next();
          while (!is("punc", "}")) {
            body.push(statement());
          }
          next();
          return new AST_ClassStaticBlock({ start, body, end: prev() });
        }
        function maybe_import_attributes() {
          if ((is("keyword", "with") || is("name", "assert")) && !has_newline_before(S.token)) {
            next();
            return object_or_destructuring_();
          }
          return null;
        }
        function import_statement() {
          var start = prev();
          var imported_name;
          var imported_names;
          if (is("name")) {
            imported_name = as_symbol(AST_SymbolImport);
          }
          if (is("punc", ",")) {
            next();
          }
          imported_names = map_names(true);
          if (imported_names || imported_name) {
            expect_token("name", "from");
          }
          var mod_str = S.token;
          if (mod_str.type !== "string") {
            unexpected();
          }
          next();
          const attributes = maybe_import_attributes();
          return new AST_Import({
            start,
            imported_name,
            imported_names,
            module_name: new AST_String({
              start: mod_str,
              value: mod_str.value,
              quote: mod_str.quote,
              end: mod_str
            }),
            attributes,
            end: S.token
          });
        }
        function import_meta(allow_calls) {
          var start = S.token;
          expect_token("name", "import");
          expect_token("punc", ".");
          expect_token("name", "meta");
          return subscripts(new AST_ImportMeta({
            start,
            end: prev()
          }), allow_calls);
        }
        function map_name(is_import) {
          function make_symbol(type2, quote) {
            return new type2({
              name: as_property_name(),
              quote: quote || void 0,
              start: prev(),
              end: prev()
            });
          }
          var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
          var type = is_import ? AST_SymbolImport : AST_SymbolExport;
          var start = S.token;
          var foreign_name;
          var name;
          if (is_import) {
            foreign_name = make_symbol(foreign_type, start.quote);
          } else {
            name = make_symbol(type, start.quote);
          }
          if (is("name", "as")) {
            next();
            if (is_import) {
              name = make_symbol(type);
            } else {
              foreign_name = make_symbol(foreign_type, S.token.quote);
            }
          } else {
            if (is_import) {
              name = new type(foreign_name);
            } else {
              foreign_name = new foreign_type(name);
            }
          }
          return new AST_NameMapping({
            start,
            foreign_name,
            name,
            end: prev()
          });
        }
        function map_nameAsterisk(is_import, import_or_export_foreign_name) {
          var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
          var type = is_import ? AST_SymbolImport : AST_SymbolExport;
          var start = S.token;
          var name, foreign_name;
          var end = prev();
          if (is_import) {
            name = import_or_export_foreign_name;
          } else {
            foreign_name = import_or_export_foreign_name;
          }
          name = name || new type({
            start,
            name: "*",
            end
          });
          foreign_name = foreign_name || new foreign_type({
            start,
            name: "*",
            end
          });
          return new AST_NameMapping({
            start,
            foreign_name,
            name,
            end
          });
        }
        function map_names(is_import) {
          var names;
          if (is("punc", "{")) {
            next();
            names = [];
            while (!is("punc", "}")) {
              names.push(map_name(is_import));
              if (is("punc", ",")) {
                next();
              }
            }
            next();
          } else if (is("operator", "*")) {
            var name;
            next();
            if (is("name", "as")) {
              next();
              name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);
            }
            names = [map_nameAsterisk(is_import, name)];
          }
          return names;
        }
        function export_statement() {
          var start = S.token;
          var is_default;
          var exported_names;
          if (is("keyword", "default")) {
            is_default = true;
            next();
          } else if (exported_names = map_names(false)) {
            if (is("name", "from")) {
              next();
              var mod_str = S.token;
              if (mod_str.type !== "string") {
                unexpected();
              }
              next();
              const attributes = maybe_import_attributes();
              return new AST_Export({
                start,
                is_default,
                exported_names,
                module_name: new AST_String({
                  start: mod_str,
                  value: mod_str.value,
                  quote: mod_str.quote,
                  end: mod_str
                }),
                end: prev(),
                attributes
              });
            } else {
              return new AST_Export({
                start,
                is_default,
                exported_names,
                end: prev()
              });
            }
          }
          var node;
          var exported_value;
          var exported_definition;
          if (is("punc", "{") || is_default && (is("keyword", "class") || is("keyword", "function")) && is_token(peek(), "punc")) {
            exported_value = expression(false);
            semicolon();
          } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {
            unexpected(node.start);
          } else if (node instanceof AST_Definitions || node instanceof AST_Defun || node instanceof AST_DefClass) {
            exported_definition = node;
          } else if (node instanceof AST_ClassExpression || node instanceof AST_Function) {
            exported_value = node;
          } else if (node instanceof AST_SimpleStatement) {
            exported_value = node.body;
          } else {
            unexpected(node.start);
          }
          return new AST_Export({
            start,
            is_default,
            exported_value,
            exported_definition,
            end: prev(),
            attributes: null
          });
        }
        function as_property_name() {
          var tmp = S.token;
          switch (tmp.type) {
            case "punc":
              if (tmp.value === "[") {
                next();
                var ex = expression(false);
                expect("]");
                return ex;
              } else
                unexpected(tmp);
            case "operator":
              if (tmp.value === "*") {
                next();
                return null;
              }
              if (!["delete", "in", "instanceof", "new", "typeof", "void"].includes(tmp.value)) {
                unexpected(tmp);
              }
            case "name":
            case "privatename":
            case "string":
            case "keyword":
            case "atom":
              next();
              return tmp.value;
            case "num":
            case "big_int":
              next();
              return "" + tmp.value;
            default:
              unexpected(tmp);
          }
        }
        function as_name() {
          var tmp = S.token;
          if (tmp.type != "name" && tmp.type != "privatename")
            unexpected();
          next();
          return tmp.value;
        }
        function _make_symbol(type) {
          var name = S.token.value;
          return new (name == "this" ? AST_This : name == "super" ? AST_Super : type)({
            name: String(name),
            start: S.token,
            end: S.token
          });
        }
        function _verify_symbol(sym) {
          var name = sym.name;
          if (is_in_generator() && name == "yield") {
            token_error(sym.start, "Yield cannot be used as identifier inside generators");
          }
          if (S.input.has_directive("use strict")) {
            if (name == "yield") {
              token_error(sym.start, "Unexpected yield identifier inside strict mode");
            }
            if (sym instanceof AST_SymbolDeclaration && (name == "arguments" || name == "eval")) {
              token_error(sym.start, "Unexpected " + name + " in strict mode");
            }
          }
        }
        function as_symbol(type, noerror) {
          if (!is("name")) {
            if (!noerror)
              croak("Name expected");
            return null;
          }
          var sym = _make_symbol(type);
          _verify_symbol(sym);
          next();
          return sym;
        }
        function as_symbol_or_string(type) {
          if (!is("name")) {
            if (!is("string")) {
              croak("Name or string expected");
            }
            var tok = S.token;
            var ret = new type({
              start: tok,
              end: tok,
              name: tok.value,
              quote: tok.quote
            });
            next();
            return ret;
          }
          var sym = _make_symbol(type);
          _verify_symbol(sym);
          next();
          return sym;
        }
        function annotate(node, before_token = node.start) {
          var comments = before_token.comments_before;
          const comments_outside_parens = outer_comments_before_counts.get(before_token);
          var i = comments_outside_parens != null ? comments_outside_parens : comments.length;
          while (--i >= 0) {
            var comment = comments[i];
            if (/[@#]__/.test(comment.value)) {
              if (/[@#]__PURE__/.test(comment.value)) {
                set_annotation(node, _PURE);
                break;
              }
              if (/[@#]__INLINE__/.test(comment.value)) {
                set_annotation(node, _INLINE);
                break;
              }
              if (/[@#]__NOINLINE__/.test(comment.value)) {
                set_annotation(node, _NOINLINE);
                break;
              }
              if (/[@#]__KEY__/.test(comment.value)) {
                set_annotation(node, _KEY);
                break;
              }
              if (/[@#]__MANGLE_PROP__/.test(comment.value)) {
                set_annotation(node, _MANGLEPROP);
                break;
              }
            }
          }
          return node;
        }
        var subscripts = function(expr, allow_calls, is_chain) {
          var start = expr.start;
          if (is("punc", ".")) {
            next();
            if (is("privatename") && !S.in_class)
              croak("Private field must be used in an enclosing class");
            const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
            return annotate(subscripts(new AST_DotVariant({
              start,
              expression: expr,
              optional: false,
              property: as_name(),
              end: prev()
            }), allow_calls, is_chain));
          }
          if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return annotate(subscripts(new AST_Sub({
              start,
              expression: expr,
              optional: false,
              property: prop,
              end: prev()
            }), allow_calls, is_chain));
          }
          if (allow_calls && is("punc", "(")) {
            next();
            var call = new AST_Call({
              start,
              expression: expr,
              optional: false,
              args: call_args(),
              end: prev()
            });
            annotate(call);
            return subscripts(call, true, is_chain);
          }
          if (is("punc", "?.")) {
            next();
            let chain_contents;
            if (allow_calls && is("punc", "(")) {
              next();
              const call2 = new AST_Call({
                start,
                optional: true,
                expression: expr,
                args: call_args(),
                end: prev()
              });
              annotate(call2);
              chain_contents = subscripts(call2, true, true);
            } else if (is("name") || is("privatename")) {
              if (is("privatename") && !S.in_class)
                croak("Private field must be used in an enclosing class");
              const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
              chain_contents = annotate(subscripts(new AST_DotVariant({
                start,
                expression: expr,
                optional: true,
                property: as_name(),
                end: prev()
              }), allow_calls, true));
            } else if (is("punc", "[")) {
              next();
              const property = expression(true);
              expect("]");
              chain_contents = annotate(subscripts(new AST_Sub({
                start,
                expression: expr,
                optional: true,
                property,
                end: prev()
              }), allow_calls, true));
            }
            if (!chain_contents)
              unexpected();
            if (chain_contents instanceof AST_Chain)
              return chain_contents;
            return new AST_Chain({
              start,
              expression: chain_contents,
              end: prev()
            });
          }
          if (is("template_head")) {
            if (is_chain) {
              unexpected();
            }
            return subscripts(new AST_PrefixedTemplateString({
              start,
              prefix: expr,
              template_string: template_string(),
              end: prev()
            }), allow_calls);
          }
          return expr;
        };
        function call_args() {
          var args = [];
          while (!is("punc", ")")) {
            if (is("expand", "...")) {
              next();
              args.push(new AST_Expansion({
                start: prev(),
                expression: expression(false),
                end: prev()
              }));
            } else {
              args.push(expression(false));
            }
            if (!is("punc", ")")) {
              expect(",");
            }
          }
          next();
          return args;
        }
        var maybe_unary = function(allow_calls, allow_arrows) {
          var start = S.token;
          if (start.type == "name" && start.value == "await" && can_await()) {
            next();
            return _await_expression();
          }
          if (is("operator") && UNARY_PREFIX.has(start.value)) {
            next();
            handle_regexp();
            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
          }
          var val = expr_atom(allow_calls, allow_arrows);
          while (is("operator") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {
            if (val instanceof AST_Arrow)
              unexpected();
            val = make_unary(AST_UnaryPostfix, S.token, val);
            val.start = start;
            val.end = S.token;
            next();
          }
          return val;
        };
        function make_unary(ctor, token, expr) {
          var op = token.value;
          switch (op) {
            case "++":
            case "--":
              if (!is_assignable(expr))
                croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
              break;
            case "delete":
              if (expr instanceof AST_SymbolRef && S.input.has_directive("use strict"))
                croak("Calling delete on expression not allowed in strict mode", expr.start.line, expr.start.col, expr.start.pos);
              break;
          }
          return new ctor({ operator: op, expression: expr });
        }
        var expr_op = function(left, min_prec, no_in) {
          var op = is("operator") ? S.token.value : null;
          if (op == "in" && no_in)
            op = null;
          if (op == "**" && left instanceof AST_UnaryPrefix && !is_token(left.start, "punc", "(") && left.operator !== "--" && left.operator !== "++")
            unexpected(left.start);
          var prec = op != null ? PRECEDENCE[op] : null;
          if (prec != null && (prec > min_prec || op === "**" && min_prec === prec)) {
            next();
            var right = expr_ops(no_in, prec, true);
            return expr_op(new AST_Binary({
              start: left.start,
              left,
              operator: op,
              right,
              end: right.end
            }), min_prec, no_in);
          }
          return left;
        };
        function expr_ops(no_in, min_prec, allow_calls, allow_arrows) {
          if (!no_in && min_prec < PRECEDENCE["in"] && is("privatename")) {
            if (!S.in_class) {
              croak("Private field must be used in an enclosing class");
            }
            const start = S.token;
            const key = new AST_SymbolPrivateProperty({
              start,
              name: start.value,
              end: start
            });
            next();
            expect_token("operator", "in");
            const private_in = new AST_PrivateIn({
              start,
              key,
              value: expr_ops(no_in, PRECEDENCE["in"], true),
              end: prev()
            });
            return expr_op(private_in, 0, no_in);
          } else {
            return expr_op(maybe_unary(allow_calls, allow_arrows), min_prec, no_in);
          }
        }
        var maybe_conditional = function(no_in) {
          var start = S.token;
          var expr = expr_ops(no_in, 0, true, true);
          if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
              start,
              condition: expr,
              consequent: yes,
              alternative: expression(false, no_in),
              end: prev()
            });
          }
          return expr;
        };
        function is_assignable(expr) {
          return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
        }
        function to_destructuring(node) {
          if (node instanceof AST_Object) {
            node = new AST_Destructuring({
              start: node.start,
              names: node.properties.map(to_destructuring),
              is_array: false,
              end: node.end
            });
          } else if (node instanceof AST_Array) {
            var names = [];
            for (var i = 0; i < node.elements.length; i++) {
              if (node.elements[i] instanceof AST_Expansion) {
                if (i + 1 !== node.elements.length) {
                  token_error(node.elements[i].start, "Spread must the be last element in destructuring array");
                }
                node.elements[i].expression = to_destructuring(node.elements[i].expression);
              }
              names.push(to_destructuring(node.elements[i]));
            }
            node = new AST_Destructuring({
              start: node.start,
              names,
              is_array: true,
              end: node.end
            });
          } else if (node instanceof AST_ObjectProperty) {
            node.value = to_destructuring(node.value);
          } else if (node instanceof AST_Assign) {
            node = new AST_DefaultAssign({
              start: node.start,
              left: node.left,
              operator: "=",
              right: node.right,
              end: node.end
            });
          }
          return node;
        }
        var maybe_assign = function(no_in) {
          handle_regexp();
          var start = S.token;
          if (start.type == "name" && start.value == "yield") {
            if (is_in_generator()) {
              next();
              return _yield_expression();
            } else if (S.input.has_directive("use strict")) {
              token_error(S.token, "Unexpected yield identifier inside strict mode");
            }
          }
          var left = maybe_conditional(no_in);
          var val = S.token.value;
          if (is("operator") && ASSIGNMENT.has(val)) {
            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {
              next();
              return new AST_Assign({
                start,
                left,
                operator: val,
                right: maybe_assign(no_in),
                logical: LOGICAL_ASSIGNMENT.has(val),
                end: prev()
              });
            }
            croak("Invalid assignment");
          }
          return left;
        };
        var to_expr_or_sequence = function(start, exprs) {
          if (exprs.length === 1) {
            return exprs[0];
          } else if (exprs.length > 1) {
            return new AST_Sequence({ start, expressions: exprs, end: peek() });
          } else {
            croak("Invalid parenthesized expression");
          }
        };
        var expression = function(commas, no_in) {
          var start = S.token;
          var exprs = [];
          while (true) {
            exprs.push(maybe_assign(no_in));
            if (!commas || !is("punc", ","))
              break;
            next();
            commas = true;
          }
          return to_expr_or_sequence(start, exprs);
        };
        function in_loop(cont) {
          ++S.in_loop;
          var ret = cont();
          --S.in_loop;
          return ret;
        }
        if (options.expression) {
          return expression(true);
        }
        return function parse_toplevel() {
          var start = S.token;
          var body = [];
          S.input.push_directives_stack();
          if (options.module)
            S.input.add_directive("use strict");
          while (!is("eof")) {
            body.push(statement());
          }
          S.input.pop_directives_stack();
          var end = prev();
          var toplevel = options.toplevel;
          if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
          } else {
            toplevel = new AST_Toplevel({ start, body, end });
          }
          TEMPLATE_RAWS = /* @__PURE__ */ new Map();
          return toplevel;
        }();
      }
      function DEFNODE(type, props, ctor, methods, base = AST_Node) {
        if (!props)
          props = [];
        else
          props = props.split(/\s+/);
        var self_props = props;
        if (base && base.PROPS)
          props = props.concat(base.PROPS);
        const proto = base && Object.create(base.prototype);
        if (proto) {
          ctor.prototype = proto;
          ctor.BASE = base;
        }
        if (base)
          base.SUBCLASSES.push(ctor);
        ctor.prototype.CTOR = ctor;
        ctor.prototype.constructor = ctor;
        ctor.PROPS = props || null;
        ctor.SELF_PROPS = self_props;
        ctor.SUBCLASSES = [];
        if (type) {
          ctor.prototype.TYPE = ctor.TYPE = type;
        }
        if (methods) {
          for (let i in methods)
            if (HOP(methods, i)) {
              if (i[0] === "$") {
                ctor[i.substr(1)] = methods[i];
              } else {
                ctor.prototype[i] = methods[i];
              }
            }
        }
        ctor.DEFMETHOD = function(name, method) {
          this.prototype[name] = method;
        };
        return ctor;
      }
      const has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);
      const set_tok_flag = (tok, flag, truth) => {
        if (truth) {
          tok.flags |= flag;
        } else {
          tok.flags &= ~flag;
        }
      };
      const TOK_FLAG_NLB = 1;
      const TOK_FLAG_QUOTE_SINGLE = 2;
      const TOK_FLAG_QUOTE_EXISTS = 4;
      const TOK_FLAG_TEMPLATE_END = 8;
      class AST_Token {
        constructor(type, value2, line, col, pos2, nlb, comments_before, comments_after, file) {
          this.flags = nlb ? 1 : 0;
          this.type = type;
          this.value = value2;
          this.line = line;
          this.col = col;
          this.pos = pos2;
          this.comments_before = comments_before;
          this.comments_after = comments_after;
          this.file = file;
          Object.seal(this);
        }
        [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
          const special = (str) => options.stylize(str, "special");
          const quote = typeof this.value === "string" && this.value.includes("`") ? "'" : "`";
          const value2 = `${quote}${this.value}${quote}`;
          return `${special("[AST_Token")} ${value2} at ${this.line}:${this.col}${special("]")}`;
        }
        get nlb() {
          return has_tok_flag(this, TOK_FLAG_NLB);
        }
        set nlb(new_nlb) {
          set_tok_flag(this, TOK_FLAG_NLB, new_nlb);
        }
        get quote() {
          return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS) ? "" : has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? "'" : '"';
        }
        set quote(quote_type) {
          set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === "'");
          set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);
        }
        get template_end() {
          return has_tok_flag(this, TOK_FLAG_TEMPLATE_END);
        }
        set template_end(new_template_end) {
          set_tok_flag(this, TOK_FLAG_TEMPLATE_END, new_template_end);
        }
      }
      var AST_Node = DEFNODE("Node", "start end", function AST_Node2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        _clone: function(deep) {
          if (deep) {
            var self2 = this.clone();
            return self2.transform(new TreeTransformer(function(node) {
              if (node !== self2) {
                return node.clone(true);
              }
            }));
          }
          return new this.CTOR(this);
        },
        clone: function(deep) {
          return this._clone(deep);
        },
        $documentation: "Base class of all AST nodes",
        $propdoc: {
          start: "[AST_Token] The first token of this node",
          end: "[AST_Token] The last token of this node"
        },
        _walk: function(visitor) {
          return visitor._visit(this);
        },
        walk: function(visitor) {
          return this._walk(visitor);
        },
        _children_backwards: () => {
        }
      }, null);
      var AST_Statement = DEFNODE("Statement", null, function AST_Statement2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class of all statements"
      });
      var AST_Debugger = DEFNODE("Debugger", null, function AST_Debugger2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Represents a debugger statement"
      }, AST_Statement);
      var AST_Directive = DEFNODE("Directive", "value quote", function AST_Directive2(props) {
        if (props) {
          this.value = props.value;
          this.quote = props.quote;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Represents a directive, like "use strict";',
        $propdoc: {
          value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
          quote: "[string] the original quote character"
        }
      }, AST_Statement);
      var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", function AST_SimpleStatement2(props) {
        if (props) {
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
        $propdoc: {
          body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
        }
      }, AST_Statement);
      function walk_body(node, visitor) {
        const body = node.body;
        for (var i = 0, len = body.length; i < len; i++) {
          body[i]._walk(visitor);
        }
      }
      function clone_block_scope(deep) {
        var clone = this._clone(deep);
        if (this.block_scope) {
          clone.block_scope = this.block_scope.clone();
        }
        return clone;
      }
      var AST_Block = DEFNODE("Block", "body block_scope", function AST_Block2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A body of statements (usually braced)",
        $propdoc: {
          body: "[AST_Statement*] an array of statements",
          block_scope: "[AST_Scope] the block scope"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
        },
        clone: clone_block_scope
      }, AST_Statement);
      var AST_BlockStatement = DEFNODE("BlockStatement", null, function AST_BlockStatement2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A block statement"
      }, AST_Block);
      var AST_EmptyStatement = DEFNODE("EmptyStatement", null, function AST_EmptyStatement2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The empty statement (empty block or simply a semicolon)"
      }, AST_Statement);
      var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", function AST_StatementWithBody2(props) {
        if (props) {
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
        $propdoc: {
          body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
        }
      }, AST_Statement);
      var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", function AST_LabeledStatement2(props) {
        if (props) {
          this.label = props.label;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Statement with a label",
        $propdoc: {
          label: "[AST_Label] a label definition"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.label._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.label);
        },
        clone: function(deep) {
          var node = this._clone(deep);
          if (deep) {
            var label = node.label;
            var def = this.label;
            node.walk(new TreeWalker(function(node2) {
              if (node2 instanceof AST_LoopControl && node2.label && node2.label.thedef === def) {
                node2.label.thedef = label;
                label.references.push(node2);
              }
            }));
          }
          return node;
        }
      }, AST_StatementWithBody);
      var AST_IterationStatement = DEFNODE("IterationStatement", "block_scope", function AST_IterationStatement2(props) {
        if (props) {
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Internal class.  All loops inherit from it.",
        $propdoc: {
          block_scope: "[AST_Scope] the block scope for this iteration statement."
        },
        clone: clone_block_scope
      }, AST_StatementWithBody);
      var AST_DWLoop = DEFNODE("DWLoop", "condition", function AST_DWLoop2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for do/while statements",
        $propdoc: {
          condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
        }
      }, AST_IterationStatement);
      var AST_Do = DEFNODE("Do", null, function AST_Do2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `do` statement",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
            this.condition._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.condition);
          push2(this.body);
        }
      }, AST_DWLoop);
      var AST_While = DEFNODE("While", null, function AST_While2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `while` statement",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.condition);
        }
      }, AST_DWLoop);
      var AST_For = DEFNODE("For", "init condition step", function AST_For2(props) {
        if (props) {
          this.init = props.init;
          this.condition = props.condition;
          this.step = props.step;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for` statement",
        $propdoc: {
          init: "[AST_Node?] the `for` initialization code, or null if empty",
          condition: "[AST_Node?] the `for` termination clause, or null if empty",
          step: "[AST_Node?] the `for` update clause, or null if empty"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.init)
              this.init._walk(visitor);
            if (this.condition)
              this.condition._walk(visitor);
            if (this.step)
              this.step._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          if (this.step)
            push2(this.step);
          if (this.condition)
            push2(this.condition);
          if (this.init)
            push2(this.init);
        }
      }, AST_IterationStatement);
      var AST_ForIn = DEFNODE("ForIn", "init object", function AST_ForIn2(props) {
        if (props) {
          this.init = props.init;
          this.object = props.object;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for ... in` statement",
        $propdoc: {
          init: "[AST_Node] the `for/in` initialization code",
          object: "[AST_Node] the object that we're looping through"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          if (this.object)
            push2(this.object);
          if (this.init)
            push2(this.init);
        }
      }, AST_IterationStatement);
      var AST_ForOf = DEFNODE("ForOf", "await", function AST_ForOf2(props) {
        if (props) {
          this.await = props.await;
          this.init = props.init;
          this.object = props.object;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for ... of` statement"
      }, AST_ForIn);
      var AST_With = DEFNODE("With", "expression", function AST_With2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `with` statement",
        $propdoc: {
          expression: "[AST_Node] the `with` expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.expression);
        }
      }, AST_StatementWithBody);
      var AST_Scope = DEFNODE("Scope", "variables uses_with uses_eval parent_scope enclosed cname", function AST_Scope2(props) {
        if (props) {
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all statements introducing a lexical scope",
        $propdoc: {
          variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
          uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
          uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
          parent_scope: "[AST_Scope?/S] link to the parent scope",
          enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
          cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
        },
        get_defun_scope: function() {
          var self2 = this;
          while (self2.is_block_scope()) {
            self2 = self2.parent_scope;
          }
          return self2;
        },
        clone: function(deep, toplevel) {
          var node = this._clone(deep);
          if (deep && this.variables && toplevel && !this._block_scope) {
            node.figure_out_scope({}, {
              toplevel,
              parent_scope: this.parent_scope
            });
          } else {
            if (this.variables)
              node.variables = new Map(this.variables);
            if (this.enclosed)
              node.enclosed = this.enclosed.slice();
            if (this._block_scope)
              node._block_scope = this._block_scope;
          }
          return node;
        },
        pinned: function() {
          return this.uses_eval || this.uses_with;
        }
      }, AST_Block);
      var AST_Toplevel = DEFNODE("Toplevel", "globals", function AST_Toplevel2(props) {
        if (props) {
          this.globals = props.globals;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The toplevel scope",
        $propdoc: {
          globals: "[Map/S] a map of name -> SymbolDef for all undeclared names"
        },
        wrap_commonjs: function(name) {
          var body = this.body;
          var wrapped_tl = "(function(exports){'$ORIG';})(typeof " + name + "=='undefined'?(" + name + "={}):" + name + ");";
          wrapped_tl = parse2(wrapped_tl);
          wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
            if (node instanceof AST_Directive && node.value == "$ORIG") {
              return MAP.splice(body);
            }
          }));
          return wrapped_tl;
        },
        wrap_enclose: function(args_values) {
          if (typeof args_values != "string")
            args_values = "";
          var index = args_values.indexOf(":");
          if (index < 0)
            index = args_values.length;
          var body = this.body;
          return parse2([
            "(function(",
            args_values.slice(0, index),
            '){"$ORIG"})(',
            args_values.slice(index + 1),
            ")"
          ].join("")).transform(new TreeTransformer(function(node) {
            if (node instanceof AST_Directive && node.value == "$ORIG") {
              return MAP.splice(body);
            }
          }));
        }
      }, AST_Scope);
      var AST_Expansion = DEFNODE("Expansion", "expression", function AST_Expansion2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
        $propdoc: {
          expression: "[AST_Node] the thing to be expanded"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression.walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments is_generator async", function AST_Lambda2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for functions",
        $propdoc: {
          name: "[AST_SymbolDeclaration?] the name of this function",
          argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
          uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
          is_generator: "[boolean] is this a generator method",
          async: "[boolean] is this method async"
        },
        args_as_names: function() {
          var out = [];
          for (var i = 0; i < this.argnames.length; i++) {
            if (this.argnames[i] instanceof AST_Destructuring) {
              out.push(...this.argnames[i].all_symbols());
            } else {
              out.push(this.argnames[i]);
            }
          }
          return out;
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.name)
              this.name._walk(visitor);
            var argnames = this.argnames;
            for (var i = 0, len = argnames.length; i < len; i++) {
              argnames[i]._walk(visitor);
            }
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          i = this.argnames.length;
          while (i--)
            push2(this.argnames[i]);
          if (this.name)
            push2(this.name);
        },
        is_braceless() {
          return this.body[0] instanceof AST_Return && this.body[0].value;
        },
        length_property() {
          let length = 0;
          for (const arg of this.argnames) {
            if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {
              length++;
            }
          }
          return length;
        }
      }, AST_Scope);
      var AST_Accessor = DEFNODE("Accessor", null, function AST_Accessor2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A setter/getter function.  The `name` property is always null."
      }, AST_Lambda);
      var AST_Function = DEFNODE("Function", null, function AST_Function2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A function expression"
      }, AST_Lambda);
      var AST_Arrow = DEFNODE("Arrow", null, function AST_Arrow2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An ES6 Arrow function ((a) => b)"
      }, AST_Lambda);
      var AST_Defun = DEFNODE("Defun", null, function AST_Defun2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A function definition"
      }, AST_Lambda);
      var AST_Destructuring = DEFNODE("Destructuring", "names is_array", function AST_Destructuring2(props) {
        if (props) {
          this.names = props.names;
          this.is_array = props.is_array;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
        $propdoc: {
          "names": "[AST_Node*] Array of properties or elements",
          "is_array": "[Boolean] Whether the destructuring represents an object or array"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.names.forEach(function(name) {
              name._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.names.length;
          while (i--)
            push2(this.names[i]);
        },
        all_symbols: function() {
          var out = [];
          walk(this, (node) => {
            if (node instanceof AST_SymbolDeclaration) {
              out.push(node);
            }
            if (node instanceof AST_Lambda) {
              return true;
            }
          });
          return out;
        }
      });
      var AST_PrefixedTemplateString = DEFNODE("PrefixedTemplateString", "template_string prefix", function AST_PrefixedTemplateString2(props) {
        if (props) {
          this.template_string = props.template_string;
          this.prefix = props.prefix;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
        $propdoc: {
          template_string: "[AST_TemplateString] The template string",
          prefix: "[AST_Node] The prefix, which will get called."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.prefix._walk(visitor);
            this.template_string._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.template_string);
          push2(this.prefix);
        }
      });
      var AST_TemplateString = DEFNODE("TemplateString", "segments", function AST_TemplateString2(props) {
        if (props) {
          this.segments = props.segments;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A template string literal",
        $propdoc: {
          segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.segments.forEach(function(seg) {
              seg._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.segments.length;
          while (i--)
            push2(this.segments[i]);
        }
      });
      var AST_TemplateSegment = DEFNODE("TemplateSegment", "value raw", function AST_TemplateSegment2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A segment of a template string literal",
        $propdoc: {
          value: "Content of the segment",
          raw: "Raw source of the segment"
        }
      });
      var AST_Jump = DEFNODE("Jump", null, function AST_Jump2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)"
      }, AST_Statement);
      var AST_Exit = DEFNODE("Exit", "value", function AST_Exit2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
        $propdoc: {
          value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.value && function() {
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value)
            push2(this.value);
        }
      }, AST_Jump);
      var AST_Return = DEFNODE("Return", null, function AST_Return2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `return` statement"
      }, AST_Exit);
      var AST_Throw = DEFNODE("Throw", null, function AST_Throw2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `throw` statement"
      }, AST_Exit);
      var AST_LoopControl = DEFNODE("LoopControl", "label", function AST_LoopControl2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for loop control statements (`break` and `continue`)",
        $propdoc: {
          label: "[AST_LabelRef?] the label, or null if none"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.label && function() {
            this.label._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.label)
            push2(this.label);
        }
      }, AST_Jump);
      var AST_Break = DEFNODE("Break", null, function AST_Break2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `break` statement"
      }, AST_LoopControl);
      var AST_Continue = DEFNODE("Continue", null, function AST_Continue2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `continue` statement"
      }, AST_LoopControl);
      var AST_Await = DEFNODE("Await", "expression", function AST_Await2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `await` statement",
        $propdoc: {
          expression: "[AST_Node] the mandatory expression being awaited"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Yield = DEFNODE("Yield", "expression is_star", function AST_Yield2(props) {
        if (props) {
          this.expression = props.expression;
          this.is_star = props.is_star;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `yield` statement",
        $propdoc: {
          expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
          is_star: "[Boolean] Whether this is a yield or yield* statement"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.expression && function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.expression)
            push2(this.expression);
        }
      });
      var AST_If = DEFNODE("If", "condition alternative", function AST_If2(props) {
        if (props) {
          this.condition = props.condition;
          this.alternative = props.alternative;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `if` statement",
        $propdoc: {
          condition: "[AST_Node] the `if` condition",
          alternative: "[AST_Statement?] the `else` part, or null if not present"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative)
              this.alternative._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.alternative) {
            push2(this.alternative);
          }
          push2(this.body);
          push2(this.condition);
        }
      }, AST_StatementWithBody);
      var AST_Switch = DEFNODE("Switch", "expression", function AST_Switch2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `switch` statement",
        $propdoc: {
          expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          push2(this.expression);
        }
      }, AST_Block);
      var AST_SwitchBranch = DEFNODE("SwitchBranch", null, function AST_SwitchBranch2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for `switch` branches"
      }, AST_Block);
      var AST_Default = DEFNODE("Default", null, function AST_Default2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `default` switch branch"
      }, AST_SwitchBranch);
      var AST_Case = DEFNODE("Case", "expression", function AST_Case2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `case` switch branch",
        $propdoc: {
          expression: "[AST_Node] the `case` expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          push2(this.expression);
        }
      }, AST_SwitchBranch);
      var AST_Try = DEFNODE("Try", "body bcatch bfinally", function AST_Try2(props) {
        if (props) {
          this.body = props.body;
          this.bcatch = props.bcatch;
          this.bfinally = props.bfinally;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `try` statement",
        $propdoc: {
          body: "[AST_TryBlock] the try block",
          bcatch: "[AST_Catch?] the catch block, or null if not present",
          bfinally: "[AST_Finally?] the finally block, or null if not present"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
            if (this.bcatch)
              this.bcatch._walk(visitor);
            if (this.bfinally)
              this.bfinally._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.bfinally)
            push2(this.bfinally);
          if (this.bcatch)
            push2(this.bcatch);
          push2(this.body);
        }
      }, AST_Statement);
      var AST_TryBlock = DEFNODE("TryBlock", null, function AST_TryBlock2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `try` block of a try statement"
      }, AST_Block);
      var AST_Catch = DEFNODE("Catch", "argname", function AST_Catch2(props) {
        if (props) {
          this.argname = props.argname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `catch` node; only makes sense as part of a `try` statement",
        $propdoc: {
          argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.argname)
              this.argname._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          if (this.argname)
            push2(this.argname);
        }
      }, AST_Block);
      var AST_Finally = DEFNODE("Finally", null, function AST_Finally2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `finally` node; only makes sense as part of a `try` statement"
      }, AST_Block);
      var AST_Definitions = DEFNODE("Definitions", "definitions", function AST_Definitions2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
        $propdoc: {
          definitions: "[AST_VarDef*] array of variable definitions"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var definitions = this.definitions;
            for (var i = 0, len = definitions.length; i < len; i++) {
              definitions[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.definitions.length;
          while (i--)
            push2(this.definitions[i]);
        }
      }, AST_Statement);
      var AST_Var = DEFNODE("Var", null, function AST_Var2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `var` statement"
      }, AST_Definitions);
      var AST_Let = DEFNODE("Let", null, function AST_Let2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `let` statement"
      }, AST_Definitions);
      var AST_Const = DEFNODE("Const", null, function AST_Const2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `const` statement"
      }, AST_Definitions);
      var AST_VarDef = DEFNODE("VarDef", "name value", function AST_VarDef2(props) {
        if (props) {
          this.name = props.name;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A variable declaration; only appears in a AST_Definitions node",
        $propdoc: {
          name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
          value: "[AST_Node?] initializer, or null of there's no initializer"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.name._walk(visitor);
            if (this.value)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value)
            push2(this.value);
          push2(this.name);
        },
        declarations_as_names() {
          if (this.name instanceof AST_SymbolDeclaration) {
            return [this];
          } else {
            return this.name.all_symbols();
          }
        }
      });
      var AST_NameMapping = DEFNODE("NameMapping", "foreign_name name", function AST_NameMapping2(props) {
        if (props) {
          this.foreign_name = props.foreign_name;
          this.name = props.name;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The part of the export/import statement that declare names from a module.",
        $propdoc: {
          foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
          name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.foreign_name._walk(visitor);
            this.name._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.name);
          push2(this.foreign_name);
        }
      });
      var AST_Import = DEFNODE("Import", "imported_name imported_names module_name attributes", function AST_Import2(props) {
        if (props) {
          this.imported_name = props.imported_name;
          this.imported_names = props.imported_names;
          this.module_name = props.module_name;
          this.attributes = props.attributes;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `import` statement",
        $propdoc: {
          imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
          imported_names: "[AST_NameMapping*] The names of non-default imported variables",
          module_name: "[AST_String] String literal describing where this module came from",
          attributes: "[AST_Object?] The import attributes (with {...})"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.imported_name) {
              this.imported_name._walk(visitor);
            }
            if (this.imported_names) {
              this.imported_names.forEach(function(name_import) {
                name_import._walk(visitor);
              });
            }
            this.module_name._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.module_name);
          if (this.imported_names) {
            let i = this.imported_names.length;
            while (i--)
              push2(this.imported_names[i]);
          }
          if (this.imported_name)
            push2(this.imported_name);
        }
      });
      var AST_ImportMeta = DEFNODE("ImportMeta", null, function AST_ImportMeta2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A reference to import.meta"
      });
      var AST_Export = DEFNODE("Export", "exported_definition exported_value is_default exported_names module_name attributes", function AST_Export2(props) {
        if (props) {
          this.exported_definition = props.exported_definition;
          this.exported_value = props.exported_value;
          this.is_default = props.is_default;
          this.exported_names = props.exported_names;
          this.module_name = props.module_name;
          this.attributes = props.attributes;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `export` statement",
        $propdoc: {
          exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
          exported_value: "[AST_Node?] An exported value",
          exported_names: "[AST_NameMapping*?] List of exported names",
          module_name: "[AST_String?] Name of the file to load exports from",
          is_default: "[Boolean] Whether this is the default exported value of this module",
          attributes: "[AST_Object?] The import attributes"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.exported_definition) {
              this.exported_definition._walk(visitor);
            }
            if (this.exported_value) {
              this.exported_value._walk(visitor);
            }
            if (this.exported_names) {
              this.exported_names.forEach(function(name_export) {
                name_export._walk(visitor);
              });
            }
            if (this.module_name) {
              this.module_name._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          if (this.module_name)
            push2(this.module_name);
          if (this.exported_names) {
            let i = this.exported_names.length;
            while (i--)
              push2(this.exported_names[i]);
          }
          if (this.exported_value)
            push2(this.exported_value);
          if (this.exported_definition)
            push2(this.exported_definition);
        }
      }, AST_Statement);
      var AST_Call = DEFNODE("Call", "expression args optional _annotations", function AST_Call2(props) {
        if (props) {
          this.expression = props.expression;
          this.args = props.args;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "A function call expression",
        $propdoc: {
          expression: "[AST_Node] expression to invoke as function",
          args: "[AST_Node*] array of arguments",
          optional: "[boolean] whether this is an optional call (IE ?.() )",
          _annotations: "[number] bitfield containing information about the call"
        },
        initialize() {
          if (this._annotations == null)
            this._annotations = 0;
        },
        _walk(visitor) {
          return visitor._visit(this, function() {
            var args = this.args;
            for (var i = 0, len = args.length; i < len; i++) {
              args[i]._walk(visitor);
            }
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.args.length;
          while (i--)
            push2(this.args[i]);
          push2(this.expression);
        }
      });
      var AST_New = DEFNODE("New", null, function AST_New2(props) {
        if (props) {
          this.expression = props.expression;
          this.args = props.args;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
      }, AST_Call);
      var AST_Sequence = DEFNODE("Sequence", "expressions", function AST_Sequence2(props) {
        if (props) {
          this.expressions = props.expressions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A sequence expression (comma-separated expressions)",
        $propdoc: {
          expressions: "[AST_Node*] array of expressions (at least two)"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expressions.forEach(function(node) {
              node._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.expressions.length;
          while (i--)
            push2(this.expressions[i]);
        }
      });
      var AST_PropAccess = DEFNODE("PropAccess", "expression property optional", function AST_PropAccess2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
        $propdoc: {
          expression: "[AST_Node] the \u201Ccontainer\u201D expression",
          property: "[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",
          optional: "[boolean] whether this is an optional property access (IE ?.)"
        }
      });
      var AST_Dot = DEFNODE("Dot", "quote", function AST_Dot2(props) {
        if (props) {
          this.quote = props.quote;
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A dotted property access expression",
        $propdoc: {
          quote: "[string] the original quote character when transformed from AST_Sub"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_DotHash = DEFNODE("DotHash", "", function AST_DotHash2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A dotted property access to a private property",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_Sub = DEFNODE("Sub", null, function AST_Sub2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Index-style property access, i.e. `a["foo"]`',
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            this.property._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.property);
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_Chain = DEFNODE("Chain", "expression", function AST_Chain2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A chain expression like a?.b?.(c)?.[d]",
        $propdoc: {
          expression: "[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Unary = DEFNODE("Unary", "operator expression", function AST_Unary2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for unary expressions",
        $propdoc: {
          operator: "[string] the operator",
          expression: "[AST_Node] expression that this unary operator applies to"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, function AST_UnaryPrefix2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
      }, AST_Unary);
      var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, function AST_UnaryPostfix2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Unary postfix expression, i.e. `i++`"
      }, AST_Unary);
      var AST_Binary = DEFNODE("Binary", "operator left right", function AST_Binary2(props) {
        if (props) {
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Binary expression, i.e. `a + b`",
        $propdoc: {
          left: "[AST_Node] left-hand side expression",
          operator: "[string] the operator",
          right: "[AST_Node] right-hand side expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.left._walk(visitor);
            this.right._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.right);
          push2(this.left);
        }
      });
      var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", function AST_Conditional2(props) {
        if (props) {
          this.condition = props.condition;
          this.consequent = props.consequent;
          this.alternative = props.alternative;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
        $propdoc: {
          condition: "[AST_Node]",
          consequent: "[AST_Node]",
          alternative: "[AST_Node]"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.alternative);
          push2(this.consequent);
          push2(this.condition);
        }
      });
      var AST_Assign = DEFNODE("Assign", "logical", function AST_Assign2(props) {
        if (props) {
          this.logical = props.logical;
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An assignment expression \u2014 `a = b + 5`",
        $propdoc: {
          logical: "Whether it's a logical assignment"
        }
      }, AST_Binary);
      var AST_DefaultAssign = DEFNODE("DefaultAssign", null, function AST_DefaultAssign2(props) {
        if (props) {
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A default assignment expression like in `(a = 3) => a`"
      }, AST_Binary);
      var AST_Array = DEFNODE("Array", "elements", function AST_Array2(props) {
        if (props) {
          this.elements = props.elements;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An array literal",
        $propdoc: {
          elements: "[AST_Node*] array of elements"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var elements = this.elements;
            for (var i = 0, len = elements.length; i < len; i++) {
              elements[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.elements.length;
          while (i--)
            push2(this.elements[i]);
        }
      });
      var AST_Object = DEFNODE("Object", "properties", function AST_Object2(props) {
        if (props) {
          this.properties = props.properties;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An object literal",
        $propdoc: {
          properties: "[AST_ObjectProperty*] array of properties"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var properties = this.properties;
            for (var i = 0, len = properties.length; i < len; i++) {
              properties[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.properties.length;
          while (i--)
            push2(this.properties[i]);
        }
      });
      var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", function AST_ObjectProperty2(props) {
        if (props) {
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for literal object properties",
        $propdoc: {
          key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
          value: "[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.key instanceof AST_Node)
              this.key._walk(visitor);
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.value);
          if (this.key instanceof AST_Node)
            push2(this.key);
        }
      });
      var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", function AST_ObjectKeyVal2(props) {
        if (props) {
          this.quote = props.quote;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A key: value object property",
        $propdoc: {
          quote: "[string] the original quote character"
        },
        computed_key() {
          return this.key instanceof AST_Node;
        }
      }, AST_ObjectProperty);
      var AST_PrivateSetter = DEFNODE("PrivateSetter", "static", function AST_PrivateSetter2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          static: "[boolean] whether this is a static private setter"
        },
        $documentation: "A private setter property",
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_PrivateGetter = DEFNODE("PrivateGetter", "static", function AST_PrivateGetter2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          static: "[boolean] whether this is a static private getter"
        },
        $documentation: "A private getter property",
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_ObjectSetter = DEFNODE("ObjectSetter", "quote static", function AST_ObjectSetter2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static setter (classes only)"
        },
        $documentation: "An object setter property",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_ObjectGetter = DEFNODE("ObjectGetter", "quote static", function AST_ObjectGetter2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static getter (classes only)"
        },
        $documentation: "An object getter property",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_ConciseMethod = DEFNODE("ConciseMethod", "quote static", function AST_ConciseMethod2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] is this method static (classes only)"
        },
        $documentation: "An ES6 concise method inside an object or class",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_PrivateMethod = DEFNODE("PrivateMethod", "static", function AST_PrivateMethod2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A private class method inside a class",
        $propdoc: {
          static: "[boolean] is this a static private method"
        },
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_Class = DEFNODE("Class", "name extends properties", function AST_Class2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
          extends: "[AST_Node]? optional parent class",
          properties: "[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks"
        },
        $documentation: "An ES6 class",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.name) {
              this.name._walk(visitor);
            }
            if (this.extends) {
              this.extends._walk(visitor);
            }
            this.properties.forEach((prop) => prop._walk(visitor));
          });
        },
        _children_backwards(push2) {
          let i = this.properties.length;
          while (i--)
            push2(this.properties[i]);
          if (this.extends)
            push2(this.extends);
          if (this.name)
            push2(this.name);
        },
        visit_nondeferred_class_parts(visitor) {
          if (this.extends) {
            this.extends._walk(visitor);
          }
          this.properties.forEach((prop) => {
            if (prop instanceof AST_ClassStaticBlock) {
              prop._walk(visitor);
              return;
            }
            if (prop.computed_key()) {
              visitor.push(prop);
              prop.key._walk(visitor);
              visitor.pop();
            }
            if (prop instanceof AST_ClassPrivateProperty && prop.static && prop.value || prop instanceof AST_ClassProperty && prop.static && prop.value) {
              visitor.push(prop);
              prop.value._walk(visitor);
              visitor.pop();
            }
          });
        },
        visit_deferred_class_parts(visitor) {
          this.properties.forEach((prop) => {
            if (prop instanceof AST_ConciseMethod || prop instanceof AST_PrivateMethod) {
              prop.walk(visitor);
            } else if (prop instanceof AST_ClassProperty && !prop.static && prop.value || prop instanceof AST_ClassPrivateProperty && !prop.static && prop.value) {
              visitor.push(prop);
              prop.value._walk(visitor);
              visitor.pop();
            }
          });
        },
        is_self_referential: function() {
          const this_id = this.name && this.name.definition().id;
          let found = false;
          let class_this = true;
          this.visit_nondeferred_class_parts(new TreeWalker((node, descend) => {
            if (found)
              return true;
            if (node instanceof AST_This)
              return found = class_this;
            if (node instanceof AST_SymbolRef)
              return found = node.definition().id === this_id;
            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
              const class_this_save = class_this;
              class_this = false;
              descend();
              class_this = class_this_save;
              return true;
            }
          }));
          return found;
        }
      }, AST_Scope);
      var AST_ClassProperty = DEFNODE("ClassProperty", "static quote", function AST_ClassProperty2(props) {
        if (props) {
          this.static = props.static;
          this.quote = props.quote;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A class property",
        $propdoc: {
          static: "[boolean] whether this is a static key",
          quote: "[string] which quote is being used"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.key instanceof AST_Node)
              this.key._walk(visitor);
            if (this.value instanceof AST_Node)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value instanceof AST_Node)
            push2(this.value);
          if (this.key instanceof AST_Node)
            push2(this.key);
        },
        computed_key() {
          return !(this.key instanceof AST_SymbolClassProperty);
        }
      }, AST_ObjectProperty);
      var AST_ClassPrivateProperty = DEFNODE("ClassPrivateProperty", "", function AST_ClassPrivateProperty2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class property for a private property",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.value instanceof AST_Node)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value instanceof AST_Node)
            push2(this.value);
        },
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_PrivateIn = DEFNODE("PrivateIn", "key value", function AST_PrivateIn2(props) {
        if (props) {
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `in` binop when the key is private, eg #x in this",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.key._walk(visitor);
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.value);
          push2(this.key);
        }
      });
      var AST_DefClass = DEFNODE("DefClass", null, function AST_DefClass2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class definition"
      }, AST_Class);
      var AST_ClassStaticBlock = DEFNODE("ClassStaticBlock", "body block_scope", function AST_ClassStaticBlock2(props) {
        this.body = props.body;
        this.block_scope = props.block_scope;
        this.start = props.start;
        this.end = props.end;
      }, {
        $documentation: "A block containing statements to be executed in the context of the class",
        $propdoc: {
          body: "[AST_Statement*] an array of statements"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
        },
        clone: clone_block_scope,
        computed_key() {
          return false;
        }
      }, AST_Scope);
      var AST_ClassExpression = DEFNODE("ClassExpression", null, function AST_ClassExpression2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class expression."
      }, AST_Class);
      var AST_Symbol = DEFNODE("Symbol", "scope name thedef", function AST_Symbol2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          name: "[string] name of this symbol",
          scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
          thedef: "[SymbolDef/S] the definition of this symbol"
        },
        $documentation: "Base class for all symbols"
      });
      var AST_NewTarget = DEFNODE("NewTarget", null, function AST_NewTarget2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A reference to new.target"
      });
      var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", function AST_SymbolDeclaration2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"
      }, AST_Symbol);
      var AST_SymbolVar = DEFNODE("SymbolVar", null, function AST_SymbolVar2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol defining a variable"
      }, AST_SymbolDeclaration);
      var AST_SymbolBlockDeclaration = DEFNODE("SymbolBlockDeclaration", null, function AST_SymbolBlockDeclaration2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for block-scoped declaration symbols"
      }, AST_SymbolDeclaration);
      var AST_SymbolConst = DEFNODE("SymbolConst", null, function AST_SymbolConst2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A constant declaration"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolLet = DEFNODE("SymbolLet", null, function AST_SymbolLet2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A block-scoped `let` declaration"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, function AST_SymbolFunarg2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a function argument"
      }, AST_SymbolVar);
      var AST_SymbolDefun = DEFNODE("SymbolDefun", null, function AST_SymbolDefun2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol defining a function"
      }, AST_SymbolDeclaration);
      var AST_SymbolMethod = DEFNODE("SymbolMethod", null, function AST_SymbolMethod2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol in an object defining a method"
      }, AST_Symbol);
      var AST_SymbolClassProperty = DEFNODE("SymbolClassProperty", null, function AST_SymbolClassProperty2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol for a class property"
      }, AST_Symbol);
      var AST_SymbolLambda = DEFNODE("SymbolLambda", null, function AST_SymbolLambda2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a function expression"
      }, AST_SymbolDeclaration);
      var AST_SymbolDefClass = DEFNODE("SymbolDefClass", null, function AST_SymbolDefClass2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolClass = DEFNODE("SymbolClass", null, function AST_SymbolClass2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a class's name. Lexically scoped to the class."
      }, AST_SymbolDeclaration);
      var AST_SymbolCatch = DEFNODE("SymbolCatch", null, function AST_SymbolCatch2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming the exception in catch"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolImport = DEFNODE("SymbolImport", null, function AST_SymbolImport2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol referring to an imported name"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolImportForeign = DEFNODE("SymbolImportForeign", "quote", function AST_SymbolImportForeign2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"
      }, AST_Symbol);
      var AST_Label = DEFNODE("Label", "references", function AST_Label2(props) {
        if (props) {
          this.references = props.references;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a label (declaration)",
        $propdoc: {
          references: "[AST_LoopControl*] a list of nodes referring to this label"
        },
        initialize: function() {
          this.references = [];
          this.thedef = this;
        }
      }, AST_Symbol);
      var AST_SymbolRef = DEFNODE("SymbolRef", null, function AST_SymbolRef2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Reference to some symbol (not definition/declaration)"
      }, AST_Symbol);
      var AST_SymbolExport = DEFNODE("SymbolExport", "quote", function AST_SymbolExport2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol referring to a name to export"
      }, AST_SymbolRef);
      var AST_SymbolExportForeign = DEFNODE("SymbolExportForeign", "quote", function AST_SymbolExportForeign2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"
      }, AST_Symbol);
      var AST_LabelRef = DEFNODE("LabelRef", null, function AST_LabelRef2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Reference to a label symbol"
      }, AST_Symbol);
      var AST_SymbolPrivateProperty = DEFNODE("SymbolPrivateProperty", null, function AST_SymbolPrivateProperty2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol that refers to a private property"
      }, AST_Symbol);
      var AST_This = DEFNODE("This", null, function AST_This2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `this` symbol"
      }, AST_Symbol);
      var AST_Super = DEFNODE("Super", null, function AST_Super2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `super` symbol"
      }, AST_This);
      var AST_Constant = DEFNODE("Constant", null, function AST_Constant2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all constants",
        getValue: function() {
          return this.value;
        }
      });
      var AST_String = DEFNODE("String", "value quote", function AST_String2(props) {
        if (props) {
          this.value = props.value;
          this.quote = props.quote;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A string literal",
        $propdoc: {
          value: "[string] the contents of this string",
          quote: "[string] the original quote character"
        }
      }, AST_Constant);
      var AST_Number = DEFNODE("Number", "value raw", function AST_Number2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A number literal",
        $propdoc: {
          value: "[number] the numeric value",
          raw: "[string] numeric value as string"
        }
      }, AST_Constant);
      var AST_BigInt = DEFNODE("BigInt", "value raw", function AST_BigInt2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A big int literal",
        $propdoc: {
          value: "[string] big int value, represented as a string",
          raw: "[string] the original format preserved"
        }
      }, AST_Constant);
      var AST_RegExp = DEFNODE("RegExp", "value", function AST_RegExp2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A regexp literal",
        $propdoc: {
          value: "[RegExp] the actual regexp"
        }
      }, AST_Constant);
      var AST_Atom = DEFNODE("Atom", null, function AST_Atom2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for atoms"
      }, AST_Constant);
      var AST_Null = DEFNODE("Null", null, function AST_Null2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `null` atom",
        value: null
      }, AST_Atom);
      var AST_NaN = DEFNODE("NaN", null, function AST_NaN2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The impossible value",
        value: 0 / 0
      }, AST_Atom);
      var AST_Undefined = DEFNODE("Undefined", null, function AST_Undefined2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `undefined` value",
        value: function() {
        }()
      }, AST_Atom);
      var AST_Hole = DEFNODE("Hole", null, function AST_Hole2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A hole in an array",
        value: function() {
        }()
      }, AST_Atom);
      var AST_Infinity = DEFNODE("Infinity", null, function AST_Infinity2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `Infinity` value",
        value: 1 / 0
      }, AST_Atom);
      var AST_Boolean = DEFNODE("Boolean", null, function AST_Boolean2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for booleans"
      }, AST_Atom);
      var AST_False = DEFNODE("False", null, function AST_False2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `false` atom",
        value: false
      }, AST_Boolean);
      var AST_True = DEFNODE("True", null, function AST_True2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `true` atom",
        value: true
      }, AST_Boolean);
      function walk(node, cb, to_visit = [node]) {
        const push2 = to_visit.push.bind(to_visit);
        while (to_visit.length) {
          const node2 = to_visit.pop();
          const ret = cb(node2, to_visit);
          if (ret) {
            if (ret === walk_abort)
              return true;
            continue;
          }
          node2._children_backwards(push2);
        }
        return false;
      }
      function walk_parent(node, cb, initial_stack) {
        const to_visit = [node];
        const push2 = to_visit.push.bind(to_visit);
        const stack = initial_stack ? initial_stack.slice() : [];
        const parent_pop_indices = [];
        let current;
        const info = {
          parent: (n2 = 0) => {
            if (n2 === -1) {
              return current;
            }
            if (initial_stack && n2 >= stack.length) {
              n2 -= stack.length;
              return initial_stack[initial_stack.length - (n2 + 1)];
            }
            return stack[stack.length - (1 + n2)];
          }
        };
        while (to_visit.length) {
          current = to_visit.pop();
          while (parent_pop_indices.length && to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]) {
            stack.pop();
            parent_pop_indices.pop();
          }
          const ret = cb(current, info);
          if (ret) {
            if (ret === walk_abort)
              return true;
            continue;
          }
          const visit_length = to_visit.length;
          current._children_backwards(push2);
          if (to_visit.length > visit_length) {
            stack.push(current);
            parent_pop_indices.push(visit_length - 1);
          }
        }
        return false;
      }
      const walk_abort = Symbol("abort walk");
      class TreeWalker {
        constructor(callback) {
          this.visit = callback;
          this.stack = [];
          this.directives = /* @__PURE__ */ Object.create(null);
        }
        _visit(node, descend) {
          this.push(node);
          var ret = this.visit(node, descend ? function() {
            descend.call(node);
          } : noop2);
          if (!ret && descend) {
            descend.call(node);
          }
          this.pop();
          return ret;
        }
        parent(n2) {
          return this.stack[this.stack.length - 2 - (n2 || 0)];
        }
        push(node) {
          if (node instanceof AST_Lambda) {
            this.directives = Object.create(this.directives);
          } else if (node instanceof AST_Directive && !this.directives[node.value]) {
            this.directives[node.value] = node;
          } else if (node instanceof AST_Class) {
            this.directives = Object.create(this.directives);
            if (!this.directives["use strict"]) {
              this.directives["use strict"] = node;
            }
          }
          this.stack.push(node);
        }
        pop() {
          var node = this.stack.pop();
          if (node instanceof AST_Lambda || node instanceof AST_Class) {
            this.directives = Object.getPrototypeOf(this.directives);
          }
        }
        self() {
          return this.stack[this.stack.length - 1];
        }
        find_parent(type) {
          var stack = this.stack;
          for (var i = stack.length; --i >= 0; ) {
            var x = stack[i];
            if (x instanceof type)
              return x;
          }
        }
        is_within_loop() {
          let i = this.stack.length - 1;
          let child = this.stack[i];
          while (i--) {
            const node = this.stack[i];
            if (node instanceof AST_Lambda)
              return false;
            if (node instanceof AST_IterationStatement && !(node instanceof AST_For && child === node.init) && !((node instanceof AST_ForIn || node instanceof AST_ForOf) && child === node.object)) {
              return true;
            }
            child = node;
          }
          return false;
        }
        find_scope() {
          var stack = this.stack;
          for (var i = stack.length; --i >= 0; ) {
            const p = stack[i];
            if (p instanceof AST_Toplevel)
              return p;
            if (p instanceof AST_Lambda)
              return p;
            if (p.block_scope)
              return p.block_scope;
          }
        }
        has_directive(type) {
          var dir = this.directives[type];
          if (dir)
            return dir;
          var node = this.stack[this.stack.length - 1];
          if (node instanceof AST_Scope && node.body) {
            for (var i = 0; i < node.body.length; ++i) {
              var st = node.body[i];
              if (!(st instanceof AST_Directive))
                break;
              if (st.value == type)
                return st;
            }
          }
        }
        loopcontrol_target(node) {
          var stack = this.stack;
          if (node.label)
            for (var i = stack.length; --i >= 0; ) {
              var x = stack[i];
              if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)
                return x.body;
            }
          else
            for (var i = stack.length; --i >= 0; ) {
              var x = stack[i];
              if (x instanceof AST_IterationStatement || node instanceof AST_Break && x instanceof AST_Switch)
                return x;
            }
        }
      }
      class TreeTransformer extends TreeWalker {
        constructor(before, after) {
          super();
          this.before = before;
          this.after = after;
        }
      }
      const _PURE = 1;
      const _INLINE = 2;
      const _NOINLINE = 4;
      const _KEY = 8;
      const _MANGLEPROP = 16;
      function def_transform(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list) {
          let transformed = void 0;
          tw.push(this);
          if (tw.before)
            transformed = tw.before(this, descend, in_list);
          if (transformed === void 0) {
            transformed = this;
            descend(transformed, tw);
            if (tw.after) {
              const after_ret = tw.after(transformed, in_list);
              if (after_ret !== void 0)
                transformed = after_ret;
            }
          }
          tw.pop();
          return transformed;
        });
      }
      def_transform(AST_Node, noop2);
      def_transform(AST_LabeledStatement, function(self2, tw) {
        self2.label = self2.label.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_SimpleStatement, function(self2, tw) {
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_Block, function(self2, tw) {
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Do, function(self2, tw) {
        self2.body = self2.body.transform(tw);
        self2.condition = self2.condition.transform(tw);
      });
      def_transform(AST_While, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_For, function(self2, tw) {
        if (self2.init)
          self2.init = self2.init.transform(tw);
        if (self2.condition)
          self2.condition = self2.condition.transform(tw);
        if (self2.step)
          self2.step = self2.step.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_ForIn, function(self2, tw) {
        self2.init = self2.init.transform(tw);
        self2.object = self2.object.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_With, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_Exit, function(self2, tw) {
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_LoopControl, function(self2, tw) {
        if (self2.label)
          self2.label = self2.label.transform(tw);
      });
      def_transform(AST_If, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.body = self2.body.transform(tw);
        if (self2.alternative)
          self2.alternative = self2.alternative.transform(tw);
      });
      def_transform(AST_Switch, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Case, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Try, function(self2, tw) {
        self2.body = self2.body.transform(tw);
        if (self2.bcatch)
          self2.bcatch = self2.bcatch.transform(tw);
        if (self2.bfinally)
          self2.bfinally = self2.bfinally.transform(tw);
      });
      def_transform(AST_Catch, function(self2, tw) {
        if (self2.argname)
          self2.argname = self2.argname.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Definitions, function(self2, tw) {
        self2.definitions = MAP(self2.definitions, tw);
      });
      def_transform(AST_VarDef, function(self2, tw) {
        self2.name = self2.name.transform(tw);
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Destructuring, function(self2, tw) {
        self2.names = MAP(self2.names, tw);
      });
      def_transform(AST_Lambda, function(self2, tw) {
        if (self2.name)
          self2.name = self2.name.transform(tw);
        self2.argnames = MAP(self2.argnames, tw, false);
        if (self2.body instanceof AST_Node) {
          self2.body = self2.body.transform(tw);
        } else {
          self2.body = MAP(self2.body, tw);
        }
      });
      def_transform(AST_Call, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.args = MAP(self2.args, tw, false);
      });
      def_transform(AST_Sequence, function(self2, tw) {
        const result = MAP(self2.expressions, tw);
        self2.expressions = result.length ? result : [new AST_Number({ value: 0 })];
      });
      def_transform(AST_PropAccess, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Sub, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.property = self2.property.transform(tw);
      });
      def_transform(AST_Chain, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Yield, function(self2, tw) {
        if (self2.expression)
          self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Await, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Unary, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Binary, function(self2, tw) {
        self2.left = self2.left.transform(tw);
        self2.right = self2.right.transform(tw);
      });
      def_transform(AST_PrivateIn, function(self2, tw) {
        self2.key = self2.key.transform(tw);
        self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Conditional, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.consequent = self2.consequent.transform(tw);
        self2.alternative = self2.alternative.transform(tw);
      });
      def_transform(AST_Array, function(self2, tw) {
        self2.elements = MAP(self2.elements, tw);
      });
      def_transform(AST_Object, function(self2, tw) {
        self2.properties = MAP(self2.properties, tw);
      });
      def_transform(AST_ObjectProperty, function(self2, tw) {
        if (self2.key instanceof AST_Node) {
          self2.key = self2.key.transform(tw);
        }
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Class, function(self2, tw) {
        if (self2.name)
          self2.name = self2.name.transform(tw);
        if (self2.extends)
          self2.extends = self2.extends.transform(tw);
        self2.properties = MAP(self2.properties, tw);
      });
      def_transform(AST_ClassStaticBlock, function(self2, tw) {
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Expansion, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_NameMapping, function(self2, tw) {
        self2.foreign_name = self2.foreign_name.transform(tw);
        self2.name = self2.name.transform(tw);
      });
      def_transform(AST_Import, function(self2, tw) {
        if (self2.imported_name)
          self2.imported_name = self2.imported_name.transform(tw);
        if (self2.imported_names)
          MAP(self2.imported_names, tw);
        self2.module_name = self2.module_name.transform(tw);
      });
      def_transform(AST_Export, function(self2, tw) {
        if (self2.exported_definition)
          self2.exported_definition = self2.exported_definition.transform(tw);
        if (self2.exported_value)
          self2.exported_value = self2.exported_value.transform(tw);
        if (self2.exported_names)
          MAP(self2.exported_names, tw);
        if (self2.module_name)
          self2.module_name = self2.module_name.transform(tw);
      });
      def_transform(AST_TemplateString, function(self2, tw) {
        self2.segments = MAP(self2.segments, tw);
      });
      def_transform(AST_PrefixedTemplateString, function(self2, tw) {
        self2.prefix = self2.prefix.transform(tw);
        self2.template_string = self2.template_string.transform(tw);
      });
      (function() {
        var normalize_directives = function(body) {
          for (var i = 0; i < body.length; i++) {
            if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {
              body[i] = new AST_Directive({
                start: body[i].start,
                end: body[i].end,
                quote: '"',
                value: body[i].body.value
              });
            } else {
              return body;
            }
          }
          return body;
        };
        function import_attributes_from_moz(attributes) {
          if (attributes && attributes.length > 0) {
            return new AST_Object({
              start: my_start_token(attributes),
              end: my_end_token(attributes),
              properties: attributes.map((attr2) => new AST_ObjectKeyVal({
                start: my_start_token(attr2),
                end: my_end_token(attr2),
                key: attr2.key.name || attr2.key.value,
                value: from_moz(attr2.value)
              }))
            });
          }
          return null;
        }
        var MOZ_TO_ME = {
          Program: function(M) {
            return new AST_Toplevel({
              start: my_start_token(M),
              end: my_end_token(M),
              body: normalize_directives(M.body.map(from_moz))
            });
          },
          ArrayPattern: function(M) {
            return new AST_Destructuring({
              start: my_start_token(M),
              end: my_end_token(M),
              names: M.elements.map(function(elm) {
                if (elm === null) {
                  return new AST_Hole();
                }
                return from_moz(elm);
              }),
              is_array: true
            });
          },
          ObjectPattern: function(M) {
            return new AST_Destructuring({
              start: my_start_token(M),
              end: my_end_token(M),
              names: M.properties.map(from_moz),
              is_array: false
            });
          },
          AssignmentPattern: function(M) {
            return new AST_DefaultAssign({
              start: my_start_token(M),
              end: my_end_token(M),
              left: from_moz(M.left),
              operator: "=",
              right: from_moz(M.right)
            });
          },
          SpreadElement: function(M) {
            return new AST_Expansion({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          RestElement: function(M) {
            return new AST_Expansion({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          TemplateElement: function(M) {
            return new AST_TemplateSegment({
              start: my_start_token(M),
              end: my_end_token(M),
              value: M.value.cooked,
              raw: M.value.raw
            });
          },
          TemplateLiteral: function(M) {
            var segments = [];
            for (var i = 0; i < M.quasis.length; i++) {
              segments.push(from_moz(M.quasis[i]));
              if (M.expressions[i]) {
                segments.push(from_moz(M.expressions[i]));
              }
            }
            return new AST_TemplateString({
              start: my_start_token(M),
              end: my_end_token(M),
              segments
            });
          },
          TaggedTemplateExpression: function(M) {
            return new AST_PrefixedTemplateString({
              start: my_start_token(M),
              end: my_end_token(M),
              template_string: from_moz(M.quasi),
              prefix: from_moz(M.tag)
            });
          },
          FunctionDeclaration: function(M) {
            return new AST_Defun({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.id && from_moz_symbol(AST_SymbolDefun, M.id),
              argnames: M.params.map((M2) => from_moz_pattern(M2, AST_SymbolFunarg)),
              is_generator: M.generator,
              async: M.async,
              body: normalize_directives(from_moz(M.body).body)
            });
          },
          FunctionExpression: function(M) {
            return from_moz_lambda(M, false);
          },
          ArrowFunctionExpression: function(M) {
            const body = M.body.type === "BlockStatement" ? from_moz(M.body).body : [make_node(AST_Return, {}, { value: from_moz(M.body) })];
            return new AST_Arrow({
              start: my_start_token(M),
              end: my_end_token(M),
              argnames: M.params.map((p) => from_moz_pattern(p, AST_SymbolFunarg)),
              body,
              async: M.async
            });
          },
          ExpressionStatement: function(M) {
            return new AST_SimpleStatement({
              start: my_start_token(M),
              end: my_end_token(M),
              body: from_moz(M.expression)
            });
          },
          TryStatement: function(M) {
            var handlers = M.handlers || [M.handler];
            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
              throw new Error("Multiple catch clauses are not supported.");
            }
            return new AST_Try({
              start: my_start_token(M),
              end: my_end_token(M),
              body: new AST_TryBlock(from_moz(M.block)),
              bcatch: from_moz(handlers[0]),
              bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
          },
          Property: function(M) {
            if (M.kind == "init" && !M.method) {
              var args = {
                start: my_start_token(M.key || M.value),
                end: my_end_token(M.value),
                key: M.computed ? from_moz(M.key) : M.key.name || String(M.key.value),
                quote: from_moz_quote(M.key, M.computed),
                static: false,
                value: from_moz(M.value)
              };
              return new AST_ObjectKeyVal(args);
            } else {
              var value2 = from_moz_lambda(M.value, true);
              var args = {
                start: my_start_token(M.key || M.value),
                end: my_end_token(M.value),
                key: M.computed ? from_moz(M.key) : from_moz_symbol(AST_SymbolMethod, M.key),
                quote: from_moz_quote(M.key, M.computed),
                static: false,
                value: value2
              };
              if (M.kind == "get")
                return new AST_ObjectGetter(args);
              if (M.kind == "set")
                return new AST_ObjectSetter(args);
              if (M.method)
                return new AST_ConciseMethod(args);
            }
          },
          MethodDefinition: function(M) {
            const is_private = M.key.type === "PrivateIdentifier";
            const key = M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || String(M.key.value) });
            var args = {
              start: my_start_token(M),
              end: my_end_token(M),
              key,
              quote: from_moz_quote(M.key, M.computed),
              value: from_moz_lambda(M.value, true),
              static: M.static
            };
            if (M.kind == "get") {
              return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);
            }
            if (M.kind == "set") {
              return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);
            }
            return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);
          },
          FieldDefinition: function(M) {
            let key;
            if (M.computed) {
              key = from_moz(M.key);
            } else {
              if (M.key.type !== "Identifier")
                throw new Error("Non-Identifier key in FieldDefinition");
              key = from_moz(M.key);
            }
            return new AST_ClassProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              quote: from_moz_quote(M.key, M.computed),
              key,
              value: from_moz(M.value),
              static: M.static
            });
          },
          PropertyDefinition: function(M) {
            let key;
            if (M.computed) {
              key = from_moz(M.key);
            } else if (M.key.type === "PrivateIdentifier") {
              return new AST_ClassPrivateProperty({
                start: my_start_token(M),
                end: my_end_token(M),
                key: from_moz(M.key),
                value: from_moz(M.value),
                static: M.static
              });
            } else {
              key = from_moz_symbol(AST_SymbolClassProperty, M.key);
            }
            return new AST_ClassProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              quote: from_moz_quote(M.key, M.computed),
              key,
              value: from_moz(M.value),
              static: M.static
            });
          },
          PrivateIdentifier: function(M) {
            return new AST_SymbolPrivateProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.name
            });
          },
          StaticBlock: function(M) {
            return new AST_ClassStaticBlock({
              start: my_start_token(M),
              end: my_end_token(M),
              body: M.body.map(from_moz)
            });
          },
          ArrayExpression: function(M) {
            return new AST_Array({
              start: my_start_token(M),
              end: my_end_token(M),
              elements: M.elements.map(function(elem) {
                return elem === null ? new AST_Hole() : from_moz(elem);
              })
            });
          },
          ObjectExpression: function(M) {
            return new AST_Object({
              start: my_start_token(M),
              end: my_end_token(M),
              properties: M.properties.map(function(prop) {
                if (prop.type === "SpreadElement") {
                  return from_moz(prop);
                }
                prop.type = "Property";
                return from_moz(prop);
              })
            });
          },
          SequenceExpression: function(M) {
            return new AST_Sequence({
              start: my_start_token(M),
              end: my_end_token(M),
              expressions: M.expressions.map(from_moz)
            });
          },
          MemberExpression: function(M) {
            if (M.property.type === "PrivateIdentifier") {
              return new AST_DotHash({
                start: my_start_token(M),
                end: my_end_token(M),
                property: M.property.name,
                expression: from_moz(M.object),
                optional: M.optional || false
              });
            }
            return new (M.computed ? AST_Sub : AST_Dot)({
              start: my_start_token(M),
              end: my_end_token(M),
              property: M.computed ? from_moz(M.property) : M.property.name,
              expression: from_moz(M.object),
              optional: M.optional || false
            });
          },
          ChainExpression: function(M) {
            return new AST_Chain({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.expression)
            });
          },
          SwitchCase: function(M) {
            return new (M.test ? AST_Case : AST_Default)({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.test),
              body: M.consequent.map(from_moz)
            });
          },
          VariableDeclaration: function(M) {
            let decl_type;
            let sym_type;
            if (M.kind === "const") {
              decl_type = AST_Const;
              sym_type = AST_SymbolConst;
            } else if (M.kind === "let") {
              decl_type = AST_Let;
              sym_type = AST_SymbolLet;
            } else {
              decl_type = AST_Var;
              sym_type = AST_SymbolVar;
            }
            const definitions = M.declarations.map((M2) => {
              return new AST_VarDef({
                start: my_start_token(M2),
                end: my_end_token(M2),
                name: from_moz_pattern(M2.id, sym_type),
                value: from_moz(M2.init)
              });
            });
            return new decl_type({
              start: my_start_token(M),
              end: my_end_token(M),
              definitions
            });
          },
          ImportDeclaration: function(M) {
            var imported_name = null;
            var imported_names = null;
            M.specifiers.forEach(function(specifier) {
              if (specifier.type === "ImportSpecifier" || specifier.type === "ImportNamespaceSpecifier") {
                if (!imported_names) {
                  imported_names = [];
                }
                imported_names.push(from_moz(specifier));
              } else if (specifier.type === "ImportDefaultSpecifier") {
                imported_name = from_moz(specifier);
              }
            });
            return new AST_Import({
              start: my_start_token(M),
              end: my_end_token(M),
              imported_name,
              imported_names,
              module_name: from_moz(M.source),
              attributes: import_attributes_from_moz(M.attributes || M.assertions)
            });
          },
          ImportSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: from_moz_symbol(AST_SymbolImportForeign, M.imported, M.imported.type === "Literal"),
              name: from_moz_symbol(AST_SymbolImport, M.local)
            });
          },
          ImportDefaultSpecifier: function(M) {
            return from_moz_symbol(AST_SymbolImport, M.local);
          },
          ImportNamespaceSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: new AST_SymbolImportForeign({ name: "*" }),
              name: from_moz_symbol(AST_SymbolImport, M.local)
            });
          },
          ImportExpression: function(M) {
            const args = [from_moz(M.source)];
            if (M.options) {
              args.push(from_moz(M.options));
            }
            return new AST_Call({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz({
                type: "Identifier",
                name: "import"
              }),
              optional: false,
              args
            });
          },
          ExportAllDeclaration: function(M) {
            var foreign_name = M.exported == null ? new AST_SymbolExportForeign({ name: "*" }) : from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === "Literal");
            return new AST_Export({
              start: my_start_token(M),
              end: my_end_token(M),
              exported_names: [
                new AST_NameMapping({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  name: new AST_SymbolExport({ name: "*" }),
                  foreign_name
                })
              ],
              module_name: from_moz(M.source),
              attributes: import_attributes_from_moz(M.attributes || M.assertions)
            });
          },
          ExportNamedDeclaration: function(M) {
            if (M.declaration) {
              return new AST_Export({
                start: my_start_token(M),
                end: my_end_token(M),
                exported_definition: from_moz(M.declaration),
                exported_names: null,
                module_name: null,
                attributes: null
              });
            } else {
              return new AST_Export({
                start: my_start_token(M),
                end: my_end_token(M),
                exported_definition: null,
                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(from_moz) : [],
                module_name: from_moz(M.source),
                attributes: import_attributes_from_moz(M.attributes || M.assertions)
              });
            }
          },
          ExportDefaultDeclaration: function(M) {
            return new AST_Export({
              start: my_start_token(M),
              end: my_end_token(M),
              exported_value: from_moz(M.declaration),
              is_default: true
            });
          },
          ExportSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === "Literal"),
              name: from_moz_symbol(AST_SymbolExport, M.local, M.local.type === "Literal")
            });
          },
          Literal: function(M) {
            var val = M.value, args = {
              start: my_start_token(M),
              end: my_end_token(M)
            };
            var rx = M.regex;
            if (rx && rx.pattern) {
              args.value = {
                source: rx.pattern,
                flags: rx.flags
              };
              return new AST_RegExp(args);
            } else if (rx) {
              const rx_source = M.raw || val;
              const match = rx_source.match(/^\/(.*)\/(\w*)$/);
              if (!match)
                throw new Error("Invalid regex source " + rx_source);
              const [_, source, flags] = match;
              args.value = { source, flags };
              return new AST_RegExp(args);
            }
            const bi = typeof M.value === "bigint" ? M.value.toString() : M.bigint;
            if (typeof bi === "string") {
              args.value = bi;
              args.raw = M.raw;
              return new AST_BigInt(args);
            }
            if (val === null)
              return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.quote = '"';
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                args.raw = M.raw || val.toString();
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
            }
          },
          MetaProperty: function(M) {
            if (M.meta.name === "new" && M.property.name === "target") {
              return new AST_NewTarget({
                start: my_start_token(M),
                end: my_end_token(M)
              });
            } else if (M.meta.name === "import" && M.property.name === "meta") {
              return new AST_ImportMeta({
                start: my_start_token(M),
                end: my_end_token(M)
              });
            }
          },
          Identifier: function(M) {
            return new AST_SymbolRef({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.name
            });
          },
          EmptyStatement: function(M) {
            return new AST_EmptyStatement({
              start: my_start_token(M),
              end: my_end_token(M)
            });
          },
          BlockStatement: function(M) {
            return new AST_BlockStatement({
              start: my_start_token(M),
              end: my_end_token(M),
              body: M.body.map(from_moz)
            });
          },
          IfStatement: function(M) {
            return new AST_If({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.consequent),
              alternative: from_moz(M.alternate)
            });
          },
          LabeledStatement: function(M) {
            try {
              const label = from_moz_symbol(AST_Label, M.label);
              FROM_MOZ_LABELS.push(label);
              const stat = new AST_LabeledStatement({
                start: my_start_token(M),
                end: my_end_token(M),
                label,
                body: from_moz(M.body)
              });
              return stat;
            } finally {
              FROM_MOZ_LABELS.pop();
            }
          },
          BreakStatement: function(M) {
            return new AST_Break({
              start: my_start_token(M),
              end: my_end_token(M),
              label: from_moz_label_ref(M.label)
            });
          },
          ContinueStatement: function(M) {
            return new AST_Continue({
              start: my_start_token(M),
              end: my_end_token(M),
              label: from_moz_label_ref(M.label)
            });
          },
          WithStatement: function(M) {
            return new AST_With({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.object),
              body: from_moz(M.body)
            });
          },
          SwitchStatement: function(M) {
            return new AST_Switch({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.discriminant),
              body: M.cases.map(from_moz)
            });
          },
          ReturnStatement: function(M) {
            return new AST_Return({
              start: my_start_token(M),
              end: my_end_token(M),
              value: from_moz(M.argument)
            });
          },
          ThrowStatement: function(M) {
            return new AST_Throw({
              start: my_start_token(M),
              end: my_end_token(M),
              value: from_moz(M.argument)
            });
          },
          WhileStatement: function(M) {
            return new AST_While({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.body)
            });
          },
          DoWhileStatement: function(M) {
            return new AST_Do({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.body)
            });
          },
          ForStatement: function(M) {
            return new AST_For({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.init),
              condition: from_moz(M.test),
              step: from_moz(M.update),
              body: from_moz(M.body)
            });
          },
          ForInStatement: function(M) {
            return new AST_ForIn({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.left),
              object: from_moz(M.right),
              body: from_moz(M.body)
            });
          },
          ForOfStatement: function(M) {
            return new AST_ForOf({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.left),
              object: from_moz(M.right),
              body: from_moz(M.body),
              await: M.await
            });
          },
          AwaitExpression: function(M) {
            return new AST_Await({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          YieldExpression: function(M) {
            return new AST_Yield({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument),
              is_star: M.delegate
            });
          },
          DebuggerStatement: function(M) {
            return new AST_Debugger({
              start: my_start_token(M),
              end: my_end_token(M)
            });
          },
          CatchClause: function(M) {
            return new AST_Catch({
              start: my_start_token(M),
              end: my_end_token(M),
              argname: M.param ? from_moz_pattern(M.param, AST_SymbolCatch) : null,
              body: from_moz(M.body).body
            });
          },
          ThisExpression: function(M) {
            return new AST_This({
              start: my_start_token(M),
              name: "this",
              end: my_end_token(M)
            });
          },
          Super: function(M) {
            return new AST_Super({
              start: my_start_token(M),
              end: my_end_token(M),
              name: "super"
            });
          },
          BinaryExpression: function(M) {
            if (M.left.type === "PrivateIdentifier") {
              return new AST_PrivateIn({
                start: my_start_token(M),
                end: my_end_token(M),
                key: new AST_SymbolPrivateProperty({
                  start: my_start_token(M.left),
                  end: my_end_token(M.left),
                  name: M.left.name
                }),
                value: from_moz(M.right)
              });
            }
            return new AST_Binary({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          LogicalExpression: function(M) {
            return new AST_Binary({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          AssignmentExpression: function(M) {
            return new AST_Assign({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              logical: M.operator === "??=" || M.operator === "&&=" || M.operator === "||=",
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          ConditionalExpression: function(M) {
            return new AST_Conditional({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              consequent: from_moz(M.consequent),
              alternative: from_moz(M.alternate)
            });
          },
          NewExpression: function(M) {
            return new AST_New({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.callee),
              args: M.arguments.map(from_moz)
            });
          },
          CallExpression: function(M) {
            return new AST_Call({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.callee),
              optional: M.optional,
              args: M.arguments.map(from_moz)
            });
          }
        };
        MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
          var prefix = "prefix" in M ? M.prefix : M.type == "UnaryExpression" ? true : false;
          return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start: my_start_token(M),
            end: my_end_token(M),
            operator: M.operator,
            expression: from_moz(M.argument)
          });
        };
        MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {
          return new (M.type === "ClassDeclaration" ? AST_DefClass : AST_ClassExpression)({
            start: my_start_token(M),
            end: my_end_token(M),
            name: M.id && from_moz_symbol(M.type === "ClassDeclaration" ? AST_SymbolDefClass : AST_SymbolClass, M.id),
            extends: from_moz(M.superClass),
            properties: M.body.body.map(from_moz)
          });
        };
        def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {
          return {
            type: "EmptyStatement"
          };
        });
        def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {
          return {
            type: "BlockStatement",
            body: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_If, function To_Moz_IfStatement(M) {
          return {
            type: "IfStatement",
            test: to_moz(M.condition),
            consequent: to_moz(M.body),
            alternate: to_moz(M.alternative)
          };
        });
        def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {
          return {
            type: "LabeledStatement",
            label: to_moz(M.label),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {
          return {
            type: "BreakStatement",
            label: to_moz(M.label)
          };
        });
        def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {
          return {
            type: "ContinueStatement",
            label: to_moz(M.label)
          };
        });
        def_to_moz(AST_With, function To_Moz_WithStatement(M) {
          return {
            type: "WithStatement",
            object: to_moz(M.expression),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {
          return {
            type: "SwitchStatement",
            discriminant: to_moz(M.expression),
            cases: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {
          return {
            type: "ReturnStatement",
            argument: to_moz(M.value)
          };
        });
        def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {
          return {
            type: "ThrowStatement",
            argument: to_moz(M.value)
          };
        });
        def_to_moz(AST_While, function To_Moz_WhileStatement(M) {
          return {
            type: "WhileStatement",
            test: to_moz(M.condition),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {
          return {
            type: "DoWhileStatement",
            test: to_moz(M.condition),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_For, function To_Moz_ForStatement(M) {
          return {
            type: "ForStatement",
            init: to_moz(M.init),
            test: to_moz(M.condition),
            update: to_moz(M.step),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {
          return {
            type: "ForInStatement",
            left: to_moz(M.init),
            right: to_moz(M.object),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {
          return {
            type: "ForOfStatement",
            left: to_moz(M.init),
            right: to_moz(M.object),
            body: to_moz(M.body),
            await: M.await
          };
        });
        def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {
          return {
            type: "AwaitExpression",
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {
          return {
            type: "YieldExpression",
            argument: to_moz(M.expression),
            delegate: M.is_star
          };
        });
        def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {
          return {
            type: "DebuggerStatement"
          };
        });
        def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M) {
          return {
            type: "VariableDeclarator",
            id: to_moz(M.name),
            init: to_moz(M.value)
          };
        });
        def_to_moz(AST_This, function To_Moz_ThisExpression() {
          return {
            type: "ThisExpression"
          };
        });
        def_to_moz(AST_Super, function To_Moz_Super() {
          return {
            type: "Super"
          };
        });
        def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {
          return {
            type: "ConditionalExpression",
            test: to_moz(M.condition),
            consequent: to_moz(M.consequent),
            alternate: to_moz(M.alternative)
          };
        });
        def_to_moz(AST_New, function To_Moz_NewExpression(M) {
          return {
            type: "NewExpression",
            callee: to_moz(M.expression),
            arguments: M.args.map(to_moz)
          };
        });
        def_to_moz(AST_Call, function To_Moz_CallExpression(M) {
          if (M.expression instanceof AST_SymbolRef && M.expression.name === "import") {
            const [source, options] = M.args.map(to_moz);
            return {
              type: "ImportExpression",
              source,
              options: options || null
            };
          }
          return {
            type: "CallExpression",
            callee: to_moz(M.expression),
            optional: M.optional,
            arguments: M.args.map(to_moz)
          };
        });
        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
          return to_moz_scope("Program", M);
        });
        def_to_moz(AST_Expansion, function To_Moz_Spread(M) {
          return {
            type: to_moz_in_destructuring() ? "RestElement" : "SpreadElement",
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {
          return {
            type: "TaggedTemplateExpression",
            tag: to_moz(M.prefix),
            quasi: to_moz(M.template_string)
          };
        });
        def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {
          var quasis = [];
          var expressions = [];
          for (var i = 0; i < M.segments.length; i++) {
            if (i % 2 !== 0) {
              expressions.push(to_moz(M.segments[i]));
            } else {
              quasis.push({
                type: "TemplateElement",
                value: {
                  raw: M.segments[i].raw,
                  cooked: M.segments[i].value
                },
                tail: i === M.segments.length - 1
              });
            }
          }
          return {
            type: "TemplateLiteral",
            quasis,
            expressions
          };
        });
        def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {
          return {
            type: "FunctionDeclaration",
            id: to_moz(M.name),
            params: M.argnames.map(to_moz_pattern),
            generator: M.is_generator,
            async: M.async,
            body: to_moz_scope("BlockStatement", M)
          };
        });
        def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {
          return {
            type: "FunctionExpression",
            id: to_moz(M.name),
            params: M.argnames.map(to_moz_pattern),
            generator: M.is_generator || false,
            async: M.async || false,
            body: to_moz_scope("BlockStatement", M)
          };
        });
        def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {
          var body = M.body.length === 1 && M.body[0] instanceof AST_Return && M.body[0].value ? to_moz(M.body[0].value) : {
            type: "BlockStatement",
            body: M.body.map(to_moz)
          };
          return {
            type: "ArrowFunctionExpression",
            params: M.argnames.map(to_moz_pattern),
            async: M.async,
            body
          };
        });
        def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {
          if (M.is_array) {
            return {
              type: "ArrayPattern",
              elements: M.names.map((M2) => M2 instanceof AST_Hole ? null : to_moz_pattern(M2))
            };
          }
          return {
            type: "ObjectPattern",
            properties: M.names.map((M2) => {
              if (M2 instanceof AST_ObjectKeyVal) {
                var computed = M2.computed_key();
                const [shorthand, key] = to_moz_property_key(M2.key, computed, M2.quote, M2.value);
                return {
                  type: "Property",
                  computed,
                  kind: "init",
                  key,
                  method: false,
                  shorthand,
                  value: to_moz_pattern(M2.value)
                };
              } else {
                return to_moz_pattern(M2);
              }
            })
          };
        });
        def_to_moz(AST_DefaultAssign, function To_Moz_AssignmentExpression(M) {
          return {
            type: "AssignmentPattern",
            left: to_moz_pattern(M.left),
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_Directive, function To_Moz_Directive(M) {
          return {
            type: "ExpressionStatement",
            expression: {
              type: "Literal",
              value: M.value,
              raw: M.print_to_string()
            },
            directive: M.value
          };
        });
        def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {
          return {
            type: "ExpressionStatement",
            expression: to_moz(M.body)
          };
        });
        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
          return {
            type: "SwitchCase",
            test: to_moz(M.expression),
            consequent: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
          return {
            type: "TryStatement",
            block: to_moz_block(M.body),
            handler: to_moz(M.bcatch),
            guardedHandlers: [],
            finalizer: to_moz(M.bfinally)
          };
        });
        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
          return {
            type: "CatchClause",
            param: M.argname != null ? to_moz_pattern(M.argname) : null,
            body: to_moz_block(M)
          };
        });
        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
          return {
            type: "VariableDeclaration",
            kind: M instanceof AST_Const ? "const" : M instanceof AST_Let ? "let" : "var",
            declarations: M.definitions.map(to_moz)
          };
        });
        function import_attributes_to_moz(attribute) {
          const import_attributes = [];
          if (attribute) {
            for (const { key, value: value2 } of attribute.properties) {
              const key_moz = is_basic_identifier_string(key) ? { type: "Identifier", name: key } : { type: "Literal", value: key, raw: JSON.stringify(key) };
              import_attributes.push({
                type: "ImportAttribute",
                key: key_moz,
                value: to_moz(value2)
              });
            }
          }
          return import_attributes;
        }
        def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {
          if (M.exported_names) {
            var first_exported = M.exported_names[0];
            if (first_exported && first_exported.name.name === "*" && !first_exported.name.quote) {
              var foreign_name = first_exported.foreign_name;
              var exported = foreign_name.name === "*" && !foreign_name.quote ? null : to_moz(foreign_name);
              return {
                type: "ExportAllDeclaration",
                source: to_moz(M.module_name),
                exported,
                attributes: import_attributes_to_moz(M.attributes)
              };
            }
            return {
              type: "ExportNamedDeclaration",
              specifiers: M.exported_names.map(function(name_mapping) {
                return {
                  type: "ExportSpecifier",
                  exported: to_moz(name_mapping.foreign_name),
                  local: to_moz(name_mapping.name)
                };
              }),
              declaration: to_moz(M.exported_definition),
              source: to_moz(M.module_name),
              attributes: import_attributes_to_moz(M.attributes)
            };
          }
          if (M.is_default) {
            return {
              type: "ExportDefaultDeclaration",
              declaration: to_moz(M.exported_value || M.exported_definition)
            };
          } else {
            return {
              type: "ExportNamedDeclaration",
              declaration: to_moz(M.exported_value || M.exported_definition),
              specifiers: [],
              source: null
            };
          }
        });
        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {
          var specifiers = [];
          if (M.imported_name) {
            specifiers.push({
              type: "ImportDefaultSpecifier",
              local: to_moz(M.imported_name)
            });
          }
          if (M.imported_names) {
            var first_imported_foreign_name = M.imported_names[0].foreign_name;
            if (first_imported_foreign_name.name === "*" && !first_imported_foreign_name.quote) {
              specifiers.push({
                type: "ImportNamespaceSpecifier",
                local: to_moz(M.imported_names[0].name)
              });
            } else {
              M.imported_names.forEach(function(name_mapping) {
                specifiers.push({
                  type: "ImportSpecifier",
                  local: to_moz(name_mapping.name),
                  imported: to_moz(name_mapping.foreign_name)
                });
              });
            }
          }
          return {
            type: "ImportDeclaration",
            specifiers,
            source: to_moz(M.module_name),
            attributes: import_attributes_to_moz(M.attributes)
          };
        });
        def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {
          return {
            type: "MetaProperty",
            meta: {
              type: "Identifier",
              name: "import"
            },
            property: {
              type: "Identifier",
              name: "meta"
            }
          };
        });
        def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {
          return {
            type: "SequenceExpression",
            expressions: M.expressions.map(to_moz)
          };
        });
        def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {
          return {
            type: "MemberExpression",
            object: to_moz(M.expression),
            computed: false,
            property: {
              type: "PrivateIdentifier",
              name: M.property
            },
            optional: M.optional
          };
        });
        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
          var isComputed = M instanceof AST_Sub;
          return {
            type: "MemberExpression",
            object: to_moz(M.expression),
            computed: isComputed,
            property: isComputed ? to_moz(M.property) : { type: "Identifier", name: M.property },
            optional: M.optional
          };
        });
        def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {
          return {
            type: "ChainExpression",
            expression: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Unary, function To_Moz_Unary(M) {
          return {
            type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
            operator: M.operator,
            prefix: M instanceof AST_UnaryPrefix,
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
          if (M.operator == "=" && to_moz_in_destructuring()) {
            return {
              type: "AssignmentPattern",
              left: to_moz(M.left),
              right: to_moz(M.right)
            };
          }
          const type = M.operator == "&&" || M.operator == "||" || M.operator === "??" ? "LogicalExpression" : "BinaryExpression";
          return {
            type,
            left: to_moz(M.left),
            operator: M.operator,
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {
          return {
            type: "AssignmentExpression",
            operator: M.operator,
            left: to_moz(M.left),
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {
          return {
            type: "BinaryExpression",
            left: { type: "PrivateIdentifier", name: M.key.name },
            operator: "in",
            right: to_moz(M.value)
          };
        });
        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
          return {
            type: "ArrayExpression",
            elements: M.elements.map(to_moz)
          };
        });
        def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {
          return {
            type: "ObjectExpression",
            properties: M.properties.map(to_moz)
          };
        });
        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {
          var computed = M.computed_key();
          const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);
          var kind;
          if (M instanceof AST_ObjectGetter) {
            kind = "get";
          } else if (M instanceof AST_ObjectSetter) {
            kind = "set";
          }
          if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {
            const kind2 = M instanceof AST_PrivateGetter ? "get" : "set";
            return {
              type: "MethodDefinition",
              computed: false,
              kind: kind2,
              static: M.static,
              key: {
                type: "PrivateIdentifier",
                name: M.key.name
              },
              value: to_moz(M.value)
            };
          }
          if (M instanceof AST_ClassPrivateProperty) {
            return {
              type: "PropertyDefinition",
              key: {
                type: "PrivateIdentifier",
                name: M.key.name
              },
              value: to_moz(M.value),
              computed: false,
              static: M.static
            };
          }
          if (M instanceof AST_ClassProperty) {
            return {
              type: "PropertyDefinition",
              key,
              value: to_moz(M.value),
              computed,
              static: M.static
            };
          }
          if (parent instanceof AST_Class) {
            return {
              type: "MethodDefinition",
              computed,
              kind,
              static: M.static,
              key: to_moz(M.key),
              value: to_moz(M.value)
            };
          }
          return {
            type: "Property",
            computed,
            method: false,
            shorthand,
            kind,
            key,
            value: to_moz(M.value)
          };
        });
        def_to_moz(AST_ObjectKeyVal, function To_Moz_Property(M) {
          var computed = M.computed_key();
          const [shorthand, key] = to_moz_property_key(M.key, computed, M.quote, M.value);
          return {
            type: "Property",
            computed,
            shorthand,
            method: false,
            kind: "init",
            key,
            value: to_moz(M.value)
          };
        });
        def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {
          const computed = M.computed_key();
          const [_always_false, key] = to_moz_property_key(M.key, computed, M.quote, M.value);
          if (parent instanceof AST_Object) {
            return {
              type: "Property",
              kind: "init",
              computed,
              method: true,
              shorthand: false,
              key,
              value: to_moz(M.value)
            };
          }
          return {
            type: "MethodDefinition",
            kind: !computed && M.key.name === "constructor" ? "constructor" : "method",
            computed,
            key,
            value: to_moz(M.value),
            static: M.static
          };
        });
        def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M) {
          return {
            type: "MethodDefinition",
            kind: "method",
            key: { type: "PrivateIdentifier", name: M.key.name },
            value: to_moz(M.value),
            computed: false,
            static: M.static
          };
        });
        def_to_moz(AST_Class, function To_Moz_Class(M) {
          var type = M instanceof AST_ClassExpression ? "ClassExpression" : "ClassDeclaration";
          return {
            type,
            superClass: to_moz(M.extends),
            id: M.name ? to_moz(M.name) : null,
            body: {
              type: "ClassBody",
              body: M.properties.map(to_moz)
            }
          };
        });
        def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {
          return {
            type: "StaticBlock",
            body: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
          return {
            type: "MetaProperty",
            meta: {
              type: "Identifier",
              name: "new"
            },
            property: {
              type: "Identifier",
              name: "target"
            }
          };
        });
        def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {
          if (M instanceof AST_SymbolMethod && parent.quote || (M instanceof AST_SymbolImportForeign || M instanceof AST_SymbolExportForeign || M instanceof AST_SymbolExport) && M.quote) {
            return {
              type: "Literal",
              value: M.name
            };
          }
          var def = M.definition();
          return {
            type: "Identifier",
            name: def ? def.mangled_name || def.name : M.name
          };
        });
        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
          const pattern = M.value.source;
          const flags = M.value.flags;
          return {
            type: "Literal",
            value: null,
            raw: M.print_to_string(),
            regex: { pattern, flags }
          };
        });
        def_to_moz(AST_Constant, function To_Moz_Literal(M) {
          var value2 = M.value;
          return {
            type: "Literal",
            value: value2,
            raw: M.raw || M.print_to_string()
          };
        });
        def_to_moz(AST_Atom, function To_Moz_Atom(M) {
          return {
            type: "Identifier",
            name: String(M.value)
          };
        });
        def_to_moz(AST_BigInt, (M) => ({
          type: "Literal",
          value: null,
          bigint: typeof BigInt === "function" ? BigInt(M.value).toString() : M.value,
          raw: M.raw
        }));
        AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
        AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
        AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() {
          return null;
        });
        AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
        AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);
        function my_start_token(moznode) {
          var loc = moznode.loc, start = loc && loc.start;
          var range = moznode.range;
          return new AST_Token("", "", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);
        }
        function my_end_token(moznode) {
          var loc = moznode.loc, end = loc && loc.end;
          var range = moznode.range;
          return new AST_Token("", "", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);
        }
        var FROM_MOZ_LABELS = null;
        function from_moz(node) {
          if (node == null)
            return null;
          return MOZ_TO_ME[node.type](node);
        }
        function from_moz_quote(moz_key, computed) {
          if (!computed && moz_key.type === "Literal" && typeof moz_key.value === "string") {
            return '"';
          } else {
            return "";
          }
        }
        function from_moz_symbol(symbol_type, M, has_quote) {
          return new symbol_type({
            start: my_start_token(M),
            quote: has_quote ? '"' : void 0,
            name: M.type === "Identifier" ? M.name : String(M.value),
            end: my_end_token(M)
          });
        }
        function from_moz_lambda(M, is_method) {
          return new (is_method ? AST_Accessor : AST_Function)({
            start: my_start_token(M),
            end: my_end_token(M),
            name: M.id && from_moz_symbol(is_method ? AST_SymbolMethod : AST_SymbolLambda, M.id),
            argnames: M.params.map((M2) => from_moz_pattern(M2, AST_SymbolFunarg)),
            is_generator: M.generator,
            async: M.async,
            body: normalize_directives(from_moz(M.body).body)
          });
        }
        function from_moz_pattern(M, sym_type) {
          switch (M.type) {
            case "ObjectPattern":
              return new AST_Destructuring({
                start: my_start_token(M),
                end: my_end_token(M),
                names: M.properties.map((p) => from_moz_pattern(p, sym_type)),
                is_array: false
              });
            case "Property":
              var key = M.key;
              var args = {
                start: my_start_token(key || M.value),
                end: my_end_token(M.value),
                key: key.type == "Identifier" ? key.name : String(key.value),
                quote: !M.computed && key.type === "Literal" && typeof key.value === "string" ? '"' : "",
                value: from_moz_pattern(M.value, sym_type)
              };
              if (M.computed) {
                args.key = from_moz(M.key);
              }
              return new AST_ObjectKeyVal(args);
            case "ArrayPattern":
              return new AST_Destructuring({
                start: my_start_token(M),
                end: my_end_token(M),
                names: M.elements.map(function(elm) {
                  if (elm === null) {
                    return new AST_Hole();
                  }
                  return from_moz_pattern(elm, sym_type);
                }),
                is_array: true
              });
            case "SpreadElement":
            case "RestElement":
              return new AST_Expansion({
                start: my_start_token(M),
                end: my_end_token(M),
                expression: from_moz_pattern(M.argument, sym_type)
              });
            case "AssignmentPattern":
              return new AST_DefaultAssign({
                start: my_start_token(M),
                end: my_end_token(M),
                left: from_moz_pattern(M.left, sym_type),
                operator: "=",
                right: from_moz(M.right)
              });
            case "Identifier":
              return new sym_type({
                start: my_start_token(M),
                end: my_end_token(M),
                name: M.name
              });
            default:
              throw new Error("Invalid node type for destructuring: " + M.type);
          }
        }
        function from_moz_label_ref(m_label) {
          if (!m_label)
            return null;
          const label = from_moz_symbol(AST_LabelRef, m_label);
          let i = FROM_MOZ_LABELS.length;
          while (i--) {
            const label_origin = FROM_MOZ_LABELS[i];
            if (label.name === label_origin.name) {
              label.thedef = label_origin;
              break;
            }
          }
          return label;
        }
        AST_Node.from_mozilla_ast = function(node) {
          var save_labels = FROM_MOZ_LABELS;
          FROM_MOZ_LABELS = [];
          var ast = from_moz(node);
          FROM_MOZ_LABELS = save_labels;
          return ast;
        };
        function set_moz_loc(mynode, moznode) {
          var start = mynode.start;
          var end = mynode.end;
          if (!(start && end)) {
            return moznode;
          }
          if (start.pos != null && end.endpos != null) {
            moznode.range = [start.pos, end.endpos];
          }
          if (start.line) {
            moznode.loc = {
              start: { line: start.line, column: start.col },
              end: end.endline ? { line: end.endline, column: end.endcol } : null
            };
            if (start.file) {
              moznode.loc.source = start.file;
            }
          }
          return moznode;
        }
        function def_to_moz(mytype, handler) {
          mytype.DEFMETHOD("to_mozilla_ast", function(parent) {
            return set_moz_loc(this, handler(this, parent));
          });
        }
        var TO_MOZ_STACK = null;
        function to_moz(node) {
          if (TO_MOZ_STACK === null) {
            TO_MOZ_STACK = [];
          }
          TO_MOZ_STACK.push(node);
          var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;
          TO_MOZ_STACK.pop();
          if (TO_MOZ_STACK.length === 0) {
            TO_MOZ_STACK = null;
          }
          return ast;
        }
        function to_moz_property_key(key, computed = false, quote = false, value2 = null) {
          if (computed) {
            return [false, to_moz(key)];
          }
          const key_name = typeof key === "string" ? key : key.name;
          let moz_key;
          if (quote) {
            moz_key = { type: "Literal", value: key_name, raw: JSON.stringify(key_name) };
          } else if ("" + +key_name === key_name && +key_name >= 0) {
            moz_key = { type: "Literal", value: +key_name, raw: JSON.stringify(+key_name) };
          } else {
            moz_key = { type: "Identifier", name: key_name };
          }
          const shorthand = moz_key.type === "Identifier" && moz_key.name === key_name && (value2 instanceof AST_Symbol && value2.name === key_name || value2 instanceof AST_DefaultAssign && value2.left.name === key_name);
          return [shorthand, moz_key];
        }
        function to_moz_pattern(node) {
          if (node instanceof AST_Expansion) {
            return {
              type: "RestElement",
              argument: to_moz_pattern(node.expression)
            };
          }
          if (node instanceof AST_Symbol || node instanceof AST_Destructuring || node instanceof AST_DefaultAssign || node instanceof AST_PropAccess) {
            return to_moz(node);
          }
          throw new Error(node.TYPE);
        }
        function to_moz_in_destructuring() {
          var i = TO_MOZ_STACK.length;
          while (i--) {
            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {
              return true;
            }
          }
          return false;
        }
        function to_moz_block(node) {
          return {
            type: "BlockStatement",
            body: node.body.map(to_moz)
          };
        }
        function to_moz_scope(type, node) {
          var body = node.body.map(to_moz);
          if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
          }
          return {
            type,
            body
          };
        }
      })();
      function first_in_statement(stack) {
        let node = stack.parent(-1);
        for (let i = 0, p; p = stack.parent(i); i++) {
          if (p instanceof AST_Statement && p.body === node)
            return true;
          if (p instanceof AST_Sequence && p.expressions[0] === node || p.TYPE === "Call" && p.expression === node || p instanceof AST_PrefixedTemplateString && p.prefix === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Chain && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {
            node = p;
          } else {
            return false;
          }
        }
      }
      function left_is_object(node) {
        if (node instanceof AST_Object)
          return true;
        if (node instanceof AST_Sequence)
          return left_is_object(node.expressions[0]);
        if (node.TYPE === "Call")
          return left_is_object(node.expression);
        if (node instanceof AST_PrefixedTemplateString)
          return left_is_object(node.prefix);
        if (node instanceof AST_Dot || node instanceof AST_Sub)
          return left_is_object(node.expression);
        if (node instanceof AST_Chain)
          return left_is_object(node.expression);
        if (node instanceof AST_Conditional)
          return left_is_object(node.condition);
        if (node instanceof AST_Binary)
          return left_is_object(node.left);
        if (node instanceof AST_UnaryPostfix)
          return left_is_object(node.expression);
        return false;
      }
      const CODE_LINE_BREAK = 10;
      const CODE_SPACE = 32;
      const r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/;
      function is_some_comments(comment) {
        return (comment.type === "comment2" || comment.type === "comment1") && /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(comment.value);
      }
      const ROPE_COMMIT_WHEN = 8 * 1e3;
      class Rope {
        constructor() {
          this.committed = "";
          this.current = "";
        }
        append(str) {
          if (this.current.length > ROPE_COMMIT_WHEN) {
            this.committed += this.current + str;
            this.current = "";
          } else {
            this.current += str;
          }
        }
        insertAt(char2, index) {
          const { committed, current } = this;
          if (index < committed.length) {
            this.committed = committed.slice(0, index) + char2 + committed.slice(index);
          } else if (index === committed.length) {
            this.committed += char2;
          } else {
            index -= committed.length;
            this.committed += current.slice(0, index) + char2;
            this.current = current.slice(index);
          }
        }
        charAt(index) {
          const { committed } = this;
          if (index < committed.length)
            return committed[index];
          return this.current[index - committed.length];
        }
        charCodeAt(index) {
          const { committed } = this;
          if (index < committed.length)
            return committed.charCodeAt(index);
          return this.current.charCodeAt(index - committed.length);
        }
        length() {
          return this.committed.length + this.current.length;
        }
        expectDirective() {
          let ch, n2 = this.length();
          if (n2 <= 0)
            return true;
          while ((ch = this.charCodeAt(--n2)) && (ch == CODE_SPACE || ch == CODE_LINE_BREAK))
            ;
          return !ch || ch === 59 || ch === 123;
        }
        hasNLB() {
          let n2 = this.length() - 1;
          while (n2 >= 0) {
            const code = this.charCodeAt(n2--);
            if (code === CODE_LINE_BREAK)
              return true;
            if (code !== CODE_SPACE)
              return false;
          }
          return true;
        }
        toString() {
          return this.committed + this.current;
        }
      }
      function OutputStream(options) {
        var readonly = !options;
        options = defaults(options, {
          ascii_only: false,
          beautify: false,
          braces: false,
          comments: "some",
          ecma: 5,
          ie8: false,
          indent_level: 4,
          indent_start: 0,
          inline_script: true,
          keep_numbers: false,
          keep_quoted_props: false,
          max_line_len: false,
          preamble: null,
          preserve_annotations: false,
          quote_keys: false,
          quote_style: 0,
          safari10: false,
          semicolons: true,
          shebang: true,
          shorthand: void 0,
          source_map: null,
          webkit: false,
          width: 80,
          wrap_iife: false,
          wrap_func_args: false,
          _destroy_ast: false
        }, true);
        if (options.shorthand === void 0)
          options.shorthand = options.ecma > 5;
        var comment_filter = return_false;
        if (options.comments) {
          let comments = options.comments;
          if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
            var regex_pos = options.comments.lastIndexOf("/");
            comments = new RegExp(options.comments.substr(1, regex_pos - 1), options.comments.substr(regex_pos + 1));
          }
          if (comments instanceof RegExp) {
            comment_filter = function(comment) {
              return comment.type != "comment5" && comments.test(comment.value);
            };
          } else if (typeof comments === "function") {
            comment_filter = function(comment) {
              return comment.type != "comment5" && comments(this, comment);
            };
          } else if (comments === "some") {
            comment_filter = is_some_comments;
          } else {
            comment_filter = return_true;
          }
        }
        if (options.preserve_annotations) {
          let prev_comment_filter = comment_filter;
          comment_filter = function(comment) {
            return r_annotation.test(comment.value) || prev_comment_filter.apply(this, arguments);
          };
        }
        var indentation = 0;
        var current_col = 0;
        var current_line = 1;
        var current_pos = 0;
        var OUTPUT = new Rope();
        let printed_comments = /* @__PURE__ */ new Set();
        var to_utf8 = options.ascii_only ? function(str, identifier = false, regexp = false) {
          if (options.ecma >= 2015 && !options.safari10 && !regexp) {
            str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
              var code = get_full_char_code(ch, 0).toString(16);
              return "\\u{" + code + "}";
            });
          }
          return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
              while (code.length < 2)
                code = "0" + code;
              return "\\x" + code;
            } else {
              while (code.length < 4)
                code = "0" + code;
              return "\\u" + code;
            }
          });
        } : function(str) {
          return str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(match, lone) {
            if (lone) {
              return "\\u" + lone.charCodeAt(0).toString(16);
            }
            return match;
          });
        };
        function make_string(str, quote) {
          var dq = 0, sq = 0;
          str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, function(s, i) {
            switch (s) {
              case '"':
                ++dq;
                return '"';
              case "'":
                ++sq;
                return "'";
              case "\\":
                return "\\\\";
              case "\n":
                return "\\n";
              case "\r":
                return "\\r";
              case "	":
                return "\\t";
              case "\b":
                return "\\b";
              case "\f":
                return "\\f";
              case "\v":
                return options.ie8 ? "\\x0B" : "\\v";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              case "\uFEFF":
                return "\\ufeff";
              case "\0":
                return /[0-9]/.test(get_full_char(str, i + 1)) ? "\\x00" : "\\0";
            }
            return s;
          });
          function quote_single() {
            return "'" + str.replace(/\x27/g, "\\'") + "'";
          }
          function quote_double() {
            return '"' + str.replace(/\x22/g, '\\"') + '"';
          }
          function quote_template() {
            return "`" + str.replace(/`/g, "\\`") + "`";
          }
          str = to_utf8(str);
          if (quote === "`")
            return quote_template();
          switch (options.quote_style) {
            case 1:
              return quote_single();
            case 2:
              return quote_double();
            case 3:
              return quote == "'" ? quote_single() : quote_double();
            default:
              return dq > sq ? quote_single() : quote_double();
          }
        }
        function encode_string(str, quote) {
          var ret = make_string(str, quote);
          if (options.inline_script) {
            ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
            ret = ret.replace(/\x3c!--/g, "\\x3c!--");
            ret = ret.replace(/--\x3e/g, "--\\x3e");
          }
          return ret;
        }
        function make_name(name) {
          name = name.toString();
          name = to_utf8(name, true);
          return name;
        }
        function make_indent(back) {
          return " ".repeat(options.indent_start + indentation - back * options.indent_level);
        }
        var has_parens = false;
        var might_need_space = false;
        var might_need_semicolon = false;
        var might_add_newline = 0;
        var need_newline_indented = false;
        var need_space = false;
        var newline_insert = -1;
        var last = "";
        var mapping_token, mapping_name, mappings = options.source_map && [];
        var do_add_mapping = mappings ? function() {
          mappings.forEach(function(mapping) {
            try {
              let { name, token } = mapping;
              if (name !== false) {
                if (token.type == "name" || token.type === "privatename") {
                  name = token.value;
                } else if (name instanceof AST_Symbol) {
                  name = token.type === "string" ? token.value : name.name;
                }
              }
              options.source_map.add(mapping.token.file, mapping.line, mapping.col, mapping.token.line, mapping.token.col, is_basic_identifier_string(name) ? name : void 0);
            } catch (ex) {
            }
          });
          mappings = [];
        } : noop2;
        var ensure_line_len = options.max_line_len ? function() {
          if (current_col > options.max_line_len) {
            if (might_add_newline) {
              OUTPUT.insertAt("\n", might_add_newline);
              const len_after_newline = OUTPUT.length() - might_add_newline - 1;
              if (mappings) {
                var delta = len_after_newline - current_col;
                mappings.forEach(function(mapping) {
                  mapping.line++;
                  mapping.col += delta;
                });
              }
              current_line++;
              current_pos++;
              current_col = len_after_newline;
            }
          }
          if (might_add_newline) {
            might_add_newline = 0;
            do_add_mapping();
          }
        } : noop2;
        var requireSemicolonChars = makePredicate("( [ + * / - , . `");
        function print(str) {
          str = String(str);
          var ch = get_full_char(str, 0);
          if (need_newline_indented && ch) {
            need_newline_indented = false;
            if (ch !== "\n") {
              print("\n");
              indent();
            }
          }
          if (need_space && ch) {
            need_space = false;
            if (!/[\s;})]/.test(ch)) {
              space2();
            }
          }
          newline_insert = -1;
          var prev = last.charAt(last.length - 1);
          if (might_need_semicolon) {
            might_need_semicolon = false;
            if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
              if (options.semicolons || requireSemicolonChars.has(ch)) {
                OUTPUT.append(";");
                current_col++;
                current_pos++;
              } else {
                ensure_line_len();
                if (current_col > 0) {
                  OUTPUT.append("\n");
                  current_pos++;
                  current_line++;
                  current_col = 0;
                }
                if (/^\s+$/.test(str)) {
                  might_need_semicolon = true;
                }
              }
              if (!options.beautify)
                might_need_space = false;
            }
          }
          if (might_need_space) {
            if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last) {
              OUTPUT.append(" ");
              current_col++;
              current_pos++;
            }
            might_need_space = false;
          }
          if (mapping_token) {
            mappings.push({
              token: mapping_token,
              name: mapping_name,
              line: current_line,
              col: current_col
            });
            mapping_token = false;
            if (!might_add_newline)
              do_add_mapping();
          }
          OUTPUT.append(str);
          has_parens = str[str.length - 1] == "(";
          current_pos += str.length;
          var a = str.split(/\r?\n/), n2 = a.length - 1;
          current_line += n2;
          current_col += a[0].length;
          if (n2 > 0) {
            ensure_line_len();
            current_col = a[n2].length;
          }
          last = str;
        }
        var star = function() {
          print("*");
        };
        var space2 = options.beautify ? function() {
          print(" ");
        } : function() {
          might_need_space = true;
        };
        var indent = options.beautify ? function(half) {
          if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
          }
        } : noop2;
        var with_indent = options.beautify ? function(col, cont) {
          if (col === true)
            col = next_indent();
          var save_indentation = indentation;
          indentation = col;
          var ret = cont();
          indentation = save_indentation;
          return ret;
        } : function(col, cont) {
          return cont();
        };
        var newline = options.beautify ? function() {
          if (newline_insert < 0)
            return print("\n");
          if (OUTPUT.charAt(newline_insert) != "\n") {
            OUTPUT.insertAt("\n", newline_insert);
            current_pos++;
            current_line++;
          }
          newline_insert++;
        } : options.max_line_len ? function() {
          ensure_line_len();
          might_add_newline = OUTPUT.length();
        } : noop2;
        var semicolon = options.beautify ? function() {
          print(";");
        } : function() {
          might_need_semicolon = true;
        };
        function force_semicolon() {
          might_need_semicolon = false;
          print(";");
        }
        function next_indent() {
          return indentation + options.indent_level;
        }
        function with_block(cont) {
          var ret;
          print("{");
          newline();
          with_indent(next_indent(), function() {
            ret = cont();
          });
          indent();
          print("}");
          return ret;
        }
        function with_parens(cont) {
          print("(");
          var ret = cont();
          print(")");
          return ret;
        }
        function with_square(cont) {
          print("[");
          var ret = cont();
          print("]");
          return ret;
        }
        function comma() {
          print(",");
          space2();
        }
        function colon() {
          print(":");
          space2();
        }
        var add_mapping = mappings ? function(token, name) {
          mapping_token = token;
          mapping_name = name;
        } : noop2;
        function get() {
          if (might_add_newline) {
            ensure_line_len();
          }
          return OUTPUT.toString();
        }
        function filter_comment(comment) {
          if (!options.preserve_annotations) {
            comment = comment.replace(r_annotation, " ");
          }
          if (/^\s*$/.test(comment)) {
            return "";
          }
          return comment.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
        }
        function prepend_comments(node) {
          var self2 = this;
          var start = node.start;
          if (!start)
            return;
          var printed_comments2 = self2.printed_comments;
          const keyword_with_value = node instanceof AST_Exit && node.value || (node instanceof AST_Await || node instanceof AST_Yield) && node.expression;
          if (start.comments_before && printed_comments2.has(start.comments_before)) {
            if (keyword_with_value) {
              start.comments_before = [];
            } else {
              return;
            }
          }
          var comments = start.comments_before;
          if (!comments) {
            comments = start.comments_before = [];
          }
          printed_comments2.add(comments);
          if (keyword_with_value) {
            var tw = new TreeWalker(function(node2) {
              var parent = tw.parent();
              if (parent instanceof AST_Exit || parent instanceof AST_Await || parent instanceof AST_Yield || parent instanceof AST_Binary && parent.left === node2 || parent.TYPE == "Call" && parent.expression === node2 || parent instanceof AST_Conditional && parent.condition === node2 || parent instanceof AST_Dot && parent.expression === node2 || parent instanceof AST_Sequence && parent.expressions[0] === node2 || parent instanceof AST_Sub && parent.expression === node2 || parent instanceof AST_UnaryPostfix) {
                if (!node2.start)
                  return;
                var text3 = node2.start.comments_before;
                if (text3 && !printed_comments2.has(text3)) {
                  printed_comments2.add(text3);
                  comments = comments.concat(text3);
                }
              } else {
                return true;
              }
            });
            tw.push(node);
            keyword_with_value.walk(tw);
          }
          if (current_pos == 0) {
            if (comments.length > 0 && options.shebang && comments[0].type === "comment5" && !printed_comments2.has(comments[0])) {
              print("#!" + comments.shift().value + "\n");
              indent();
            }
            var preamble = options.preamble;
            if (preamble) {
              print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }
          }
          comments = comments.filter(comment_filter, node).filter((c) => !printed_comments2.has(c));
          if (comments.length == 0)
            return;
          var last_nlb = OUTPUT.hasNLB();
          comments.forEach(function(c, i) {
            printed_comments2.add(c);
            if (!last_nlb) {
              if (c.nlb) {
                print("\n");
                indent();
                last_nlb = true;
              } else if (i > 0) {
                space2();
              }
            }
            if (/comment[134]/.test(c.type)) {
              var value2 = filter_comment(c.value);
              if (value2) {
                print("//" + value2 + "\n");
                indent();
              }
              last_nlb = true;
            } else if (c.type == "comment2") {
              var value2 = filter_comment(c.value);
              if (value2) {
                print("/*" + value2 + "*/");
              }
              last_nlb = false;
            }
          });
          if (!last_nlb) {
            if (start.nlb) {
              print("\n");
              indent();
            } else {
              space2();
            }
          }
        }
        function append_comments(node, tail) {
          var self2 = this;
          var token = node.end;
          if (!token)
            return;
          var printed_comments2 = self2.printed_comments;
          var comments = token[tail ? "comments_before" : "comments_after"];
          if (!comments || printed_comments2.has(comments))
            return;
          if (!(node instanceof AST_Statement || comments.every((c) => !/comment[134]/.test(c.type))))
            return;
          printed_comments2.add(comments);
          var insert2 = OUTPUT.length();
          comments.filter(comment_filter, node).forEach(function(c, i) {
            if (printed_comments2.has(c))
              return;
            printed_comments2.add(c);
            need_space = false;
            if (need_newline_indented) {
              print("\n");
              indent();
              need_newline_indented = false;
            } else if (c.nlb && (i > 0 || !OUTPUT.hasNLB())) {
              print("\n");
              indent();
            } else if (i > 0 || !tail) {
              space2();
            }
            if (/comment[134]/.test(c.type)) {
              const value2 = filter_comment(c.value);
              if (value2) {
                print("//" + value2);
              }
              need_newline_indented = true;
            } else if (c.type == "comment2") {
              const value2 = filter_comment(c.value);
              if (value2) {
                print("/*" + value2 + "*/");
              }
              need_space = true;
            }
          });
          if (OUTPUT.length() > insert2)
            newline_insert = insert2;
        }
        const gc_scope = options["_destroy_ast"] ? function gc_scope2(scope) {
          scope.body.length = 0;
          scope.argnames.length = 0;
        } : noop2;
        var stack = [];
        return {
          get,
          toString: get,
          indent,
          in_directive: false,
          use_asm: null,
          active_scope: null,
          indentation: function() {
            return indentation;
          },
          current_width: function() {
            return current_col - indentation;
          },
          should_break: function() {
            return options.width && this.current_width() >= options.width;
          },
          has_parens: function() {
            return has_parens;
          },
          newline,
          print,
          star,
          space: space2,
          comma,
          colon,
          last: function() {
            return last;
          },
          semicolon,
          force_semicolon,
          to_utf8,
          print_name: function(name) {
            print(make_name(name));
          },
          print_string: function(str, quote, escape_directive) {
            var encoded = encode_string(str, quote);
            if (escape_directive === true && !encoded.includes("\\")) {
              if (!OUTPUT.expectDirective()) {
                force_semicolon();
              }
              force_semicolon();
            }
            print(encoded);
          },
          print_template_string_chars: function(str) {
            var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
            return print(encoded.substr(1, encoded.length - 2));
          },
          encode_string,
          next_indent,
          with_indent,
          with_block,
          with_parens,
          with_square,
          add_mapping,
          option: function(opt) {
            return options[opt];
          },
          gc_scope,
          printed_comments,
          prepend_comments: readonly ? noop2 : prepend_comments,
          append_comments: readonly || comment_filter === return_false ? noop2 : append_comments,
          line: function() {
            return current_line;
          },
          col: function() {
            return current_col;
          },
          pos: function() {
            return current_pos;
          },
          push_node: function(node) {
            stack.push(node);
          },
          pop_node: function() {
            return stack.pop();
          },
          parent: function(n2) {
            return stack[stack.length - 2 - (n2 || 0)];
          }
        };
      }
      (function() {
        function DEFPRINT(nodetype, generator) {
          nodetype.DEFMETHOD("_codegen", generator);
        }
        AST_Node.DEFMETHOD("print", function(output, force_parens) {
          var self2 = this, generator = self2._codegen;
          if (self2 instanceof AST_Scope) {
            output.active_scope = self2;
          } else if (!output.use_asm && self2 instanceof AST_Directive && self2.value == "use asm") {
            output.use_asm = output.active_scope;
          }
          function doit() {
            output.prepend_comments(self2);
            self2.add_source_map(output);
            generator(self2, output);
            output.append_comments(self2);
          }
          output.push_node(self2);
          if (force_parens || self2.needs_parens(output)) {
            output.with_parens(doit);
          } else {
            doit();
          }
          output.pop_node();
          if (self2 === output.use_asm) {
            output.use_asm = null;
          }
        });
        AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);
        AST_Node.DEFMETHOD("print_to_string", function(options) {
          var output = OutputStream(options);
          this.print(output);
          return output.get();
        });
        function PARENS(nodetype, func) {
          if (Array.isArray(nodetype)) {
            nodetype.forEach(function(nodetype2) {
              PARENS(nodetype2, func);
            });
          } else {
            nodetype.DEFMETHOD("needs_parens", func);
          }
        }
        PARENS(AST_Node, return_false);
        PARENS(AST_Function, function(output) {
          if (!output.has_parens() && first_in_statement(output)) {
            return true;
          }
          if (output.option("webkit")) {
            var p = output.parent();
            if (p instanceof AST_PropAccess && p.expression === this) {
              return true;
            }
          }
          if (output.option("wrap_iife")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.expression === this) {
              return true;
            }
          }
          if (output.option("wrap_func_args")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.args.includes(this)) {
              return true;
            }
          }
          return false;
        });
        PARENS(AST_Arrow, function(output) {
          var p = output.parent();
          if (output.option("wrap_func_args") && p instanceof AST_Call && p.args.includes(this)) {
            return true;
          }
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Conditional && p.condition === this;
        });
        PARENS(AST_Object, function(output) {
          return !output.has_parens() && first_in_statement(output);
        });
        PARENS(AST_ClassExpression, first_in_statement);
        PARENS(AST_Unary, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Call && p.expression === this || p instanceof AST_Binary && p.operator === "**" && this instanceof AST_UnaryPrefix && p.left === this && this.operator !== "++" && this.operator !== "--";
        });
        PARENS(AST_Await, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Call && p.expression === this || p instanceof AST_Binary && p.operator === "**" && p.left === this || output.option("safari10") && p instanceof AST_UnaryPrefix;
        });
        PARENS(AST_Sequence, function(output) {
          var p = output.parent();
          return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_PropAccess || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional || p instanceof AST_Arrow || p instanceof AST_DefaultAssign || p instanceof AST_Expansion || p instanceof AST_ForOf && this === p.object || p instanceof AST_Yield || p instanceof AST_Export;
        });
        PARENS(AST_Binary, function(output) {
          var p = output.parent();
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
          if (p instanceof AST_Binary) {
            const parent_op = p.operator;
            const op = this.operator;
            if (op === "??" && (parent_op === "||" || parent_op === "&&")) {
              return true;
            }
            if (parent_op === "??" && (op === "||" || op === "&&")) {
              return true;
            }
            const pp = PRECEDENCE[parent_op];
            const sp = PRECEDENCE[op];
            if (pp > sp || pp == sp && (this === p.right || parent_op == "**")) {
              return true;
            }
          }
          if (p instanceof AST_PrivateIn) {
            const op = this.operator;
            const pp = PRECEDENCE["in"];
            const sp = PRECEDENCE[op];
            if (pp > sp || pp == sp && this === p.value) {
              return true;
            }
          }
        });
        PARENS(AST_PrivateIn, function(output) {
          var p = output.parent();
          if (p instanceof AST_Call && p.expression === this) {
            return true;
          }
          if (p instanceof AST_Unary) {
            return true;
          }
          if (p instanceof AST_PropAccess && p.expression === this) {
            return true;
          }
          if (p instanceof AST_Binary) {
            const parent_op = p.operator;
            const pp = PRECEDENCE[parent_op];
            const sp = PRECEDENCE["in"];
            if (pp > sp || pp == sp && (this === p.right || parent_op == "**")) {
              return true;
            }
          }
          if (p instanceof AST_PrivateIn && this === p.value) {
            return true;
          }
        });
        PARENS(AST_Yield, function(output) {
          var p = output.parent();
          if (p instanceof AST_Binary && p.operator !== "=")
            return true;
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Conditional && p.condition === this)
            return true;
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        });
        PARENS(AST_Chain, function(output) {
          var p = output.parent();
          if (!(p instanceof AST_Call || p instanceof AST_PropAccess))
            return false;
          return p.expression === this;
        });
        PARENS(AST_PropAccess, function(output) {
          var p = output.parent();
          if (p instanceof AST_New && p.expression === this) {
            return walk(this, (node) => {
              if (node instanceof AST_Scope)
                return true;
              if (node instanceof AST_Call) {
                return walk_abort;
              }
            });
          }
        });
        PARENS(AST_Call, function(output) {
          var p = output.parent(), p1;
          if (p instanceof AST_New && p.expression === this || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)
            return true;
          return this.expression instanceof AST_Function && p instanceof AST_PropAccess && p.expression === this && (p1 = output.parent(1)) instanceof AST_Assign && p1.left === p;
        });
        PARENS(AST_New, function(output) {
          var p = output.parent();
          if (this.args.length === 0 && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this || p instanceof AST_PrefixedTemplateString && p.prefix === this))
            return true;
        });
        PARENS(AST_Number, function(output) {
          var p = output.parent();
          if (p instanceof AST_PropAccess && p.expression === this) {
            var value2 = this.getValue();
            if (value2 < 0 || /^0/.test(make_num(value2))) {
              return true;
            }
          }
        });
        PARENS(AST_BigInt, function(output) {
          var p = output.parent();
          if (p instanceof AST_PropAccess && p.expression === this) {
            var value2 = this.getValue();
            if (value2.startsWith("-")) {
              return true;
            }
          }
        });
        PARENS([AST_Assign, AST_Conditional], function(output) {
          var p = output.parent();
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Conditional && p.condition === this)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
          if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)
            return true;
        });
        DEFPRINT(AST_Directive, function(self2, output) {
          output.print_string(self2.value, self2.quote);
          output.semicolon();
        });
        DEFPRINT(AST_Expansion, function(self2, output) {
          output.print("...");
          self2.expression.print(output);
        });
        DEFPRINT(AST_Destructuring, function(self2, output) {
          output.print(self2.is_array ? "[" : "{");
          var len = self2.names.length;
          self2.names.forEach(function(name, i) {
            if (i > 0)
              output.comma();
            name.print(output);
            if (i == len - 1 && name instanceof AST_Hole)
              output.comma();
          });
          output.print(self2.is_array ? "]" : "}");
        });
        DEFPRINT(AST_Debugger, function(self2, output) {
          output.print("debugger");
          output.semicolon();
        });
        function display_body(body, is_toplevel, output, allow_directives) {
          var last = body.length - 1;
          output.in_directive = allow_directives;
          body.forEach(function(stmt, i) {
            if (output.in_directive === true && !(stmt instanceof AST_Directive || stmt instanceof AST_EmptyStatement || stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)) {
              output.in_directive = false;
            }
            if (!(stmt instanceof AST_EmptyStatement)) {
              output.indent();
              stmt.print(output);
              if (!(i == last && is_toplevel)) {
                output.newline();
                if (is_toplevel)
                  output.newline();
              }
            }
            if (output.in_directive === true && stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {
              output.in_directive = false;
            }
          });
          output.in_directive = false;
        }
        AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
          print_maybe_braced_body(this.body, output);
        });
        DEFPRINT(AST_Statement, function(self2, output) {
          self2.body.print(output);
          output.semicolon();
        });
        DEFPRINT(AST_Toplevel, function(self2, output) {
          display_body(self2.body, true, output, true);
          output.print("");
        });
        DEFPRINT(AST_LabeledStatement, function(self2, output) {
          self2.label.print(output);
          output.colon();
          self2.body.print(output);
        });
        DEFPRINT(AST_SimpleStatement, function(self2, output) {
          self2.body.print(output);
          output.semicolon();
        });
        function print_braced_empty(self2, output) {
          output.print("{");
          output.with_indent(output.next_indent(), function() {
            output.append_comments(self2, true);
          });
          output.add_mapping(self2.end);
          output.print("}");
        }
        function print_braced(self2, output, allow_directives) {
          if (self2.body.length > 0) {
            output.with_block(function() {
              display_body(self2.body, false, output, allow_directives);
              output.add_mapping(self2.end);
            });
          } else
            print_braced_empty(self2, output);
        }
        DEFPRINT(AST_BlockStatement, function(self2, output) {
          print_braced(self2, output);
        });
        DEFPRINT(AST_EmptyStatement, function(self2, output) {
          output.semicolon();
        });
        DEFPRINT(AST_Do, function(self2, output) {
          output.print("do");
          output.space();
          make_block(self2.body, output);
          output.space();
          output.print("while");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.semicolon();
        });
        DEFPRINT(AST_While, function(self2, output) {
          output.print("while");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_For, function(self2, output) {
          output.print("for");
          output.space();
          output.with_parens(function() {
            if (self2.init) {
              if (self2.init instanceof AST_Definitions) {
                self2.init.print(output);
              } else {
                parenthesize_for_noin(self2.init, output, true);
              }
              output.print(";");
              output.space();
            } else {
              output.print(";");
            }
            if (self2.condition) {
              self2.condition.print(output);
              output.print(";");
              output.space();
            } else {
              output.print(";");
            }
            if (self2.step) {
              self2.step.print(output);
            }
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_ForIn, function(self2, output) {
          output.print("for");
          if (self2.await) {
            output.space();
            output.print("await");
          }
          output.space();
          output.with_parens(function() {
            self2.init.print(output);
            output.space();
            output.print(self2 instanceof AST_ForOf ? "of" : "in");
            output.space();
            self2.object.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_With, function(self2, output) {
          output.print("with");
          output.space();
          output.with_parens(function() {
            self2.expression.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
          var self2 = this;
          if (!nokeyword) {
            if (self2.async) {
              output.print("async");
              output.space();
            }
            output.print("function");
            if (self2.is_generator) {
              output.star();
            }
            if (self2.name) {
              output.space();
            }
          }
          if (self2.name instanceof AST_Symbol) {
            self2.name.print(output);
          } else if (nokeyword && self2.name instanceof AST_Node) {
            output.with_square(function() {
              self2.name.print(output);
            });
          }
          output.with_parens(function() {
            self2.argnames.forEach(function(arg, i) {
              if (i)
                output.comma();
              arg.print(output);
            });
          });
          output.space();
          print_braced(self2, output, true);
        });
        DEFPRINT(AST_Lambda, function(self2, output) {
          self2._do_print(output);
          output.gc_scope(self2);
        });
        DEFPRINT(AST_PrefixedTemplateString, function(self2, output) {
          var tag = self2.prefix;
          var parenthesize_tag = tag instanceof AST_Lambda || tag instanceof AST_Binary || tag instanceof AST_Conditional || tag instanceof AST_Sequence || tag instanceof AST_Unary || tag instanceof AST_Dot && tag.expression instanceof AST_Object;
          if (parenthesize_tag)
            output.print("(");
          self2.prefix.print(output);
          if (parenthesize_tag)
            output.print(")");
          self2.template_string.print(output);
        });
        DEFPRINT(AST_TemplateString, function(self2, output) {
          var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;
          output.print("`");
          for (var i = 0; i < self2.segments.length; i++) {
            if (!(self2.segments[i] instanceof AST_TemplateSegment)) {
              output.print("${");
              self2.segments[i].print(output);
              output.print("}");
            } else if (is_tagged) {
              output.print(self2.segments[i].raw);
            } else {
              output.print_template_string_chars(self2.segments[i].value);
            }
          }
          output.print("`");
        });
        DEFPRINT(AST_TemplateSegment, function(self2, output) {
          output.print_template_string_chars(self2.value);
        });
        AST_Arrow.DEFMETHOD("_do_print", function(output) {
          var self2 = this;
          var parent = output.parent();
          var needs_parens = parent instanceof AST_Binary && !(parent instanceof AST_Assign) && !(parent instanceof AST_DefaultAssign) || parent instanceof AST_Unary || parent instanceof AST_Call && self2 === parent.expression;
          if (needs_parens) {
            output.print("(");
          }
          if (self2.async) {
            output.print("async");
            output.space();
          }
          if (self2.argnames.length === 1 && self2.argnames[0] instanceof AST_Symbol) {
            self2.argnames[0].print(output);
          } else {
            output.with_parens(function() {
              self2.argnames.forEach(function(arg, i) {
                if (i)
                  output.comma();
                arg.print(output);
              });
            });
          }
          output.space();
          output.print("=>");
          output.space();
          const first_statement = self2.body[0];
          if (self2.body.length === 1 && first_statement instanceof AST_Return) {
            const returned = first_statement.value;
            if (!returned) {
              output.print("{}");
            } else if (left_is_object(returned)) {
              output.print("(");
              returned.print(output);
              output.print(")");
            } else {
              returned.print(output);
            }
          } else {
            print_braced(self2, output);
          }
          if (needs_parens) {
            output.print(")");
          }
          output.gc_scope(self2);
        });
        AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          if (this.value) {
            output.space();
            const comments = this.value.start.comments_before;
            if (comments && comments.length && !output.printed_comments.has(comments)) {
              output.print("(");
              this.value.print(output);
              output.print(")");
            } else {
              this.value.print(output);
            }
          }
          output.semicolon();
        });
        DEFPRINT(AST_Return, function(self2, output) {
          self2._do_print(output, "return");
        });
        DEFPRINT(AST_Throw, function(self2, output) {
          self2._do_print(output, "throw");
        });
        DEFPRINT(AST_Yield, function(self2, output) {
          var star = self2.is_star ? "*" : "";
          output.print("yield" + star);
          if (self2.expression) {
            output.space();
            self2.expression.print(output);
          }
        });
        DEFPRINT(AST_Await, function(self2, output) {
          output.print("await");
          output.space();
          var e = self2.expression;
          var parens = !(e instanceof AST_Call || e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Unary || e instanceof AST_Constant || e instanceof AST_Await || e instanceof AST_Object);
          if (parens)
            output.print("(");
          self2.expression.print(output);
          if (parens)
            output.print(")");
        });
        AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          if (this.label) {
            output.space();
            this.label.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_Break, function(self2, output) {
          self2._do_print(output, "break");
        });
        DEFPRINT(AST_Continue, function(self2, output) {
          self2._do_print(output, "continue");
        });
        function make_then(self2, output) {
          var b = self2.body;
          if (output.option("braces") || output.option("ie8") && b instanceof AST_Do)
            return make_block(b, output);
          if (!b)
            return output.force_semicolon();
          while (true) {
            if (b instanceof AST_If) {
              if (!b.alternative) {
                make_block(self2.body, output);
                return;
              }
              b = b.alternative;
            } else if (b instanceof AST_StatementWithBody) {
              b = b.body;
            } else
              break;
          }
          print_maybe_braced_body(self2.body, output);
        }
        DEFPRINT(AST_If, function(self2, output) {
          output.print("if");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.space();
          if (self2.alternative) {
            make_then(self2, output);
            output.space();
            output.print("else");
            output.space();
            if (self2.alternative instanceof AST_If)
              self2.alternative.print(output);
            else
              print_maybe_braced_body(self2.alternative, output);
          } else {
            self2._do_print_body(output);
          }
        });
        DEFPRINT(AST_Switch, function(self2, output) {
          output.print("switch");
          output.space();
          output.with_parens(function() {
            self2.expression.print(output);
          });
          output.space();
          var last = self2.body.length - 1;
          if (last < 0)
            print_braced_empty(self2, output);
          else
            output.with_block(function() {
              self2.body.forEach(function(branch, i) {
                output.indent(true);
                branch.print(output);
                if (i < last && branch.body.length > 0)
                  output.newline();
              });
            });
        });
        AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
          output.newline();
          this.body.forEach(function(stmt) {
            output.indent();
            stmt.print(output);
            output.newline();
          });
        });
        DEFPRINT(AST_Default, function(self2, output) {
          output.print("default:");
          self2._do_print_body(output);
        });
        DEFPRINT(AST_Case, function(self2, output) {
          output.print("case");
          output.space();
          self2.expression.print(output);
          output.print(":");
          self2._do_print_body(output);
        });
        DEFPRINT(AST_Try, function(self2, output) {
          output.print("try");
          output.space();
          self2.body.print(output);
          if (self2.bcatch) {
            output.space();
            self2.bcatch.print(output);
          }
          if (self2.bfinally) {
            output.space();
            self2.bfinally.print(output);
          }
        });
        DEFPRINT(AST_TryBlock, function(self2, output) {
          print_braced(self2, output);
        });
        DEFPRINT(AST_Catch, function(self2, output) {
          output.print("catch");
          if (self2.argname) {
            output.space();
            output.with_parens(function() {
              self2.argname.print(output);
            });
          }
          output.space();
          print_braced(self2, output);
        });
        DEFPRINT(AST_Finally, function(self2, output) {
          output.print("finally");
          output.space();
          print_braced(self2, output);
        });
        AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          output.space();
          this.definitions.forEach(function(def, i) {
            if (i)
              output.comma();
            def.print(output);
          });
          var p = output.parent();
          var in_for = p instanceof AST_For || p instanceof AST_ForIn;
          var output_semicolon = !in_for || p && p.init !== this;
          if (output_semicolon)
            output.semicolon();
        });
        DEFPRINT(AST_Let, function(self2, output) {
          self2._do_print(output, "let");
        });
        DEFPRINT(AST_Var, function(self2, output) {
          self2._do_print(output, "var");
        });
        DEFPRINT(AST_Const, function(self2, output) {
          self2._do_print(output, "const");
        });
        DEFPRINT(AST_Import, function(self2, output) {
          output.print("import");
          output.space();
          if (self2.imported_name) {
            self2.imported_name.print(output);
          }
          if (self2.imported_name && self2.imported_names) {
            output.print(",");
            output.space();
          }
          if (self2.imported_names) {
            if (self2.imported_names.length === 1 && self2.imported_names[0].foreign_name.name === "*" && !self2.imported_names[0].foreign_name.quote) {
              self2.imported_names[0].print(output);
            } else {
              output.print("{");
              self2.imported_names.forEach(function(name_import, i) {
                output.space();
                name_import.print(output);
                if (i < self2.imported_names.length - 1) {
                  output.print(",");
                }
              });
              output.space();
              output.print("}");
            }
          }
          if (self2.imported_name || self2.imported_names) {
            output.space();
            output.print("from");
            output.space();
          }
          self2.module_name.print(output);
          if (self2.attributes) {
            output.print("with");
            self2.attributes.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_ImportMeta, function(self2, output) {
          output.print("import.meta");
        });
        DEFPRINT(AST_NameMapping, function(self2, output) {
          var is_import = output.parent() instanceof AST_Import;
          var definition = self2.name.definition();
          var foreign_name = self2.foreign_name;
          var names_are_different = (definition && definition.mangled_name || self2.name.name) !== foreign_name.name;
          if (!names_are_different && foreign_name.name === "*" && !!foreign_name.quote != !!self2.name.quote) {
            names_are_different = true;
          }
          var foreign_name_is_name = !foreign_name.quote;
          if (names_are_different) {
            if (is_import) {
              if (foreign_name_is_name) {
                output.print(foreign_name.name);
              } else {
                output.print_string(foreign_name.name, foreign_name.quote);
              }
            } else {
              if (!self2.name.quote) {
                self2.name.print(output);
              } else {
                output.print_string(self2.name.name, self2.name.quote);
              }
            }
            output.space();
            output.print("as");
            output.space();
            if (is_import) {
              self2.name.print(output);
            } else {
              if (foreign_name_is_name) {
                output.print(foreign_name.name);
              } else {
                output.print_string(foreign_name.name, foreign_name.quote);
              }
            }
          } else {
            if (!self2.name.quote) {
              self2.name.print(output);
            } else {
              output.print_string(self2.name.name, self2.name.quote);
            }
          }
        });
        DEFPRINT(AST_Export, function(self2, output) {
          output.print("export");
          output.space();
          if (self2.is_default) {
            output.print("default");
            output.space();
          }
          if (self2.exported_names) {
            if (self2.exported_names.length === 1 && self2.exported_names[0].name.name === "*" && !self2.exported_names[0].name.quote) {
              self2.exported_names[0].print(output);
            } else {
              output.print("{");
              self2.exported_names.forEach(function(name_export, i) {
                output.space();
                name_export.print(output);
                if (i < self2.exported_names.length - 1) {
                  output.print(",");
                }
              });
              output.space();
              output.print("}");
            }
          } else if (self2.exported_value) {
            self2.exported_value.print(output);
          } else if (self2.exported_definition) {
            self2.exported_definition.print(output);
            if (self2.exported_definition instanceof AST_Definitions)
              return;
          }
          if (self2.module_name) {
            output.space();
            output.print("from");
            output.space();
            self2.module_name.print(output);
          }
          if (self2.attributes) {
            output.print("with");
            self2.attributes.print(output);
          }
          if (self2.exported_value && !(self2.exported_value instanceof AST_Defun || self2.exported_value instanceof AST_Function || self2.exported_value instanceof AST_Class) || self2.module_name || self2.exported_names) {
            output.semicolon();
          }
        });
        function parenthesize_for_noin(node, output, noin) {
          var parens = false;
          if (noin) {
            parens = walk(node, (node2) => {
              if (node2 instanceof AST_Scope && !(node2 instanceof AST_Arrow)) {
                return true;
              }
              if (node2 instanceof AST_Binary && node2.operator == "in" || node2 instanceof AST_PrivateIn) {
                return walk_abort;
              }
            });
          }
          node.print(output, parens);
        }
        DEFPRINT(AST_VarDef, function(self2, output) {
          self2.name.print(output);
          if (self2.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self2.value, output, noin);
          }
        });
        DEFPRINT(AST_Call, function(self2, output) {
          self2.expression.print(output);
          if (self2 instanceof AST_New && self2.args.length === 0)
            return;
          if (self2.expression instanceof AST_Call || self2.expression instanceof AST_Lambda) {
            output.add_mapping(self2.start);
          }
          if (self2.optional)
            output.print("?.");
          output.with_parens(function() {
            self2.args.forEach(function(expr, i) {
              if (i)
                output.comma();
              expr.print(output);
            });
          });
        });
        DEFPRINT(AST_New, function(self2, output) {
          output.print("new");
          output.space();
          AST_Call.prototype._codegen(self2, output);
        });
        AST_Sequence.DEFMETHOD("_do_print", function(output) {
          this.expressions.forEach(function(node, index) {
            if (index > 0) {
              output.comma();
              if (output.should_break()) {
                output.newline();
                output.indent();
              }
            }
            node.print(output);
          });
        });
        DEFPRINT(AST_Sequence, function(self2, output) {
          self2._do_print(output);
        });
        DEFPRINT(AST_Dot, function(self2, output) {
          var expr = self2.expression;
          expr.print(output);
          var prop = self2.property;
          var print_computed = ALL_RESERVED_WORDS.has(prop) ? output.option("ie8") : !is_identifier_string(prop, output.option("ecma") >= 2015 && !output.option("safari10"));
          if (self2.optional)
            output.print("?.");
          if (print_computed) {
            output.print("[");
            output.add_mapping(self2.end);
            output.print_string(prop);
            output.print("]");
          } else {
            if (expr instanceof AST_Number && expr.getValue() >= 0) {
              if (!/[xa-f.)]/i.test(output.last())) {
                output.print(".");
              }
            }
            if (!self2.optional)
              output.print(".");
            output.add_mapping(self2.end);
            output.print_name(prop);
          }
        });
        DEFPRINT(AST_DotHash, function(self2, output) {
          var expr = self2.expression;
          expr.print(output);
          var prop = self2.property;
          if (self2.optional)
            output.print("?");
          output.print(".#");
          output.add_mapping(self2.end);
          output.print_name(prop);
        });
        DEFPRINT(AST_Sub, function(self2, output) {
          self2.expression.print(output);
          if (self2.optional)
            output.print("?.");
          output.print("[");
          self2.property.print(output);
          output.print("]");
        });
        DEFPRINT(AST_Chain, function(self2, output) {
          self2.expression.print(output);
        });
        DEFPRINT(AST_UnaryPrefix, function(self2, output) {
          var op = self2.operator;
          if (op === "--" && output.last().endsWith("!")) {
            output.print(" ");
          }
          output.print(op);
          if (/^[a-z]/i.test(op) || /[+-]$/.test(op) && self2.expression instanceof AST_UnaryPrefix && /^[+-]/.test(self2.expression.operator)) {
            output.space();
          }
          self2.expression.print(output);
        });
        DEFPRINT(AST_UnaryPostfix, function(self2, output) {
          self2.expression.print(output);
          output.print(self2.operator);
        });
        DEFPRINT(AST_Binary, function(self2, output) {
          var op = self2.operator;
          self2.left.print(output);
          if (op[0] == ">" && output.last().endsWith("--")) {
            output.print(" ");
          } else {
            output.space();
          }
          output.print(op);
          output.space();
          self2.right.print(output);
        });
        DEFPRINT(AST_Conditional, function(self2, output) {
          self2.condition.print(output);
          output.space();
          output.print("?");
          output.space();
          self2.consequent.print(output);
          output.space();
          output.colon();
          self2.alternative.print(output);
        });
        DEFPRINT(AST_Array, function(self2, output) {
          output.with_square(function() {
            var a = self2.elements, len = a.length;
            if (len > 0)
              output.space();
            a.forEach(function(exp, i) {
              if (i)
                output.comma();
              exp.print(output);
              if (i === len - 1 && exp instanceof AST_Hole)
                output.comma();
            });
            if (len > 0)
              output.space();
          });
        });
        DEFPRINT(AST_Object, function(self2, output) {
          if (self2.properties.length > 0)
            output.with_block(function() {
              self2.properties.forEach(function(prop, i) {
                if (i) {
                  output.print(",");
                  output.newline();
                }
                output.indent();
                prop.print(output);
              });
              output.newline();
            });
          else
            print_braced_empty(self2, output);
        });
        DEFPRINT(AST_Class, function(self2, output) {
          output.print("class");
          output.space();
          if (self2.name) {
            self2.name.print(output);
            output.space();
          }
          if (self2.extends) {
            var parens = !(self2.extends instanceof AST_SymbolRef) && !(self2.extends instanceof AST_PropAccess) && !(self2.extends instanceof AST_ClassExpression) && !(self2.extends instanceof AST_Function);
            output.print("extends");
            if (parens) {
              output.print("(");
            } else {
              output.space();
            }
            self2.extends.print(output);
            if (parens) {
              output.print(")");
            } else {
              output.space();
            }
          }
          if (self2.properties.length > 0)
            output.with_block(function() {
              self2.properties.forEach(function(prop, i) {
                if (i) {
                  output.newline();
                }
                output.indent();
                prop.print(output);
              });
              output.newline();
            });
          else
            output.print("{}");
        });
        DEFPRINT(AST_NewTarget, function(self2, output) {
          output.print("new.target");
        });
        function print_property_name(key, quote, output) {
          if (output.option("quote_keys")) {
            output.print_string(key);
            return false;
          }
          if ("" + +key == key && key >= 0) {
            if (output.option("keep_numbers")) {
              output.print(key);
              return false;
            }
            output.print(make_num(key));
            return false;
          }
          var print_string = ALL_RESERVED_WORDS.has(key) ? output.option("ie8") : output.option("ecma") < 2015 || output.option("safari10") ? !is_basic_identifier_string(key) : !is_identifier_string(key, true);
          if (print_string || quote && output.option("keep_quoted_props")) {
            output.print_string(key, quote);
            return false;
          }
          output.print_name(key);
          return true;
        }
        DEFPRINT(AST_ObjectKeyVal, function(self2, output) {
          function get_name(self3) {
            var def = self3.definition();
            return def ? def.mangled_name || def.name : self3.name;
          }
          const try_shorthand = output.option("shorthand") && !(self2.key instanceof AST_Node);
          if (try_shorthand && self2.value instanceof AST_Symbol && get_name(self2.value) === self2.key && !ALL_RESERVED_WORDS.has(self2.key)) {
            const was_shorthand = print_property_name(self2.key, self2.quote, output);
            if (!was_shorthand) {
              output.colon();
              self2.value.print(output);
            }
          } else if (try_shorthand && self2.value instanceof AST_DefaultAssign && self2.value.left instanceof AST_Symbol && get_name(self2.value.left) === self2.key) {
            const was_shorthand = print_property_name(self2.key, self2.quote, output);
            if (!was_shorthand) {
              output.colon();
              self2.value.left.print(output);
            }
            output.space();
            output.print("=");
            output.space();
            self2.value.right.print(output);
          } else {
            if (!(self2.key instanceof AST_Node)) {
              print_property_name(self2.key, self2.quote, output);
            } else {
              output.with_square(function() {
                self2.key.print(output);
              });
            }
            output.colon();
            self2.value.print(output);
          }
        });
        DEFPRINT(AST_ClassPrivateProperty, (self2, output) => {
          if (self2.static) {
            output.print("static");
            output.space();
          }
          output.print("#");
          print_property_name(self2.key.name, void 0, output);
          if (self2.value) {
            output.print("=");
            self2.value.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_ClassProperty, (self2, output) => {
          if (self2.static) {
            output.print("static");
            output.space();
          }
          if (self2.key instanceof AST_SymbolClassProperty) {
            print_property_name(self2.key.name, self2.quote, output);
          } else {
            output.print("[");
            self2.key.print(output);
            output.print("]");
          }
          if (self2.value) {
            output.print("=");
            self2.value.print(output);
          }
          output.semicolon();
        });
        AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, is_private, output) {
          var self2 = this;
          if (self2.static) {
            output.print("static");
            output.space();
          }
          if (type) {
            output.print(type);
            output.space();
          }
          if (self2.key instanceof AST_SymbolMethod) {
            if (is_private)
              output.print("#");
            print_property_name(self2.key.name, self2.quote, output);
            self2.key.add_source_map(output);
          } else {
            output.with_square(function() {
              self2.key.print(output);
            });
          }
          self2.value._do_print(output, true);
        });
        DEFPRINT(AST_ObjectSetter, function(self2, output) {
          self2._print_getter_setter("set", false, output);
        });
        DEFPRINT(AST_ObjectGetter, function(self2, output) {
          self2._print_getter_setter("get", false, output);
        });
        DEFPRINT(AST_PrivateSetter, function(self2, output) {
          self2._print_getter_setter("set", true, output);
        });
        DEFPRINT(AST_PrivateGetter, function(self2, output) {
          self2._print_getter_setter("get", true, output);
        });
        DEFPRINT(AST_ConciseMethod, function(self2, output) {
          var type;
          if (self2.value.is_generator && self2.value.async) {
            type = "async*";
          } else if (self2.value.is_generator) {
            type = "*";
          } else if (self2.value.async) {
            type = "async";
          }
          self2._print_getter_setter(type, false, output);
        });
        DEFPRINT(AST_PrivateMethod, function(self2, output) {
          var type;
          if (self2.value.is_generator && self2.value.async) {
            type = "async*";
          } else if (self2.value.is_generator) {
            type = "*";
          } else if (self2.value.async) {
            type = "async";
          }
          self2._print_getter_setter(type, true, output);
        });
        DEFPRINT(AST_PrivateIn, function(self2, output) {
          self2.key.print(output);
          output.space();
          output.print("in");
          output.space();
          self2.value.print(output);
        });
        DEFPRINT(AST_SymbolPrivateProperty, function(self2, output) {
          output.print("#" + self2.name);
        });
        DEFPRINT(AST_ClassStaticBlock, function(self2, output) {
          output.print("static");
          output.space();
          print_braced(self2, output);
        });
        AST_Symbol.DEFMETHOD("_do_print", function(output) {
          var def = this.definition();
          output.print_name(def ? def.mangled_name || def.name : this.name);
        });
        DEFPRINT(AST_Symbol, function(self2, output) {
          self2._do_print(output);
        });
        DEFPRINT(AST_Hole, noop2);
        DEFPRINT(AST_This, function(self2, output) {
          output.print("this");
        });
        DEFPRINT(AST_Super, function(self2, output) {
          output.print("super");
        });
        DEFPRINT(AST_Constant, function(self2, output) {
          output.print(self2.getValue());
        });
        DEFPRINT(AST_String, function(self2, output) {
          output.print_string(self2.getValue(), self2.quote, output.in_directive);
        });
        DEFPRINT(AST_Number, function(self2, output) {
          if ((output.option("keep_numbers") || output.use_asm) && self2.raw) {
            output.print(self2.raw);
          } else {
            output.print(make_num(self2.getValue()));
          }
        });
        DEFPRINT(AST_BigInt, function(self2, output) {
          if (output.option("keep_numbers") && self2.raw) {
            output.print(self2.raw);
          } else {
            output.print(self2.getValue() + "n");
          }
        });
        const r_slash_script = /(<\s*\/\s*script)/i;
        const r_starts_with_script = /^\s*script/i;
        const slash_script_replace = (_, $1) => $1.replace("/", "\\/");
        DEFPRINT(AST_RegExp, function(self2, output) {
          let { source, flags } = self2.getValue();
          source = regexp_source_fix(source);
          flags = flags ? sort_regexp_flags(flags) : "";
          source = source.replace(r_slash_script, slash_script_replace);
          if (r_starts_with_script.test(source) && output.last().endsWith("<")) {
            output.print(" ");
          }
          output.print(output.to_utf8(`/${source}/${flags}`, false, true));
          const parent = output.parent();
          if (parent instanceof AST_Binary && /^\w/.test(parent.operator) && parent.left === self2) {
            output.print(" ");
          }
        });
        function print_maybe_braced_body(stat, output) {
          if (output.option("braces")) {
            make_block(stat, output);
          } else {
            if (!stat || stat instanceof AST_EmptyStatement)
              output.force_semicolon();
            else if (stat instanceof AST_Let || stat instanceof AST_Const || stat instanceof AST_Class)
              make_block(stat, output);
            else
              stat.print(output);
          }
        }
        function best_of2(a) {
          var best = a[0], len = best.length;
          for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
              best = a[i];
              len = best.length;
            }
          }
          return best;
        }
        function make_num(num) {
          var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
          var candidates = [str];
          if (Math.floor(num) === num) {
            if (num < 0) {
              candidates.push("-0x" + (-num).toString(16).toLowerCase());
            } else {
              candidates.push("0x" + num.toString(16).toLowerCase());
            }
          }
          var match, len, digits;
          if (match = /^\.0+/.exec(str)) {
            len = match[0].length;
            digits = str.slice(len);
            candidates.push(digits + "e-" + (digits.length + len - 1));
          } else if (match = /0+$/.exec(str)) {
            len = match[0].length;
            candidates.push(str.slice(0, -len) + "e" + len);
          } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
            candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
          }
          return best_of2(candidates);
        }
        function make_block(stmt, output) {
          if (!stmt || stmt instanceof AST_EmptyStatement)
            output.print("{}");
          else if (stmt instanceof AST_BlockStatement)
            stmt.print(output);
          else
            output.with_block(function() {
              output.indent();
              stmt.print(output);
              output.newline();
            });
        }
        function DEFMAP(nodetype, generator) {
          nodetype.forEach(function(nodetype2) {
            nodetype2.DEFMETHOD("add_source_map", generator);
          });
        }
        DEFMAP([
          AST_Node,
          AST_LabeledStatement,
          AST_Toplevel
        ], noop2);
        DEFMAP([
          AST_Array,
          AST_BlockStatement,
          AST_Catch,
          AST_Class,
          AST_Constant,
          AST_Debugger,
          AST_Definitions,
          AST_Directive,
          AST_Finally,
          AST_Jump,
          AST_Lambda,
          AST_New,
          AST_Object,
          AST_StatementWithBody,
          AST_Symbol,
          AST_Switch,
          AST_SwitchBranch,
          AST_TemplateString,
          AST_TemplateSegment,
          AST_Try
        ], function(output) {
          output.add_mapping(this.start);
        });
        DEFMAP([
          AST_ObjectGetter,
          AST_ObjectSetter,
          AST_PrivateGetter,
          AST_PrivateSetter,
          AST_ConciseMethod,
          AST_PrivateMethod
        ], function(output) {
          output.add_mapping(this.start, false);
        });
        DEFMAP([
          AST_SymbolMethod,
          AST_SymbolPrivateProperty
        ], function(output) {
          const tok_type = this.end && this.end.type;
          if (tok_type === "name" || tok_type === "privatename") {
            output.add_mapping(this.end, this.name);
          } else {
            output.add_mapping(this.end);
          }
        });
        DEFMAP([AST_ObjectProperty], function(output) {
          output.add_mapping(this.start, this.key);
        });
      })();
      const shallow_cmp = (node1, node2) => {
        return node1 === null && node2 === null || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2);
      };
      const equivalent_to = (tree1, tree2) => {
        if (!shallow_cmp(tree1, tree2))
          return false;
        const walk_1_state = [tree1];
        const walk_2_state = [tree2];
        const walk_1_push = walk_1_state.push.bind(walk_1_state);
        const walk_2_push = walk_2_state.push.bind(walk_2_state);
        while (walk_1_state.length && walk_2_state.length) {
          const node_12 = walk_1_state.pop();
          const node_2 = walk_2_state.pop();
          if (!shallow_cmp(node_12, node_2))
            return false;
          node_12._children_backwards(walk_1_push);
          node_2._children_backwards(walk_2_push);
          if (walk_1_state.length !== walk_2_state.length) {
            return false;
          }
        }
        return walk_1_state.length == 0 && walk_2_state.length == 0;
      };
      const pass_through = () => true;
      AST_Node.prototype.shallow_cmp = function() {
        throw new Error("did not find a shallow_cmp function for " + this.constructor.name);
      };
      AST_Debugger.prototype.shallow_cmp = pass_through;
      AST_Directive.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_SimpleStatement.prototype.shallow_cmp = pass_through;
      AST_Block.prototype.shallow_cmp = pass_through;
      AST_EmptyStatement.prototype.shallow_cmp = pass_through;
      AST_LabeledStatement.prototype.shallow_cmp = function(other) {
        return this.label.name === other.label.name;
      };
      AST_Do.prototype.shallow_cmp = pass_through;
      AST_While.prototype.shallow_cmp = pass_through;
      AST_For.prototype.shallow_cmp = function(other) {
        return (this.init == null ? other.init == null : this.init === other.init) && (this.condition == null ? other.condition == null : this.condition === other.condition) && (this.step == null ? other.step == null : this.step === other.step);
      };
      AST_ForIn.prototype.shallow_cmp = pass_through;
      AST_ForOf.prototype.shallow_cmp = pass_through;
      AST_With.prototype.shallow_cmp = pass_through;
      AST_Toplevel.prototype.shallow_cmp = pass_through;
      AST_Expansion.prototype.shallow_cmp = pass_through;
      AST_Lambda.prototype.shallow_cmp = function(other) {
        return this.is_generator === other.is_generator && this.async === other.async;
      };
      AST_Destructuring.prototype.shallow_cmp = function(other) {
        return this.is_array === other.is_array;
      };
      AST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;
      AST_TemplateString.prototype.shallow_cmp = pass_through;
      AST_TemplateSegment.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_Jump.prototype.shallow_cmp = pass_through;
      AST_LoopControl.prototype.shallow_cmp = pass_through;
      AST_Await.prototype.shallow_cmp = pass_through;
      AST_Yield.prototype.shallow_cmp = function(other) {
        return this.is_star === other.is_star;
      };
      AST_If.prototype.shallow_cmp = function(other) {
        return this.alternative == null ? other.alternative == null : this.alternative === other.alternative;
      };
      AST_Switch.prototype.shallow_cmp = pass_through;
      AST_SwitchBranch.prototype.shallow_cmp = pass_through;
      AST_Try.prototype.shallow_cmp = function(other) {
        return this.body === other.body && (this.bcatch == null ? other.bcatch == null : this.bcatch === other.bcatch) && (this.bfinally == null ? other.bfinally == null : this.bfinally === other.bfinally);
      };
      AST_Catch.prototype.shallow_cmp = function(other) {
        return this.argname == null ? other.argname == null : this.argname === other.argname;
      };
      AST_Finally.prototype.shallow_cmp = pass_through;
      AST_Definitions.prototype.shallow_cmp = pass_through;
      AST_VarDef.prototype.shallow_cmp = function(other) {
        return this.value == null ? other.value == null : this.value === other.value;
      };
      AST_NameMapping.prototype.shallow_cmp = pass_through;
      AST_Import.prototype.shallow_cmp = function(other) {
        return (this.imported_name == null ? other.imported_name == null : this.imported_name === other.imported_name) && (this.imported_names == null ? other.imported_names == null : this.imported_names === other.imported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes);
      };
      AST_ImportMeta.prototype.shallow_cmp = pass_through;
      AST_Export.prototype.shallow_cmp = function(other) {
        return (this.exported_definition == null ? other.exported_definition == null : this.exported_definition === other.exported_definition) && (this.exported_value == null ? other.exported_value == null : this.exported_value === other.exported_value) && (this.exported_names == null ? other.exported_names == null : this.exported_names === other.exported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes) && this.module_name === other.module_name && this.is_default === other.is_default;
      };
      AST_Call.prototype.shallow_cmp = pass_through;
      AST_Sequence.prototype.shallow_cmp = pass_through;
      AST_PropAccess.prototype.shallow_cmp = pass_through;
      AST_Chain.prototype.shallow_cmp = pass_through;
      AST_Dot.prototype.shallow_cmp = function(other) {
        return this.property === other.property;
      };
      AST_DotHash.prototype.shallow_cmp = function(other) {
        return this.property === other.property;
      };
      AST_Unary.prototype.shallow_cmp = function(other) {
        return this.operator === other.operator;
      };
      AST_Binary.prototype.shallow_cmp = function(other) {
        return this.operator === other.operator;
      };
      AST_PrivateIn.prototype.shallow_cmp = pass_through;
      AST_Conditional.prototype.shallow_cmp = pass_through;
      AST_Array.prototype.shallow_cmp = pass_through;
      AST_Object.prototype.shallow_cmp = pass_through;
      AST_ObjectProperty.prototype.shallow_cmp = pass_through;
      AST_ObjectKeyVal.prototype.shallow_cmp = function(other) {
        return this.key === other.key && this.quote === other.quote;
      };
      AST_ObjectSetter.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_ObjectGetter.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_ConciseMethod.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_PrivateMethod.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_Class.prototype.shallow_cmp = function(other) {
        return (this.name == null ? other.name == null : this.name === other.name) && (this.extends == null ? other.extends == null : this.extends === other.extends);
      };
      AST_ClassProperty.prototype.shallow_cmp = function(other) {
        return this.static === other.static && (typeof this.key === "string" ? this.key === other.key : true);
      };
      AST_ClassPrivateProperty.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_Symbol.prototype.shallow_cmp = function(other) {
        return this.name === other.name;
      };
      AST_NewTarget.prototype.shallow_cmp = pass_through;
      AST_This.prototype.shallow_cmp = pass_through;
      AST_Super.prototype.shallow_cmp = pass_through;
      AST_String.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_Number.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_BigInt.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_RegExp.prototype.shallow_cmp = function(other) {
        return this.value.flags === other.value.flags && this.value.source === other.value.source;
      };
      AST_Atom.prototype.shallow_cmp = pass_through;
      const MASK_EXPORT_DONT_MANGLE = 1 << 0;
      const MASK_EXPORT_WANT_MANGLE = 1 << 1;
      let function_defs = null;
      let unmangleable_names = null;
      let scopes_with_block_defuns = null;
      class SymbolDef {
        constructor(scope, orig, init2) {
          this.name = orig.name;
          this.orig = [orig];
          this.init = init2;
          this.eliminated = 0;
          this.assignments = 0;
          this.scope = scope;
          this.replaced = 0;
          this.global = false;
          this.export = 0;
          this.mangled_name = null;
          this.undeclared = false;
          this.id = SymbolDef.next_id++;
          this.chained = false;
          this.direct_access = false;
          this.escaped = 0;
          this.recursive_refs = 0;
          this.references = [];
          this.should_replace = void 0;
          this.single_use = false;
          this.fixed = false;
          Object.seal(this);
        }
        fixed_value() {
          if (!this.fixed || this.fixed instanceof AST_Node)
            return this.fixed;
          return this.fixed();
        }
        unmangleable(options) {
          if (!options)
            options = {};
          if (function_defs && function_defs.has(this.id) && keep_name(options.keep_fnames, this.orig[0].name))
            return true;
          return this.global && !options.toplevel || this.export & MASK_EXPORT_DONT_MANGLE || this.undeclared || !options.eval && this.scope.pinned() || (this.orig[0] instanceof AST_SymbolLambda || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name) || this.orig[0] instanceof AST_SymbolMethod || (this.orig[0] instanceof AST_SymbolClass || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);
        }
        mangle(options) {
          const cache = options.cache && options.cache.props;
          if (this.global && cache && cache.has(this.name)) {
            this.mangled_name = cache.get(this.name);
          } else if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            var sym = this.orig[0];
            if (options.ie8 && sym instanceof AST_SymbolLambda)
              s = s.parent_scope;
            const redefinition = redefined_catch_def(this);
            this.mangled_name = redefinition ? redefinition.mangled_name || redefinition.name : s.next_mangled(options, this);
            if (this.global && cache) {
              cache.set(this.name, this.mangled_name);
            }
          }
        }
      }
      SymbolDef.next_id = 1;
      function redefined_catch_def(def) {
        if (def.orig[0] instanceof AST_SymbolCatch && def.scope.is_block_scope()) {
          return def.scope.get_defun_scope().variables.get(def.name);
        }
      }
      AST_Scope.DEFMETHOD("figure_out_scope", function(options, { parent_scope = void 0, toplevel = this } = {}) {
        options = defaults(options, {
          cache: null,
          ie8: false,
          safari10: false,
          module: false
        });
        if (!(toplevel instanceof AST_Toplevel)) {
          throw new Error("Invalid toplevel scope");
        }
        var scope = this.parent_scope = parent_scope;
        var labels = /* @__PURE__ */ new Map();
        var defun = null;
        var in_destructuring = null;
        var for_scopes = [];
        var tw = new TreeWalker((node, descend) => {
          if (node.is_block_scope()) {
            const save_scope2 = scope;
            node.block_scope = scope = new AST_Scope(node);
            scope._block_scope = true;
            scope.init_scope_vars(save_scope2);
            scope.uses_with = save_scope2.uses_with;
            scope.uses_eval = save_scope2.uses_eval;
            if (options.safari10) {
              if (node instanceof AST_For || node instanceof AST_ForIn || node instanceof AST_ForOf) {
                for_scopes.push(scope);
              }
            }
            if (node instanceof AST_Switch) {
              const the_block_scope = scope;
              scope = save_scope2;
              node.expression.walk(tw);
              scope = the_block_scope;
              for (let i = 0; i < node.body.length; i++) {
                node.body[i].walk(tw);
              }
            } else {
              descend();
            }
            scope = save_scope2;
            return true;
          }
          if (node instanceof AST_Destructuring) {
            const save_destructuring = in_destructuring;
            in_destructuring = node;
            descend();
            in_destructuring = save_destructuring;
            return true;
          }
          if (node instanceof AST_Scope) {
            node.init_scope_vars(scope);
            var save_scope = scope;
            var save_defun = defun;
            var save_labels = labels;
            defun = scope = node;
            labels = /* @__PURE__ */ new Map();
            descend();
            scope = save_scope;
            defun = save_defun;
            labels = save_labels;
            return true;
          }
          if (node instanceof AST_LabeledStatement) {
            var l = node.label;
            if (labels.has(l.name)) {
              throw new Error(string_template("Label {name} defined twice", l));
            }
            labels.set(l.name, l);
            descend();
            labels.delete(l.name);
            return true;
          }
          if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
              s.uses_with = true;
            return;
          }
          if (node instanceof AST_Symbol) {
            node.scope = scope;
          }
          if (node instanceof AST_Label) {
            node.thedef = node;
            node.references = [];
          }
          if (node instanceof AST_SymbolLambda) {
            defun.def_function(node, node.name == "arguments" ? void 0 : defun);
          } else if (node instanceof AST_SymbolDefun) {
            const closest_scope = defun.parent_scope;
            node.scope = tw.directives["use strict"] ? closest_scope : closest_scope.get_defun_scope();
            mark_export(node.scope.def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolClass) {
            mark_export(defun.def_variable(node, defun), 1);
          } else if (node instanceof AST_SymbolImport) {
            scope.def_variable(node);
          } else if (node instanceof AST_SymbolDefClass) {
            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolLet || node instanceof AST_SymbolConst || node instanceof AST_SymbolCatch) {
            var def;
            if (node instanceof AST_SymbolBlockDeclaration) {
              def = scope.def_variable(node, null);
            } else {
              def = defun.def_variable(node, node.TYPE == "SymbolVar" ? null : void 0);
            }
            if (!def.orig.every((sym2) => {
              if (sym2 === node)
                return true;
              if (node instanceof AST_SymbolBlockDeclaration) {
                return sym2 instanceof AST_SymbolLambda;
              }
              return !(sym2 instanceof AST_SymbolLet || sym2 instanceof AST_SymbolConst);
            })) {
              js_error(`"${node.name}" is redeclared`, node.start.file, node.start.line, node.start.col, node.start.pos);
            }
            if (!(node instanceof AST_SymbolFunarg))
              mark_export(def, 2);
            if (defun !== scope) {
              node.mark_enclosed();
              var def = scope.find_variable(node);
              if (node.thedef !== def) {
                node.thedef = def;
                node.reference();
              }
            }
          } else if (node instanceof AST_LabelRef) {
            var sym = labels.get(node.name);
            if (!sym)
              throw new Error(string_template("Undefined label {name} [{line},{col}]", {
                name: node.name,
                line: node.start.line,
                col: node.start.col
              }));
            node.thedef = sym;
          }
          if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {
            js_error(`"${node.TYPE}" statement may only appear at the top level`, node.start.file, node.start.line, node.start.col, node.start.pos);
          }
        });
        if (options.module) {
          tw.directives["use strict"] = true;
        }
        this.walk(tw);
        function mark_export(def, level) {
          if (in_destructuring) {
            var i = 0;
            do {
              level++;
            } while (tw.parent(i++) !== in_destructuring);
          }
          var node = tw.parent(level);
          if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {
            var exported = node.exported_definition;
            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {
              def.export = MASK_EXPORT_WANT_MANGLE;
            }
          }
        }
        const is_toplevel = this instanceof AST_Toplevel;
        if (is_toplevel) {
          this.globals = /* @__PURE__ */ new Map();
        }
        var tw = new TreeWalker((node) => {
          if (node instanceof AST_LoopControl && node.label) {
            node.label.thedef.references.push(node);
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            var name = node.name;
            if (name == "eval" && tw.parent() instanceof AST_Call) {
              for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
                s.uses_eval = true;
              }
            }
            var sym;
            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name || !(sym = node.scope.find_variable(name))) {
              sym = toplevel.def_global(node);
              if (node instanceof AST_SymbolExport)
                sym.export = MASK_EXPORT_DONT_MANGLE;
            } else if (sym.scope instanceof AST_Lambda && name == "arguments") {
              sym.scope.get_defun_scope().uses_arguments = true;
            }
            node.thedef = sym;
            node.reference();
            if (node.scope.is_block_scope() && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {
              node.scope = node.scope.get_defun_scope();
            }
            return true;
          }
          var def;
          if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {
            var s = node.scope;
            while (s) {
              push_uniq(s.enclosed, def);
              if (s === def.scope)
                break;
              s = s.parent_scope;
            }
          }
        });
        this.walk(tw);
        if (options.ie8 || options.safari10) {
          walk(this, (node) => {
            if (node instanceof AST_SymbolCatch) {
              var name = node.name;
              var refs = node.thedef.references;
              var scope2 = node.scope.get_defun_scope();
              var def = scope2.find_variable(name) || toplevel.globals.get(name) || scope2.def_variable(node);
              refs.forEach(function(ref) {
                ref.thedef = def;
                ref.reference();
              });
              node.thedef = def;
              node.reference();
              return true;
            }
          });
        }
        if (options.safari10) {
          for (const scope2 of for_scopes) {
            scope2.parent_scope.variables.forEach(function(def) {
              push_uniq(scope2.enclosed, def);
            });
          }
        }
      });
      AST_Toplevel.DEFMETHOD("def_global", function(node) {
        var globals2 = this.globals, name = node.name;
        if (globals2.has(name)) {
          return globals2.get(name);
        } else {
          var g = new SymbolDef(this, node);
          g.undeclared = true;
          g.global = true;
          globals2.set(name, g);
          return g;
        }
      });
      AST_Scope.DEFMETHOD("init_scope_vars", function(parent_scope) {
        this.variables = /* @__PURE__ */ new Map();
        this.uses_with = false;
        this.uses_eval = false;
        this.parent_scope = parent_scope;
        this.enclosed = [];
        this.cname = -1;
      });
      AST_Scope.DEFMETHOD("conflicting_def", function(name) {
        return this.enclosed.find((def) => def.name === name) || this.variables.has(name) || this.parent_scope && this.parent_scope.conflicting_def(name);
      });
      AST_Scope.DEFMETHOD("conflicting_def_shallow", function(name) {
        return this.enclosed.find((def) => def.name === name) || this.variables.has(name);
      });
      AST_Scope.DEFMETHOD("add_child_scope", function(scope) {
        if (scope.parent_scope === this)
          return;
        scope.parent_scope = this;
        if (scope instanceof AST_Arrow && (this instanceof AST_Lambda && !this.uses_arguments)) {
          this.uses_arguments = walk(scope, (node) => {
            if (node instanceof AST_SymbolRef && node.scope instanceof AST_Lambda && node.name === "arguments") {
              return walk_abort;
            }
            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
              return true;
            }
          });
        }
        this.uses_with = this.uses_with || scope.uses_with;
        this.uses_eval = this.uses_eval || scope.uses_eval;
        const scope_ancestry = (() => {
          const ancestry = [];
          let cur = this;
          do {
            ancestry.push(cur);
          } while (cur = cur.parent_scope);
          ancestry.reverse();
          return ancestry;
        })();
        const new_scope_enclosed_set = new Set(scope.enclosed);
        const to_enclose = [];
        for (const scope_topdown of scope_ancestry) {
          to_enclose.forEach((e) => push_uniq(scope_topdown.enclosed, e));
          for (const def of scope_topdown.variables.values()) {
            if (new_scope_enclosed_set.has(def)) {
              push_uniq(to_enclose, def);
              push_uniq(scope_topdown.enclosed, def);
            }
          }
        }
      });
      function find_scopes_visible_from(scopes) {
        const found_scopes = /* @__PURE__ */ new Set();
        for (const scope of new Set(scopes)) {
          (function bubble_up(scope2) {
            if (scope2 == null || found_scopes.has(scope2))
              return;
            found_scopes.add(scope2);
            bubble_up(scope2.parent_scope);
          })(scope);
        }
        return [...found_scopes];
      }
      AST_Scope.DEFMETHOD("create_symbol", function(SymClass, {
        source,
        tentative_name,
        scope,
        conflict_scopes = [scope],
        init: init2 = null
      } = {}) {
        let symbol_name;
        conflict_scopes = find_scopes_visible_from(conflict_scopes);
        if (tentative_name) {
          tentative_name = symbol_name = tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");
          let i = 0;
          while (conflict_scopes.find((s) => s.conflicting_def_shallow(symbol_name))) {
            symbol_name = tentative_name + "$" + i++;
          }
        }
        if (!symbol_name) {
          throw new Error("No symbol name could be generated in create_symbol()");
        }
        const symbol = make_node(SymClass, source, {
          name: symbol_name,
          scope
        });
        this.def_variable(symbol, init2 || null);
        symbol.mark_enclosed();
        return symbol;
      });
      AST_Node.DEFMETHOD("is_block_scope", return_false);
      AST_Class.DEFMETHOD("is_block_scope", return_false);
      AST_Lambda.DEFMETHOD("is_block_scope", return_false);
      AST_Toplevel.DEFMETHOD("is_block_scope", return_false);
      AST_SwitchBranch.DEFMETHOD("is_block_scope", return_false);
      AST_Block.DEFMETHOD("is_block_scope", return_true);
      AST_Scope.DEFMETHOD("is_block_scope", function() {
        return this._block_scope || false;
      });
      AST_IterationStatement.DEFMETHOD("is_block_scope", return_true);
      AST_Lambda.DEFMETHOD("init_scope_vars", function() {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
        this.uses_arguments = false;
        this.def_variable(new AST_SymbolFunarg({
          name: "arguments",
          start: this.start,
          end: this.end
        }));
      });
      AST_Arrow.DEFMETHOD("init_scope_vars", function() {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
        this.uses_arguments = false;
      });
      AST_Symbol.DEFMETHOD("mark_enclosed", function() {
        var def = this.definition();
        var s = this.scope;
        while (s) {
          push_uniq(s.enclosed, def);
          if (s === def.scope)
            break;
          s = s.parent_scope;
        }
      });
      AST_Symbol.DEFMETHOD("reference", function() {
        this.definition().references.push(this);
        this.mark_enclosed();
      });
      AST_Scope.DEFMETHOD("find_variable", function(name) {
        if (name instanceof AST_Symbol)
          name = name.name;
        return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
      });
      AST_Scope.DEFMETHOD("def_function", function(symbol, init2) {
        var def = this.def_variable(symbol, init2);
        if (!def.init || def.init instanceof AST_Defun)
          def.init = init2;
        return def;
      });
      AST_Scope.DEFMETHOD("def_variable", function(symbol, init2) {
        var def = this.variables.get(symbol.name);
        if (def) {
          def.orig.push(symbol);
          if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {
            def.init = init2;
          }
        } else {
          def = new SymbolDef(this, symbol, init2);
          this.variables.set(symbol.name, def);
          def.global = !this.parent_scope;
        }
        return symbol.thedef = def;
      });
      function next_mangled(scope, options) {
        let defun_scope;
        if (scopes_with_block_defuns && (defun_scope = scope.get_defun_scope()) && scopes_with_block_defuns.has(defun_scope)) {
          scope = defun_scope;
        }
        var ext = scope.enclosed;
        var nth_identifier = options.nth_identifier;
        out:
          while (true) {
            var m = nth_identifier.get(++scope.cname);
            if (ALL_RESERVED_WORDS.has(m))
              continue;
            if (options.reserved.has(m))
              continue;
            if (unmangleable_names && unmangleable_names.has(m))
              continue out;
            for (let i = ext.length; --i >= 0; ) {
              const def = ext[i];
              const name = def.mangled_name || def.unmangleable(options) && def.name;
              if (m == name)
                continue out;
            }
            return m;
          }
      }
      AST_Scope.DEFMETHOD("next_mangled", function(options) {
        return next_mangled(this, options);
      });
      AST_Toplevel.DEFMETHOD("next_mangled", function(options) {
        let name;
        const mangled_names = this.mangled_names;
        do {
          name = next_mangled(this, options);
        } while (mangled_names.has(name));
        return name;
      });
      AST_Function.DEFMETHOD("next_mangled", function(options, def) {
        var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
        var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;
        while (true) {
          var name = next_mangled(this, options);
          if (!tricky_name || tricky_name != name)
            return name;
        }
      });
      AST_Symbol.DEFMETHOD("unmangleable", function(options) {
        var def = this.definition();
        return !def || def.unmangleable(options);
      });
      AST_Label.DEFMETHOD("unmangleable", return_false);
      AST_Symbol.DEFMETHOD("unreferenced", function() {
        return !this.definition().references.length && !this.scope.pinned();
      });
      AST_Symbol.DEFMETHOD("definition", function() {
        return this.thedef;
      });
      AST_Symbol.DEFMETHOD("global", function() {
        return this.thedef.global;
      });
      function format_mangler_options(options) {
        options = defaults(options, {
          eval: false,
          nth_identifier: base54,
          ie8: false,
          keep_classnames: false,
          keep_fnames: false,
          module: false,
          reserved: [],
          toplevel: false
        });
        if (options.module)
          options.toplevel = true;
        if (!Array.isArray(options.reserved) && !(options.reserved instanceof Set)) {
          options.reserved = [];
        }
        options.reserved = new Set(options.reserved);
        options.reserved.add("arguments");
        return options;
      }
      AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        var lname = -1;
        var to_mangle = [];
        if (options.keep_fnames) {
          function_defs = /* @__PURE__ */ new Set();
        }
        const mangled_names = this.mangled_names = /* @__PURE__ */ new Set();
        unmangleable_names = /* @__PURE__ */ new Set();
        if (options.cache) {
          this.globals.forEach(collect);
          if (options.cache.props) {
            options.cache.props.forEach(function(mangled_name) {
              mangled_names.add(mangled_name);
            });
          }
        }
        var tw = new TreeWalker(function(node, descend) {
          if (node instanceof AST_LabeledStatement) {
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;
          }
          if (node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
            scopes_with_block_defuns = scopes_with_block_defuns || /* @__PURE__ */ new Set();
            scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());
          }
          if (node instanceof AST_Scope) {
            node.variables.forEach(collect);
            return;
          }
          if (node.is_block_scope()) {
            node.block_scope.variables.forEach(collect);
            return;
          }
          if (function_defs && node instanceof AST_VarDef && node.value instanceof AST_Lambda && !node.value.name && keep_name(options.keep_fnames, node.name.name)) {
            function_defs.add(node.name.definition().id);
            return;
          }
          if (node instanceof AST_Label) {
            let name;
            do {
              name = nth_identifier.get(++lname);
            } while (ALL_RESERVED_WORDS.has(name));
            node.mangled_name = name;
            return true;
          }
          if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {
            to_mangle.push(node.definition());
            return;
          }
        });
        this.walk(tw);
        if (options.keep_fnames || options.keep_classnames) {
          to_mangle.forEach((def) => {
            if (def.name.length < 6 && def.unmangleable(options)) {
              unmangleable_names.add(def.name);
            }
          });
        }
        to_mangle.forEach((def) => {
          def.mangle(options);
        });
        function_defs = null;
        unmangleable_names = null;
        scopes_with_block_defuns = null;
        function collect(symbol) {
          if (symbol.export & MASK_EXPORT_DONT_MANGLE) {
            unmangleable_names.add(symbol.name);
          } else if (!options.reserved.has(symbol.name)) {
            to_mangle.push(symbol);
          }
        }
      });
      AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
        const cache = options.cache && options.cache.props;
        const avoid = /* @__PURE__ */ new Set();
        options.reserved.forEach(to_avoid);
        this.globals.forEach(add_def);
        this.walk(new TreeWalker(function(node) {
          if (node instanceof AST_Scope)
            node.variables.forEach(add_def);
          if (node instanceof AST_SymbolCatch)
            add_def(node.definition());
        }));
        return avoid;
        function to_avoid(name) {
          avoid.add(name);
        }
        function add_def(def) {
          var name = def.name;
          if (def.global && cache && cache.has(name))
            name = cache.get(name);
          else if (!def.unmangleable(options))
            return;
          to_avoid(name);
        }
      });
      AST_Toplevel.DEFMETHOD("expand_names", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        if (nth_identifier.reset && nth_identifier.sort) {
          nth_identifier.reset();
          nth_identifier.sort();
        }
        var avoid = this.find_colliding_names(options);
        var cname = 0;
        this.globals.forEach(rename);
        this.walk(new TreeWalker(function(node) {
          if (node instanceof AST_Scope)
            node.variables.forEach(rename);
          if (node instanceof AST_SymbolCatch)
            rename(node.definition());
        }));
        function next_name() {
          var name;
          do {
            name = nth_identifier.get(cname++);
          } while (avoid.has(name) || ALL_RESERVED_WORDS.has(name));
          return name;
        }
        function rename(def) {
          if (def.global && options.cache)
            return;
          if (def.unmangleable(options))
            return;
          if (options.reserved.has(def.name))
            return;
          const redefinition = redefined_catch_def(def);
          const name = def.name = redefinition ? redefinition.name : next_name();
          def.orig.forEach(function(sym) {
            sym.name = name;
          });
          def.references.forEach(function(sym) {
            sym.name = name;
          });
        }
      });
      AST_Node.DEFMETHOD("tail_node", return_this);
      AST_Sequence.DEFMETHOD("tail_node", function() {
        return this.expressions[this.expressions.length - 1];
      });
      AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        if (!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {
          return;
        }
        nth_identifier.reset();
        try {
          AST_Node.prototype.print = function(stream, force_parens) {
            this._print(stream, force_parens);
            if (this instanceof AST_Symbol && !this.unmangleable(options)) {
              nth_identifier.consider(this.name, -1);
            } else if (options.properties) {
              if (this instanceof AST_DotHash) {
                nth_identifier.consider("#" + this.property, -1);
              } else if (this instanceof AST_Dot) {
                nth_identifier.consider(this.property, -1);
              } else if (this instanceof AST_Sub) {
                skip_string(this.property);
              }
            }
          };
          nth_identifier.consider(this.print_to_string(), 1);
        } finally {
          AST_Node.prototype.print = AST_Node.prototype._print;
        }
        nth_identifier.sort();
        function skip_string(node) {
          if (node instanceof AST_String) {
            nth_identifier.consider(node.value, -1);
          } else if (node instanceof AST_Conditional) {
            skip_string(node.consequent);
            skip_string(node.alternative);
          } else if (node instanceof AST_Sequence) {
            skip_string(node.tail_node());
          }
        }
      });
      const base54 = (() => {
        const leading = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split("");
        const digits = "0123456789".split("");
        let chars;
        let frequency;
        function reset() {
          frequency = /* @__PURE__ */ new Map();
          leading.forEach(function(ch) {
            frequency.set(ch, 0);
          });
          digits.forEach(function(ch) {
            frequency.set(ch, 0);
          });
        }
        function consider(str, delta) {
          for (var i = str.length; --i >= 0; ) {
            frequency.set(str[i], frequency.get(str[i]) + delta);
          }
        }
        function compare(a, b) {
          return frequency.get(b) - frequency.get(a);
        }
        function sort() {
          chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));
        }
        reset();
        sort();
        function base542(num) {
          var ret = "", base = 54;
          num++;
          do {
            num--;
            ret += chars[num % base];
            num = Math.floor(num / base);
            base = 64;
          } while (num > 0);
          return ret;
        }
        return {
          get: base542,
          consider,
          reset,
          sort
        };
      })();
      let mangle_options = void 0;
      AST_Node.prototype.size = function(compressor, stack) {
        mangle_options = compressor && compressor._mangle_options;
        let size = 0;
        walk_parent(this, (node, info) => {
          size += node._size(info);
          if (node instanceof AST_Arrow && node.is_braceless()) {
            size += node.body[0].value._size(info);
            return true;
          }
        }, stack || compressor && compressor.stack);
        mangle_options = void 0;
        return size;
      };
      AST_Node.prototype._size = () => 0;
      AST_Debugger.prototype._size = () => 8;
      AST_Directive.prototype._size = function() {
        return 2 + this.value.length;
      };
      const list_overhead = (array) => array.length && array.length - 1;
      AST_Block.prototype._size = function() {
        return 2 + list_overhead(this.body);
      };
      AST_Toplevel.prototype._size = function() {
        return list_overhead(this.body);
      };
      AST_EmptyStatement.prototype._size = () => 1;
      AST_LabeledStatement.prototype._size = () => 2;
      AST_Do.prototype._size = () => 9;
      AST_While.prototype._size = () => 7;
      AST_For.prototype._size = () => 8;
      AST_ForIn.prototype._size = () => 8;
      AST_With.prototype._size = () => 6;
      AST_Expansion.prototype._size = () => 3;
      const lambda_modifiers = (func) => (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);
      AST_Accessor.prototype._size = function() {
        return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Function.prototype._size = function(info) {
        const first = !!first_in_statement(info);
        return first * 2 + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Defun.prototype._size = function() {
        return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Arrow.prototype._size = function() {
        let args_and_arrow = 2 + list_overhead(this.argnames);
        if (!(this.argnames.length === 1 && this.argnames[0] instanceof AST_Symbol)) {
          args_and_arrow += 2;
        }
        const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;
        return lambda_modifiers(this) + args_and_arrow + body_overhead;
      };
      AST_Destructuring.prototype._size = () => 2;
      AST_TemplateString.prototype._size = function() {
        return 2 + Math.floor(this.segments.length / 2) * 3;
      };
      AST_TemplateSegment.prototype._size = function() {
        return this.value.length;
      };
      AST_Return.prototype._size = function() {
        return this.value ? 7 : 6;
      };
      AST_Throw.prototype._size = () => 6;
      AST_Break.prototype._size = function() {
        return this.label ? 6 : 5;
      };
      AST_Continue.prototype._size = function() {
        return this.label ? 9 : 8;
      };
      AST_If.prototype._size = () => 4;
      AST_Switch.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_Case.prototype._size = function() {
        return 5 + list_overhead(this.body);
      };
      AST_Default.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_Try.prototype._size = () => 3;
      AST_Catch.prototype._size = function() {
        let size = 7 + list_overhead(this.body);
        if (this.argname) {
          size += 2;
        }
        return size;
      };
      AST_Finally.prototype._size = function() {
        return 7 + list_overhead(this.body);
      };
      AST_Var.prototype._size = function() {
        return 4 + list_overhead(this.definitions);
      };
      AST_Let.prototype._size = function() {
        return 4 + list_overhead(this.definitions);
      };
      AST_Const.prototype._size = function() {
        return 6 + list_overhead(this.definitions);
      };
      AST_VarDef.prototype._size = function() {
        return this.value ? 1 : 0;
      };
      AST_NameMapping.prototype._size = function() {
        return this.name ? 4 : 0;
      };
      AST_Import.prototype._size = function() {
        let size = 6;
        if (this.imported_name)
          size += 1;
        if (this.imported_name || this.imported_names)
          size += 5;
        if (this.imported_names) {
          size += 2 + list_overhead(this.imported_names);
        }
        return size;
      };
      AST_ImportMeta.prototype._size = () => 11;
      AST_Export.prototype._size = function() {
        let size = 7 + (this.is_default ? 8 : 0);
        if (this.exported_value) {
          size += this.exported_value._size();
        }
        if (this.exported_names) {
          size += 2 + list_overhead(this.exported_names);
        }
        if (this.module_name) {
          size += 5;
        }
        return size;
      };
      AST_Call.prototype._size = function() {
        if (this.optional) {
          return 4 + list_overhead(this.args);
        }
        return 2 + list_overhead(this.args);
      };
      AST_New.prototype._size = function() {
        return 6 + list_overhead(this.args);
      };
      AST_Sequence.prototype._size = function() {
        return list_overhead(this.expressions);
      };
      AST_Dot.prototype._size = function() {
        if (this.optional) {
          return this.property.length + 2;
        }
        return this.property.length + 1;
      };
      AST_DotHash.prototype._size = function() {
        if (this.optional) {
          return this.property.length + 3;
        }
        return this.property.length + 2;
      };
      AST_Sub.prototype._size = function() {
        return this.optional ? 4 : 2;
      };
      AST_Unary.prototype._size = function() {
        if (this.operator === "typeof")
          return 7;
        if (this.operator === "void")
          return 5;
        return this.operator.length;
      };
      AST_Binary.prototype._size = function(info) {
        if (this.operator === "in")
          return 4;
        let size = this.operator.length;
        if ((this.operator === "+" || this.operator === "-") && this.right instanceof AST_Unary && this.right.operator === this.operator) {
          size += 1;
        }
        if (this.needs_parens(info)) {
          size += 2;
        }
        return size;
      };
      AST_Conditional.prototype._size = () => 3;
      AST_Array.prototype._size = function() {
        return 2 + list_overhead(this.elements);
      };
      AST_Object.prototype._size = function(info) {
        let base = 2;
        if (first_in_statement(info)) {
          base += 2;
        }
        return base + list_overhead(this.properties);
      };
      const key_size = (key) => typeof key === "string" ? key.length : 0;
      AST_ObjectKeyVal.prototype._size = function() {
        return key_size(this.key) + 1;
      };
      const static_size = (is_static) => is_static ? 7 : 0;
      AST_ObjectGetter.prototype._size = function() {
        return 5 + static_size(this.static) + key_size(this.key);
      };
      AST_ObjectSetter.prototype._size = function() {
        return 5 + static_size(this.static) + key_size(this.key);
      };
      AST_ConciseMethod.prototype._size = function() {
        return static_size(this.static) + key_size(this.key);
      };
      AST_PrivateMethod.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 1;
      };
      AST_PrivateGetter.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 4;
      };
      AST_PrivateSetter.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 4;
      };
      AST_PrivateIn.prototype._size = function() {
        return 5;
      };
      AST_Class.prototype._size = function() {
        return (this.name ? 8 : 7) + (this.extends ? 8 : 0);
      };
      AST_ClassStaticBlock.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_ClassProperty.prototype._size = function() {
        return static_size(this.static) + (typeof this.key === "string" ? this.key.length + 2 : 0) + (this.value ? 1 : 0);
      };
      AST_ClassPrivateProperty.prototype._size = function() {
        return AST_ClassProperty.prototype._size.call(this) + 1;
      };
      AST_Symbol.prototype._size = function() {
        if (!(mangle_options && this.thedef && !this.thedef.unmangleable(mangle_options))) {
          return this.name.length;
        } else {
          return 1;
        }
      };
      AST_SymbolClassProperty.prototype._size = function() {
        return this.name.length;
      };
      AST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function() {
        if (this.name === "arguments")
          return 9;
        return AST_Symbol.prototype._size.call(this);
      };
      AST_NewTarget.prototype._size = () => 10;
      AST_SymbolImportForeign.prototype._size = function() {
        return this.name.length;
      };
      AST_SymbolExportForeign.prototype._size = function() {
        return this.name.length;
      };
      AST_This.prototype._size = () => 4;
      AST_Super.prototype._size = () => 5;
      AST_String.prototype._size = function() {
        return this.value.length + 2;
      };
      AST_Number.prototype._size = function() {
        const { value: value2 } = this;
        if (value2 === 0)
          return 1;
        if (value2 > 0 && Math.floor(value2) === value2) {
          return Math.floor(Math.log10(value2) + 1);
        }
        return value2.toString().length;
      };
      AST_BigInt.prototype._size = function() {
        return this.value.length;
      };
      AST_RegExp.prototype._size = function() {
        return this.value.toString().length;
      };
      AST_Null.prototype._size = () => 4;
      AST_NaN.prototype._size = () => 3;
      AST_Undefined.prototype._size = () => 6;
      AST_Hole.prototype._size = () => 0;
      AST_Infinity.prototype._size = () => 8;
      AST_True.prototype._size = () => 4;
      AST_False.prototype._size = () => 5;
      AST_Await.prototype._size = () => 6;
      AST_Yield.prototype._size = () => 6;
      const UNUSED = 1;
      const TRUTHY = 2;
      const FALSY = 4;
      const UNDEFINED = 8;
      const INLINED = 16;
      const WRITE_ONLY = 32;
      const SQUEEZED = 256;
      const OPTIMIZED = 512;
      const TOP = 1024;
      const CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;
      const has_flag = (node, flag) => node.flags & flag;
      const set_flag = (node, flag) => {
        node.flags |= flag;
      };
      const clear_flag = (node, flag) => {
        node.flags &= ~flag;
      };
      function merge_sequence(array, node) {
        if (node instanceof AST_Sequence) {
          array.push(...node.expressions);
        } else {
          array.push(node);
        }
        return array;
      }
      function make_sequence(orig, expressions) {
        if (expressions.length == 1)
          return expressions[0];
        if (expressions.length == 0)
          throw new Error("trying to create a sequence with length zero!");
        return make_node(AST_Sequence, orig, {
          expressions: expressions.reduce(merge_sequence, [])
        });
      }
      function make_empty_function(self2) {
        return make_node(AST_Function, self2, {
          uses_arguments: false,
          argnames: [],
          body: [],
          is_generator: false,
          async: false,
          variables: /* @__PURE__ */ new Map(),
          uses_with: false,
          uses_eval: false,
          parent_scope: null,
          enclosed: [],
          cname: 0,
          block_scope: void 0
        });
      }
      function make_node_from_constant(val, orig) {
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
              value: val
            });
          case "number":
            if (isNaN(val))
              return make_node(AST_NaN, orig);
            if (isFinite(val)) {
              return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
                operator: "-",
                expression: make_node(AST_Number, orig, { value: -val })
              }) : make_node(AST_Number, orig, { value: val });
            }
            return val < 0 ? make_node(AST_UnaryPrefix, orig, {
              operator: "-",
              expression: make_node(AST_Infinity, orig)
            }) : make_node(AST_Infinity, orig);
          case "bigint":
            return make_node(AST_BigInt, orig, { value: val.toString() });
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig);
          case "undefined":
            return make_node(AST_Undefined, orig);
          default:
            if (val === null) {
              return make_node(AST_Null, orig, { value: null });
            }
            if (val instanceof RegExp) {
              return make_node(AST_RegExp, orig, {
                value: {
                  source: regexp_source_fix(val.source),
                  flags: val.flags
                }
              });
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
              type: typeof val
            }));
        }
      }
      function best_of_expression(ast1, ast2) {
        return ast1.size() > ast2.size() ? ast2 : ast1;
      }
      function best_of_statement(ast1, ast2) {
        return best_of_expression(make_node(AST_SimpleStatement, ast1, {
          body: ast1
        }), make_node(AST_SimpleStatement, ast2, {
          body: ast2
        })).body;
      }
      function best_of(compressor, ast1, ast2) {
        if (first_in_statement(compressor)) {
          return best_of_statement(ast1, ast2);
        } else {
          return best_of_expression(ast1, ast2);
        }
      }
      function get_simple_key(key) {
        if (key instanceof AST_Constant) {
          return key.getValue();
        }
        if (key instanceof AST_UnaryPrefix && key.operator == "void" && key.expression instanceof AST_Constant) {
          return;
        }
        return key;
      }
      function read_property(obj, key) {
        key = get_simple_key(key);
        if (key instanceof AST_Node)
          return;
        var value2;
        if (obj instanceof AST_Array) {
          var elements = obj.elements;
          if (key == "length")
            return make_node_from_constant(elements.length, obj);
          if (typeof key == "number" && key in elements)
            value2 = elements[key];
        } else if (obj instanceof AST_Object) {
          key = "" + key;
          var props = obj.properties;
          for (var i = props.length; --i >= 0; ) {
            var prop = props[i];
            if (!(prop instanceof AST_ObjectKeyVal))
              return;
            if (!value2 && props[i].key === key)
              value2 = props[i].value;
          }
        }
        return value2 instanceof AST_SymbolRef && value2.fixed_value() || value2;
      }
      function has_break_or_continue(loop, parent) {
        var found = false;
        var tw = new TreeWalker(function(node) {
          if (found || node instanceof AST_Scope)
            return true;
          if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop) {
            return found = true;
          }
        });
        if (parent instanceof AST_LabeledStatement)
          tw.push(parent);
        tw.push(loop);
        loop.body.walk(tw);
        return found;
      }
      function maintain_this_binding(parent, orig, val) {
        if (requires_sequence_to_maintain_binding(parent, orig, val)) {
          const zero = make_node(AST_Number, orig, { value: 0 });
          return make_sequence(orig, [zero, val]);
        } else {
          return val;
        }
      }
      function requires_sequence_to_maintain_binding(parent, orig, val) {
        return parent instanceof AST_UnaryPrefix && parent.operator == "delete" || parent instanceof AST_Call && parent.expression === orig && (val instanceof AST_Chain || val instanceof AST_PropAccess || val instanceof AST_SymbolRef && val.name == "eval");
      }
      function is_func_expr(node) {
        return node instanceof AST_Arrow || node instanceof AST_Function;
      }
      function is_iife_call(node) {
        if (node.TYPE != "Call")
          return false;
        return node.expression instanceof AST_Function || is_iife_call(node.expression);
      }
      function is_empty2(thing) {
        if (thing === null)
          return true;
        if (thing instanceof AST_EmptyStatement)
          return true;
        if (thing instanceof AST_BlockStatement)
          return thing.body.length == 0;
        return false;
      }
      const identifier_atom = makePredicate("Infinity NaN undefined");
      function is_identifier_atom(node) {
        return node instanceof AST_Infinity || node instanceof AST_NaN || node instanceof AST_Undefined;
      }
      function is_ref_of(ref, type) {
        if (!(ref instanceof AST_SymbolRef))
          return false;
        var orig = ref.definition().orig;
        for (var i = orig.length; --i >= 0; ) {
          if (orig[i] instanceof type)
            return true;
        }
      }
      function can_be_evicted_from_block(node) {
        return !(node instanceof AST_DefClass || node instanceof AST_Defun || node instanceof AST_Let || node instanceof AST_Const || node instanceof AST_Export || node instanceof AST_Import);
      }
      function as_statement_array(thing) {
        if (thing === null)
          return [];
        if (thing instanceof AST_BlockStatement)
          return thing.body;
        if (thing instanceof AST_EmptyStatement)
          return [];
        if (thing instanceof AST_Statement)
          return [thing];
        throw new Error("Can't convert thing to statement array");
      }
      function is_reachable(scope_node, defs) {
        const find_ref = (node) => {
          if (node instanceof AST_SymbolRef && defs.includes(node.definition())) {
            return walk_abort;
          }
        };
        return walk_parent(scope_node, (node, info) => {
          if (node instanceof AST_Scope && node !== scope_node) {
            var parent = info.parent();
            if (parent instanceof AST_Call && parent.expression === node && !(node.async || node.is_generator)) {
              return;
            }
            if (walk(node, find_ref))
              return walk_abort;
            return true;
          }
        });
      }
      function is_recursive_ref(tw, def) {
        var node;
        for (var i = 0; node = tw.parent(i); i++) {
          if (node instanceof AST_Lambda || node instanceof AST_Class) {
            var name = node.name;
            if (name && name.definition() === def) {
              return true;
            }
          }
        }
        return false;
      }
      function retain_top_func(fn, compressor) {
        return compressor.top_retain && fn instanceof AST_Defun && has_flag(fn, TOP) && fn.name && compressor.top_retain(fn.name.definition());
      }
      function make_nested_lookup(obj) {
        const out = /* @__PURE__ */ new Map();
        for (var key of Object.keys(obj)) {
          out.set(key, makePredicate(obj[key]));
        }
        const does_have = (global_name, fname) => {
          const inner_map = out.get(global_name);
          return inner_map != null && inner_map.has(fname);
        };
        return does_have;
      }
      const pure_prop_access_globals = /* @__PURE__ */ new Set([
        "Number",
        "String",
        "Array",
        "Object",
        "Function",
        "Promise"
      ]);
      const object_methods = [
        "constructor",
        "toString",
        "valueOf"
      ];
      const is_pure_native_method = make_nested_lookup({
        Array: [
          "at",
          "flat",
          "includes",
          "indexOf",
          "join",
          "lastIndexOf",
          "slice",
          ...object_methods
        ],
        Boolean: object_methods,
        Function: object_methods,
        Number: [
          "toExponential",
          "toFixed",
          "toPrecision",
          ...object_methods
        ],
        Object: object_methods,
        RegExp: [
          "test",
          ...object_methods
        ],
        String: [
          "at",
          "charAt",
          "charCodeAt",
          "charPointAt",
          "concat",
          "endsWith",
          "fromCharCode",
          "fromCodePoint",
          "includes",
          "indexOf",
          "italics",
          "lastIndexOf",
          "localeCompare",
          "match",
          "matchAll",
          "normalize",
          "padStart",
          "padEnd",
          "repeat",
          "replace",
          "replaceAll",
          "search",
          "slice",
          "split",
          "startsWith",
          "substr",
          "substring",
          "repeat",
          "toLocaleLowerCase",
          "toLocaleUpperCase",
          "toLowerCase",
          "toUpperCase",
          "trim",
          "trimEnd",
          "trimStart",
          ...object_methods
        ]
      });
      const is_pure_native_fn = make_nested_lookup({
        Array: [
          "isArray"
        ],
        Math: [
          "abs",
          "acos",
          "asin",
          "atan",
          "ceil",
          "cos",
          "exp",
          "floor",
          "log",
          "round",
          "sin",
          "sqrt",
          "tan",
          "atan2",
          "pow",
          "max",
          "min"
        ],
        Number: [
          "isFinite",
          "isNaN"
        ],
        Object: [
          "create",
          "getOwnPropertyDescriptor",
          "getOwnPropertyNames",
          "getPrototypeOf",
          "isExtensible",
          "isFrozen",
          "isSealed",
          "hasOwn",
          "keys"
        ],
        String: [
          "fromCharCode"
        ]
      });
      const is_pure_native_value = make_nested_lookup({
        Math: [
          "E",
          "LN10",
          "LN2",
          "LOG2E",
          "LOG10E",
          "PI",
          "SQRT1_2",
          "SQRT2"
        ],
        Number: [
          "MAX_VALUE",
          "MIN_VALUE",
          "NaN",
          "NEGATIVE_INFINITY",
          "POSITIVE_INFINITY"
        ]
      });
      const is_undeclared_ref = (node) => node instanceof AST_SymbolRef && node.definition().undeclared;
      const bitwise_binop = makePredicate("<<< >> << & | ^ ~");
      const lazy_op = makePredicate("&& || ??");
      const unary_side_effects = makePredicate("delete ++ --");
      (function(def_is_boolean) {
        const unary_bool = makePredicate("! delete");
        const binary_bool = makePredicate("in instanceof == != === !== < <= >= >");
        def_is_boolean(AST_Node, return_false);
        def_is_boolean(AST_UnaryPrefix, function() {
          return unary_bool.has(this.operator);
        });
        def_is_boolean(AST_Binary, function() {
          return binary_bool.has(this.operator) || lazy_op.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();
        });
        def_is_boolean(AST_Conditional, function() {
          return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def_is_boolean(AST_Assign, function() {
          return this.operator == "=" && this.right.is_boolean();
        });
        def_is_boolean(AST_Sequence, function() {
          return this.tail_node().is_boolean();
        });
        def_is_boolean(AST_True, return_true);
        def_is_boolean(AST_False, return_true);
      })(function(node, func) {
        node.DEFMETHOD("is_boolean", func);
      });
      (function(def_is_number) {
        def_is_number(AST_Node, return_false);
        def_is_number(AST_Number, return_true);
        const unary = makePredicate("+ - ~ ++ --");
        def_is_number(AST_Unary, function(compressor) {
          return unary.has(this.operator) && this.expression.is_number(compressor);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >> >>>");
        def_is_number(AST_Binary, function(compressor) {
          if (this.operator === "+") {
            return this.left.is_number(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_number(compressor) && this.left.is_number_or_bigint(compressor);
          } else if (numeric_ops.has(this.operator)) {
            return this.left.is_number(compressor) || this.right.is_number(compressor);
          } else {
            return false;
          }
        });
        def_is_number(AST_Assign, function(compressor) {
          return (this.operator === "=" || numeric_ops.has(this.operator.slice(0, -1))) && this.right.is_number(compressor);
        });
        def_is_number(AST_Sequence, function(compressor) {
          return this.tail_node().is_number(compressor);
        });
        def_is_number(AST_Conditional, function(compressor) {
          return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_number", func);
      });
      (function(def_is_bigint) {
        def_is_bigint(AST_Node, return_false);
        def_is_bigint(AST_BigInt, return_true);
        const unary = makePredicate("+ - ~ ++ --");
        def_is_bigint(AST_Unary, function(compressor) {
          return unary.has(this.operator) && this.expression.is_bigint(compressor);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >>");
        def_is_bigint(AST_Binary, function(compressor) {
          if (this.operator === "+") {
            return this.left.is_bigint(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_bigint(compressor) && this.left.is_number_or_bigint(compressor);
          } else if (numeric_ops.has(this.operator)) {
            return this.left.is_bigint(compressor) || this.right.is_bigint(compressor);
          } else {
            return false;
          }
        });
        def_is_bigint(AST_Assign, function(compressor) {
          return (numeric_ops.has(this.operator.slice(0, -1)) || this.operator == "=") && this.right.is_bigint(compressor);
        });
        def_is_bigint(AST_Sequence, function(compressor) {
          return this.tail_node().is_bigint(compressor);
        });
        def_is_bigint(AST_Conditional, function(compressor) {
          return this.consequent.is_bigint(compressor) && this.alternative.is_bigint(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_bigint", func);
      });
      (function(def_is_number_or_bigint) {
        def_is_number_or_bigint(AST_Node, return_false);
        def_is_number_or_bigint(AST_Number, return_true);
        def_is_number_or_bigint(AST_BigInt, return_true);
        const numeric_unary_ops = makePredicate("+ - ~ ++ --");
        def_is_number_or_bigint(AST_Unary, function(_compressor) {
          return numeric_unary_ops.has(this.operator);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >>");
        def_is_number_or_bigint(AST_Binary, function(compressor) {
          return this.operator === "+" ? this.left.is_number_or_bigint(compressor) && this.right.is_number_or_bigint(compressor) : numeric_ops.has(this.operator);
        });
        def_is_number_or_bigint(AST_Assign, function(compressor) {
          return numeric_ops.has(this.operator.slice(0, -1)) || this.operator == "=" && this.right.is_number_or_bigint(compressor);
        });
        def_is_number_or_bigint(AST_Sequence, function(compressor) {
          return this.tail_node().is_number_or_bigint(compressor);
        });
        def_is_number_or_bigint(AST_Conditional, function(compressor) {
          return this.consequent.is_number_or_bigint(compressor) && this.alternative.is_number_or_bigint(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_number_or_bigint", func);
      });
      (function(def_is_32_bit_integer) {
        def_is_32_bit_integer(AST_Node, return_false);
        def_is_32_bit_integer(AST_Number, function(_compressor) {
          return this.value === (this.value | 0);
        });
        def_is_32_bit_integer(AST_UnaryPrefix, function(compressor) {
          return this.operator == "~" ? this.expression.is_number(compressor) : this.operator === "+" ? this.expression.is_32_bit_integer(compressor) : false;
        });
        def_is_32_bit_integer(AST_Binary, function(compressor) {
          return bitwise_binop.has(this.operator) && (this.left.is_number(compressor) || this.right.is_number(compressor));
        });
      })(function(node, func) {
        node.DEFMETHOD("is_32_bit_integer", func);
      });
      (function(def_is_string) {
        def_is_string(AST_Node, return_false);
        def_is_string(AST_String, return_true);
        def_is_string(AST_TemplateString, return_true);
        def_is_string(AST_UnaryPrefix, function() {
          return this.operator == "typeof";
        });
        def_is_string(AST_Binary, function(compressor) {
          return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def_is_string(AST_Assign, function(compressor) {
          return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def_is_string(AST_Sequence, function(compressor) {
          return this.tail_node().is_string(compressor);
        });
        def_is_string(AST_Conditional, function(compressor) {
          return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_string", func);
      });
      function is_undefined(node, compressor) {
        return has_flag(node, UNDEFINED) || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == "void" && !node.expression.has_side_effects(compressor);
      }
      function is_null_or_undefined(node, compressor) {
        let fixed;
        return node instanceof AST_Null || is_undefined(node, compressor) || node instanceof AST_SymbolRef && (fixed = node.definition().fixed) instanceof AST_Node && is_nullish(fixed, compressor);
      }
      function is_nullish_shortcircuited(node, compressor) {
        if (node instanceof AST_PropAccess || node instanceof AST_Call) {
          return node.optional && is_null_or_undefined(node.expression, compressor) || is_nullish_shortcircuited(node.expression, compressor);
        }
        if (node instanceof AST_Chain)
          return is_nullish_shortcircuited(node.expression, compressor);
        return false;
      }
      function is_nullish(node, compressor) {
        if (is_null_or_undefined(node, compressor))
          return true;
        return is_nullish_shortcircuited(node, compressor);
      }
      (function(def_has_side_effects) {
        def_has_side_effects(AST_Node, return_true);
        def_has_side_effects(AST_EmptyStatement, return_false);
        def_has_side_effects(AST_Constant, return_false);
        def_has_side_effects(AST_This, return_false);
        function any(list, compressor) {
          for (var i = list.length; --i >= 0; )
            if (list[i].has_side_effects(compressor))
              return true;
          return false;
        }
        def_has_side_effects(AST_Block, function(compressor) {
          return any(this.body, compressor);
        });
        def_has_side_effects(AST_Call, function(compressor) {
          if (!this.is_callee_pure(compressor) && (!this.expression.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {
            return true;
          }
          return any(this.args, compressor);
        });
        def_has_side_effects(AST_Switch, function(compressor) {
          return this.expression.has_side_effects(compressor) || any(this.body, compressor);
        });
        def_has_side_effects(AST_Case, function(compressor) {
          return this.expression.has_side_effects(compressor) || any(this.body, compressor);
        });
        def_has_side_effects(AST_Try, function(compressor) {
          return this.body.has_side_effects(compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);
        });
        def_has_side_effects(AST_If, function(compressor) {
          return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);
        });
        def_has_side_effects(AST_ImportMeta, return_false);
        def_has_side_effects(AST_LabeledStatement, function(compressor) {
          return this.body.has_side_effects(compressor);
        });
        def_has_side_effects(AST_SimpleStatement, function(compressor) {
          return this.body.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Lambda, return_false);
        def_has_side_effects(AST_Class, function(compressor) {
          if (this.extends && this.extends.has_side_effects(compressor)) {
            return true;
          }
          return any(this.properties, compressor);
        });
        def_has_side_effects(AST_ClassStaticBlock, function(compressor) {
          return any(this.body, compressor);
        });
        def_has_side_effects(AST_Binary, function(compressor) {
          return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Assign, return_true);
        def_has_side_effects(AST_Conditional, function(compressor) {
          return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Unary, function(compressor) {
          return unary_side_effects.has(this.operator) || this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_SymbolRef, function(compressor) {
          return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
        });
        def_has_side_effects(AST_SymbolClassProperty, return_false);
        def_has_side_effects(AST_SymbolDeclaration, return_false);
        def_has_side_effects(AST_Object, function(compressor) {
          return any(this.properties, compressor);
        });
        def_has_side_effects(AST_ObjectKeyVal, function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor) || this.value && this.value.has_side_effects(compressor);
        });
        def_has_side_effects([
          AST_ClassProperty,
          AST_ClassPrivateProperty
        ], function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);
        });
        def_has_side_effects([
          AST_PrivateMethod,
          AST_PrivateGetter,
          AST_PrivateSetter,
          AST_ConciseMethod,
          AST_ObjectGetter,
          AST_ObjectSetter
        ], function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Array, function(compressor) {
          return any(this.elements, compressor);
        });
        def_has_side_effects(AST_Dot, function(compressor) {
          if (is_nullish(this, compressor)) {
            return this.expression.has_side_effects(compressor);
          }
          if (!this.optional && this.expression.may_throw_on_access(compressor)) {
            return true;
          }
          return this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Sub, function(compressor) {
          if (is_nullish(this, compressor)) {
            return this.expression.has_side_effects(compressor);
          }
          if (!this.optional && this.expression.may_throw_on_access(compressor)) {
            return true;
          }
          var property = this.property.has_side_effects(compressor);
          if (property && this.optional)
            return true;
          return property || this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Chain, function(compressor) {
          return this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Sequence, function(compressor) {
          return any(this.expressions, compressor);
        });
        def_has_side_effects(AST_Definitions, function(compressor) {
          return any(this.definitions, compressor);
        });
        def_has_side_effects(AST_VarDef, function() {
          return this.value != null;
        });
        def_has_side_effects(AST_TemplateSegment, return_false);
        def_has_side_effects(AST_TemplateString, function(compressor) {
          return any(this.segments, compressor);
        });
      })(function(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("has_side_effects", func);
        }
      });
      (function(def_may_throw) {
        def_may_throw(AST_Node, return_true);
        def_may_throw(AST_Constant, return_false);
        def_may_throw(AST_EmptyStatement, return_false);
        def_may_throw(AST_Lambda, return_false);
        def_may_throw(AST_SymbolDeclaration, return_false);
        def_may_throw(AST_This, return_false);
        def_may_throw(AST_ImportMeta, return_false);
        function any(list, compressor) {
          for (var i = list.length; --i >= 0; )
            if (list[i].may_throw(compressor))
              return true;
          return false;
        }
        def_may_throw(AST_Class, function(compressor) {
          if (this.extends && this.extends.may_throw(compressor))
            return true;
          return any(this.properties, compressor);
        });
        def_may_throw(AST_ClassStaticBlock, function(compressor) {
          return any(this.body, compressor);
        });
        def_may_throw(AST_Array, function(compressor) {
          return any(this.elements, compressor);
        });
        def_may_throw(AST_Assign, function(compressor) {
          if (this.right.may_throw(compressor))
            return true;
          if (!compressor.has_directive("use strict") && this.operator == "=" && this.left instanceof AST_SymbolRef) {
            return false;
          }
          return this.left.may_throw(compressor);
        });
        def_may_throw(AST_Binary, function(compressor) {
          return this.left.may_throw(compressor) || this.right.may_throw(compressor);
        });
        def_may_throw(AST_Block, function(compressor) {
          return any(this.body, compressor);
        });
        def_may_throw(AST_Call, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          if (any(this.args, compressor))
            return true;
          if (this.is_callee_pure(compressor))
            return false;
          if (this.expression.may_throw(compressor))
            return true;
          return !(this.expression instanceof AST_Lambda) || any(this.expression.body, compressor);
        });
        def_may_throw(AST_Case, function(compressor) {
          return this.expression.may_throw(compressor) || any(this.body, compressor);
        });
        def_may_throw(AST_Conditional, function(compressor) {
          return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);
        });
        def_may_throw(AST_Definitions, function(compressor) {
          return any(this.definitions, compressor);
        });
        def_may_throw(AST_If, function(compressor) {
          return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);
        });
        def_may_throw(AST_LabeledStatement, function(compressor) {
          return this.body.may_throw(compressor);
        });
        def_may_throw(AST_Object, function(compressor) {
          return any(this.properties, compressor);
        });
        def_may_throw(AST_ObjectKeyVal, function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor) || this.value ? this.value.may_throw(compressor) : false;
        });
        def_may_throw([
          AST_ClassProperty,
          AST_ClassPrivateProperty
        ], function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor) || this.static && this.value && this.value.may_throw(compressor);
        });
        def_may_throw([
          AST_ConciseMethod,
          AST_ObjectGetter,
          AST_ObjectSetter
        ], function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor);
        });
        def_may_throw([
          AST_PrivateMethod,
          AST_PrivateGetter,
          AST_PrivateSetter
        ], return_false);
        def_may_throw(AST_Return, function(compressor) {
          return this.value && this.value.may_throw(compressor);
        });
        def_may_throw(AST_Sequence, function(compressor) {
          return any(this.expressions, compressor);
        });
        def_may_throw(AST_SimpleStatement, function(compressor) {
          return this.body.may_throw(compressor);
        });
        def_may_throw(AST_Dot, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);
        });
        def_may_throw(AST_Sub, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);
        });
        def_may_throw(AST_Chain, function(compressor) {
          return this.expression.may_throw(compressor);
        });
        def_may_throw(AST_Switch, function(compressor) {
          return this.expression.may_throw(compressor) || any(this.body, compressor);
        });
        def_may_throw(AST_SymbolRef, function(compressor) {
          return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
        });
        def_may_throw(AST_SymbolClassProperty, return_false);
        def_may_throw(AST_Try, function(compressor) {
          return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor) || this.bfinally && this.bfinally.may_throw(compressor);
        });
        def_may_throw(AST_Unary, function(compressor) {
          if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
            return false;
          return this.expression.may_throw(compressor);
        });
        def_may_throw(AST_VarDef, function(compressor) {
          if (!this.value)
            return false;
          return this.value.may_throw(compressor);
        });
      })(function(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("may_throw", func);
        }
      });
      (function(def_is_constant_expression) {
        function all_refs_local(scope) {
          let result = true;
          walk(this, (node) => {
            if (node instanceof AST_SymbolRef) {
              if (has_flag(this, INLINED)) {
                result = false;
                return walk_abort;
              }
              var def = node.definition();
              if (member(def, this.enclosed) && !this.variables.has(def.name)) {
                if (scope) {
                  var scope_def = scope.find_variable(node);
                  if (def.undeclared ? !scope_def : scope_def === def) {
                    result = "f";
                    return true;
                  }
                }
                result = false;
                return walk_abort;
              }
              return true;
            }
            if (node instanceof AST_This && this instanceof AST_Arrow) {
              result = false;
              return walk_abort;
            }
          });
          return result;
        }
        def_is_constant_expression(AST_Node, return_false);
        def_is_constant_expression(AST_Constant, return_true);
        def_is_constant_expression(AST_Class, function(scope) {
          if (this.extends && !this.extends.is_constant_expression(scope)) {
            return false;
          }
          for (const prop of this.properties) {
            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {
              return false;
            }
            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {
              return false;
            }
            if (prop instanceof AST_ClassStaticBlock) {
              return false;
            }
          }
          return all_refs_local.call(this, scope);
        });
        def_is_constant_expression(AST_Lambda, all_refs_local);
        def_is_constant_expression(AST_Unary, function() {
          return this.expression.is_constant_expression();
        });
        def_is_constant_expression(AST_Binary, function() {
          return this.left.is_constant_expression() && this.right.is_constant_expression();
        });
        def_is_constant_expression(AST_Array, function() {
          return this.elements.every((l) => l.is_constant_expression());
        });
        def_is_constant_expression(AST_Object, function() {
          return this.properties.every((l) => l.is_constant_expression());
        });
        def_is_constant_expression(AST_ObjectProperty, function() {
          return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());
        });
      })(function(node, func) {
        node.DEFMETHOD("is_constant_expression", func);
      });
      (function(def_may_throw_on_access) {
        AST_Node.DEFMETHOD("may_throw_on_access", function(compressor) {
          return !compressor.option("pure_getters") || this._dot_throw(compressor);
        });
        function is_strict(compressor) {
          return /strict/.test(compressor.option("pure_getters"));
        }
        def_may_throw_on_access(AST_Node, is_strict);
        def_may_throw_on_access(AST_Null, return_true);
        def_may_throw_on_access(AST_Undefined, return_true);
        def_may_throw_on_access(AST_Constant, return_false);
        def_may_throw_on_access(AST_Array, return_false);
        def_may_throw_on_access(AST_Object, function(compressor) {
          if (!is_strict(compressor))
            return false;
          for (var i = this.properties.length; --i >= 0; )
            if (this.properties[i]._dot_throw(compressor))
              return true;
          return false;
        });
        def_may_throw_on_access(AST_Class, return_false);
        def_may_throw_on_access(AST_ObjectProperty, return_false);
        def_may_throw_on_access(AST_ObjectGetter, return_true);
        def_may_throw_on_access(AST_Expansion, function(compressor) {
          return this.expression._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Function, return_false);
        def_may_throw_on_access(AST_Arrow, return_false);
        def_may_throw_on_access(AST_UnaryPostfix, return_false);
        def_may_throw_on_access(AST_UnaryPrefix, function() {
          return this.operator == "void";
        });
        def_may_throw_on_access(AST_Binary, function(compressor) {
          return (this.operator == "&&" || this.operator == "||" || this.operator == "??") && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
        });
        def_may_throw_on_access(AST_Assign, function(compressor) {
          if (this.logical)
            return true;
          return this.operator == "=" && this.right._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Conditional, function(compressor) {
          return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Dot, function(compressor) {
          if (!is_strict(compressor))
            return false;
          if (this.property == "prototype") {
            return !(this.expression instanceof AST_Function || this.expression instanceof AST_Class);
          }
          return true;
        });
        def_may_throw_on_access(AST_Chain, function(compressor) {
          return this.expression._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Sequence, function(compressor) {
          return this.tail_node()._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_SymbolRef, function(compressor) {
          if (this.name === "arguments" && this.scope instanceof AST_Lambda)
            return false;
          if (has_flag(this, UNDEFINED))
            return true;
          if (!is_strict(compressor))
            return false;
          if (is_undeclared_ref(this) && this.is_declared(compressor))
            return false;
          if (this.is_immutable())
            return false;
          var fixed = this.fixed_value();
          return !fixed || fixed._dot_throw(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("_dot_throw", func);
      });
      function is_lhs(node, parent) {
        if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator))
          return parent.expression;
        if (parent instanceof AST_Assign && parent.left === node)
          return node;
        if (parent instanceof AST_ForIn && parent.init === node)
          return node;
      }
      (function(def_negate) {
        function basic_negation(exp) {
          return make_node(AST_UnaryPrefix, exp, {
            operator: "!",
            expression: exp
          });
        }
        function best(orig, alt, first_in_statement2) {
          var negated = basic_negation(orig);
          if (first_in_statement2) {
            var stat = make_node(AST_SimpleStatement, alt, {
              body: alt
            });
            return best_of_expression(negated, stat) === stat ? alt : negated;
          }
          return best_of_expression(negated, alt);
        }
        def_negate(AST_Node, function() {
          return basic_negation(this);
        });
        def_negate(AST_Statement, function() {
          throw new Error("Cannot negate a statement");
        });
        def_negate(AST_Function, function() {
          return basic_negation(this);
        });
        def_negate(AST_Class, function() {
          return basic_negation(this);
        });
        def_negate(AST_Arrow, function() {
          return basic_negation(this);
        });
        def_negate(AST_UnaryPrefix, function() {
          if (this.operator == "!")
            return this.expression;
          return basic_negation(this);
        });
        def_negate(AST_Sequence, function(compressor) {
          var expressions = this.expressions.slice();
          expressions.push(expressions.pop().negate(compressor));
          return make_sequence(this, expressions);
        });
        def_negate(AST_Conditional, function(compressor, first_in_statement2) {
          var self2 = this.clone();
          self2.consequent = self2.consequent.negate(compressor);
          self2.alternative = self2.alternative.negate(compressor);
          return best(this, self2, first_in_statement2);
        });
        def_negate(AST_Binary, function(compressor, first_in_statement2) {
          var self2 = this.clone(), op = this.operator;
          if (compressor.option("unsafe_comps")) {
            switch (op) {
              case "<=":
                self2.operator = ">";
                return self2;
              case "<":
                self2.operator = ">=";
                return self2;
              case ">=":
                self2.operator = "<";
                return self2;
              case ">":
                self2.operator = "<=";
                return self2;
            }
          }
          switch (op) {
            case "==":
              self2.operator = "!=";
              return self2;
            case "!=":
              self2.operator = "==";
              return self2;
            case "===":
              self2.operator = "!==";
              return self2;
            case "!==":
              self2.operator = "===";
              return self2;
            case "&&":
              self2.operator = "||";
              self2.left = self2.left.negate(compressor, first_in_statement2);
              self2.right = self2.right.negate(compressor);
              return best(this, self2, first_in_statement2);
            case "||":
              self2.operator = "&&";
              self2.left = self2.left.negate(compressor, first_in_statement2);
              self2.right = self2.right.negate(compressor);
              return best(this, self2, first_in_statement2);
          }
          return basic_negation(this);
        });
      })(function(node, func) {
        node.DEFMETHOD("negate", function(compressor, first_in_statement2) {
          return func.call(this, compressor, first_in_statement2);
        });
      });
      (function(def_bitwise_negate) {
        function basic_bitwise_negation(exp) {
          return make_node(AST_UnaryPrefix, exp, {
            operator: "~",
            expression: exp
          });
        }
        def_bitwise_negate(AST_Node, function(_compressor) {
          return basic_bitwise_negation(this);
        });
        def_bitwise_negate(AST_Number, function(_compressor) {
          const neg = ~this.value;
          if (neg.toString().length > this.value.toString().length) {
            return basic_bitwise_negation(this);
          }
          return make_node(AST_Number, this, { value: neg });
        });
        def_bitwise_negate(AST_UnaryPrefix, function(compressor, in_32_bit_context) {
          if (this.operator == "~" && (this.expression.is_32_bit_integer(compressor) || (in_32_bit_context != null ? in_32_bit_context : compressor.in_32_bit_context()))) {
            return this.expression;
          } else {
            return basic_bitwise_negation(this);
          }
        });
      })(function(node, func) {
        node.DEFMETHOD("bitwise_negate", func);
      });
      var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
      AST_Call.DEFMETHOD("is_callee_pure", function(compressor) {
        if (compressor.option("unsafe")) {
          var expr = this.expression;
          var first_arg = this.args && this.args[0] && this.args[0].evaluate(compressor);
          if (expr.expression && expr.expression.name === "hasOwnProperty" && (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {
            return false;
          }
          if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name))
            return true;
          if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression) && is_pure_native_fn(expr.expression.name, expr.property)) {
            return true;
          }
        }
        if (this instanceof AST_New && compressor.option("pure_new")) {
          return true;
        }
        if (compressor.option("side_effects") && has_annotation(this, _PURE)) {
          return true;
        }
        return !compressor.pure_funcs(this);
      });
      AST_Node.DEFMETHOD("is_call_pure", return_false);
      AST_Dot.DEFMETHOD("is_call_pure", function(compressor) {
        if (!compressor.option("unsafe"))
          return;
        const expr = this.expression;
        let native_obj;
        if (expr instanceof AST_Array) {
          native_obj = "Array";
        } else if (expr.is_boolean()) {
          native_obj = "Boolean";
        } else if (expr.is_number(compressor)) {
          native_obj = "Number";
        } else if (expr instanceof AST_RegExp) {
          native_obj = "RegExp";
        } else if (expr.is_string(compressor)) {
          native_obj = "String";
        } else if (!this.may_throw_on_access(compressor)) {
          native_obj = "Object";
        }
        return native_obj != null && is_pure_native_method(native_obj, this.property);
      });
      const aborts = (thing) => thing && thing.aborts();
      (function(def_aborts) {
        def_aborts(AST_Statement, return_null);
        def_aborts(AST_Jump, return_this);
        function block_aborts() {
          for (var i = 0; i < this.body.length; i++) {
            if (aborts(this.body[i])) {
              return this.body[i];
            }
          }
          return null;
        }
        def_aborts(AST_Import, return_null);
        def_aborts(AST_BlockStatement, block_aborts);
        def_aborts(AST_SwitchBranch, block_aborts);
        def_aborts(AST_DefClass, function() {
          for (const prop of this.properties) {
            if (prop instanceof AST_ClassStaticBlock) {
              if (prop.aborts())
                return prop;
            }
          }
          return null;
        });
        def_aborts(AST_ClassStaticBlock, block_aborts);
        def_aborts(AST_If, function() {
          return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
        });
      })(function(node, func) {
        node.DEFMETHOD("aborts", func);
      });
      AST_Node.DEFMETHOD("contains_this", function() {
        return walk(this, (node) => {
          if (node instanceof AST_This)
            return walk_abort;
          if (node !== this && node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
            return true;
          }
        });
      });
      function is_modified(compressor, tw, node, value2, level, immutable) {
        var parent = tw.parent(level);
        var lhs = is_lhs(node, parent);
        if (lhs)
          return lhs;
        if (!immutable && parent instanceof AST_Call && parent.expression === node && !(value2 instanceof AST_Arrow) && !(value2 instanceof AST_Class) && !parent.is_callee_pure(compressor) && (!(value2 instanceof AST_Function) || !(parent instanceof AST_New) && value2.contains_this())) {
          return true;
        }
        if (parent instanceof AST_Array) {
          return is_modified(compressor, tw, parent, parent, level + 1);
        }
        if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
          var obj = tw.parent(level + 1);
          return is_modified(compressor, tw, obj, obj, level + 2);
        }
        if (parent instanceof AST_PropAccess && parent.expression === node) {
          var prop = read_property(value2, parent.property);
          return !immutable && is_modified(compressor, tw, parent, prop, level + 1);
        }
      }
      function is_used_in_expression(tw) {
        for (let p = -1, node, parent; node = tw.parent(p), parent = tw.parent(p + 1); p++) {
          if (parent instanceof AST_Sequence) {
            const nth_expression = parent.expressions.indexOf(node);
            if (nth_expression !== parent.expressions.length - 1) {
              const grandparent = tw.parent(p + 2);
              if (parent.expressions.length > 2 || parent.expressions.length === 1 || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])) {
                return false;
              }
              return true;
            } else {
              continue;
            }
          }
          if (parent instanceof AST_Unary) {
            const op = parent.operator;
            if (op === "void") {
              return false;
            }
            if (op === "typeof" || op === "+" || op === "-" || op === "!" || op === "~") {
              continue;
            }
          }
          if (parent instanceof AST_SimpleStatement || parent instanceof AST_LabeledStatement) {
            return false;
          }
          if (parent instanceof AST_Scope) {
            return false;
          }
          return true;
        }
        return true;
      }
      function def_eval(node, func) {
        node.DEFMETHOD("_eval", func);
      }
      const nullish = Symbol("This AST_Chain is nullish");
      AST_Node.DEFMETHOD("evaluate", function(compressor) {
        if (!compressor.option("evaluate"))
          return this;
        var val = this._eval(compressor, 1);
        if (!val || val instanceof RegExp)
          return val;
        if (typeof val == "function" || typeof val == "object" || val == nullish)
          return this;
        if (typeof val === "string") {
          const unevaluated_size = this.size(compressor);
          if (val.length + 2 > unevaluated_size)
            return this;
        }
        return val;
      });
      var unaryPrefix = makePredicate("! ~ - + void");
      AST_Node.DEFMETHOD("is_constant", function() {
        if (this instanceof AST_Constant) {
          return !(this instanceof AST_RegExp);
        } else {
          return this instanceof AST_UnaryPrefix && unaryPrefix.has(this.operator) && (this.expression instanceof AST_Constant || this.expression.is_constant());
        }
      });
      def_eval(AST_Statement, function() {
        throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
      });
      def_eval(AST_Lambda, return_this);
      def_eval(AST_Class, return_this);
      def_eval(AST_Node, return_this);
      def_eval(AST_Constant, function() {
        return this.getValue();
      });
      const supports_bigint = typeof BigInt === "function";
      def_eval(AST_BigInt, function() {
        if (supports_bigint) {
          return BigInt(this.value);
        } else {
          return this;
        }
      });
      def_eval(AST_RegExp, function(compressor) {
        let evaluated = compressor.evaluated_regexps.get(this.value);
        if (evaluated === void 0 && regexp_is_safe(this.value.source)) {
          try {
            const { source, flags } = this.value;
            evaluated = new RegExp(source, flags);
          } catch (e) {
            evaluated = null;
          }
          compressor.evaluated_regexps.set(this.value, evaluated);
        }
        return evaluated || this;
      });
      def_eval(AST_TemplateString, function() {
        if (this.segments.length !== 1)
          return this;
        return this.segments[0].value;
      });
      def_eval(AST_Function, function(compressor) {
        if (compressor.option("unsafe")) {
          var fn = function() {
          };
          fn.node = this;
          fn.toString = () => this.print_to_string();
          return fn;
        }
        return this;
      });
      def_eval(AST_Array, function(compressor, depth) {
        if (compressor.option("unsafe")) {
          var elements = [];
          for (var i = 0, len = this.elements.length; i < len; i++) {
            var element2 = this.elements[i];
            var value2 = element2._eval(compressor, depth);
            if (element2 === value2)
              return this;
            elements.push(value2);
          }
          return elements;
        }
        return this;
      });
      def_eval(AST_Object, function(compressor, depth) {
        if (compressor.option("unsafe")) {
          var val = {};
          for (var i = 0, len = this.properties.length; i < len; i++) {
            var prop = this.properties[i];
            if (prop instanceof AST_Expansion)
              return this;
            var key = prop.key;
            if (key instanceof AST_Symbol) {
              key = key.name;
            } else if (key instanceof AST_Node) {
              key = key._eval(compressor, depth);
              if (key === prop.key)
                return this;
            }
            if (typeof Object.prototype[key] === "function") {
              return this;
            }
            if (prop.value instanceof AST_Function)
              continue;
            val[key] = prop.value._eval(compressor, depth);
            if (val[key] === prop.value)
              return this;
          }
          return val;
        }
        return this;
      });
      var non_converting_unary = makePredicate("! typeof void");
      def_eval(AST_UnaryPrefix, function(compressor, depth) {
        var e = this.expression;
        if (compressor.option("typeofs") && this.operator == "typeof") {
          if (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda) {
            return "function";
          }
          if ((e instanceof AST_Object || e instanceof AST_Array || e instanceof AST_SymbolRef && (e.fixed_value() instanceof AST_Object || e.fixed_value() instanceof AST_Array)) && !e.has_side_effects(compressor)) {
            return typeof {};
          }
        }
        if (!non_converting_unary.has(this.operator))
          depth++;
        e = e._eval(compressor, depth);
        if (e === this.expression)
          return this;
        switch (this.operator) {
          case "!":
            return !e;
          case "typeof":
            if (e instanceof RegExp)
              return this;
            return typeof e;
          case "void":
            return void 0;
          case "~":
            return ~e;
          case "-":
            return -e;
          case "+":
            return +e;
        }
        return this;
      });
      var non_converting_binary = makePredicate("&& || ?? === !==");
      const identity_comparison = makePredicate("== != === !==");
      const has_identity = (value2) => typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol";
      def_eval(AST_Binary, function(compressor, depth) {
        if (!non_converting_binary.has(this.operator))
          depth++;
        var left = this.left._eval(compressor, depth);
        if (left === this.left)
          return this;
        var right = this.right._eval(compressor, depth);
        if (right === this.right)
          return this;
        if (left != null && right != null && identity_comparison.has(this.operator) && has_identity(left) && has_identity(right) && typeof left === typeof right) {
          return this;
        }
        if (typeof left === "bigint" !== (typeof right === "bigint") || typeof left === "bigint" && (this.operator === ">>>" || this.operator === "/" && Number(right) === 0)) {
          return this;
        }
        var result;
        switch (this.operator) {
          case "&&":
            result = left && right;
            break;
          case "||":
            result = left || right;
            break;
          case "??":
            result = left != null ? left : right;
            break;
          case "|":
            result = left | right;
            break;
          case "&":
            result = left & right;
            break;
          case "^":
            result = left ^ right;
            break;
          case "+":
            result = left + right;
            break;
          case "*":
            result = left * right;
            break;
          case "**":
            result = left ** right;
            break;
          case "/":
            result = left / right;
            break;
          case "%":
            result = left % right;
            break;
          case "-":
            result = left - right;
            break;
          case "<<":
            result = left << right;
            break;
          case ">>":
            result = left >> right;
            break;
          case ">>>":
            result = left >>> right;
            break;
          case "==":
            result = left == right;
            break;
          case "===":
            result = left === right;
            break;
          case "!=":
            result = left != right;
            break;
          case "!==":
            result = left !== right;
            break;
          case "<":
            result = left < right;
            break;
          case "<=":
            result = left <= right;
            break;
          case ">":
            result = left > right;
            break;
          case ">=":
            result = left >= right;
            break;
          default:
            return this;
        }
        if (typeof result === "number" && isNaN(result) && compressor.find_parent(AST_With)) {
          return this;
        }
        return result;
      });
      def_eval(AST_Conditional, function(compressor, depth) {
        var condition = this.condition._eval(compressor, depth);
        if (condition === this.condition)
          return this;
        var node = condition ? this.consequent : this.alternative;
        var value2 = node._eval(compressor, depth);
        return value2 === node ? this : value2;
      });
      const reentrant_ref_eval = /* @__PURE__ */ new Set();
      def_eval(AST_SymbolRef, function(compressor, depth) {
        if (reentrant_ref_eval.has(this))
          return this;
        var fixed = this.fixed_value();
        if (!fixed)
          return this;
        reentrant_ref_eval.add(this);
        const value2 = fixed._eval(compressor, depth);
        reentrant_ref_eval.delete(this);
        if (value2 === fixed)
          return this;
        if (value2 && typeof value2 == "object") {
          var escaped = this.definition().escaped;
          if (escaped && depth > escaped)
            return this;
        }
        return value2;
      });
      const global_objs = { Array, Math, Number, Object, String };
      const regexp_flags = /* @__PURE__ */ new Set([
        "dotAll",
        "global",
        "ignoreCase",
        "multiline",
        "sticky",
        "unicode"
      ]);
      def_eval(AST_PropAccess, function(compressor, depth) {
        let obj = this.expression._eval(compressor, depth + 1);
        if (obj === nullish || this.optional && obj == null)
          return nullish;
        if (this.property === "length") {
          if (typeof obj === "string") {
            return obj.length;
          }
          const is_spreadless_array = obj instanceof AST_Array && obj.elements.every((el) => !(el instanceof AST_Expansion));
          if (is_spreadless_array && obj.elements.every((el) => !el.has_side_effects(compressor))) {
            return obj.elements.length;
          }
        }
        if (compressor.option("unsafe")) {
          var key = this.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, depth);
            if (key === this.property)
              return this;
          }
          var exp = this.expression;
          if (is_undeclared_ref(exp)) {
            var aa;
            var first_arg = exp.name === "hasOwnProperty" && key === "call" && (aa = compressor.parent() && compressor.parent().args) && (aa && aa[0] && aa[0].evaluate(compressor));
            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
              return this.clone();
            }
            if (!is_pure_native_value(exp.name, key))
              return this;
            obj = global_objs[exp.name];
          } else {
            if (obj instanceof RegExp) {
              if (key == "source") {
                return regexp_source_fix(obj.source);
              } else if (key == "flags" || regexp_flags.has(key)) {
                return obj[key];
              }
            }
            if (!obj || obj === exp || !HOP(obj, key))
              return this;
            if (typeof obj == "function")
              switch (key) {
                case "name":
                  return obj.node.name ? obj.node.name.name : "";
                case "length":
                  return obj.node.length_property();
                default:
                  return this;
              }
          }
          return obj[key];
        }
        return this;
      });
      def_eval(AST_Chain, function(compressor, depth) {
        const evaluated = this.expression._eval(compressor, depth);
        return evaluated === nullish ? void 0 : evaluated === this.expression ? this : evaluated;
      });
      def_eval(AST_Call, function(compressor, depth) {
        var exp = this.expression;
        const callee = exp._eval(compressor, depth);
        if (callee === nullish || this.optional && callee == null)
          return nullish;
        if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
          var key = exp.property;
          if (key instanceof AST_Node) {
            key = key._eval(compressor, depth);
            if (key === exp.property)
              return this;
          }
          var val;
          var e = exp.expression;
          if (is_undeclared_ref(e)) {
            var first_arg = e.name === "hasOwnProperty" && key === "call" && (this.args[0] && this.args[0].evaluate(compressor));
            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
              return this.clone();
            }
            if (!is_pure_native_fn(e.name, key))
              return this;
            val = global_objs[e.name];
          } else {
            val = e._eval(compressor, depth + 1);
            if (val === e || !val)
              return this;
            if (!is_pure_native_method(val.constructor.name, key))
              return this;
          }
          var args = [];
          for (var i = 0, len = this.args.length; i < len; i++) {
            var arg = this.args[i];
            var value2 = arg._eval(compressor, depth);
            if (arg === value2)
              return this;
            if (arg instanceof AST_Lambda)
              return this;
            args.push(value2);
          }
          try {
            return val[key].apply(val, args);
          } catch (ex) {
          }
        }
        return this;
      });
      def_eval(AST_New, return_this);
      function def_drop_side_effect_free(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("drop_side_effect_free", func);
        }
      }
      function trim(nodes, compressor, first_in_statement2) {
        var len = nodes.length;
        if (!len)
          return null;
        var ret = [], changed = false;
        for (var i = 0; i < len; i++) {
          var node = nodes[i].drop_side_effect_free(compressor, first_in_statement2);
          changed |= node !== nodes[i];
          if (node) {
            ret.push(node);
            first_in_statement2 = false;
          }
        }
        return changed ? ret.length ? ret : null : nodes;
      }
      def_drop_side_effect_free(AST_Node, return_this);
      def_drop_side_effect_free(AST_Constant, return_null);
      def_drop_side_effect_free(AST_This, return_null);
      def_drop_side_effect_free(AST_Call, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.is_callee_pure(compressor)) {
          if (this.expression.is_call_pure(compressor)) {
            var exprs = this.args.slice();
            exprs.unshift(this.expression.expression);
            exprs = trim(exprs, compressor, first_in_statement2);
            return exprs && make_sequence(this, exprs);
          }
          if (is_func_expr(this.expression) && (!this.expression.name || !this.expression.name.definition().references.length)) {
            var node = this.clone();
            node.expression.process_expression(false, compressor);
            return node;
          }
          return this;
        }
        var args = trim(this.args, compressor, first_in_statement2);
        return args && make_sequence(this, args);
      });
      def_drop_side_effect_free(AST_Accessor, return_null);
      def_drop_side_effect_free(AST_Function, return_null);
      def_drop_side_effect_free(AST_Arrow, return_null);
      def_drop_side_effect_free(AST_Class, function(compressor) {
        const with_effects = [];
        if (this.is_self_referential() && this.has_side_effects(compressor)) {
          return this;
        }
        const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);
        if (trimmed_extends)
          with_effects.push(trimmed_extends);
        for (const prop of this.properties) {
          if (prop instanceof AST_ClassStaticBlock) {
            if (prop.has_side_effects(compressor)) {
              return this;
            }
          } else {
            const trimmed_prop = prop.drop_side_effect_free(compressor);
            if (trimmed_prop)
              with_effects.push(trimmed_prop);
          }
        }
        if (!with_effects.length)
          return null;
        const exprs = make_sequence(this, with_effects);
        if (this instanceof AST_DefClass) {
          return make_node(AST_SimpleStatement, this, { body: exprs });
        } else {
          return exprs;
        }
      });
      def_drop_side_effect_free([
        AST_ClassProperty,
        AST_ClassPrivateProperty
      ], function(compressor) {
        const key = this.computed_key() && this.key.drop_side_effect_free(compressor);
        const value2 = this.static && this.value && this.value.drop_side_effect_free(compressor);
        if (key && value2)
          return make_sequence(this, [key, value2]);
        return key || value2 || null;
      });
      def_drop_side_effect_free(AST_Binary, function(compressor, first_in_statement2) {
        var right = this.right.drop_side_effect_free(compressor);
        if (!right)
          return this.left.drop_side_effect_free(compressor, first_in_statement2);
        if (lazy_op.has(this.operator)) {
          if (right === this.right)
            return this;
          var node = this.clone();
          node.right = right;
          return node;
        } else {
          var left = this.left.drop_side_effect_free(compressor, first_in_statement2);
          if (!left)
            return this.right.drop_side_effect_free(compressor, first_in_statement2);
          return make_sequence(this, [left, right]);
        }
      });
      def_drop_side_effect_free(AST_Assign, function(compressor) {
        if (this.logical)
          return this;
        var left = this.left;
        if (left.has_side_effects(compressor) || compressor.has_directive("use strict") && left instanceof AST_PropAccess && left.expression.is_constant()) {
          return this;
        }
        set_flag(this, WRITE_ONLY);
        while (left instanceof AST_PropAccess) {
          left = left.expression;
        }
        if (left.is_constant_expression(compressor.find_parent(AST_Scope))) {
          return this.right.drop_side_effect_free(compressor);
        }
        return this;
      });
      def_drop_side_effect_free(AST_Conditional, function(compressor) {
        var consequent = this.consequent.drop_side_effect_free(compressor);
        var alternative = this.alternative.drop_side_effect_free(compressor);
        if (consequent === this.consequent && alternative === this.alternative)
          return this;
        if (!consequent)
          return alternative ? make_node(AST_Binary, this, {
            operator: "||",
            left: this.condition,
            right: alternative
          }) : this.condition.drop_side_effect_free(compressor);
        if (!alternative)
          return make_node(AST_Binary, this, {
            operator: "&&",
            left: this.condition,
            right: consequent
          });
        var node = this.clone();
        node.consequent = consequent;
        node.alternative = alternative;
        return node;
      });
      def_drop_side_effect_free(AST_Unary, function(compressor, first_in_statement2) {
        if (unary_side_effects.has(this.operator)) {
          if (!this.expression.has_side_effects(compressor)) {
            set_flag(this, WRITE_ONLY);
          } else {
            clear_flag(this, WRITE_ONLY);
          }
          return this;
        }
        if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
          return null;
        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
        if (first_in_statement2 && expression && is_iife_call(expression)) {
          if (expression === this.expression && this.operator == "!")
            return this;
          return expression.negate(compressor, first_in_statement2);
        }
        return expression;
      });
      def_drop_side_effect_free(AST_SymbolRef, function(compressor) {
        const safe_access = this.is_declared(compressor) || pure_prop_access_globals.has(this.name);
        return safe_access ? null : this;
      });
      def_drop_side_effect_free(AST_Object, function(compressor, first_in_statement2) {
        var values = trim(this.properties, compressor, first_in_statement2);
        return values && make_sequence(this, values);
      });
      def_drop_side_effect_free(AST_ObjectKeyVal, function(compressor, first_in_statement2) {
        const computed_key = this.key instanceof AST_Node;
        const key = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement2);
        const value2 = this.value.drop_side_effect_free(compressor, first_in_statement2);
        if (key && value2) {
          return make_sequence(this, [key, value2]);
        }
        return key || value2;
      });
      def_drop_side_effect_free([
        AST_ConciseMethod,
        AST_ObjectGetter,
        AST_ObjectSetter
      ], function() {
        return this.computed_key() ? this.key : null;
      });
      def_drop_side_effect_free([
        AST_PrivateMethod,
        AST_PrivateGetter,
        AST_PrivateSetter
      ], function() {
        return null;
      });
      def_drop_side_effect_free(AST_Array, function(compressor, first_in_statement2) {
        var values = trim(this.elements, compressor, first_in_statement2);
        return values && make_sequence(this, values);
      });
      def_drop_side_effect_free(AST_Dot, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
          return this;
        }
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_Sub, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
          return this;
        }
        var property = this.property.drop_side_effect_free(compressor);
        if (property && this.optional)
          return this;
        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
        if (expression && property)
          return make_sequence(this, [expression, property]);
        return expression || property;
      });
      def_drop_side_effect_free(AST_Chain, function(compressor, first_in_statement2) {
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_Sequence, function(compressor) {
        var last = this.tail_node();
        var expr = last.drop_side_effect_free(compressor);
        if (expr === last)
          return this;
        var expressions = this.expressions.slice(0, -1);
        if (expr)
          expressions.push(expr);
        if (!expressions.length) {
          return make_node(AST_Number, this, { value: 0 });
        }
        return make_sequence(this, expressions);
      });
      def_drop_side_effect_free(AST_Expansion, function(compressor, first_in_statement2) {
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_TemplateSegment, return_null);
      def_drop_side_effect_free(AST_TemplateString, function(compressor) {
        var values = trim(this.segments, compressor, first_in_statement);
        return values && make_sequence(this, values);
      });
      const r_keep_assign = /keep_assign/;
      AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
        if (!compressor.option("unused"))
          return;
        if (compressor.has_directive("use asm"))
          return;
        if (!this.variables)
          return;
        var self2 = this;
        if (self2.pinned())
          return;
        var drop_funcs = !(self2 instanceof AST_Toplevel) || compressor.toplevel.funcs;
        var drop_vars = !(self2 instanceof AST_Toplevel) || compressor.toplevel.vars;
        const assign_as_unused = r_keep_assign.test(compressor.option("unused")) ? return_false : function(node) {
          if (node instanceof AST_Assign && !node.logical && (has_flag(node, WRITE_ONLY) || node.operator == "=")) {
            return node.left;
          }
          if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {
            return node.expression;
          }
        };
        var in_use_ids = /* @__PURE__ */ new Map();
        var fixed_ids = /* @__PURE__ */ new Map();
        if (self2 instanceof AST_Toplevel && compressor.top_retain) {
          self2.variables.forEach(function(def) {
            if (compressor.top_retain(def)) {
              in_use_ids.set(def.id, def);
            }
          });
        }
        var var_defs_by_id = /* @__PURE__ */ new Map();
        var initializations = /* @__PURE__ */ new Map();
        var scope = this;
        var tw = new TreeWalker(function(node, descend) {
          if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
            node.argnames.forEach(function(argname) {
              if (!(argname instanceof AST_SymbolDeclaration))
                return;
              var def = argname.definition();
              in_use_ids.set(def.id, def);
            });
          }
          if (node === self2)
            return;
          if (node instanceof AST_Class && node.has_side_effects(compressor)) {
            if (node.is_self_referential()) {
              descend();
            } else {
              node.visit_nondeferred_class_parts(tw);
            }
          }
          if (node instanceof AST_Defun || node instanceof AST_DefClass) {
            var node_def = node.name.definition();
            const in_export = tw.parent() instanceof AST_Export;
            if (in_export || !drop_funcs && scope === self2) {
              if (node_def.global) {
                in_use_ids.set(node_def.id, node_def);
              }
            }
            map_add(initializations, node_def.id, node);
            return true;
          }
          const in_root_scope = scope === self2;
          if (node instanceof AST_SymbolFunarg && in_root_scope) {
            map_add(var_defs_by_id, node.definition().id, node);
          }
          if (node instanceof AST_Definitions && in_root_scope) {
            const in_export = tw.parent() instanceof AST_Export;
            node.definitions.forEach(function(def) {
              if (def.name instanceof AST_SymbolVar) {
                map_add(var_defs_by_id, def.name.definition().id, def);
              }
              if (in_export || !drop_vars) {
                walk(def.name, (node2) => {
                  if (node2 instanceof AST_SymbolDeclaration) {
                    const def2 = node2.definition();
                    if (def2.global) {
                      in_use_ids.set(def2.id, def2);
                    }
                  }
                });
              }
              if (def.name instanceof AST_Destructuring) {
                def.walk(tw);
              }
              if (def.name instanceof AST_SymbolDeclaration && def.value) {
                var node_def2 = def.name.definition();
                map_add(initializations, node_def2.id, def.value);
                if (!node_def2.chained && def.name.fixed_value() === def.value) {
                  fixed_ids.set(node_def2.id, def);
                }
                if (def.value.has_side_effects(compressor)) {
                  def.value.walk(tw);
                }
              }
            });
            return true;
          }
          return scan_ref_scoped(node, descend);
        });
        self2.walk(tw);
        tw = new TreeWalker(scan_ref_scoped);
        in_use_ids.forEach(function(def) {
          var init2 = initializations.get(def.id);
          if (init2)
            init2.forEach(function(init3) {
              init3.walk(tw);
            });
        });
        var tt = new TreeTransformer(function before(node, descend, in_list) {
          var parent = tt.parent();
          if (drop_vars) {
            const sym2 = assign_as_unused(node);
            if (sym2 instanceof AST_SymbolRef) {
              var def = sym2.definition();
              var in_use = in_use_ids.has(def.id);
              if (node instanceof AST_Assign) {
                if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {
                  const assignee = node.right.transform(tt);
                  if (!in_use && !assignee.has_side_effects(compressor) && !is_used_in_expression(tt)) {
                    return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
                  }
                  return maintain_this_binding(parent, node, assignee);
                }
              } else if (!in_use) {
                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
              }
            }
          }
          if (scope !== self2)
            return;
          var def;
          if (node.name && (node instanceof AST_ClassExpression && !keep_name(compressor.option("keep_classnames"), (def = node.name.definition()).name) || node instanceof AST_Function && !keep_name(compressor.option("keep_fnames"), (def = node.name.definition()).name))) {
            if (!in_use_ids.has(def.id) || def.orig.length > 1)
              node.name = null;
          }
          if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
            var trim2 = !compressor.option("keep_fargs") || parent instanceof AST_Call && parent.expression === node && !node.pinned() && (!node.name || node.name.unreferenced());
            for (var a = node.argnames, i = a.length; --i >= 0; ) {
              var sym = a[i];
              if (sym instanceof AST_Expansion) {
                sym = sym.expression;
              }
              if (sym instanceof AST_DefaultAssign) {
                sym = sym.left;
              }
              if (!(sym instanceof AST_Destructuring) && !in_use_ids.has(sym.definition().id)) {
                set_flag(sym, UNUSED);
                if (trim2) {
                  a.pop();
                }
              } else {
                trim2 = false;
              }
            }
          }
          if (node instanceof AST_DefClass && node !== self2) {
            const def2 = node.name.definition();
            descend(node, this);
            const keep_class = def2.global && !drop_funcs || in_use_ids.has(def2.id);
            if (!keep_class) {
              const kept = node.drop_side_effect_free(compressor);
              if (kept == null) {
                def2.eliminated++;
                return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
              }
              return kept;
            }
            return node;
          }
          if (node instanceof AST_Defun && node !== self2) {
            const def2 = node.name.definition();
            const keep = def2.global && !drop_funcs || in_use_ids.has(def2.id);
            if (!keep) {
              def2.eliminated++;
              return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
            }
          }
          if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {
            var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);
            var body = [], head = [], tail = [];
            var side_effects = [];
            node.definitions.forEach(function(def2) {
              if (def2.value)
                def2.value = def2.value.transform(tt);
              var is_destructure = def2.name instanceof AST_Destructuring;
              var sym2 = is_destructure ? new SymbolDef(null, { name: "<destructure>" }) : def2.name.definition();
              if (drop_block && sym2.global)
                return tail.push(def2);
              if (!(drop_vars || drop_block) || is_destructure && (def2.name.names.length || def2.name.is_array || compressor.option("pure_getters") != true) || in_use_ids.has(sym2.id)) {
                if (def2.value && fixed_ids.has(sym2.id) && fixed_ids.get(sym2.id) !== def2) {
                  def2.value = def2.value.drop_side_effect_free(compressor);
                }
                if (def2.name instanceof AST_SymbolVar) {
                  var var_defs = var_defs_by_id.get(sym2.id);
                  if (var_defs.length > 1 && (!def2.value || sym2.orig.indexOf(def2.name) > sym2.eliminated)) {
                    if (def2.value) {
                      var ref = make_node(AST_SymbolRef, def2.name, def2.name);
                      sym2.references.push(ref);
                      var assign = make_node(AST_Assign, def2, {
                        operator: "=",
                        logical: false,
                        left: ref,
                        right: def2.value
                      });
                      if (fixed_ids.get(sym2.id) === def2) {
                        fixed_ids.set(sym2.id, assign);
                      }
                      side_effects.push(assign.transform(tt));
                    }
                    remove(var_defs, def2);
                    sym2.eliminated++;
                    return;
                  }
                }
                if (def2.value) {
                  if (side_effects.length > 0) {
                    if (tail.length > 0) {
                      side_effects.push(def2.value);
                      def2.value = make_sequence(def2.value, side_effects);
                    } else {
                      body.push(make_node(AST_SimpleStatement, node, {
                        body: make_sequence(node, side_effects)
                      }));
                    }
                    side_effects = [];
                  }
                  tail.push(def2);
                } else {
                  head.push(def2);
                }
              } else if (sym2.orig[0] instanceof AST_SymbolCatch) {
                var value2 = def2.value && def2.value.drop_side_effect_free(compressor);
                if (value2)
                  side_effects.push(value2);
                def2.value = null;
                head.push(def2);
              } else {
                var value2 = def2.value && def2.value.drop_side_effect_free(compressor);
                if (value2) {
                  side_effects.push(value2);
                }
                sym2.eliminated++;
              }
            });
            if (head.length > 0 || tail.length > 0) {
              node.definitions = head.concat(tail);
              body.push(node);
            }
            if (side_effects.length > 0) {
              body.push(make_node(AST_SimpleStatement, node, {
                body: make_sequence(node, side_effects)
              }));
            }
            switch (body.length) {
              case 0:
                return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
              case 1:
                return body[0];
              default:
                return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });
            }
          }
          if (node instanceof AST_For) {
            descend(node, this);
            var block;
            if (node.init instanceof AST_BlockStatement) {
              block = node.init;
              node.init = block.body.pop();
              block.body.push(node);
            }
            if (node.init instanceof AST_SimpleStatement) {
              node.init = node.init.body;
            } else if (is_empty2(node.init)) {
              node.init = null;
            }
            return !block ? node : in_list ? MAP.splice(block.body) : block;
          }
          if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
            descend(node, this);
            if (node.body instanceof AST_BlockStatement) {
              var block = node.body;
              node.body = block.body.pop();
              block.body.push(node);
              return in_list ? MAP.splice(block.body) : block;
            }
            return node;
          }
          if (node instanceof AST_BlockStatement) {
            descend(node, this);
            if (in_list && node.body.every(can_be_evicted_from_block)) {
              return MAP.splice(node.body);
            }
            return node;
          }
          if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
            const save_scope = scope;
            scope = node;
            descend(node, this);
            scope = save_scope;
            return node;
          }
        }, function after(node, in_list) {
          if (node instanceof AST_Sequence) {
            switch (node.expressions.length) {
              case 0:
                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
              case 1:
                return node.expressions[0];
            }
          }
        });
        self2.transform(tt);
        function scan_ref_scoped(node, descend) {
          var node_def;
          const sym = assign_as_unused(node);
          if (sym instanceof AST_SymbolRef && !is_ref_of(node.left, AST_SymbolBlockDeclaration) && self2.variables.get(sym.name) === (node_def = sym.definition())) {
            if (node instanceof AST_Assign) {
              node.right.walk(tw);
              if (!node_def.chained && node.left.fixed_value() === node.right) {
                fixed_ids.set(node_def.id, node);
              }
            }
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            node_def = node.definition();
            if (!in_use_ids.has(node_def.id)) {
              in_use_ids.set(node_def.id, node_def);
              if (node_def.orig[0] instanceof AST_SymbolCatch) {
                const redef = node_def.scope.is_block_scope() && node_def.scope.get_defun_scope().variables.get(node_def.name);
                if (redef)
                  in_use_ids.set(redef.id, redef);
              }
            }
            return true;
          }
          if (node instanceof AST_Class) {
            descend();
            return true;
          }
          if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
            var save_scope = scope;
            scope = node;
            descend();
            scope = save_scope;
            return true;
          }
        }
      });
      function def_reduce_vars(node, func) {
        node.DEFMETHOD("reduce_vars", func);
      }
      def_reduce_vars(AST_Node, noop2);
      function reset_def(compressor, def) {
        def.assignments = 0;
        def.chained = false;
        def.direct_access = false;
        def.escaped = 0;
        def.recursive_refs = 0;
        def.references = [];
        def.single_use = void 0;
        if (def.scope.pinned() || def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments) {
          def.fixed = false;
        } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {
          def.fixed = def.init;
        } else {
          def.fixed = false;
        }
      }
      function reset_variables(tw, compressor, node) {
        node.variables.forEach(function(def) {
          reset_def(compressor, def);
          if (def.fixed === null) {
            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);
            mark(tw, def, true);
          } else if (def.fixed) {
            tw.loop_ids.set(def.id, tw.in_loop);
            mark(tw, def, true);
          }
        });
      }
      function reset_block_variables(compressor, node) {
        if (node.block_scope)
          node.block_scope.variables.forEach((def) => {
            reset_def(compressor, def);
          });
      }
      function push(tw) {
        tw.safe_ids = Object.create(tw.safe_ids);
      }
      function pop(tw) {
        tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
      }
      function mark(tw, def, safe) {
        tw.safe_ids[def.id] = safe;
      }
      function safe_to_read(tw, def) {
        if (def.single_use == "m")
          return false;
        if (tw.safe_ids[def.id]) {
          if (def.fixed == null) {
            var orig = def.orig[0];
            if (orig instanceof AST_SymbolFunarg || orig.name == "arguments")
              return false;
            def.fixed = make_node(AST_Undefined, orig);
          }
          return true;
        }
        return def.fixed instanceof AST_Defun;
      }
      function safe_to_assign(tw, def, scope, value2) {
        if (def.fixed === void 0)
          return true;
        let def_safe_ids;
        if (def.fixed === null && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))) {
          def_safe_ids[def.id] = false;
          tw.defs_to_safe_ids.delete(def.id);
          return true;
        }
        if (!HOP(tw.safe_ids, def.id))
          return false;
        if (!safe_to_read(tw, def))
          return false;
        if (def.fixed === false)
          return false;
        if (def.fixed != null && (!value2 || def.references.length > def.assignments))
          return false;
        if (def.fixed instanceof AST_Defun) {
          return value2 instanceof AST_Node && def.fixed.parent_scope === scope;
        }
        return def.orig.every((sym) => {
          return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolDefun || sym instanceof AST_SymbolLambda);
        });
      }
      function ref_once(tw, compressor, def) {
        return compressor.option("unused") && !def.scope.pinned() && def.references.length - def.recursive_refs == 1 && tw.loop_ids.get(def.id) === tw.in_loop;
      }
      function is_immutable(value2) {
        if (!value2)
          return false;
        return value2.is_constant() || value2 instanceof AST_Lambda || value2 instanceof AST_This;
      }
      function mark_escaped(tw, d, scope, node, value2, level = 0, depth = 1) {
        var parent = tw.parent(level);
        if (value2) {
          if (value2.is_constant())
            return;
          if (value2 instanceof AST_ClassExpression)
            return;
        }
        if (parent instanceof AST_Assign && (parent.operator === "=" || parent.logical) && node === parent.right || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New) || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope || parent instanceof AST_VarDef && node === parent.value || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope) {
          if (depth > 1 && !(value2 && value2.is_constant_expression(scope)))
            depth = 1;
          if (!d.escaped || d.escaped > depth)
            d.escaped = depth;
          return;
        } else if (parent instanceof AST_Array || parent instanceof AST_Await || parent instanceof AST_Binary && lazy_op.has(parent.operator) || parent instanceof AST_Conditional && node !== parent.condition || parent instanceof AST_Expansion || parent instanceof AST_Sequence && node === parent.tail_node()) {
          mark_escaped(tw, d, scope, parent, parent, level + 1, depth);
        } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
          var obj = tw.parent(level + 1);
          mark_escaped(tw, d, scope, obj, obj, level + 2, depth);
        } else if (parent instanceof AST_PropAccess && node === parent.expression) {
          value2 = read_property(value2, parent.property);
          mark_escaped(tw, d, scope, parent, value2, level + 1, depth + 1);
          if (value2)
            return;
        }
        if (level > 0)
          return;
        if (parent instanceof AST_Sequence && node !== parent.tail_node())
          return;
        if (parent instanceof AST_SimpleStatement)
          return;
        d.direct_access = true;
      }
      const suppress = (node) => walk(node, (node2) => {
        if (!(node2 instanceof AST_Symbol))
          return;
        var d = node2.definition();
        if (!d)
          return;
        if (node2 instanceof AST_SymbolRef)
          d.references.push(node2);
        d.fixed = false;
      });
      def_reduce_vars(AST_Accessor, function(tw, descend, compressor) {
        push(tw);
        reset_variables(tw, compressor, this);
        descend();
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Assign, function(tw, descend, compressor) {
        var node = this;
        if (node.left instanceof AST_Destructuring) {
          suppress(node.left);
          return;
        }
        const finish_walk = () => {
          if (node.logical) {
            node.left.walk(tw);
            push(tw);
            node.right.walk(tw);
            pop(tw);
            return true;
          }
        };
        var sym = node.left;
        if (!(sym instanceof AST_SymbolRef))
          return finish_walk();
        var def = sym.definition();
        var safe = safe_to_assign(tw, def, sym.scope, node.right);
        def.assignments++;
        if (!safe)
          return finish_walk();
        var fixed = def.fixed;
        if (!fixed && node.operator != "=" && !node.logical)
          return finish_walk();
        var eq = node.operator == "=";
        var value2 = eq ? node.right : node;
        if (is_modified(compressor, tw, node, value2, 0))
          return finish_walk();
        def.references.push(sym);
        if (!node.logical) {
          if (!eq)
            def.chained = true;
          def.fixed = eq ? function() {
            return node.right;
          } : function() {
            return make_node(AST_Binary, node, {
              operator: node.operator.slice(0, -1),
              left: fixed instanceof AST_Node ? fixed : fixed(),
              right: node.right
            });
          };
        }
        if (node.logical) {
          mark(tw, def, false);
          push(tw);
          node.right.walk(tw);
          pop(tw);
          return true;
        }
        mark(tw, def, false);
        node.right.walk(tw);
        mark(tw, def, true);
        mark_escaped(tw, def, sym.scope, node, value2, 0, 1);
        return true;
      });
      def_reduce_vars(AST_Binary, function(tw) {
        if (!lazy_op.has(this.operator))
          return;
        this.left.walk(tw);
        push(tw);
        this.right.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Block, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
      });
      def_reduce_vars(AST_Case, function(tw) {
        push(tw);
        this.expression.walk(tw);
        pop(tw);
        push(tw);
        walk_body(this, tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Class, function(tw, descend) {
        clear_flag(this, INLINED);
        push(tw);
        descend();
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
      });
      def_reduce_vars(AST_Conditional, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.consequent.walk(tw);
        pop(tw);
        push(tw);
        this.alternative.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Chain, function(tw, descend) {
        const safe_ids = tw.safe_ids;
        descend();
        tw.safe_ids = safe_ids;
        return true;
      });
      def_reduce_vars(AST_Call, function(tw) {
        this.expression.walk(tw);
        if (this.optional) {
          push(tw);
        }
        for (const arg of this.args)
          arg.walk(tw);
        return true;
      });
      def_reduce_vars(AST_PropAccess, function(tw) {
        if (!this.optional)
          return;
        this.expression.walk(tw);
        push(tw);
        if (this.property instanceof AST_Node)
          this.property.walk(tw);
        return true;
      });
      def_reduce_vars(AST_Default, function(tw, descend) {
        push(tw);
        descend();
        pop(tw);
        return true;
      });
      function mark_lambda(tw, descend, compressor) {
        clear_flag(this, INLINED);
        push(tw);
        reset_variables(tw, compressor, this);
        var iife;
        if (!this.name && !this.uses_arguments && !this.pinned() && (iife = tw.parent()) instanceof AST_Call && iife.expression === this && !iife.args.some((arg) => arg instanceof AST_Expansion) && this.argnames.every((arg_name) => arg_name instanceof AST_Symbol)) {
          this.argnames.forEach((arg, i) => {
            if (!arg.definition)
              return;
            var d = arg.definition();
            if (d.orig.length > 1)
              return;
            if (d.fixed === void 0 && (!this.uses_arguments || tw.has_directive("use strict"))) {
              d.fixed = function() {
                return iife.args[i] || make_node(AST_Undefined, iife);
              };
              tw.loop_ids.set(d.id, tw.in_loop);
              mark(tw, d, true);
            } else {
              d.fixed = false;
            }
          });
        }
        descend();
        pop(tw);
        handle_defined_after_hoist(this);
        return true;
      }
      function handle_defined_after_hoist(parent) {
        const defuns = [];
        walk(parent, (node) => {
          if (node === parent)
            return;
          if (node instanceof AST_Defun) {
            defuns.push(node);
            return true;
          }
          if (node instanceof AST_Scope || node instanceof AST_SimpleStatement)
            return true;
        });
        const defun_dependencies_map = /* @__PURE__ */ new Map();
        const dependencies_map = /* @__PURE__ */ new Map();
        const symbols_of_interest = /* @__PURE__ */ new Set();
        const defuns_of_interest = /* @__PURE__ */ new Set();
        for (const defun of defuns) {
          const fname_def = defun.name.definition();
          const enclosing_defs = [];
          for (const def of defun.enclosed) {
            if (def.fixed === false || def === fname_def || def.scope.get_defun_scope() !== parent) {
              continue;
            }
            symbols_of_interest.add(def.id);
            if (def.assignments === 0 && def.orig.length === 1 && def.orig[0] instanceof AST_SymbolDefun) {
              defuns_of_interest.add(def.id);
              symbols_of_interest.add(def.id);
              defuns_of_interest.add(fname_def.id);
              symbols_of_interest.add(fname_def.id);
              if (!defun_dependencies_map.has(fname_def.id)) {
                defun_dependencies_map.set(fname_def.id, []);
              }
              defun_dependencies_map.get(fname_def.id).push(def.id);
              continue;
            }
            enclosing_defs.push(def);
          }
          if (enclosing_defs.length) {
            dependencies_map.set(fname_def.id, enclosing_defs);
            defuns_of_interest.add(fname_def.id);
            symbols_of_interest.add(fname_def.id);
          }
        }
        if (!dependencies_map.size) {
          return;
        }
        let symbol_index = 1;
        const defun_first_read_map = /* @__PURE__ */ new Map();
        const symbol_last_write_map = /* @__PURE__ */ new Map();
        walk_parent(parent, (node, walk_info) => {
          if (node instanceof AST_Symbol && node.thedef) {
            const id = node.definition().id;
            symbol_index++;
            if (symbols_of_interest.has(id)) {
              if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {
                symbol_last_write_map.set(id, symbol_index);
              }
            }
            if (defuns_of_interest.has(id)) {
              if (!defun_first_read_map.has(id) && !is_recursive_ref(walk_info, id)) {
                defun_first_read_map.set(id, symbol_index);
              }
            }
          }
        });
        for (const [defun, defun_first_read] of defun_first_read_map) {
          const queue = new Set(defun_dependencies_map.get(defun));
          for (const enclosed_defun of queue) {
            let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);
            if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {
              continue;
            }
            defun_first_read_map.set(enclosed_defun, defun_first_read);
            for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {
              queue.add(enclosed_enclosed_defun);
            }
          }
        }
        for (const [defun, defs] of dependencies_map) {
          const defun_first_read = defun_first_read_map.get(defun);
          if (defun_first_read === void 0) {
            continue;
          }
          for (const def of defs) {
            if (def.fixed === false) {
              continue;
            }
            let def_last_write = symbol_last_write_map.get(def.id) || 0;
            if (defun_first_read < def_last_write) {
              def.fixed = false;
            }
          }
        }
      }
      def_reduce_vars(AST_Lambda, mark_lambda);
      def_reduce_vars(AST_Do, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        if (has_break_or_continue(this)) {
          pop(tw);
          push(tw);
        }
        this.condition.walk(tw);
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_For, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        if (this.init)
          this.init.walk(tw);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        if (this.condition)
          this.condition.walk(tw);
        this.body.walk(tw);
        if (this.step) {
          if (has_break_or_continue(this)) {
            pop(tw);
            push(tw);
          }
          this.step.walk(tw);
        }
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_ForIn, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        suppress(this.init);
        this.object.walk(tw);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_If, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.body.walk(tw);
        pop(tw);
        if (this.alternative) {
          push(tw);
          this.alternative.walk(tw);
          pop(tw);
        }
        return true;
      });
      def_reduce_vars(AST_LabeledStatement, function(tw) {
        push(tw);
        this.body.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_SymbolCatch, function() {
        this.definition().fixed = false;
      });
      def_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {
        var d = this.definition();
        d.references.push(this);
        if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {
          tw.loop_ids.set(d.id, tw.in_loop);
        }
        var fixed_value;
        if (d.fixed === void 0 || !safe_to_read(tw, d)) {
          d.fixed = false;
        } else if (d.fixed) {
          fixed_value = this.fixed_value();
          if (fixed_value instanceof AST_Lambda && is_recursive_ref(tw, d)) {
            d.recursive_refs++;
          } else if (fixed_value && !compressor.exposed(d) && ref_once(tw, compressor, d)) {
            d.single_use = fixed_value instanceof AST_Lambda && !fixed_value.pinned() || fixed_value instanceof AST_Class || d.scope === this.scope && fixed_value.is_constant_expression();
          } else {
            d.single_use = false;
          }
          if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {
            if (d.single_use) {
              d.single_use = "m";
            } else {
              d.fixed = false;
            }
          }
        }
        mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);
      });
      def_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {
        this.globals.forEach(function(def) {
          reset_def(compressor, def);
        });
        reset_variables(tw, compressor, this);
        descend();
        handle_defined_after_hoist(this);
        return true;
      });
      def_reduce_vars(AST_Try, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        push(tw);
        this.body.walk(tw);
        pop(tw);
        if (this.bcatch) {
          push(tw);
          this.bcatch.walk(tw);
          pop(tw);
        }
        if (this.bfinally)
          this.bfinally.walk(tw);
        return true;
      });
      def_reduce_vars(AST_Unary, function(tw) {
        var node = this;
        if (node.operator !== "++" && node.operator !== "--")
          return;
        var exp = node.expression;
        if (!(exp instanceof AST_SymbolRef))
          return;
        var def = exp.definition();
        var safe = safe_to_assign(tw, def, exp.scope, true);
        def.assignments++;
        if (!safe)
          return;
        var fixed = def.fixed;
        if (!fixed)
          return;
        def.references.push(exp);
        def.chained = true;
        def.fixed = function() {
          return make_node(AST_Binary, node, {
            operator: node.operator.slice(0, -1),
            left: make_node(AST_UnaryPrefix, node, {
              operator: "+",
              expression: fixed instanceof AST_Node ? fixed : fixed()
            }),
            right: make_node(AST_Number, node, {
              value: 1
            })
          });
        };
        mark(tw, def, true);
        return true;
      });
      def_reduce_vars(AST_VarDef, function(tw, descend) {
        var node = this;
        if (node.name instanceof AST_Destructuring) {
          suppress(node.name);
          return;
        }
        var d = node.name.definition();
        if (node.value) {
          if (safe_to_assign(tw, d, node.name.scope, node.value)) {
            d.fixed = function() {
              return node.value;
            };
            tw.loop_ids.set(d.id, tw.in_loop);
            mark(tw, d, false);
            descend();
            mark(tw, d, true);
            return true;
          } else {
            d.fixed = false;
          }
        }
      });
      def_reduce_vars(AST_While, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        descend();
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      function loop_body(x) {
        if (x instanceof AST_IterationStatement) {
          return x.body instanceof AST_BlockStatement ? x.body : x;
        }
        return x;
      }
      function is_lhs_read_only(lhs) {
        if (lhs instanceof AST_This)
          return true;
        if (lhs instanceof AST_SymbolRef)
          return lhs.definition().orig[0] instanceof AST_SymbolLambda;
        if (lhs instanceof AST_PropAccess) {
          lhs = lhs.expression;
          if (lhs instanceof AST_SymbolRef) {
            if (lhs.is_immutable())
              return false;
            lhs = lhs.fixed_value();
          }
          if (!lhs)
            return true;
          if (lhs instanceof AST_RegExp)
            return false;
          if (lhs instanceof AST_Constant)
            return true;
          return is_lhs_read_only(lhs);
        }
        return false;
      }
      function remove_initializers(var_statement) {
        var decls = [];
        var_statement.definitions.forEach(function(def) {
          if (def.name instanceof AST_SymbolDeclaration) {
            def.value = null;
            decls.push(def);
          } else {
            def.declarations_as_names().forEach((name) => {
              decls.push(make_node(AST_VarDef, def, {
                name,
                value: null
              }));
            });
          }
        });
        return decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : null;
      }
      function trim_unreachable_code(compressor, stat, target) {
        walk(stat, (node) => {
          if (node instanceof AST_Var) {
            const no_initializers = remove_initializers(node);
            if (no_initializers)
              target.push(no_initializers);
            return true;
          }
          if (node instanceof AST_Defun && (node === stat || !compressor.has_directive("use strict"))) {
            target.push(node === stat ? node : make_node(AST_Var, node, {
              definitions: [
                make_node(AST_VarDef, node, {
                  name: make_node(AST_SymbolVar, node.name, node.name),
                  value: null
                })
              ]
            }));
            return true;
          }
          if (node instanceof AST_Export || node instanceof AST_Import) {
            target.push(node);
            return true;
          }
          if (node instanceof AST_Scope) {
            return true;
          }
        });
      }
      function tighten_body(statements, compressor) {
        const nearest_scope = compressor.find_scope();
        const defun_scope = nearest_scope.get_defun_scope();
        const { in_loop, in_try } = find_loop_scope_try();
        var CHANGED, max_iter = 10;
        do {
          CHANGED = false;
          eliminate_spurious_blocks(statements);
          if (compressor.option("dead_code")) {
            eliminate_dead_code(statements, compressor);
          }
          if (compressor.option("if_return")) {
            handle_if_return(statements, compressor);
          }
          if (compressor.sequences_limit > 0) {
            sequencesize(statements, compressor);
            sequencesize_2(statements, compressor);
          }
          if (compressor.option("join_vars")) {
            join_consecutive_vars(statements);
          }
          if (compressor.option("collapse_vars")) {
            collapse(statements, compressor);
          }
        } while (CHANGED && max_iter-- > 0);
        function find_loop_scope_try() {
          var node = compressor.self(), level = 0, in_loop2 = false, in_try2 = false;
          do {
            if (node instanceof AST_IterationStatement) {
              in_loop2 = true;
            } else if (node instanceof AST_Scope) {
              break;
            } else if (node instanceof AST_TryBlock) {
              in_try2 = true;
            }
          } while (node = compressor.parent(level++));
          return { in_loop: in_loop2, in_try: in_try2 };
        }
        function collapse(statements2, compressor2) {
          if (nearest_scope.pinned() || defun_scope.pinned())
            return statements2;
          var args;
          var candidates = [];
          var stat_index = statements2.length;
          var scanner = new TreeTransformer(function(node) {
            if (abort)
              return node;
            if (!hit) {
              if (node !== hit_stack[hit_index])
                return node;
              hit_index++;
              if (hit_index < hit_stack.length)
                return handle_custom_scan_order(node);
              hit = true;
              stop_after = find_stop(node, 0);
              if (stop_after === node)
                abort = true;
              return node;
            }
            var parent = scanner.parent();
            if (node instanceof AST_Assign && (node.logical || node.operator != "=" && lhs.equivalent_to(node.left)) || node instanceof AST_Await || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression) || (node instanceof AST_Call || node instanceof AST_PropAccess) && node.optional || node instanceof AST_Debugger || node instanceof AST_Destructuring || node instanceof AST_Expansion && node.expression instanceof AST_Symbol && (node.expression instanceof AST_This || node.expression.definition().references.length > 1) || node instanceof AST_IterationStatement && !(node instanceof AST_For) || node instanceof AST_LoopControl || node instanceof AST_Try || node instanceof AST_With || node instanceof AST_Yield || node instanceof AST_Export || node instanceof AST_Class || parent instanceof AST_For && node !== parent.init || !replace_all && (node instanceof AST_SymbolRef && !node.is_declared(compressor2) && !pure_prop_access_globals.has(node)) || node instanceof AST_SymbolRef && parent instanceof AST_Call && has_annotation(parent, _NOINLINE) || node instanceof AST_ObjectProperty && node.key instanceof AST_Node) {
              abort = true;
              return node;
            }
            if (!stop_if_hit && (!lhs_local || !replace_all) && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node || parent instanceof AST_Conditional && parent.condition !== node || parent instanceof AST_If && parent.condition !== node)) {
              stop_if_hit = parent;
            }
            if (can_replace && !(node instanceof AST_SymbolDeclaration) && lhs.equivalent_to(node) && !shadows(scanner.find_scope() || nearest_scope, lvalues)) {
              if (stop_if_hit) {
                abort = true;
                return node;
              }
              if (is_lhs(node, parent)) {
                if (value_def)
                  replaced++;
                return node;
              } else {
                replaced++;
                if (value_def && candidate instanceof AST_VarDef)
                  return node;
              }
              CHANGED = abort = true;
              if (candidate instanceof AST_UnaryPostfix) {
                return make_node(AST_UnaryPrefix, candidate, candidate);
              }
              if (candidate instanceof AST_VarDef) {
                var def2 = candidate.name.definition();
                var value2 = candidate.value;
                if (def2.references.length - def2.replaced == 1 && !compressor2.exposed(def2)) {
                  def2.replaced++;
                  if (funarg && is_identifier_atom(value2)) {
                    return value2.transform(compressor2);
                  } else {
                    return maintain_this_binding(parent, node, value2);
                  }
                }
                return make_node(AST_Assign, candidate, {
                  operator: "=",
                  logical: false,
                  left: make_node(AST_SymbolRef, candidate.name, candidate.name),
                  right: value2
                });
              }
              clear_flag(candidate, WRITE_ONLY);
              return candidate;
            }
            var sym;
            if (node instanceof AST_Call || node instanceof AST_Exit && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs)) || node instanceof AST_PropAccess && (side_effects || node.expression.may_throw_on_access(compressor2)) || node instanceof AST_SymbolRef && (lvalues.has(node.name) && lvalues.get(node.name).modified || side_effects && may_modify(node)) || node instanceof AST_VarDef && node.value && (lvalues.has(node.name.name) || side_effects && may_modify(node.name)) || (sym = is_lhs(node.left, node)) && (sym instanceof AST_PropAccess || lvalues.has(sym.name)) || may_throw && (in_try ? node.has_side_effects(compressor2) : side_effects_external(node))) {
              stop_after = node;
              if (node instanceof AST_Scope)
                abort = true;
            }
            return handle_custom_scan_order(node);
          }, function(node) {
            if (abort)
              return;
            if (stop_after === node)
              abort = true;
            if (stop_if_hit === node)
              stop_if_hit = null;
          });
          var multi_replacer = new TreeTransformer(function(node) {
            if (abort)
              return node;
            if (!hit) {
              if (node !== hit_stack[hit_index])
                return node;
              hit_index++;
              if (hit_index < hit_stack.length)
                return;
              hit = true;
              return node;
            }
            if (node instanceof AST_SymbolRef && node.name == def.name) {
              if (!--replaced)
                abort = true;
              if (is_lhs(node, multi_replacer.parent()))
                return node;
              def.replaced++;
              value_def.replaced--;
              return candidate.value;
            }
            if (node instanceof AST_Default || node instanceof AST_Scope)
              return node;
          });
          while (--stat_index >= 0) {
            if (stat_index == 0 && compressor2.option("unused"))
              extract_args();
            var hit_stack = [];
            extract_candidates(statements2[stat_index]);
            while (candidates.length > 0) {
              hit_stack = candidates.pop();
              var hit_index = 0;
              var candidate = hit_stack[hit_stack.length - 1];
              var value_def = null;
              var stop_after = null;
              var stop_if_hit = null;
              var lhs = get_lhs(candidate);
              if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor2))
                continue;
              var lvalues = get_lvalues(candidate);
              var lhs_local = is_lhs_local(lhs);
              if (lhs instanceof AST_SymbolRef) {
                lvalues.set(lhs.name, { def: lhs.definition(), modified: false });
              }
              var side_effects = value_has_side_effects(candidate);
              var replace_all = replace_all_symbols();
              var may_throw = candidate.may_throw(compressor2);
              var funarg = candidate.name instanceof AST_SymbolFunarg;
              var hit = funarg;
              var abort = false, replaced = 0, can_replace = !args || !hit;
              if (!can_replace) {
                for (let j = compressor2.self().argnames.lastIndexOf(candidate.name) + 1; !abort && j < args.length; j++) {
                  args[j].transform(scanner);
                }
                can_replace = true;
              }
              for (var i = stat_index; !abort && i < statements2.length; i++) {
                statements2[i].transform(scanner);
              }
              if (value_def) {
                var def = candidate.name.definition();
                if (abort && def.references.length - def.replaced > replaced)
                  replaced = false;
                else {
                  abort = false;
                  hit_index = 0;
                  hit = funarg;
                  for (var i = stat_index; !abort && i < statements2.length; i++) {
                    statements2[i].transform(multi_replacer);
                  }
                  value_def.single_use = false;
                }
              }
              if (replaced && !remove_candidate(candidate))
                statements2.splice(stat_index, 1);
            }
          }
          function handle_custom_scan_order(node) {
            if (node instanceof AST_Scope)
              return node;
            if (node instanceof AST_Switch) {
              node.expression = node.expression.transform(scanner);
              for (var i2 = 0, len = node.body.length; !abort && i2 < len; i2++) {
                var branch = node.body[i2];
                if (branch instanceof AST_Case) {
                  if (!hit) {
                    if (branch !== hit_stack[hit_index])
                      continue;
                    hit_index++;
                  }
                  branch.expression = branch.expression.transform(scanner);
                  if (!replace_all)
                    break;
                }
              }
              abort = true;
              return node;
            }
          }
          function redefined_within_scope(def2, scope) {
            if (def2.global)
              return false;
            let cur_scope = def2.scope;
            while (cur_scope && cur_scope !== scope) {
              if (cur_scope.variables.has(def2.name)) {
                return true;
              }
              cur_scope = cur_scope.parent_scope;
            }
            return false;
          }
          function has_overlapping_symbol(fn, arg, fn_strict) {
            var found = false, scan_this = !(fn instanceof AST_Arrow);
            arg.walk(new TreeWalker(function(node, descend) {
              if (found)
                return true;
              if (node instanceof AST_SymbolRef && (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {
                var s = node.definition().scope;
                if (s !== defun_scope)
                  while (s = s.parent_scope) {
                    if (s === defun_scope)
                      return true;
                  }
                return found = true;
              }
              if ((fn_strict || scan_this) && node instanceof AST_This) {
                return found = true;
              }
              if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
                var prev = scan_this;
                scan_this = false;
                descend();
                scan_this = prev;
                return true;
              }
            }));
            return found;
          }
          function arg_is_injectable(arg) {
            if (arg instanceof AST_Expansion)
              return false;
            const contains_await = walk(arg, (node) => {
              if (node instanceof AST_Await)
                return walk_abort;
            });
            if (contains_await)
              return false;
            return true;
          }
          function extract_args() {
            var iife, fn = compressor2.self();
            if (is_func_expr(fn) && !fn.name && !fn.uses_arguments && !fn.pinned() && (iife = compressor2.parent()) instanceof AST_Call && iife.expression === fn && iife.args.every(arg_is_injectable)) {
              var fn_strict = compressor2.has_directive("use strict");
              if (fn_strict && !member(fn_strict, fn.body))
                fn_strict = false;
              var len = fn.argnames.length;
              args = iife.args.slice(len);
              var names = /* @__PURE__ */ new Set();
              for (var i2 = len; --i2 >= 0; ) {
                var sym = fn.argnames[i2];
                var arg = iife.args[i2];
                const def2 = sym.definition && sym.definition();
                const is_reassigned = def2 && def2.orig.length > 1;
                if (is_reassigned)
                  continue;
                args.unshift(make_node(AST_VarDef, sym, {
                  name: sym,
                  value: arg
                }));
                if (names.has(sym.name))
                  continue;
                names.add(sym.name);
                if (sym instanceof AST_Expansion) {
                  var elements = iife.args.slice(i2);
                  if (elements.every((arg2) => !has_overlapping_symbol(fn, arg2, fn_strict))) {
                    candidates.unshift([make_node(AST_VarDef, sym, {
                      name: sym.expression,
                      value: make_node(AST_Array, iife, {
                        elements
                      })
                    })]);
                  }
                } else {
                  if (!arg) {
                    arg = make_node(AST_Undefined, sym).transform(compressor2);
                  } else if (arg instanceof AST_Lambda && arg.pinned() || has_overlapping_symbol(fn, arg, fn_strict)) {
                    arg = null;
                  }
                  if (arg)
                    candidates.unshift([make_node(AST_VarDef, sym, {
                      name: sym,
                      value: arg
                    })]);
                }
              }
            }
          }
          function extract_candidates(expr) {
            hit_stack.push(expr);
            if (expr instanceof AST_Assign) {
              if (!expr.left.has_side_effects(compressor2) && !(expr.right instanceof AST_Chain)) {
                candidates.push(hit_stack.slice());
              }
              extract_candidates(expr.right);
            } else if (expr instanceof AST_Binary) {
              extract_candidates(expr.left);
              extract_candidates(expr.right);
            } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {
              extract_candidates(expr.expression);
              expr.args.forEach(extract_candidates);
            } else if (expr instanceof AST_Case) {
              extract_candidates(expr.expression);
            } else if (expr instanceof AST_Conditional) {
              extract_candidates(expr.condition);
              extract_candidates(expr.consequent);
              extract_candidates(expr.alternative);
            } else if (expr instanceof AST_Definitions) {
              var len = expr.definitions.length;
              var i2 = len - 200;
              if (i2 < 0)
                i2 = 0;
              for (; i2 < len; i2++) {
                extract_candidates(expr.definitions[i2]);
              }
            } else if (expr instanceof AST_DWLoop) {
              extract_candidates(expr.condition);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_Exit) {
              if (expr.value)
                extract_candidates(expr.value);
            } else if (expr instanceof AST_For) {
              if (expr.init)
                extract_candidates(expr.init);
              if (expr.condition)
                extract_candidates(expr.condition);
              if (expr.step)
                extract_candidates(expr.step);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_ForIn) {
              extract_candidates(expr.object);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_If) {
              extract_candidates(expr.condition);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
              if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
                extract_candidates(expr.alternative);
              }
            } else if (expr instanceof AST_Sequence) {
              expr.expressions.forEach(extract_candidates);
            } else if (expr instanceof AST_SimpleStatement) {
              extract_candidates(expr.body);
            } else if (expr instanceof AST_Switch) {
              extract_candidates(expr.expression);
              expr.body.forEach(extract_candidates);
            } else if (expr instanceof AST_Unary) {
              if (expr.operator == "++" || expr.operator == "--") {
                candidates.push(hit_stack.slice());
              }
            } else if (expr instanceof AST_VarDef) {
              if (expr.value && !(expr.value instanceof AST_Chain)) {
                candidates.push(hit_stack.slice());
                extract_candidates(expr.value);
              }
            }
            hit_stack.pop();
          }
          function find_stop(node, level, write_only) {
            var parent = scanner.parent(level);
            if (parent instanceof AST_Assign) {
              if (write_only && !parent.logical && !(parent.left instanceof AST_PropAccess || lvalues.has(parent.left.name))) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Binary) {
              if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Call)
              return node;
            if (parent instanceof AST_Case)
              return node;
            if (parent instanceof AST_Conditional) {
              if (write_only && parent.condition === node) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Definitions) {
              return find_stop(parent, level + 1, true);
            }
            if (parent instanceof AST_Exit) {
              return write_only ? find_stop(parent, level + 1, write_only) : node;
            }
            if (parent instanceof AST_If) {
              if (write_only && parent.condition === node) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_IterationStatement)
              return node;
            if (parent instanceof AST_Sequence) {
              return find_stop(parent, level + 1, parent.tail_node() !== node);
            }
            if (parent instanceof AST_SimpleStatement) {
              return find_stop(parent, level + 1, true);
            }
            if (parent instanceof AST_Switch)
              return node;
            if (parent instanceof AST_VarDef)
              return node;
            return null;
          }
          function mangleable_var(var_def) {
            var value2 = var_def.value;
            if (!(value2 instanceof AST_SymbolRef))
              return;
            if (value2.name == "arguments")
              return;
            var def2 = value2.definition();
            if (def2.undeclared)
              return;
            return value_def = def2;
          }
          function get_lhs(expr) {
            if (expr instanceof AST_Assign && expr.logical) {
              return false;
            } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {
              var def2 = expr.name.definition();
              if (!member(expr.name, def2.orig))
                return;
              var referenced = def2.references.length - def2.replaced;
              if (!referenced)
                return;
              var declared = def2.orig.length - def2.eliminated;
              if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg) || (referenced > 1 ? mangleable_var(expr) : !compressor2.exposed(def2))) {
                return make_node(AST_SymbolRef, expr.name, expr.name);
              }
            } else {
              const lhs2 = expr instanceof AST_Assign ? expr.left : expr.expression;
              return !is_ref_of(lhs2, AST_SymbolConst) && !is_ref_of(lhs2, AST_SymbolLet) && lhs2;
            }
          }
          function get_rvalue(expr) {
            if (expr instanceof AST_Assign) {
              return expr.right;
            } else {
              return expr.value;
            }
          }
          function get_lvalues(expr) {
            var lvalues2 = /* @__PURE__ */ new Map();
            if (expr instanceof AST_Unary)
              return lvalues2;
            var tw = new TreeWalker(function(node) {
              var sym = node;
              while (sym instanceof AST_PropAccess)
                sym = sym.expression;
              if (sym instanceof AST_SymbolRef) {
                const prev = lvalues2.get(sym.name);
                if (!prev || !prev.modified) {
                  lvalues2.set(sym.name, {
                    def: sym.definition(),
                    modified: is_modified(compressor2, tw, node, node, 0)
                  });
                }
              }
            });
            get_rvalue(expr).walk(tw);
            return lvalues2;
          }
          function remove_candidate(expr) {
            if (expr.name instanceof AST_SymbolFunarg) {
              var iife = compressor2.parent(), argnames = compressor2.self().argnames;
              var index = argnames.indexOf(expr.name);
              if (index < 0) {
                iife.args.length = Math.min(iife.args.length, argnames.length - 1);
              } else {
                var args2 = iife.args;
                if (args2[index])
                  args2[index] = make_node(AST_Number, args2[index], {
                    value: 0
                  });
              }
              return true;
            }
            var found = false;
            return statements2[stat_index].transform(new TreeTransformer(function(node, descend, in_list) {
              if (found)
                return node;
              if (node === expr || node.body === expr) {
                found = true;
                if (node instanceof AST_VarDef) {
                  node.value = node.name instanceof AST_SymbolConst ? make_node(AST_Undefined, node.value) : null;
                  return node;
                }
                return in_list ? MAP.skip : null;
              }
            }, function(node) {
              if (node instanceof AST_Sequence)
                switch (node.expressions.length) {
                  case 0:
                    return null;
                  case 1:
                    return node.expressions[0];
                }
            }));
          }
          function is_lhs_local(lhs2) {
            while (lhs2 instanceof AST_PropAccess)
              lhs2 = lhs2.expression;
            return lhs2 instanceof AST_SymbolRef && lhs2.definition().scope.get_defun_scope() === defun_scope && !(in_loop && (lvalues.has(lhs2.name) || candidate instanceof AST_Unary || candidate instanceof AST_Assign && !candidate.logical && candidate.operator != "="));
          }
          function value_has_side_effects(expr) {
            if (expr instanceof AST_Unary)
              return unary_side_effects.has(expr.operator);
            return get_rvalue(expr).has_side_effects(compressor2);
          }
          function replace_all_symbols() {
            if (side_effects)
              return false;
            if (value_def)
              return true;
            if (lhs instanceof AST_SymbolRef) {
              var def2 = lhs.definition();
              if (def2.references.length - def2.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {
                return true;
              }
            }
            return false;
          }
          function may_modify(sym) {
            if (!sym.definition)
              return true;
            var def2 = sym.definition();
            if (def2.orig.length == 1 && def2.orig[0] instanceof AST_SymbolDefun)
              return false;
            if (def2.scope.get_defun_scope() !== defun_scope)
              return true;
            return def2.references.some((ref) => ref.scope.get_defun_scope() !== defun_scope);
          }
          function side_effects_external(node, lhs2) {
            if (node instanceof AST_Assign)
              return side_effects_external(node.left, true);
            if (node instanceof AST_Unary)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_VarDef)
              return node.value && side_effects_external(node.value);
            if (lhs2) {
              if (node instanceof AST_Dot)
                return side_effects_external(node.expression, true);
              if (node instanceof AST_Sub)
                return side_effects_external(node.expression, true);
              if (node instanceof AST_SymbolRef)
                return node.definition().scope.get_defun_scope() !== defun_scope;
            }
            return false;
          }
          function shadows(my_scope, lvalues2) {
            for (const { def: def2 } of lvalues2.values()) {
              const looked_up = my_scope.find_variable(def2.name);
              if (looked_up) {
                if (looked_up === def2)
                  continue;
                return true;
              }
            }
            return false;
          }
        }
        function eliminate_spurious_blocks(statements2) {
          var seen_dirs = [];
          for (var i = 0; i < statements2.length; ) {
            var stat = statements2[i];
            if (stat instanceof AST_BlockStatement && stat.body.every(can_be_evicted_from_block)) {
              CHANGED = true;
              eliminate_spurious_blocks(stat.body);
              statements2.splice(i, 1, ...stat.body);
              i += stat.body.length;
            } else if (stat instanceof AST_EmptyStatement) {
              CHANGED = true;
              statements2.splice(i, 1);
            } else if (stat instanceof AST_Directive) {
              if (seen_dirs.indexOf(stat.value) < 0) {
                i++;
                seen_dirs.push(stat.value);
              } else {
                CHANGED = true;
                statements2.splice(i, 1);
              }
            } else
              i++;
          }
        }
        function handle_if_return(statements2, compressor2) {
          var self2 = compressor2.self();
          var multiple_if_returns = has_multiple_if_returns(statements2);
          var in_lambda = self2 instanceof AST_Lambda;
          const iteration_start = Math.min(statements2.length, 500);
          for (var i = iteration_start; --i >= 0; ) {
            var stat = statements2[i];
            var j = next_index(i);
            var next = statements2[j];
            if (in_lambda && !next && stat instanceof AST_Return) {
              if (!stat.value) {
                CHANGED = true;
                statements2.splice(i, 1);
                continue;
              }
              if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == "void") {
                CHANGED = true;
                statements2[i] = make_node(AST_SimpleStatement, stat, {
                  body: stat.value.expression
                });
                continue;
              }
            }
            if (stat instanceof AST_If) {
              let ab, new_else;
              ab = aborts(stat.body);
              if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat.body, ab))) {
                if (ab.label) {
                  remove(ab.label.thedef.references, ab);
                }
                CHANGED = true;
                stat = stat.clone();
                stat.condition = stat.condition.negate(compressor2);
                stat.body = make_node(AST_BlockStatement, stat, {
                  body: as_statement_array(stat.alternative).concat(extract_defuns())
                });
                stat.alternative = make_node(AST_BlockStatement, stat, {
                  body: new_else
                });
                statements2[i] = stat.transform(compressor2);
                continue;
              }
              ab = aborts(stat.alternative);
              if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat.alternative, ab))) {
                if (ab.label) {
                  remove(ab.label.thedef.references, ab);
                }
                CHANGED = true;
                stat = stat.clone();
                stat.body = make_node(AST_BlockStatement, stat.body, {
                  body: as_statement_array(stat.body).concat(extract_defuns())
                });
                stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                  body: new_else
                });
                statements2[i] = stat.transform(compressor2);
                continue;
              }
            }
            if (stat instanceof AST_If && stat.body instanceof AST_Return) {
              var value2 = stat.body.value;
              if (!value2 && !stat.alternative && (in_lambda && !next || next instanceof AST_Return && !next.value)) {
                CHANGED = true;
                statements2[i] = make_node(AST_SimpleStatement, stat.condition, {
                  body: stat.condition
                });
                continue;
              }
              if (value2 && !stat.alternative && next instanceof AST_Return && next.value) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = next;
                statements2[i] = stat.transform(compressor2);
                statements2.splice(j, 1);
                continue;
              }
              if (value2 && !stat.alternative && (!next && in_lambda && multiple_if_returns || next instanceof AST_Return)) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = next || make_node(AST_Return, stat, {
                  value: null
                });
                statements2[i] = stat.transform(compressor2);
                if (next)
                  statements2.splice(j, 1);
                continue;
              }
              var prev = statements2[prev_index(i)];
              if (compressor2.option("sequences") && in_lambda && !stat.alternative && prev instanceof AST_If && prev.body instanceof AST_Return && next_index(j) == statements2.length && next instanceof AST_SimpleStatement) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = make_node(AST_BlockStatement, next, {
                  body: [
                    next,
                    make_node(AST_Return, next, {
                      value: null
                    })
                  ]
                });
                statements2[i] = stat.transform(compressor2);
                statements2.splice(j, 1);
                continue;
              }
            }
          }
          function has_multiple_if_returns(statements3) {
            var n2 = 0;
            for (var i2 = statements3.length; --i2 >= 0; ) {
              var stat2 = statements3[i2];
              if (stat2 instanceof AST_If && stat2.body instanceof AST_Return) {
                if (++n2 > 1)
                  return true;
              }
            }
            return false;
          }
          function is_return_void(value3) {
            return !value3 || value3 instanceof AST_UnaryPrefix && value3.operator == "void";
          }
          function can_merge_flow(ab) {
            if (!ab)
              return false;
            for (var j2 = i + 1, len = statements2.length; j2 < len; j2++) {
              var stat2 = statements2[j2];
              if (stat2 instanceof AST_Const || stat2 instanceof AST_Let)
                return false;
            }
            var lct = ab instanceof AST_LoopControl ? compressor2.loopcontrol_target(ab) : null;
            return ab instanceof AST_Return && in_lambda && is_return_void(ab.value) || ab instanceof AST_Continue && self2 === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self2 === lct;
          }
          function extract_defuns() {
            var tail = statements2.slice(i + 1);
            statements2.length = i + 1;
            return tail.filter(function(stat2) {
              if (stat2 instanceof AST_Defun) {
                statements2.push(stat2);
                return false;
              }
              return true;
            });
          }
          function as_statement_array_with_return(node, ab) {
            var body = as_statement_array(node);
            if (ab !== body[body.length - 1]) {
              return void 0;
            }
            body = body.slice(0, -1);
            if (!body.every((stat2) => can_be_evicted_from_block(stat2))) {
              return void 0;
            }
            if (ab.value) {
              body.push(make_node(AST_SimpleStatement, ab.value, {
                body: ab.value.expression
              }));
            }
            return body;
          }
          function next_index(i2) {
            for (var j2 = i2 + 1, len = statements2.length; j2 < len; j2++) {
              var stat2 = statements2[j2];
              if (!(stat2 instanceof AST_Var && declarations_only(stat2))) {
                break;
              }
            }
            return j2;
          }
          function prev_index(i2) {
            for (var j2 = i2; --j2 >= 0; ) {
              var stat2 = statements2[j2];
              if (!(stat2 instanceof AST_Var && declarations_only(stat2))) {
                break;
              }
            }
            return j2;
          }
        }
        function eliminate_dead_code(statements2, compressor2) {
          var has_quit;
          var self2 = compressor2.self();
          for (var i = 0, n2 = 0, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            if (stat instanceof AST_LoopControl) {
              var lct = compressor2.loopcontrol_target(stat);
              if (stat instanceof AST_Break && !(lct instanceof AST_IterationStatement) && loop_body(lct) === self2 || stat instanceof AST_Continue && loop_body(lct) === self2) {
                if (stat.label) {
                  remove(stat.label.thedef.references, stat);
                }
              } else {
                statements2[n2++] = stat;
              }
            } else {
              statements2[n2++] = stat;
            }
            if (aborts(stat)) {
              has_quit = statements2.slice(i + 1);
              break;
            }
          }
          statements2.length = n2;
          CHANGED = n2 != len;
          if (has_quit)
            has_quit.forEach(function(stat2) {
              trim_unreachable_code(compressor2, stat2, statements2);
            });
        }
        function declarations_only(node) {
          return node.definitions.every((var_def) => !var_def.value);
        }
        function sequencesize(statements2, compressor2) {
          if (statements2.length < 2)
            return;
          var seq = [], n2 = 0;
          function push_seq() {
            if (!seq.length)
              return;
            var body2 = make_sequence(seq[0], seq);
            statements2[n2++] = make_node(AST_SimpleStatement, body2, { body: body2 });
            seq = [];
          }
          for (var i = 0, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            if (stat instanceof AST_SimpleStatement) {
              if (seq.length >= compressor2.sequences_limit)
                push_seq();
              var body = stat.body;
              if (seq.length > 0)
                body = body.drop_side_effect_free(compressor2);
              if (body)
                merge_sequence(seq, body);
            } else if (stat instanceof AST_Definitions && declarations_only(stat) || stat instanceof AST_Defun) {
              statements2[n2++] = stat;
            } else {
              push_seq();
              statements2[n2++] = stat;
            }
          }
          push_seq();
          statements2.length = n2;
          if (n2 != len)
            CHANGED = true;
        }
        function to_simple_statement(block, decls) {
          if (!(block instanceof AST_BlockStatement))
            return block;
          var stat = null;
          for (var i = 0, len = block.body.length; i < len; i++) {
            var line = block.body[i];
            if (line instanceof AST_Var && declarations_only(line)) {
              decls.push(line);
            } else if (stat || line instanceof AST_Const || line instanceof AST_Let) {
              return false;
            } else {
              stat = line;
            }
          }
          return stat;
        }
        function sequencesize_2(statements2, compressor2) {
          function cons_seq(right) {
            n2--;
            CHANGED = true;
            var left = prev.body;
            return make_sequence(left, [left, right]).transform(compressor2);
          }
          var n2 = 0, prev;
          for (var i = 0; i < statements2.length; i++) {
            var stat = statements2[i];
            if (prev) {
              if (stat instanceof AST_Exit) {
                stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor2));
              } else if (stat instanceof AST_For) {
                if (!(stat.init instanceof AST_Definitions)) {
                  const abort = walk(prev.body, (node) => {
                    if (node instanceof AST_Scope)
                      return true;
                    if (node instanceof AST_Binary && node.operator === "in") {
                      return walk_abort;
                    }
                  });
                  if (!abort) {
                    if (stat.init)
                      stat.init = cons_seq(stat.init);
                    else {
                      stat.init = prev.body;
                      n2--;
                      CHANGED = true;
                    }
                  }
                }
              } else if (stat instanceof AST_ForIn) {
                if (!(stat.init instanceof AST_Const) && !(stat.init instanceof AST_Let)) {
                  stat.object = cons_seq(stat.object);
                }
              } else if (stat instanceof AST_If) {
                stat.condition = cons_seq(stat.condition);
              } else if (stat instanceof AST_Switch) {
                stat.expression = cons_seq(stat.expression);
              } else if (stat instanceof AST_With) {
                stat.expression = cons_seq(stat.expression);
              }
            }
            if (compressor2.option("conditionals") && stat instanceof AST_If) {
              var decls = [];
              var body = to_simple_statement(stat.body, decls);
              var alt = to_simple_statement(stat.alternative, decls);
              if (body !== false && alt !== false && decls.length > 0) {
                var len = decls.length;
                decls.push(make_node(AST_If, stat, {
                  condition: stat.condition,
                  body: body || make_node(AST_EmptyStatement, stat.body),
                  alternative: alt
                }));
                decls.unshift(n2, 1);
                [].splice.apply(statements2, decls);
                i += len;
                n2 += len + 1;
                prev = null;
                CHANGED = true;
                continue;
              }
            }
            statements2[n2++] = stat;
            prev = stat instanceof AST_SimpleStatement ? stat : null;
          }
          statements2.length = n2;
        }
        function join_object_assignments(defn, body) {
          if (!(defn instanceof AST_Definitions))
            return;
          var def = defn.definitions[defn.definitions.length - 1];
          if (!(def.value instanceof AST_Object))
            return;
          var exprs;
          if (body instanceof AST_Assign && !body.logical) {
            exprs = [body];
          } else if (body instanceof AST_Sequence) {
            exprs = body.expressions.slice();
          }
          if (!exprs)
            return;
          var trimmed = false;
          do {
            var node = exprs[0];
            if (!(node instanceof AST_Assign))
              break;
            if (node.operator != "=")
              break;
            if (!(node.left instanceof AST_PropAccess))
              break;
            var sym = node.left.expression;
            if (!(sym instanceof AST_SymbolRef))
              break;
            if (def.name.name != sym.name)
              break;
            if (!node.right.is_constant_expression(nearest_scope))
              break;
            var prop = node.left.property;
            if (prop instanceof AST_Node) {
              prop = prop.evaluate(compressor);
            }
            if (prop instanceof AST_Node)
              break;
            prop = "" + prop;
            var diff = compressor.option("ecma") < 2015 && compressor.has_directive("use strict") ? function(node2) {
              return node2.key != prop && (node2.key && node2.key.name != prop);
            } : function(node2) {
              return node2.key && node2.key.name != prop;
            };
            if (!def.value.properties.every(diff))
              break;
            var p = def.value.properties.filter(function(p2) {
              return p2.key === prop;
            })[0];
            if (!p) {
              def.value.properties.push(make_node(AST_ObjectKeyVal, node, {
                key: prop,
                value: node.right
              }));
            } else {
              p.value = new AST_Sequence({
                start: p.start,
                expressions: [p.value.clone(), node.right.clone()],
                end: p.end
              });
            }
            exprs.shift();
            trimmed = true;
          } while (exprs.length);
          return trimmed && exprs;
        }
        function join_consecutive_vars(statements2) {
          var defs;
          for (var i = 0, j = -1, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            var prev = statements2[j];
            if (stat instanceof AST_Definitions) {
              if (prev && prev.TYPE == stat.TYPE) {
                prev.definitions = prev.definitions.concat(stat.definitions);
                CHANGED = true;
              } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {
                defs.definitions = defs.definitions.concat(stat.definitions);
                CHANGED = true;
              } else {
                statements2[++j] = stat;
                defs = stat;
              }
            } else if (stat instanceof AST_Exit) {
              stat.value = extract_object_assignments(stat.value);
            } else if (stat instanceof AST_For) {
              var exprs = join_object_assignments(prev, stat.init);
              if (exprs) {
                CHANGED = true;
                stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;
                statements2[++j] = stat;
              } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                if (stat.init) {
                  prev.definitions = prev.definitions.concat(stat.init.definitions);
                }
                stat.init = prev;
                statements2[j] = stat;
                CHANGED = true;
              } else if (defs instanceof AST_Var && stat.init instanceof AST_Var && declarations_only(stat.init)) {
                defs.definitions = defs.definitions.concat(stat.init.definitions);
                stat.init = null;
                statements2[++j] = stat;
                CHANGED = true;
              } else {
                statements2[++j] = stat;
              }
            } else if (stat instanceof AST_ForIn) {
              stat.object = extract_object_assignments(stat.object);
            } else if (stat instanceof AST_If) {
              stat.condition = extract_object_assignments(stat.condition);
            } else if (stat instanceof AST_SimpleStatement) {
              var exprs = join_object_assignments(prev, stat.body);
              if (exprs) {
                CHANGED = true;
                if (!exprs.length)
                  continue;
                stat.body = make_sequence(stat.body, exprs);
              }
              statements2[++j] = stat;
            } else if (stat instanceof AST_Switch) {
              stat.expression = extract_object_assignments(stat.expression);
            } else if (stat instanceof AST_With) {
              stat.expression = extract_object_assignments(stat.expression);
            } else {
              statements2[++j] = stat;
            }
          }
          statements2.length = j + 1;
          function extract_object_assignments(value2) {
            statements2[++j] = stat;
            var exprs2 = join_object_assignments(prev, value2);
            if (exprs2) {
              CHANGED = true;
              if (exprs2.length) {
                return make_sequence(value2, exprs2);
              } else if (value2 instanceof AST_Sequence) {
                return value2.tail_node().left;
              } else {
                return value2.left;
              }
            }
            return value2;
          }
        }
      }
      function within_array_or_object_literal(compressor) {
        var node, level = 0;
        while (node = compressor.parent(level++)) {
          if (node instanceof AST_Statement)
            return false;
          if (node instanceof AST_Array || node instanceof AST_ObjectKeyVal || node instanceof AST_Object) {
            return true;
          }
        }
        return false;
      }
      function scope_encloses_variables_in_this_scope(scope, pulled_scope) {
        for (const enclosed of pulled_scope.enclosed) {
          if (pulled_scope.variables.has(enclosed.name)) {
            continue;
          }
          const looked_up = scope.find_variable(enclosed.name);
          if (looked_up) {
            if (looked_up === enclosed)
              continue;
            return true;
          }
        }
        return false;
      }
      function is_const_symbol_short_than_init_value(def, fixed_value) {
        if (def.orig.length === 1 && fixed_value) {
          const init_value_length = fixed_value.size();
          const identifer_length = def.name.length;
          return init_value_length > identifer_length;
        }
        return true;
      }
      function inline_into_symbolref(self2, compressor) {
        if (compressor.in_computed_key())
          return self2;
        const parent = compressor.parent();
        const def = self2.definition();
        const nearest_scope = compressor.find_scope();
        let fixed = self2.fixed_value();
        if (compressor.top_retain && def.global && compressor.top_retain(def) && is_const_symbol_short_than_init_value(def, fixed)) {
          def.fixed = false;
          def.single_use = false;
          return self2;
        }
        if (dont_inline_lambda_in_loop(compressor, fixed))
          return self2;
        let single_use = def.single_use && !(parent instanceof AST_Call && parent.is_callee_pure(compressor) || has_annotation(parent, _NOINLINE)) && !(parent instanceof AST_Export && fixed instanceof AST_Lambda && fixed.name);
        if (single_use && fixed instanceof AST_Node) {
          single_use = !fixed.has_side_effects(compressor) && !fixed.may_throw(compressor);
        }
        if (fixed instanceof AST_Class && def.scope !== self2.scope) {
          return self2;
        }
        if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
          if (retain_top_func(fixed, compressor)) {
            single_use = false;
          } else if (def.scope !== self2.scope && (def.escaped == 1 || has_flag(fixed, INLINED) || within_array_or_object_literal(compressor) || !compressor.option("reduce_funcs"))) {
            single_use = false;
          } else if (is_recursive_ref(compressor, def)) {
            single_use = false;
          } else if (def.scope !== self2.scope || def.orig[0] instanceof AST_SymbolFunarg) {
            single_use = fixed.is_constant_expression(self2.scope);
            if (single_use == "f") {
              var scope = self2.scope;
              do {
                if (scope instanceof AST_Defun || is_func_expr(scope)) {
                  set_flag(scope, INLINED);
                }
              } while (scope = scope.parent_scope);
            }
          }
        }
        if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
          single_use = def.scope === self2.scope && !scope_encloses_variables_in_this_scope(nearest_scope, fixed) || parent instanceof AST_Call && parent.expression === self2 && !scope_encloses_variables_in_this_scope(nearest_scope, fixed) && !(fixed.name && fixed.name.definition().recursive_refs > 0);
        }
        if (single_use && fixed) {
          if (fixed instanceof AST_DefClass) {
            set_flag(fixed, SQUEEZED);
            fixed = make_node(AST_ClassExpression, fixed, fixed);
          }
          if (fixed instanceof AST_Defun) {
            set_flag(fixed, SQUEEZED);
            fixed = make_node(AST_Function, fixed, fixed);
          }
          if (def.recursive_refs > 0 && fixed.name instanceof AST_SymbolDefun) {
            const defun_def = fixed.name.definition();
            let lambda_def = fixed.variables.get(fixed.name.name);
            let name = lambda_def && lambda_def.orig[0];
            if (!(name instanceof AST_SymbolLambda)) {
              name = make_node(AST_SymbolLambda, fixed.name, fixed.name);
              name.scope = fixed;
              fixed.name = name;
              lambda_def = fixed.def_function(name);
            }
            walk(fixed, (node) => {
              if (node instanceof AST_SymbolRef && node.definition() === defun_def) {
                node.thedef = lambda_def;
                lambda_def.references.push(node);
              }
            });
          }
          if ((fixed instanceof AST_Lambda || fixed instanceof AST_Class) && fixed.parent_scope !== nearest_scope) {
            fixed = fixed.clone(true, compressor.get_toplevel());
            nearest_scope.add_child_scope(fixed);
          }
          return fixed.optimize(compressor);
        }
        if (fixed) {
          let replace;
          if (fixed instanceof AST_This) {
            if (!(def.orig[0] instanceof AST_SymbolFunarg) && def.references.every((ref) => def.scope === ref.scope)) {
              replace = fixed;
            }
          } else {
            var ev = fixed.evaluate(compressor);
            if (ev !== fixed && (compressor.option("unsafe_regexp") || !(ev instanceof RegExp))) {
              replace = make_node_from_constant(ev, fixed);
            }
          }
          if (replace) {
            const name_length = self2.size(compressor);
            const replace_size = replace.size(compressor);
            let overhead = 0;
            if (compressor.option("unused") && !compressor.exposed(def)) {
              overhead = (name_length + 2 + fixed.size(compressor)) / (def.references.length - def.assignments);
            }
            if (replace_size <= name_length + overhead) {
              return replace;
            }
          }
        }
        return self2;
      }
      function inline_into_call(self2, compressor) {
        if (compressor.in_computed_key())
          return self2;
        var exp = self2.expression;
        var fn = exp;
        var simple_args = self2.args.every((arg) => !(arg instanceof AST_Expansion));
        if (compressor.option("reduce_vars") && fn instanceof AST_SymbolRef && !has_annotation(self2, _NOINLINE)) {
          const fixed = fn.fixed_value();
          if (retain_top_func(fixed, compressor) || !compressor.toplevel.funcs && exp.definition().global) {
            return self2;
          }
          fn = fixed;
        }
        if (dont_inline_lambda_in_loop(compressor, fn) && !has_annotation(self2, _INLINE))
          return self2;
        var is_func = fn instanceof AST_Lambda;
        var stat = is_func && fn.body[0];
        var is_regular_func = is_func && !fn.is_generator && !fn.async;
        var can_inline = is_regular_func && compressor.option("inline") && !self2.is_callee_pure(compressor);
        if (can_inline && stat instanceof AST_Return) {
          let returned = stat.value;
          if (!returned || returned.is_constant_expression()) {
            if (returned) {
              returned = returned.clone(true);
            } else {
              returned = make_node(AST_Undefined, self2);
            }
            const args2 = self2.args.concat(returned);
            return make_sequence(self2, args2).optimize(compressor);
          }
          if (fn.argnames.length === 1 && fn.argnames[0] instanceof AST_SymbolFunarg && self2.args.length < 2 && !(self2.args[0] instanceof AST_Expansion) && returned instanceof AST_SymbolRef && returned.name === fn.argnames[0].name) {
            const replacement = (self2.args[0] || make_node(AST_Undefined)).optimize(compressor);
            let parent;
            if (replacement instanceof AST_PropAccess && (parent = compressor.parent()) instanceof AST_Call && parent.expression === self2) {
              return make_sequence(self2, [
                make_node(AST_Number, self2, { value: 0 }),
                replacement
              ]);
            }
            return replacement;
          }
        }
        if (can_inline) {
          var scope, in_loop, level = -1;
          let def;
          let returned_value;
          let nearest_scope;
          if (simple_args && !fn.uses_arguments && !(compressor.parent() instanceof AST_Class) && !(fn.name && fn instanceof AST_Function) && (returned_value = can_flatten_body(stat)) && (exp === fn || has_annotation(self2, _INLINE) || compressor.option("unused") && (def = exp.definition()).references.length == 1 && !is_recursive_ref(compressor, def) && fn.is_constant_expression(exp.scope)) && !has_annotation(self2, _PURE | _NOINLINE) && !fn.contains_this() && can_inject_symbols() && (nearest_scope = compressor.find_scope()) && !scope_encloses_variables_in_this_scope(nearest_scope, fn) && !function in_default_assign() {
            let i = 0;
            let p;
            while (p = compressor.parent(i++)) {
              if (p instanceof AST_DefaultAssign)
                return true;
              if (p instanceof AST_Block)
                break;
            }
            return false;
          }() && !(scope instanceof AST_Class)) {
            set_flag(fn, SQUEEZED);
            nearest_scope.add_child_scope(fn);
            return make_sequence(self2, flatten_fn(returned_value)).optimize(compressor);
          }
        }
        if (can_inline && has_annotation(self2, _INLINE)) {
          set_flag(fn, SQUEEZED);
          fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);
          fn = fn.clone(true);
          fn.figure_out_scope({}, {
            parent_scope: compressor.find_scope(),
            toplevel: compressor.get_toplevel()
          });
          return make_node(AST_Call, self2, {
            expression: fn,
            args: self2.args
          }).optimize(compressor);
        }
        const can_drop_this_call = is_regular_func && compressor.option("side_effects") && fn.body.every(is_empty2);
        if (can_drop_this_call) {
          var args = self2.args.concat(make_node(AST_Undefined, self2));
          return make_sequence(self2, args).optimize(compressor);
        }
        if (compressor.option("negate_iife") && compressor.parent() instanceof AST_SimpleStatement && is_iife_call(self2)) {
          return self2.negate(compressor, true);
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
        function return_value(stat2) {
          if (!stat2)
            return make_node(AST_Undefined, self2);
          if (stat2 instanceof AST_Return) {
            if (!stat2.value)
              return make_node(AST_Undefined, self2);
            return stat2.value.clone(true);
          }
          if (stat2 instanceof AST_SimpleStatement) {
            return make_node(AST_UnaryPrefix, stat2, {
              operator: "void",
              expression: stat2.body.clone(true)
            });
          }
        }
        function can_flatten_body(stat2) {
          var body = fn.body;
          var len = body.length;
          if (compressor.option("inline") < 3) {
            return len == 1 && return_value(stat2);
          }
          stat2 = null;
          for (var i = 0; i < len; i++) {
            var line = body[i];
            if (line instanceof AST_Var) {
              if (stat2 && !line.definitions.every((var_def) => !var_def.value)) {
                return false;
              }
            } else if (stat2) {
              return false;
            } else if (!(line instanceof AST_EmptyStatement)) {
              stat2 = line;
            }
          }
          return return_value(stat2);
        }
        function can_inject_args(block_scoped, safe_to_inject) {
          for (var i = 0, len = fn.argnames.length; i < len; i++) {
            var arg = fn.argnames[i];
            if (arg instanceof AST_DefaultAssign) {
              if (has_flag(arg.left, UNUSED))
                continue;
              return false;
            }
            if (arg instanceof AST_Destructuring)
              return false;
            if (arg instanceof AST_Expansion) {
              if (has_flag(arg.expression, UNUSED))
                continue;
              return false;
            }
            if (has_flag(arg, UNUSED))
              continue;
            if (!safe_to_inject || block_scoped.has(arg.name) || identifier_atom.has(arg.name) || scope.conflicting_def(arg.name)) {
              return false;
            }
            if (in_loop)
              in_loop.push(arg.definition());
          }
          return true;
        }
        function can_inject_vars(block_scoped, safe_to_inject) {
          var len = fn.body.length;
          for (var i = 0; i < len; i++) {
            var stat2 = fn.body[i];
            if (!(stat2 instanceof AST_Var))
              continue;
            if (!safe_to_inject)
              return false;
            for (var j = stat2.definitions.length; --j >= 0; ) {
              var name = stat2.definitions[j].name;
              if (name instanceof AST_Destructuring || block_scoped.has(name.name) || identifier_atom.has(name.name) || scope.conflicting_def(name.name)) {
                return false;
              }
              if (in_loop)
                in_loop.push(name.definition());
            }
          }
          return true;
        }
        function can_inject_symbols() {
          var block_scoped = /* @__PURE__ */ new Set();
          do {
            scope = compressor.parent(++level);
            if (scope.is_block_scope() && scope.block_scope) {
              scope.block_scope.variables.forEach(function(variable) {
                block_scoped.add(variable.name);
              });
            }
            if (scope instanceof AST_Catch) {
              if (scope.argname) {
                block_scoped.add(scope.argname.name);
              }
            } else if (scope instanceof AST_IterationStatement) {
              in_loop = [];
            } else if (scope instanceof AST_SymbolRef) {
              if (scope.fixed_value() instanceof AST_Scope)
                return false;
            }
          } while (!(scope instanceof AST_Scope));
          var safe_to_inject = !(scope instanceof AST_Toplevel) || compressor.toplevel.vars;
          var inline = compressor.option("inline");
          if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject))
            return false;
          if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject))
            return false;
          return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);
        }
        function append_var(decls, expressions, name, value2) {
          var def = name.definition();
          const already_appended = scope.variables.has(name.name);
          if (!already_appended) {
            scope.variables.set(name.name, def);
            scope.enclosed.push(def);
            decls.push(make_node(AST_VarDef, name, {
              name,
              value: null
            }));
          }
          var sym = make_node(AST_SymbolRef, name, name);
          def.references.push(sym);
          if (value2)
            expressions.push(make_node(AST_Assign, self2, {
              operator: "=",
              logical: false,
              left: sym,
              right: value2.clone()
            }));
        }
        function flatten_args(decls, expressions) {
          var len = fn.argnames.length;
          for (var i = self2.args.length; --i >= len; ) {
            expressions.push(self2.args[i]);
          }
          for (i = len; --i >= 0; ) {
            var name = fn.argnames[i];
            var value2 = self2.args[i];
            if (has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {
              if (value2)
                expressions.push(value2);
            } else {
              var symbol = make_node(AST_SymbolVar, name, name);
              name.definition().orig.push(symbol);
              if (!value2 && in_loop)
                value2 = make_node(AST_Undefined, self2);
              append_var(decls, expressions, symbol, value2);
            }
          }
          decls.reverse();
          expressions.reverse();
        }
        function flatten_vars(decls, expressions) {
          var pos2 = expressions.length;
          for (var i = 0, lines = fn.body.length; i < lines; i++) {
            var stat2 = fn.body[i];
            if (!(stat2 instanceof AST_Var))
              continue;
            for (var j = 0, defs = stat2.definitions.length; j < defs; j++) {
              var var_def = stat2.definitions[j];
              var name = var_def.name;
              append_var(decls, expressions, name, var_def.value);
              if (in_loop && fn.argnames.every((argname) => argname.name != name.name)) {
                var def = fn.variables.get(name.name);
                var sym = make_node(AST_SymbolRef, name, name);
                def.references.push(sym);
                expressions.splice(pos2++, 0, make_node(AST_Assign, var_def, {
                  operator: "=",
                  logical: false,
                  left: sym,
                  right: make_node(AST_Undefined, name)
                }));
              }
            }
          }
        }
        function flatten_fn(returned_value) {
          var decls = [];
          var expressions = [];
          flatten_args(decls, expressions);
          flatten_vars(decls, expressions);
          expressions.push(returned_value);
          if (decls.length) {
            const i = scope.body.indexOf(compressor.parent(level - 1)) + 1;
            scope.body.splice(i, 0, make_node(AST_Var, fn, {
              definitions: decls
            }));
          }
          return expressions.map((exp2) => exp2.clone(true));
        }
      }
      function dont_inline_lambda_in_loop(compressor, maybe_lambda) {
        return (maybe_lambda instanceof AST_Lambda || maybe_lambda instanceof AST_Class) && !!compressor.is_within_loop();
      }
      (function(def_find_defs) {
        function to_node(value2, orig) {
          if (value2 instanceof AST_Node) {
            if (!(value2 instanceof AST_Constant)) {
              value2 = value2.clone(true);
            }
            return make_node(value2.CTOR, orig, value2);
          }
          if (Array.isArray(value2))
            return make_node(AST_Array, orig, {
              elements: value2.map(function(value3) {
                return to_node(value3, orig);
              })
            });
          if (value2 && typeof value2 == "object") {
            var props = [];
            for (var key in value2)
              if (HOP(value2, key)) {
                props.push(make_node(AST_ObjectKeyVal, orig, {
                  key,
                  value: to_node(value2[key], orig)
                }));
              }
            return make_node(AST_Object, orig, {
              properties: props
            });
          }
          return make_node_from_constant(value2, orig);
        }
        AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
          if (!compressor.option("global_defs"))
            return this;
          this.figure_out_scope({ ie8: compressor.option("ie8") });
          return this.transform(new TreeTransformer(function(node) {
            var def = node._find_defs(compressor, "");
            if (!def)
              return;
            var level = 0, child = node, parent;
            while (parent = this.parent(level++)) {
              if (!(parent instanceof AST_PropAccess))
                break;
              if (parent.expression !== child)
                break;
              child = parent;
            }
            if (is_lhs(child, parent)) {
              return;
            }
            return def;
          }));
        });
        def_find_defs(AST_Node, noop2);
        def_find_defs(AST_Chain, function(compressor, suffix) {
          return this.expression._find_defs(compressor, suffix);
        });
        def_find_defs(AST_Dot, function(compressor, suffix) {
          return this.expression._find_defs(compressor, "." + this.property + suffix);
        });
        def_find_defs(AST_SymbolDeclaration, function() {
          if (!this.global())
            return;
        });
        def_find_defs(AST_SymbolRef, function(compressor, suffix) {
          if (!this.global())
            return;
          var defines = compressor.option("global_defs");
          var name = this.name + suffix;
          if (HOP(defines, name))
            return to_node(defines[name], this);
        });
        def_find_defs(AST_ImportMeta, function(compressor, suffix) {
          var defines = compressor.option("global_defs");
          var name = "import.meta" + suffix;
          if (HOP(defines, name))
            return to_node(defines[name], this);
        });
      })(function(node, func) {
        node.DEFMETHOD("_find_defs", func);
      });
      class Compressor extends TreeWalker {
        constructor(options, { false_by_default = false, mangle_options: mangle_options2 = false }) {
          super();
          if (options.defaults !== void 0 && !options.defaults)
            false_by_default = true;
          this.options = defaults(options, {
            arguments: false,
            arrows: !false_by_default,
            booleans: !false_by_default,
            booleans_as_integers: false,
            collapse_vars: !false_by_default,
            comparisons: !false_by_default,
            computed_props: !false_by_default,
            conditionals: !false_by_default,
            dead_code: !false_by_default,
            defaults: true,
            directives: !false_by_default,
            drop_console: false,
            drop_debugger: !false_by_default,
            ecma: 5,
            evaluate: !false_by_default,
            expression: false,
            global_defs: false,
            hoist_funs: false,
            hoist_props: !false_by_default,
            hoist_vars: false,
            ie8: false,
            if_return: !false_by_default,
            inline: !false_by_default,
            join_vars: !false_by_default,
            keep_classnames: false,
            keep_fargs: true,
            keep_fnames: false,
            keep_infinity: false,
            lhs_constants: !false_by_default,
            loops: !false_by_default,
            module: false,
            negate_iife: !false_by_default,
            passes: 1,
            properties: !false_by_default,
            pure_getters: !false_by_default && "strict",
            pure_funcs: null,
            pure_new: false,
            reduce_funcs: !false_by_default,
            reduce_vars: !false_by_default,
            sequences: !false_by_default,
            side_effects: !false_by_default,
            switches: !false_by_default,
            top_retain: null,
            toplevel: !!(options && options["top_retain"]),
            typeofs: !false_by_default,
            unsafe: false,
            unsafe_arrows: false,
            unsafe_comps: false,
            unsafe_Function: false,
            unsafe_math: false,
            unsafe_symbols: false,
            unsafe_methods: false,
            unsafe_proto: false,
            unsafe_regexp: false,
            unsafe_undefined: false,
            unused: !false_by_default,
            warnings: false
          }, true);
          var global_defs = this.options["global_defs"];
          if (typeof global_defs == "object")
            for (var key in global_defs) {
              if (key[0] === "@" && HOP(global_defs, key)) {
                global_defs[key.slice(1)] = parse2(global_defs[key], {
                  expression: true
                });
              }
            }
          if (this.options["inline"] === true)
            this.options["inline"] = 3;
          var pure_funcs = this.options["pure_funcs"];
          if (typeof pure_funcs == "function") {
            this.pure_funcs = pure_funcs;
          } else {
            this.pure_funcs = pure_funcs ? function(node) {
              return !pure_funcs.includes(node.expression.print_to_string());
            } : return_true;
          }
          var top_retain = this.options["top_retain"];
          if (top_retain instanceof RegExp) {
            this.top_retain = function(def) {
              return top_retain.test(def.name);
            };
          } else if (typeof top_retain == "function") {
            this.top_retain = top_retain;
          } else if (top_retain) {
            if (typeof top_retain == "string") {
              top_retain = top_retain.split(/,/);
            }
            this.top_retain = function(def) {
              return top_retain.includes(def.name);
            };
          }
          if (this.options["module"]) {
            this.directives["use strict"] = true;
            this.options["toplevel"] = true;
          }
          var toplevel = this.options["toplevel"];
          this.toplevel = typeof toplevel == "string" ? {
            funcs: /funcs/.test(toplevel),
            vars: /vars/.test(toplevel)
          } : {
            funcs: toplevel,
            vars: toplevel
          };
          var sequences = this.options["sequences"];
          this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
          this.evaluated_regexps = /* @__PURE__ */ new Map();
          this._toplevel = void 0;
          this._mangle_options = mangle_options2 ? format_mangler_options(mangle_options2) : mangle_options2;
        }
        mangle_options() {
          var nth_identifier = this._mangle_options && this._mangle_options.nth_identifier || base54;
          var module3 = this._mangle_options && this._mangle_options.module || this.option("module");
          return { ie8: this.option("ie8"), nth_identifier, module: module3 };
        }
        option(key) {
          return this.options[key];
        }
        exposed(def) {
          if (def.export)
            return true;
          if (def.global) {
            for (var i = 0, len = def.orig.length; i < len; i++)
              if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? "funcs" : "vars"])
                return true;
          }
          return false;
        }
        in_boolean_context() {
          if (!this.option("booleans"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_SimpleStatement || p instanceof AST_Conditional && p.condition === self2 || p instanceof AST_DWLoop && p.condition === self2 || p instanceof AST_For && p.condition === self2 || p instanceof AST_If && p.condition === self2 || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self2) {
              return true;
            }
            if (p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||" || p.operator == "??") || p instanceof AST_Conditional || p.tail_node() === self2) {
              self2 = p;
            } else {
              return false;
            }
          }
        }
        in_32_bit_context(other_operand_must_be_number) {
          if (!this.option("evaluate"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_Binary && bitwise_binop.has(p.operator)) {
              if (other_operand_must_be_number) {
                return (self2 === p.left ? p.right : p.left).is_number(this);
              } else {
                return true;
              }
            }
            if (p instanceof AST_UnaryPrefix) {
              return p.operator === "~";
            }
            if (p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||" || p.operator == "??") || p instanceof AST_Conditional && p.condition !== self2 || p.tail_node() === self2) {
              self2 = p;
            } else {
              return false;
            }
          }
        }
        in_computed_key() {
          if (!this.option("evaluate"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_ObjectProperty && p.key === self2) {
              return true;
            }
          }
          return false;
        }
        get_toplevel() {
          return this._toplevel;
        }
        compress(toplevel) {
          toplevel = toplevel.resolve_defines(this);
          this._toplevel = toplevel;
          if (this.option("expression")) {
            this._toplevel.process_expression(true);
          }
          var passes = +this.options.passes || 1;
          var min_count = 1 / 0;
          var stopping = false;
          var mangle = this.mangle_options();
          for (var pass = 0; pass < passes; pass++) {
            this._toplevel.figure_out_scope(mangle);
            if (pass === 0 && this.option("drop_console")) {
              this._toplevel = this._toplevel.drop_console(this.option("drop_console"));
            }
            if (pass > 0 || this.option("reduce_vars")) {
              this._toplevel.reset_opt_flags(this);
            }
            this._toplevel = this._toplevel.transform(this);
            if (passes > 1) {
              let count = 0;
              walk(this._toplevel, () => {
                count++;
              });
              if (count < min_count) {
                min_count = count;
                stopping = false;
              } else if (stopping) {
                break;
              } else {
                stopping = true;
              }
            }
          }
          if (this.option("expression")) {
            this._toplevel.process_expression(false);
          }
          toplevel = this._toplevel;
          this._toplevel = void 0;
          return toplevel;
        }
        before(node, descend) {
          if (has_flag(node, SQUEEZED))
            return node;
          var was_scope = false;
          if (node instanceof AST_Scope) {
            node = node.hoist_properties(this);
            node = node.hoist_declarations(this);
            was_scope = true;
          }
          descend(node, this);
          descend(node, this);
          var opt = node.optimize(this);
          if (was_scope && opt instanceof AST_Scope) {
            opt.drop_unused(this);
            descend(opt, this);
          }
          if (opt === node)
            set_flag(opt, SQUEEZED);
          return opt;
        }
        is_lhs() {
          const self2 = this.stack[this.stack.length - 1];
          const parent = this.stack[this.stack.length - 2];
          return is_lhs(self2, parent);
        }
      }
      function def_optimize(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor) {
          var self2 = this;
          if (has_flag(self2, OPTIMIZED))
            return self2;
          if (compressor.has_directive("use asm"))
            return self2;
          var opt = optimizer(self2, compressor);
          set_flag(opt, OPTIMIZED);
          return opt;
        });
      }
      def_optimize(AST_Node, function(self2) {
        return self2;
      });
      AST_Toplevel.DEFMETHOD("drop_console", function(options) {
        const isArray = Array.isArray(options);
        const tt = new TreeTransformer(function(self2) {
          if (self2.TYPE !== "Call") {
            return;
          }
          var exp = self2.expression;
          if (!(exp instanceof AST_PropAccess)) {
            return;
          }
          var name = exp.expression;
          var property = exp.property;
          var depth = 2;
          while (name.expression) {
            property = name.property;
            name = name.expression;
            depth++;
          }
          if (isArray && !options.includes(property)) {
            return;
          }
          if (is_undeclared_ref(name) && name.name == "console") {
            if (depth === 3 && !["call", "apply"].includes(exp.property) && is_used_in_expression(tt)) {
              exp.expression = make_empty_function(self2);
              set_flag(exp.expression, SQUEEZED);
              self2.args = [];
            } else {
              return make_node(AST_Undefined, self2);
            }
          }
        });
        return this.transform(tt);
      });
      AST_Node.DEFMETHOD("equivalent_to", function(node) {
        return equivalent_to(this, node);
      });
      AST_Scope.DEFMETHOD("process_expression", function(insert2, compressor) {
        var self2 = this;
        var tt = new TreeTransformer(function(node) {
          if (insert2 && node instanceof AST_SimpleStatement) {
            return make_node(AST_Return, node, {
              value: node.body
            });
          }
          if (!insert2 && node instanceof AST_Return) {
            if (compressor) {
              var value2 = node.value && node.value.drop_side_effect_free(compressor, true);
              return value2 ? make_node(AST_SimpleStatement, node, { body: value2 }) : make_node(AST_EmptyStatement, node);
            }
            return make_node(AST_SimpleStatement, node, {
              body: node.value || make_node(AST_UnaryPrefix, node, {
                operator: "void",
                expression: make_node(AST_Number, node, {
                  value: 0
                })
              })
            });
          }
          if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self2) {
            return node;
          }
          if (node instanceof AST_Block) {
            var index = node.body.length - 1;
            if (index >= 0) {
              node.body[index] = node.body[index].transform(tt);
            }
          } else if (node instanceof AST_If) {
            node.body = node.body.transform(tt);
            if (node.alternative) {
              node.alternative = node.alternative.transform(tt);
            }
          } else if (node instanceof AST_With) {
            node.body = node.body.transform(tt);
          }
          return node;
        });
        self2.transform(tt);
      });
      AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
        const self2 = this;
        const reduce_vars = compressor.option("reduce_vars");
        const preparation = new TreeWalker(function(node, descend) {
          clear_flag(node, CLEAR_BETWEEN_PASSES);
          if (reduce_vars) {
            if (compressor.top_retain && node instanceof AST_Defun && preparation.parent() === self2) {
              set_flag(node, TOP);
            }
            return node.reduce_vars(preparation, descend, compressor);
          }
        });
        preparation.safe_ids = /* @__PURE__ */ Object.create(null);
        preparation.in_loop = null;
        preparation.loop_ids = /* @__PURE__ */ new Map();
        preparation.defs_to_safe_ids = /* @__PURE__ */ new Map();
        self2.walk(preparation);
      });
      AST_Symbol.DEFMETHOD("fixed_value", function() {
        var fixed = this.thedef.fixed;
        if (!fixed || fixed instanceof AST_Node)
          return fixed;
        return fixed();
      });
      AST_SymbolRef.DEFMETHOD("is_immutable", function() {
        var orig = this.definition().orig;
        return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;
      });
      function find_variable(compressor, name) {
        var scope, i = 0;
        while (scope = compressor.parent(i++)) {
          if (scope instanceof AST_Scope)
            break;
          if (scope instanceof AST_Catch && scope.argname) {
            scope = scope.argname.definition().scope;
            break;
          }
        }
        return scope.find_variable(name);
      }
      var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");
      AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
        return !this.definition().undeclared || compressor.option("unsafe") && global_names.has(this.name);
      });
      var directives = /* @__PURE__ */ new Set(["use asm", "use strict"]);
      def_optimize(AST_Directive, function(self2, compressor) {
        if (compressor.option("directives") && (!directives.has(self2.value) || compressor.has_directive(self2.value) !== self2)) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      def_optimize(AST_Debugger, function(self2, compressor) {
        if (compressor.option("drop_debugger"))
          return make_node(AST_EmptyStatement, self2);
        return self2;
      });
      def_optimize(AST_LabeledStatement, function(self2, compressor) {
        if (self2.body instanceof AST_Break && compressor.loopcontrol_target(self2.body) === self2.body) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2.label.references.length == 0 ? self2.body : self2;
      });
      def_optimize(AST_Block, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        return self2;
      });
      function can_be_extracted_from_if_block(node) {
        return !(node instanceof AST_Const || node instanceof AST_Let || node instanceof AST_Class);
      }
      def_optimize(AST_BlockStatement, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        switch (self2.body.length) {
          case 1:
            if (!compressor.has_directive("use strict") && compressor.parent() instanceof AST_If && can_be_extracted_from_if_block(self2.body[0]) || can_be_evicted_from_block(self2.body[0])) {
              return self2.body[0];
            }
            break;
          case 0:
            return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      function opt_AST_Lambda(self2, compressor) {
        tighten_body(self2.body, compressor);
        if (compressor.option("side_effects") && self2.body.length == 1 && self2.body[0] === compressor.has_directive("use strict")) {
          self2.body.length = 0;
        }
        return self2;
      }
      def_optimize(AST_Lambda, opt_AST_Lambda);
      AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
        var self2 = this;
        if (compressor.has_directive("use asm"))
          return self2;
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        if (hoist_funs || hoist_vars) {
          var dirs = [];
          var hoisted = [];
          var vars = /* @__PURE__ */ new Map(), vars_found = 0, var_decl = 0;
          walk(self2, (node) => {
            if (node instanceof AST_Scope && node !== self2)
              return true;
            if (node instanceof AST_Var) {
              ++var_decl;
              return true;
            }
          });
          hoist_vars = hoist_vars && var_decl > 1;
          var tt = new TreeTransformer(function before(node) {
            if (node !== self2) {
              if (node instanceof AST_Directive) {
                dirs.push(node);
                return make_node(AST_EmptyStatement, node);
              }
              if (hoist_funs && node instanceof AST_Defun && !(tt.parent() instanceof AST_Export) && tt.parent() === self2) {
                hoisted.push(node);
                return make_node(AST_EmptyStatement, node);
              }
              if (hoist_vars && node instanceof AST_Var && !node.definitions.some((def3) => def3.name instanceof AST_Destructuring)) {
                node.definitions.forEach(function(def3) {
                  vars.set(def3.name.name, def3);
                  ++vars_found;
                });
                var seq = node.to_assignments(compressor);
                var p = tt.parent();
                if (p instanceof AST_ForIn && p.init === node) {
                  if (seq == null) {
                    var def2 = node.definitions[0].name;
                    return make_node(AST_SymbolRef, def2, def2);
                  }
                  return seq;
                }
                if (p instanceof AST_For && p.init === node) {
                  return seq;
                }
                if (!seq)
                  return make_node(AST_EmptyStatement, node);
                return make_node(AST_SimpleStatement, node, {
                  body: seq
                });
              }
              if (node instanceof AST_Scope)
                return node;
            }
          });
          self2 = self2.transform(tt);
          if (vars_found > 0) {
            var defs = [];
            const is_lambda = self2 instanceof AST_Lambda;
            const args_as_names = is_lambda ? self2.args_as_names() : null;
            vars.forEach((def2, name) => {
              if (is_lambda && args_as_names.some((x) => x.name === def2.name.name)) {
                vars.delete(name);
              } else {
                def2 = def2.clone();
                def2.value = null;
                defs.push(def2);
                vars.set(name, def2);
              }
            });
            if (defs.length > 0) {
              for (var i = 0; i < self2.body.length; ) {
                if (self2.body[i] instanceof AST_SimpleStatement) {
                  var expr = self2.body[i].body, sym, assign;
                  if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
                    var def = vars.get(sym.name);
                    if (def.value)
                      break;
                    def.value = expr.right;
                    remove(defs, def);
                    defs.push(def);
                    self2.body.splice(i, 1);
                    continue;
                  }
                  if (expr instanceof AST_Sequence && (assign = expr.expressions[0]) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
                    var def = vars.get(sym.name);
                    if (def.value)
                      break;
                    def.value = assign.right;
                    remove(defs, def);
                    defs.push(def);
                    self2.body[i].body = make_sequence(expr, expr.expressions.slice(1));
                    continue;
                  }
                }
                if (self2.body[i] instanceof AST_EmptyStatement) {
                  self2.body.splice(i, 1);
                  continue;
                }
                if (self2.body[i] instanceof AST_BlockStatement) {
                  self2.body.splice(i, 1, ...self2.body[i].body);
                  continue;
                }
                break;
              }
              defs = make_node(AST_Var, self2, {
                definitions: defs
              });
              hoisted.push(defs);
            }
          }
          self2.body = dirs.concat(hoisted, self2.body);
        }
        return self2;
      });
      AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
        var self2 = this;
        if (!compressor.option("hoist_props") || compressor.has_directive("use asm"))
          return self2;
        var top_retain = self2 instanceof AST_Toplevel && compressor.top_retain || return_false;
        var defs_by_id = /* @__PURE__ */ new Map();
        var hoister = new TreeTransformer(function(node, descend) {
          if (node instanceof AST_VarDef) {
            const sym = node.name;
            let def;
            let value2;
            if (sym.scope === self2 && (def = sym.definition()).escaped != 1 && !def.assignments && !def.direct_access && !def.single_use && !compressor.exposed(def) && !top_retain(def) && (value2 = sym.fixed_value()) === node.value && value2 instanceof AST_Object && !value2.properties.some((prop) => prop instanceof AST_Expansion || prop.computed_key())) {
              descend(node, this);
              const defs = /* @__PURE__ */ new Map();
              const assignments = [];
              value2.properties.forEach(({ key, value: value3 }) => {
                const scope = hoister.find_scope();
                const symbol = self2.create_symbol(sym.CTOR, {
                  source: sym,
                  scope,
                  conflict_scopes: /* @__PURE__ */ new Set([
                    scope,
                    ...sym.definition().references.map((ref) => ref.scope)
                  ]),
                  tentative_name: sym.name + "_" + key
                });
                defs.set(String(key), symbol.definition());
                assignments.push(make_node(AST_VarDef, node, {
                  name: symbol,
                  value: value3
                }));
              });
              defs_by_id.set(def.id, defs);
              return MAP.splice(assignments);
            }
          } else if (node instanceof AST_PropAccess && node.expression instanceof AST_SymbolRef) {
            const defs = defs_by_id.get(node.expression.definition().id);
            if (defs) {
              const def = defs.get(String(get_simple_key(node.property)));
              const sym = make_node(AST_SymbolRef, node, {
                name: def.name,
                scope: node.expression.scope,
                thedef: def
              });
              sym.reference({});
              return sym;
            }
          }
        });
        return self2.transform(hoister);
      });
      def_optimize(AST_SimpleStatement, function(self2, compressor) {
        if (compressor.option("side_effects")) {
          var body = self2.body;
          var node = body.drop_side_effect_free(compressor, true);
          if (!node) {
            return make_node(AST_EmptyStatement, self2);
          }
          if (node !== body) {
            return make_node(AST_SimpleStatement, self2, { body: node });
          }
        }
        return self2;
      });
      def_optimize(AST_While, function(self2, compressor) {
        return compressor.option("loops") ? make_node(AST_For, self2, self2).optimize(compressor) : self2;
      });
      def_optimize(AST_Do, function(self2, compressor) {
        if (!compressor.option("loops"))
          return self2;
        var cond = self2.condition.tail_node().evaluate(compressor);
        if (!(cond instanceof AST_Node)) {
          if (cond)
            return make_node(AST_For, self2, {
              body: make_node(AST_BlockStatement, self2.body, {
                body: [
                  self2.body,
                  make_node(AST_SimpleStatement, self2.condition, {
                    body: self2.condition
                  })
                ]
              })
            }).optimize(compressor);
          if (!has_break_or_continue(self2, compressor.parent())) {
            return make_node(AST_BlockStatement, self2.body, {
              body: [
                self2.body,
                make_node(AST_SimpleStatement, self2.condition, {
                  body: self2.condition
                })
              ]
            }).optimize(compressor);
          }
        }
        return self2;
      });
      function if_break_in_loop(self2, compressor) {
        var first = self2.body instanceof AST_BlockStatement ? self2.body.body[0] : self2.body;
        if (compressor.option("dead_code") && is_break(first)) {
          var body = [];
          if (self2.init instanceof AST_Statement) {
            body.push(self2.init);
          } else if (self2.init) {
            body.push(make_node(AST_SimpleStatement, self2.init, {
              body: self2.init
            }));
          }
          if (self2.condition) {
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
          }
          trim_unreachable_code(compressor, self2.body, body);
          return make_node(AST_BlockStatement, self2, {
            body
          });
        }
        if (first instanceof AST_If) {
          if (is_break(first.body)) {
            if (self2.condition) {
              self2.condition = make_node(AST_Binary, self2.condition, {
                left: self2.condition,
                operator: "&&",
                right: first.condition.negate(compressor)
              });
            } else {
              self2.condition = first.condition.negate(compressor);
            }
            drop_it(first.alternative);
          } else if (is_break(first.alternative)) {
            if (self2.condition) {
              self2.condition = make_node(AST_Binary, self2.condition, {
                left: self2.condition,
                operator: "&&",
                right: first.condition
              });
            } else {
              self2.condition = first.condition;
            }
            drop_it(first.body);
          }
        }
        return self2;
        function is_break(node) {
          return node instanceof AST_Break && compressor.loopcontrol_target(node) === compressor.self();
        }
        function drop_it(rest) {
          rest = as_statement_array(rest);
          if (self2.body instanceof AST_BlockStatement) {
            self2.body = self2.body.clone();
            self2.body.body = rest.concat(self2.body.body.slice(1));
            self2.body = self2.body.transform(compressor);
          } else {
            self2.body = make_node(AST_BlockStatement, self2.body, {
              body: rest
            }).transform(compressor);
          }
          self2 = if_break_in_loop(self2, compressor);
        }
      }
      def_optimize(AST_For, function(self2, compressor) {
        if (!compressor.option("loops"))
          return self2;
        if (compressor.option("side_effects") && self2.init) {
          self2.init = self2.init.drop_side_effect_free(compressor);
        }
        if (self2.condition) {
          var cond = self2.condition.evaluate(compressor);
          if (!(cond instanceof AST_Node)) {
            if (cond)
              self2.condition = null;
            else if (!compressor.option("dead_code")) {
              var orig = self2.condition;
              self2.condition = make_node_from_constant(cond, self2.condition);
              self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
            }
          }
          if (compressor.option("dead_code")) {
            if (cond instanceof AST_Node)
              cond = self2.condition.tail_node().evaluate(compressor);
            if (!cond) {
              var body = [];
              trim_unreachable_code(compressor, self2.body, body);
              if (self2.init instanceof AST_Statement) {
                body.push(self2.init);
              } else if (self2.init) {
                body.push(make_node(AST_SimpleStatement, self2.init, {
                  body: self2.init
                }));
              }
              body.push(make_node(AST_SimpleStatement, self2.condition, {
                body: self2.condition
              }));
              return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
            }
          }
        }
        return if_break_in_loop(self2, compressor);
      });
      def_optimize(AST_If, function(self2, compressor) {
        if (is_empty2(self2.alternative))
          self2.alternative = null;
        if (!compressor.option("conditionals"))
          return self2;
        var cond = self2.condition.evaluate(compressor);
        if (!compressor.option("dead_code") && !(cond instanceof AST_Node)) {
          var orig = self2.condition;
          self2.condition = make_node_from_constant(cond, orig);
          self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
        }
        if (compressor.option("dead_code")) {
          if (cond instanceof AST_Node)
            cond = self2.condition.tail_node().evaluate(compressor);
          if (!cond) {
            var body = [];
            trim_unreachable_code(compressor, self2.body, body);
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
            if (self2.alternative)
              body.push(self2.alternative);
            return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
          } else if (!(cond instanceof AST_Node)) {
            var body = [];
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
            body.push(self2.body);
            if (self2.alternative) {
              trim_unreachable_code(compressor, self2.alternative, body);
            }
            return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
          }
        }
        var negated = self2.condition.negate(compressor);
        var self_condition_length = self2.condition.size();
        var negated_length = negated.size();
        var negated_is_best = negated_length < self_condition_length;
        if (self2.alternative && negated_is_best) {
          negated_is_best = false;
          self2.condition = negated;
          var tmp = self2.body;
          self2.body = self2.alternative || make_node(AST_EmptyStatement, self2);
          self2.alternative = tmp;
        }
        if (is_empty2(self2.body) && is_empty2(self2.alternative)) {
          return make_node(AST_SimpleStatement, self2.condition, {
            body: self2.condition.clone()
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_SimpleStatement && self2.alternative instanceof AST_SimpleStatement) {
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: self2.body.body,
              alternative: self2.alternative.body
            })
          }).optimize(compressor);
        }
        if (is_empty2(self2.alternative) && self2.body instanceof AST_SimpleStatement) {
          if (self_condition_length === negated_length && !negated_is_best && self2.condition instanceof AST_Binary && self2.condition.operator == "||") {
            negated_is_best = true;
          }
          if (negated_is_best)
            return make_node(AST_SimpleStatement, self2, {
              body: make_node(AST_Binary, self2, {
                operator: "||",
                left: negated,
                right: self2.body.body
              })
            }).optimize(compressor);
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Binary, self2, {
              operator: "&&",
              left: self2.condition,
              right: self2.body.body
            })
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_EmptyStatement && self2.alternative instanceof AST_SimpleStatement) {
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Binary, self2, {
              operator: "||",
              left: self2.condition,
              right: self2.alternative.body
            })
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_Exit && self2.alternative instanceof AST_Exit && self2.body.TYPE == self2.alternative.TYPE) {
          return make_node(self2.body.CTOR, self2, {
            value: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: self2.body.value || make_node(AST_Undefined, self2.body),
              alternative: self2.alternative.value || make_node(AST_Undefined, self2.alternative)
            }).transform(compressor)
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_If && !self2.body.alternative && !self2.alternative) {
          self2 = make_node(AST_If, self2, {
            condition: make_node(AST_Binary, self2.condition, {
              operator: "&&",
              left: self2.condition,
              right: self2.body.condition
            }),
            body: self2.body.body,
            alternative: null
          });
        }
        if (aborts(self2.body)) {
          if (self2.alternative) {
            var alt = self2.alternative;
            self2.alternative = null;
            return make_node(AST_BlockStatement, self2, {
              body: [self2, alt]
            }).optimize(compressor);
          }
        }
        if (aborts(self2.alternative)) {
          var body = self2.body;
          self2.body = self2.alternative;
          self2.condition = negated_is_best ? negated : self2.condition.negate(compressor);
          self2.alternative = null;
          return make_node(AST_BlockStatement, self2, {
            body: [self2, body]
          }).optimize(compressor);
        }
        return self2;
      });
      def_optimize(AST_Switch, function(self2, compressor) {
        if (!compressor.option("switches"))
          return self2;
        var branch;
        var value2 = self2.expression.evaluate(compressor);
        if (!(value2 instanceof AST_Node)) {
          var orig = self2.expression;
          self2.expression = make_node_from_constant(value2, orig);
          self2.expression = best_of_expression(self2.expression.transform(compressor), orig);
        }
        if (!compressor.option("dead_code"))
          return self2;
        if (value2 instanceof AST_Node) {
          value2 = self2.expression.tail_node().evaluate(compressor);
        }
        var decl = [];
        var body = [];
        var default_branch;
        var exact_match;
        for (var i = 0, len = self2.body.length; i < len && !exact_match; i++) {
          branch = self2.body[i];
          if (branch instanceof AST_Default) {
            if (!default_branch) {
              default_branch = branch;
            } else {
              eliminate_branch(branch, body[body.length - 1]);
            }
          } else if (!(value2 instanceof AST_Node)) {
            var exp = branch.expression.evaluate(compressor);
            if (!(exp instanceof AST_Node) && exp !== value2) {
              eliminate_branch(branch, body[body.length - 1]);
              continue;
            }
            if (exp instanceof AST_Node && !exp.has_side_effects(compressor)) {
              exp = branch.expression.tail_node().evaluate(compressor);
            }
            if (exp === value2) {
              exact_match = branch;
              if (default_branch) {
                var default_index = body.indexOf(default_branch);
                body.splice(default_index, 1);
                eliminate_branch(default_branch, body[default_index - 1]);
                default_branch = null;
              }
            }
          }
          body.push(branch);
        }
        while (i < len)
          eliminate_branch(self2.body[i++], body[body.length - 1]);
        self2.body = body;
        let default_or_exact = default_branch || exact_match;
        default_branch = null;
        exact_match = null;
        if (body.every((branch2, i2) => (branch2 === default_or_exact || branch2.expression instanceof AST_Constant) && (branch2.body.length === 0 || aborts(branch2) || body.length - 1 === i2))) {
          for (let i2 = 0; i2 < body.length; i2++) {
            const branch2 = body[i2];
            for (let j = i2 + 1; j < body.length; j++) {
              const next = body[j];
              if (next.body.length === 0)
                continue;
              const last_branch = j === body.length - 1;
              const equivalentBranch = branches_equivalent(next, branch2, false);
              if (equivalentBranch || last_branch && branches_equivalent(next, branch2, true)) {
                if (!equivalentBranch && last_branch) {
                  next.body.push(make_node(AST_Break));
                }
                let x = j - 1;
                let fallthroughDepth = 0;
                while (x > i2) {
                  if (is_inert_body(body[x--])) {
                    fallthroughDepth++;
                  } else {
                    break;
                  }
                }
                const plucked = body.splice(j - fallthroughDepth, 1 + fallthroughDepth);
                body.splice(i2 + 1, 0, ...plucked);
                i2 += plucked.length;
              }
            }
          }
        }
        for (let i2 = 0; i2 < body.length; i2++) {
          let branch2 = body[i2];
          if (branch2.body.length === 0)
            continue;
          if (!aborts(branch2))
            continue;
          for (let j = i2 + 1; j < body.length; i2++, j++) {
            let next = body[j];
            if (next.body.length === 0)
              continue;
            if (branches_equivalent(next, branch2, false) || j === body.length - 1 && branches_equivalent(next, branch2, true)) {
              branch2.body = [];
              branch2 = next;
              continue;
            }
            break;
          }
        }
        {
          let i2 = body.length - 1;
          for (; i2 >= 0; i2--) {
            let bbody = body[i2].body;
            if (is_break(bbody[bbody.length - 1], compressor))
              bbody.pop();
            if (!is_inert_body(body[i2]))
              break;
          }
          i2++;
          if (!default_or_exact || body.indexOf(default_or_exact) >= i2) {
            for (let j = body.length - 1; j >= i2; j--) {
              let branch2 = body[j];
              if (branch2 === default_or_exact) {
                default_or_exact = null;
                body.pop();
              } else if (!branch2.expression.has_side_effects(compressor)) {
                body.pop();
              } else {
                break;
              }
            }
          }
        }
        DEFAULT:
          if (default_or_exact) {
            let default_index2 = body.indexOf(default_or_exact);
            let default_body_index = default_index2;
            for (; default_body_index < body.length - 1; default_body_index++) {
              if (!is_inert_body(body[default_body_index]))
                break;
            }
            if (default_body_index < body.length - 1) {
              break DEFAULT;
            }
            let side_effect_index = body.length - 1;
            for (; side_effect_index >= 0; side_effect_index--) {
              let branch2 = body[side_effect_index];
              if (branch2 === default_or_exact)
                continue;
              if (branch2.expression.has_side_effects(compressor))
                break;
            }
            if (default_body_index > side_effect_index) {
              let prev_body_index = default_index2 - 1;
              for (; prev_body_index >= 0; prev_body_index--) {
                if (!is_inert_body(body[prev_body_index]))
                  break;
              }
              let before = Math.max(side_effect_index, prev_body_index) + 1;
              let after = default_index2;
              if (side_effect_index > default_index2) {
                after = side_effect_index;
                body[side_effect_index].body = body[default_body_index].body;
              } else {
                default_or_exact.body = body[default_body_index].body;
              }
              body.splice(after + 1, default_body_index - after);
              body.splice(before, default_index2 - before);
            }
          }
        DEFAULT:
          if (default_or_exact) {
            let i2 = body.findIndex((branch2) => !is_inert_body(branch2));
            let caseBody;
            if (i2 === body.length - 1) {
              let branch2 = body[i2];
              if (has_nested_break(self2))
                break DEFAULT;
              caseBody = make_node(AST_BlockStatement, branch2, {
                body: branch2.body
              });
              branch2.body = [];
            } else if (i2 !== -1) {
              break DEFAULT;
            }
            let sideEffect = body.find((branch2) => branch2 !== default_or_exact && branch2.expression.has_side_effects(compressor));
            if (!sideEffect) {
              return make_node(AST_BlockStatement, self2, {
                body: decl.concat(statement(self2.expression), default_or_exact.expression ? statement(default_or_exact.expression) : [], caseBody || [])
              }).optimize(compressor);
            }
            const default_index2 = body.indexOf(default_or_exact);
            body.splice(default_index2, 1);
            default_or_exact = null;
            if (caseBody) {
              return make_node(AST_BlockStatement, self2, {
                body: decl.concat(self2, caseBody)
              }).optimize(compressor);
            }
          }
        if (body.length > 0) {
          body[0].body = decl.concat(body[0].body);
        }
        if (body.length == 0) {
          return make_node(AST_BlockStatement, self2, {
            body: decl.concat(statement(self2.expression))
          }).optimize(compressor);
        }
        if (body.length == 1 && !has_nested_break(self2)) {
          let branch2 = body[0];
          return make_node(AST_If, self2, {
            condition: make_node(AST_Binary, self2, {
              operator: "===",
              left: self2.expression,
              right: branch2.expression
            }),
            body: make_node(AST_BlockStatement, branch2, {
              body: branch2.body
            }),
            alternative: null
          }).optimize(compressor);
        }
        if (body.length === 2 && default_or_exact && !has_nested_break(self2)) {
          let branch2 = body[0] === default_or_exact ? body[1] : body[0];
          let exact_exp = default_or_exact.expression && statement(default_or_exact.expression);
          if (aborts(body[0])) {
            let first = body[0];
            if (is_break(first.body[first.body.length - 1], compressor)) {
              first.body.pop();
            }
            return make_node(AST_If, self2, {
              condition: make_node(AST_Binary, self2, {
                operator: "===",
                left: self2.expression,
                right: branch2.expression
              }),
              body: make_node(AST_BlockStatement, branch2, {
                body: branch2.body
              }),
              alternative: make_node(AST_BlockStatement, default_or_exact, {
                body: [].concat(exact_exp || [], default_or_exact.body)
              })
            }).optimize(compressor);
          }
          let operator = "===";
          let consequent = make_node(AST_BlockStatement, branch2, {
            body: branch2.body
          });
          let always = make_node(AST_BlockStatement, default_or_exact, {
            body: [].concat(exact_exp || [], default_or_exact.body)
          });
          if (body[0] === default_or_exact) {
            operator = "!==";
            let tmp = always;
            always = consequent;
            consequent = tmp;
          }
          return make_node(AST_BlockStatement, self2, {
            body: [
              make_node(AST_If, self2, {
                condition: make_node(AST_Binary, self2, {
                  operator,
                  left: self2.expression,
                  right: branch2.expression
                }),
                body: consequent,
                alternative: null
              }),
              always
            ]
          }).optimize(compressor);
        }
        return self2;
        function eliminate_branch(branch2, prev) {
          if (prev && !aborts(prev)) {
            prev.body = prev.body.concat(branch2.body);
          } else {
            trim_unreachable_code(compressor, branch2, decl);
          }
        }
        function branches_equivalent(branch2, prev, insertBreak) {
          let bbody = branch2.body;
          let pbody = prev.body;
          if (insertBreak) {
            bbody = bbody.concat(make_node(AST_Break));
          }
          if (bbody.length !== pbody.length)
            return false;
          let bblock = make_node(AST_BlockStatement, branch2, { body: bbody });
          let pblock = make_node(AST_BlockStatement, prev, { body: pbody });
          return bblock.equivalent_to(pblock);
        }
        function statement(body2) {
          return make_node(AST_SimpleStatement, body2, { body: body2 });
        }
        function has_nested_break(root) {
          let has_break = false;
          let tw = new TreeWalker((node) => {
            if (has_break)
              return true;
            if (node instanceof AST_Lambda)
              return true;
            if (node instanceof AST_SimpleStatement)
              return true;
            if (!is_break(node, tw))
              return;
            let parent = tw.parent();
            if (parent instanceof AST_SwitchBranch && parent.body[parent.body.length - 1] === node) {
              return;
            }
            has_break = true;
          });
          root.walk(tw);
          return has_break;
        }
        function is_break(node, stack) {
          return node instanceof AST_Break && stack.loopcontrol_target(node) === self2;
        }
        function is_inert_body(branch2) {
          return !aborts(branch2) && !make_node(AST_BlockStatement, branch2, {
            body: branch2.body
          }).has_side_effects(compressor);
        }
      });
      def_optimize(AST_Try, function(self2, compressor) {
        if (self2.bcatch && self2.bfinally && self2.bfinally.body.every(is_empty2))
          self2.bfinally = null;
        if (compressor.option("dead_code") && self2.body.body.every(is_empty2)) {
          var body = [];
          if (self2.bcatch) {
            trim_unreachable_code(compressor, self2.bcatch, body);
          }
          if (self2.bfinally)
            body.push(...self2.bfinally.body);
          return make_node(AST_BlockStatement, self2, {
            body
          }).optimize(compressor);
        }
        return self2;
      });
      AST_Definitions.DEFMETHOD("to_assignments", function(compressor) {
        var reduce_vars = compressor.option("reduce_vars");
        var assignments = [];
        for (const def of this.definitions) {
          if (def.value) {
            var name = make_node(AST_SymbolRef, def.name, def.name);
            assignments.push(make_node(AST_Assign, def, {
              operator: "=",
              logical: false,
              left: name,
              right: def.value
            }));
            if (reduce_vars)
              name.definition().fixed = false;
          }
          const thedef = def.name.definition();
          thedef.eliminated++;
          thedef.replaced--;
        }
        if (assignments.length == 0)
          return null;
        return make_sequence(this, assignments);
      });
      def_optimize(AST_Definitions, function(self2) {
        if (self2.definitions.length == 0) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      def_optimize(AST_VarDef, function(self2, compressor) {
        if (self2.name instanceof AST_SymbolLet && self2.value != null && is_undefined(self2.value, compressor)) {
          self2.value = null;
        }
        return self2;
      });
      def_optimize(AST_Import, function(self2) {
        return self2;
      });
      def_optimize(AST_Call, function(self2, compressor) {
        var exp = self2.expression;
        var fn = exp;
        inline_array_like_spread(self2.args);
        var simple_args = self2.args.every((arg2) => !(arg2 instanceof AST_Expansion));
        if (compressor.option("reduce_vars") && fn instanceof AST_SymbolRef) {
          fn = fn.fixed_value();
        }
        var is_func = fn instanceof AST_Lambda;
        if (is_func && fn.pinned())
          return self2;
        if (compressor.option("unused") && simple_args && is_func && !fn.uses_arguments) {
          var pos2 = 0, last = 0;
          for (var i = 0, len = self2.args.length; i < len; i++) {
            if (fn.argnames[i] instanceof AST_Expansion) {
              if (has_flag(fn.argnames[i].expression, UNUSED))
                while (i < len) {
                  var node = self2.args[i++].drop_side_effect_free(compressor);
                  if (node) {
                    self2.args[pos2++] = node;
                  }
                }
              else
                while (i < len) {
                  self2.args[pos2++] = self2.args[i++];
                }
              last = pos2;
              break;
            }
            var trim2 = i >= fn.argnames.length;
            if (trim2 || has_flag(fn.argnames[i], UNUSED)) {
              var node = self2.args[i].drop_side_effect_free(compressor);
              if (node) {
                self2.args[pos2++] = node;
              } else if (!trim2) {
                self2.args[pos2++] = make_node(AST_Number, self2.args[i], {
                  value: 0
                });
                continue;
              }
            } else {
              self2.args[pos2++] = self2.args[i];
            }
            last = pos2;
          }
          self2.args.length = last;
        }
        if (exp instanceof AST_Dot && exp.expression instanceof AST_SymbolRef && exp.expression.name === "console" && exp.expression.definition().undeclared && exp.property === "assert") {
          const condition = self2.args[0];
          if (condition) {
            const value3 = condition.evaluate(compressor);
            if (value3 === 1 || value3 === true) {
              return make_node(AST_Undefined, self2);
            }
          }
        }
        if (compressor.option("unsafe") && !exp.contains_optional()) {
          if (exp instanceof AST_Dot && exp.start.value === "Array" && exp.property === "from" && self2.args.length === 1) {
            const [argument] = self2.args;
            if (argument instanceof AST_Array) {
              return make_node(AST_Array, argument, {
                elements: argument.elements
              }).optimize(compressor);
            }
          }
          if (is_undeclared_ref(exp))
            switch (exp.name) {
              case "Array":
                if (self2.args.length != 1) {
                  return make_node(AST_Array, self2, {
                    elements: self2.args
                  }).optimize(compressor);
                } else if (self2.args[0] instanceof AST_Number && self2.args[0].value <= 11) {
                  const elements2 = [];
                  for (let i2 = 0; i2 < self2.args[0].value; i2++)
                    elements2.push(new AST_Hole());
                  return new AST_Array({ elements: elements2 });
                }
                break;
              case "Object":
                if (self2.args.length == 0) {
                  return make_node(AST_Object, self2, {
                    properties: []
                  });
                }
                break;
              case "String":
                if (self2.args.length == 0)
                  return make_node(AST_String, self2, {
                    value: ""
                  });
                if (self2.args.length <= 1)
                  return make_node(AST_Binary, self2, {
                    left: self2.args[0],
                    operator: "+",
                    right: make_node(AST_String, self2, { value: "" })
                  }).optimize(compressor);
                break;
              case "Number":
                if (self2.args.length == 0)
                  return make_node(AST_Number, self2, {
                    value: 0
                  });
                if (self2.args.length == 1 && compressor.option("unsafe_math")) {
                  return make_node(AST_UnaryPrefix, self2, {
                    expression: self2.args[0],
                    operator: "+"
                  }).optimize(compressor);
                }
                break;
              case "Symbol":
                if (self2.args.length == 1 && self2.args[0] instanceof AST_String && compressor.option("unsafe_symbols"))
                  self2.args.length = 0;
                break;
              case "Boolean":
                if (self2.args.length == 0)
                  return make_node(AST_False, self2);
                if (self2.args.length == 1)
                  return make_node(AST_UnaryPrefix, self2, {
                    expression: make_node(AST_UnaryPrefix, self2, {
                      expression: self2.args[0],
                      operator: "!"
                    }),
                    operator: "!"
                  }).optimize(compressor);
                break;
              case "RegExp":
                var params = [];
                if (self2.args.length >= 1 && self2.args.length <= 2 && self2.args.every((arg2) => {
                  var value3 = arg2.evaluate(compressor);
                  params.push(value3);
                  return arg2 !== value3;
                }) && regexp_is_safe(params[0])) {
                  let [source, flags] = params;
                  source = regexp_source_fix(new RegExp(source).source);
                  const rx = make_node(AST_RegExp, self2, {
                    value: { source, flags }
                  });
                  if (rx._eval(compressor) !== rx) {
                    return rx;
                  }
                }
                break;
            }
          else if (exp instanceof AST_Dot)
            switch (exp.property) {
              case "toString":
                if (self2.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {
                  return make_node(AST_Binary, self2, {
                    left: make_node(AST_String, self2, { value: "" }),
                    operator: "+",
                    right: exp.expression
                  }).optimize(compressor);
                }
                break;
              case "join":
                if (exp.expression instanceof AST_Array)
                  EXIT: {
                    var separator;
                    if (self2.args.length > 0) {
                      separator = self2.args[0].evaluate(compressor);
                      if (separator === self2.args[0])
                        break EXIT;
                    }
                    var elements = [];
                    var consts = [];
                    for (var i = 0, len = exp.expression.elements.length; i < len; i++) {
                      var el = exp.expression.elements[i];
                      if (el instanceof AST_Expansion)
                        break EXIT;
                      var value2 = el.evaluate(compressor);
                      if (value2 !== el) {
                        consts.push(value2);
                      } else {
                        if (consts.length > 0) {
                          elements.push(make_node(AST_String, self2, {
                            value: consts.join(separator)
                          }));
                          consts.length = 0;
                        }
                        elements.push(el);
                      }
                    }
                    if (consts.length > 0) {
                      elements.push(make_node(AST_String, self2, {
                        value: consts.join(separator)
                      }));
                    }
                    if (elements.length == 0)
                      return make_node(AST_String, self2, { value: "" });
                    if (elements.length == 1) {
                      if (elements[0].is_string(compressor)) {
                        return elements[0];
                      }
                      return make_node(AST_Binary, elements[0], {
                        operator: "+",
                        left: make_node(AST_String, self2, { value: "" }),
                        right: elements[0]
                      });
                    }
                    if (separator == "") {
                      var first;
                      if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {
                        first = elements.shift();
                      } else {
                        first = make_node(AST_String, self2, { value: "" });
                      }
                      return elements.reduce(function(prev, el2) {
                        return make_node(AST_Binary, el2, {
                          operator: "+",
                          left: prev,
                          right: el2
                        });
                      }, first).optimize(compressor);
                    }
                    var node = self2.clone();
                    node.expression = node.expression.clone();
                    node.expression.expression = node.expression.expression.clone();
                    node.expression.expression.elements = elements;
                    return best_of(compressor, self2, node);
                  }
                break;
              case "charAt":
                if (exp.expression.is_string(compressor)) {
                  var arg = self2.args[0];
                  var index = arg ? arg.evaluate(compressor) : 0;
                  if (index !== arg) {
                    return make_node(AST_Sub, exp, {
                      expression: exp.expression,
                      property: make_node_from_constant(index | 0, arg || exp)
                    }).optimize(compressor);
                  }
                }
                break;
              case "apply":
                if (self2.args.length == 2 && self2.args[1] instanceof AST_Array) {
                  var args = self2.args[1].elements.slice();
                  args.unshift(self2.args[0]);
                  return make_node(AST_Call, self2, {
                    expression: make_node(AST_Dot, exp, {
                      expression: exp.expression,
                      optional: false,
                      property: "call"
                    }),
                    args
                  }).optimize(compressor);
                }
                break;
              case "call":
                var func = exp.expression;
                if (func instanceof AST_SymbolRef) {
                  func = func.fixed_value();
                }
                if (func instanceof AST_Lambda && !func.contains_this()) {
                  return (self2.args.length ? make_sequence(this, [
                    self2.args[0],
                    make_node(AST_Call, self2, {
                      expression: exp.expression,
                      args: self2.args.slice(1)
                    })
                  ]) : make_node(AST_Call, self2, {
                    expression: exp.expression,
                    args: []
                  })).optimize(compressor);
                }
                break;
            }
        }
        if (compressor.option("unsafe_Function") && is_undeclared_ref(exp) && exp.name == "Function") {
          if (self2.args.length == 0)
            return make_empty_function(self2).optimize(compressor);
          if (self2.args.every((x) => x instanceof AST_String)) {
            try {
              var code = "n(function(" + self2.args.slice(0, -1).map(function(arg2) {
                return arg2.value;
              }).join(",") + "){" + self2.args[self2.args.length - 1].value + "})";
              var ast = parse2(code);
              var mangle = compressor.mangle_options();
              ast.figure_out_scope(mangle);
              var comp = new Compressor(compressor.options, {
                mangle_options: compressor._mangle_options
              });
              ast = ast.transform(comp);
              ast.figure_out_scope(mangle);
              ast.compute_char_frequency(mangle);
              ast.mangle_names(mangle);
              var fun;
              walk(ast, (node2) => {
                if (is_func_expr(node2)) {
                  fun = node2;
                  return walk_abort;
                }
              });
              var code = OutputStream();
              AST_BlockStatement.prototype._codegen.call(fun, fun, code);
              self2.args = [
                make_node(AST_String, self2, {
                  value: fun.argnames.map(function(arg2) {
                    return arg2.print_to_string();
                  }).join(",")
                }),
                make_node(AST_String, self2.args[self2.args.length - 1], {
                  value: code.get().replace(/^{|}$/g, "")
                })
              ];
              return self2;
            } catch (ex) {
              if (!(ex instanceof JS_Parse_Error)) {
                throw ex;
              }
            }
          }
        }
        return inline_into_call(self2, compressor);
      });
      AST_Node.DEFMETHOD("contains_optional", function() {
        if (this instanceof AST_PropAccess || this instanceof AST_Call || this instanceof AST_Chain) {
          if (this.optional) {
            return true;
          } else {
            return this.expression.contains_optional();
          }
        } else {
          return false;
        }
      });
      def_optimize(AST_New, function(self2, compressor) {
        if (compressor.option("unsafe") && is_undeclared_ref(self2.expression) && ["Object", "RegExp", "Function", "Error", "Array"].includes(self2.expression.name))
          return make_node(AST_Call, self2, self2).transform(compressor);
        return self2;
      });
      def_optimize(AST_Sequence, function(self2, compressor) {
        if (!compressor.option("side_effects"))
          return self2;
        var expressions = [];
        filter_for_side_effects();
        var end = expressions.length - 1;
        trim_right_for_undefined();
        if (end == 0) {
          self2 = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);
          if (!(self2 instanceof AST_Sequence))
            self2 = self2.optimize(compressor);
          return self2;
        }
        self2.expressions = expressions;
        return self2;
        function filter_for_side_effects() {
          var first = first_in_statement(compressor);
          var last = self2.expressions.length - 1;
          self2.expressions.forEach(function(expr, index) {
            if (index < last)
              expr = expr.drop_side_effect_free(compressor, first);
            if (expr) {
              merge_sequence(expressions, expr);
              first = false;
            }
          });
        }
        function trim_right_for_undefined() {
          while (end > 0 && is_undefined(expressions[end], compressor))
            end--;
          if (end < expressions.length - 1) {
            expressions[end] = make_node(AST_UnaryPrefix, self2, {
              operator: "void",
              expression: expressions[end]
            });
            expressions.length = end + 1;
          }
        }
      });
      AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
        if (compressor.option("sequences")) {
          if (this.expression instanceof AST_Sequence) {
            var x = this.expression.expressions.slice();
            var e = this.clone();
            e.expression = x.pop();
            x.push(e);
            return make_sequence(this, x).optimize(compressor);
          }
        }
        return this;
      });
      def_optimize(AST_UnaryPostfix, function(self2, compressor) {
        return self2.lift_sequences(compressor);
      });
      def_optimize(AST_UnaryPrefix, function(self2, compressor) {
        var e = self2.expression;
        if (self2.operator == "delete" && !(e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Chain || is_identifier_atom(e))) {
          return make_sequence(self2, [e, make_node(AST_True, self2)]).optimize(compressor);
        }
        var seq = self2.lift_sequences(compressor);
        if (seq !== self2) {
          return seq;
        }
        if (compressor.option("side_effects") && self2.operator == "void") {
          e = e.drop_side_effect_free(compressor);
          if (e) {
            self2.expression = e;
            return self2;
          } else {
            return make_node(AST_Undefined, self2).optimize(compressor);
          }
        }
        if (compressor.in_boolean_context()) {
          switch (self2.operator) {
            case "!":
              if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                return e.expression;
              }
              if (e instanceof AST_Binary) {
                self2 = best_of(compressor, self2, e.negate(compressor, first_in_statement(compressor)));
              }
              break;
            case "typeof":
              return (e instanceof AST_SymbolRef ? make_node(AST_True, self2) : make_sequence(self2, [
                e,
                make_node(AST_True, self2)
              ])).optimize(compressor);
          }
        }
        if (self2.operator == "-" && e instanceof AST_Infinity) {
          e = e.transform(compressor);
        }
        if (e instanceof AST_Binary && (self2.operator == "+" || self2.operator == "-") && (e.operator == "*" || e.operator == "/" || e.operator == "%")) {
          return make_node(AST_Binary, self2, {
            operator: e.operator,
            left: make_node(AST_UnaryPrefix, e.left, {
              operator: self2.operator,
              expression: e.left
            }),
            right: e.right
          });
        }
        if (compressor.option("evaluate")) {
          if (self2.operator === "~" && self2.expression instanceof AST_UnaryPrefix && self2.expression.operator === "~" && (compressor.in_32_bit_context(false) || self2.expression.expression.is_32_bit_integer(compressor))) {
            return self2.expression.expression;
          }
          if (self2.operator === "~" && e instanceof AST_Binary && e.operator === "^") {
            if (e.left instanceof AST_UnaryPrefix && e.left.operator === "~") {
              e.left = e.left.bitwise_negate(compressor, true);
            } else {
              e.right = e.right.bitwise_negate(compressor, true);
            }
            return e;
          }
        }
        if (self2.operator != "-" || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)) {
          var ev = self2.evaluate(compressor);
          if (ev !== self2) {
            ev = make_node_from_constant(ev, self2).optimize(compressor);
            return best_of(compressor, ev, self2);
          }
        }
        return self2;
      });
      AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
        if (compressor.option("sequences")) {
          if (this.left instanceof AST_Sequence) {
            var x = this.left.expressions.slice();
            var e = this.clone();
            e.left = x.pop();
            x.push(e);
            return make_sequence(this, x).optimize(compressor);
          }
          if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {
            var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
            var x = this.right.expressions;
            var last = x.length - 1;
            for (var i = 0; i < last; i++) {
              if (!assign && x[i].has_side_effects(compressor))
                break;
            }
            if (i == last) {
              x = x.slice();
              var e = this.clone();
              e.right = x.pop();
              x.push(e);
              return make_sequence(this, x).optimize(compressor);
            } else if (i > 0) {
              var e = this.clone();
              e.right = make_sequence(this.right, x.slice(i));
              x = x.slice(0, i);
              x.push(e);
              return make_sequence(this, x).optimize(compressor);
            }
          }
        }
        return this;
      });
      var commutativeOperators = makePredicate("== === != !== * & | ^");
      function is_object(node) {
        return node instanceof AST_Array || node instanceof AST_Lambda || node instanceof AST_Object || node instanceof AST_Class;
      }
      def_optimize(AST_Binary, function(self2, compressor) {
        function reversible() {
          return self2.left.is_constant() || self2.right.is_constant() || !self2.left.has_side_effects(compressor) && !self2.right.has_side_effects(compressor);
        }
        function reverse(op) {
          if (reversible()) {
            if (op)
              self2.operator = op;
            var tmp = self2.left;
            self2.left = self2.right;
            self2.right = tmp;
          }
        }
        if (compressor.option("lhs_constants") && commutativeOperators.has(self2.operator)) {
          if (self2.right.is_constant() && !self2.left.is_constant()) {
            if (!(self2.left instanceof AST_Binary && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
              reverse();
            }
          }
        }
        self2 = self2.lift_sequences(compressor);
        if (compressor.option("comparisons"))
          switch (self2.operator) {
            case "===":
            case "!==":
              var is_strict_comparison = true;
              if (self2.left.is_string(compressor) && self2.right.is_string(compressor) || self2.left.is_number(compressor) && self2.right.is_number(compressor) || self2.left.is_bigint(compressor) && self2.right.is_bigint(compressor) || self2.left.is_boolean() && self2.right.is_boolean() || self2.left.equivalent_to(self2.right)) {
                self2.operator = self2.operator.substr(0, 2);
              }
            case "==":
            case "!=":
              if (!is_strict_comparison && is_undefined(self2.left, compressor)) {
                self2.left = make_node(AST_Null, self2.left);
              } else if (!is_strict_comparison && is_undefined(self2.right, compressor)) {
                self2.right = make_node(AST_Null, self2.right);
              } else if (compressor.option("typeofs") && self2.left instanceof AST_String && self2.left.value == "undefined" && self2.right instanceof AST_UnaryPrefix && self2.right.operator == "typeof") {
                var expr = self2.right.expression;
                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
                  self2.right = expr;
                  self2.left = make_node(AST_Undefined, self2.left).optimize(compressor);
                  if (self2.operator.length == 2)
                    self2.operator += "=";
                }
              } else if (compressor.option("typeofs") && self2.left instanceof AST_UnaryPrefix && self2.left.operator == "typeof" && self2.right instanceof AST_String && self2.right.value == "undefined") {
                var expr = self2.left.expression;
                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
                  self2.left = expr;
                  self2.right = make_node(AST_Undefined, self2.right).optimize(compressor);
                  if (self2.operator.length == 2)
                    self2.operator += "=";
                }
              } else if (self2.left instanceof AST_SymbolRef && self2.right instanceof AST_SymbolRef && self2.left.definition() === self2.right.definition() && is_object(self2.left.fixed_value())) {
                return make_node(self2.operator[0] == "=" ? AST_True : AST_False, self2);
              } else if (self2.left.is_32_bit_integer(compressor) && self2.right.is_32_bit_integer(compressor)) {
                const not = (node) => make_node(AST_UnaryPrefix, node, {
                  operator: "!",
                  expression: node
                });
                const booleanify = (node, truthy) => {
                  if (truthy) {
                    return compressor.in_boolean_context() ? node : not(not(node));
                  } else {
                    return not(node);
                  }
                };
                if (self2.left instanceof AST_Number && self2.left.value === 0) {
                  return booleanify(self2.right, self2.operator[0] === "!");
                }
                if (self2.right instanceof AST_Number && self2.right.value === 0) {
                  return booleanify(self2.left, self2.operator[0] === "!");
                }
                let and_op, x, mask;
                if ((and_op = self2.left instanceof AST_Binary ? self2.left : self2.right instanceof AST_Binary ? self2.right : null) && (mask = and_op === self2.left ? self2.right : self2.left) && and_op.operator === "&" && mask instanceof AST_Number && mask.is_32_bit_integer(compressor) && (x = and_op.left.equivalent_to(mask) ? and_op.right : and_op.right.equivalent_to(mask) ? and_op.left : null)) {
                  let optimized = booleanify(make_node(AST_Binary, self2, {
                    operator: "&",
                    left: mask,
                    right: make_node(AST_UnaryPrefix, self2, {
                      operator: "~",
                      expression: x
                    })
                  }), self2.operator[0] === "!");
                  return best_of(compressor, optimized, self2);
                }
              }
              break;
            case "&&":
            case "||":
              var lhs = self2.left;
              if (lhs.operator == self2.operator) {
                lhs = lhs.right;
              }
              if (lhs instanceof AST_Binary && lhs.operator == (self2.operator == "&&" ? "!==" : "===") && self2.right instanceof AST_Binary && lhs.operator == self2.right.operator && (is_undefined(lhs.left, compressor) && self2.right.left instanceof AST_Null || lhs.left instanceof AST_Null && is_undefined(self2.right.left, compressor)) && !lhs.right.has_side_effects(compressor) && lhs.right.equivalent_to(self2.right.right)) {
                var combined = make_node(AST_Binary, self2, {
                  operator: lhs.operator.slice(0, -1),
                  left: make_node(AST_Null, self2),
                  right: lhs.right
                });
                if (lhs !== self2.left) {
                  combined = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: self2.left.left,
                    right: combined
                  });
                }
                return combined;
              }
              break;
          }
        if (self2.operator == "+" && compressor.in_boolean_context()) {
          var ll = self2.left.evaluate(compressor);
          var rr = self2.right.evaluate(compressor);
          if (ll && typeof ll == "string") {
            return make_sequence(self2, [
              self2.right,
              make_node(AST_True, self2)
            ]).optimize(compressor);
          }
          if (rr && typeof rr == "string") {
            return make_sequence(self2, [
              self2.left,
              make_node(AST_True, self2)
            ]).optimize(compressor);
          }
        }
        if (compressor.option("comparisons") && self2.is_boolean()) {
          if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
            var negated = make_node(AST_UnaryPrefix, self2, {
              operator: "!",
              expression: self2.negate(compressor, first_in_statement(compressor))
            });
            self2 = best_of(compressor, self2, negated);
          }
          if (compressor.option("unsafe_comps")) {
            switch (self2.operator) {
              case "<":
                reverse(">");
                break;
              case "<=":
                reverse(">=");
                break;
            }
          }
        }
        if (self2.operator == "+") {
          if (self2.right instanceof AST_String && self2.right.getValue() == "" && self2.left.is_string(compressor)) {
            return self2.left;
          }
          if (self2.left instanceof AST_String && self2.left.getValue() == "" && self2.right.is_string(compressor)) {
            return self2.right;
          }
          if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.left instanceof AST_String && self2.left.left.getValue() == "" && self2.right.is_string(compressor)) {
            self2.left = self2.left.right;
            return self2;
          }
        }
        if (compressor.option("evaluate")) {
          switch (self2.operator) {
            case "&&":
              var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
              if (!ll) {
                return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
              } else if (!(ll instanceof AST_Node)) {
                return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
              }
              var rr = self2.right.evaluate(compressor);
              if (!rr) {
                if (compressor.in_boolean_context()) {
                  return make_sequence(self2, [
                    self2.left,
                    make_node(AST_False, self2)
                  ]).optimize(compressor);
                } else {
                  set_flag(self2, FALSY);
                }
              } else if (!(rr instanceof AST_Node)) {
                var parent = compressor.parent();
                if (parent.operator == "&&" && parent.left === compressor.self() || compressor.in_boolean_context()) {
                  return self2.left.optimize(compressor);
                }
              }
              if (self2.left.operator == "||") {
                var lr = self2.left.right.evaluate(compressor);
                if (!lr)
                  return make_node(AST_Conditional, self2, {
                    condition: self2.left.left,
                    consequent: self2.right,
                    alternative: self2.left.right
                  }).optimize(compressor);
              }
              break;
            case "||":
              var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
              if (!ll) {
                return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
              } else if (!(ll instanceof AST_Node)) {
                return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
              }
              var rr = self2.right.evaluate(compressor);
              if (!rr) {
                var parent = compressor.parent();
                if (parent.operator == "||" && parent.left === compressor.self() || compressor.in_boolean_context()) {
                  return self2.left.optimize(compressor);
                }
              } else if (!(rr instanceof AST_Node)) {
                if (compressor.in_boolean_context()) {
                  return make_sequence(self2, [
                    self2.left,
                    make_node(AST_True, self2)
                  ]).optimize(compressor);
                } else {
                  set_flag(self2, TRUTHY);
                }
              }
              if (self2.left.operator == "&&") {
                var lr = self2.left.right.evaluate(compressor);
                if (lr && !(lr instanceof AST_Node))
                  return make_node(AST_Conditional, self2, {
                    condition: self2.left.left,
                    consequent: self2.left.right,
                    alternative: self2.right
                  }).optimize(compressor);
              }
              break;
            case "??":
              if (is_nullish(self2.left, compressor)) {
                return self2.right;
              }
              var ll = self2.left.evaluate(compressor);
              if (!(ll instanceof AST_Node)) {
                return ll == null ? self2.right : self2.left;
              }
              if (compressor.in_boolean_context()) {
                const rr2 = self2.right.evaluate(compressor);
                if (!(rr2 instanceof AST_Node) && !rr2) {
                  return self2.left;
                }
              }
          }
          var associative = true;
          switch (self2.operator) {
            case "+":
              if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor)) {
                var binary = make_node(AST_Binary, self2, {
                  operator: "+",
                  left: self2.left.right,
                  right: self2.right
                });
                var r = binary.optimize(compressor);
                if (binary !== r) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: "+",
                    left: self2.left.left,
                    right: r
                  });
                }
              }
              if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor) && self2.right instanceof AST_Binary && self2.right.operator == "+" && self2.right.is_string(compressor)) {
                var binary = make_node(AST_Binary, self2, {
                  operator: "+",
                  left: self2.left.right,
                  right: self2.right.left
                });
                var m = binary.optimize(compressor);
                if (binary !== m) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: "+",
                    left: make_node(AST_Binary, self2.left, {
                      operator: "+",
                      left: self2.left.left,
                      right: m
                    }),
                    right: self2.right.right
                  });
                }
              }
              if (self2.right instanceof AST_UnaryPrefix && self2.right.operator == "-" && self2.left.is_number_or_bigint(compressor)) {
                self2 = make_node(AST_Binary, self2, {
                  operator: "-",
                  left: self2.left,
                  right: self2.right.expression
                });
                break;
              }
              if (self2.left instanceof AST_UnaryPrefix && self2.left.operator == "-" && reversible() && self2.right.is_number_or_bigint(compressor)) {
                self2 = make_node(AST_Binary, self2, {
                  operator: "-",
                  left: self2.right,
                  right: self2.left.expression
                });
                break;
              }
              if (self2.left instanceof AST_TemplateString) {
                var l = self2.left;
                var r = self2.right.evaluate(compressor);
                if (r != self2.right) {
                  l.segments[l.segments.length - 1].value += String(r);
                  return l;
                }
              }
              if (self2.right instanceof AST_TemplateString) {
                var r = self2.right;
                var l = self2.left.evaluate(compressor);
                if (l != self2.left) {
                  r.segments[0].value = String(l) + r.segments[0].value;
                  return r;
                }
              }
              if (self2.left instanceof AST_TemplateString && self2.right instanceof AST_TemplateString) {
                var l = self2.left;
                var segments = l.segments;
                var r = self2.right;
                segments[segments.length - 1].value += r.segments[0].value;
                for (var i = 1; i < r.segments.length; i++) {
                  segments.push(r.segments[i]);
                }
                return l;
              }
            case "*":
              associative = compressor.option("unsafe_math");
            case "&":
            case "|":
            case "^":
              if (self2.left.is_number_or_bigint(compressor) && self2.right.is_number_or_bigint(compressor) && reversible() && !(self2.left instanceof AST_Binary && self2.left.operator != self2.operator && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
                var reversed = make_node(AST_Binary, self2, {
                  operator: self2.operator,
                  left: self2.right,
                  right: self2.left
                });
                if (self2.right instanceof AST_Constant && !(self2.left instanceof AST_Constant)) {
                  self2 = best_of(compressor, reversed, self2);
                } else {
                  self2 = best_of(compressor, self2, reversed);
                }
              }
              if (associative && self2.is_number_or_bigint(compressor)) {
                if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: make_node(AST_Binary, self2.left, {
                      operator: self2.operator,
                      left: self2.left,
                      right: self2.right.left,
                      start: self2.left.start,
                      end: self2.right.left.end
                    }),
                    right: self2.right.right
                  });
                }
                if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == self2.operator) {
                  if (self2.left.left instanceof AST_Constant) {
                    self2 = make_node(AST_Binary, self2, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left, {
                        operator: self2.operator,
                        left: self2.left.left,
                        right: self2.right,
                        start: self2.left.left.start,
                        end: self2.right.end
                      }),
                      right: self2.left.right
                    });
                  } else if (self2.left.right instanceof AST_Constant) {
                    self2 = make_node(AST_Binary, self2, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left, {
                        operator: self2.operator,
                        left: self2.left.right,
                        right: self2.right,
                        start: self2.left.right.start,
                        end: self2.right.end
                      }),
                      right: self2.left.left
                    });
                  }
                }
                if (self2.left instanceof AST_Binary && self2.left.operator == self2.operator && self2.left.right instanceof AST_Constant && self2.right instanceof AST_Binary && self2.right.operator == self2.operator && self2.right.left instanceof AST_Constant) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: make_node(AST_Binary, self2.left, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left.left, {
                        operator: self2.operator,
                        left: self2.left.right,
                        right: self2.right.left,
                        start: self2.left.right.start,
                        end: self2.right.left.end
                      }),
                      right: self2.left.left
                    }),
                    right: self2.right.right
                  });
                }
              }
          }
          if (bitwise_binop.has(self2.operator)) {
            let y, z, x_node, y_node, z_node = self2.left;
            if (self2.operator === "&" && self2.right instanceof AST_Binary && self2.right.operator === "|" && typeof (z = self2.left.evaluate(compressor)) === "number") {
              if (typeof (y = self2.right.right.evaluate(compressor)) === "number") {
                x_node = self2.right.left;
                y_node = self2.right.right;
              } else if (typeof (y = self2.right.left.evaluate(compressor)) === "number") {
                x_node = self2.right.right;
                y_node = self2.right.left;
              }
              if (x_node && y_node) {
                if ((y & z) === 0) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: z_node,
                    right: x_node
                  });
                } else {
                  const reordered_ops = make_node(AST_Binary, self2, {
                    operator: "|",
                    left: make_node(AST_Binary, self2, {
                      operator: "&",
                      left: x_node,
                      right: z_node
                    }),
                    right: make_node_from_constant(y & z, y_node)
                  });
                  self2 = best_of(compressor, self2, reordered_ops);
                }
              }
            }
            if ((self2.operator === "|" || self2.operator === "&") && self2.left.equivalent_to(self2.right) && !self2.left.has_side_effects(compressor) && compressor.in_32_bit_context(true)) {
              self2.left = make_node(AST_Number, self2, { value: 0 });
              self2.operator = "|";
            }
            if (self2.operator === "^" && self2.left instanceof AST_UnaryPrefix && self2.left.operator === "~" && self2.right instanceof AST_UnaryPrefix && self2.right.operator === "~") {
              self2 = make_node(AST_Binary, self2, {
                operator: "^",
                left: self2.left.expression,
                right: self2.right.expression
              });
            }
            if ((self2.operator === "<<" || self2.operator === ">>") && self2.right instanceof AST_Number && self2.right.value === 0) {
              self2.operator = "|";
            }
            const zero_side = self2.right instanceof AST_Number && self2.right.value === 0 ? self2.right : self2.left instanceof AST_Number && self2.left.value === 0 ? self2.left : null;
            const non_zero_side = zero_side && (zero_side === self2.right ? self2.left : self2.right);
            if (zero_side && (self2.operator === "|" || self2.operator === "^") && (non_zero_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return non_zero_side;
            }
            if (zero_side && self2.operator === "&" && !non_zero_side.has_side_effects(compressor) && non_zero_side.is_32_bit_integer(compressor)) {
              return zero_side;
            }
            const is_full_mask = (node) => node instanceof AST_Number && node.value === -1 || node instanceof AST_UnaryPrefix && node.operator === "-" && node.expression instanceof AST_Number && node.expression.value === 1;
            const full_mask = is_full_mask(self2.right) ? self2.right : is_full_mask(self2.left) ? self2.left : null;
            const other_side = full_mask === self2.right ? self2.left : self2.right;
            if (full_mask && self2.operator === "&" && (other_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return other_side;
            }
            if (full_mask && self2.operator === "^" && (other_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return other_side.bitwise_negate(compressor);
            }
          }
        }
        if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator && (lazy_op.has(self2.operator) || self2.operator == "+" && (self2.right.left.is_string(compressor) || self2.left.is_string(compressor) && self2.right.right.is_string(compressor)))) {
          self2.left = make_node(AST_Binary, self2.left, {
            operator: self2.operator,
            left: self2.left.transform(compressor),
            right: self2.right.left.transform(compressor)
          });
          self2.right = self2.right.right.transform(compressor);
          return self2.transform(compressor);
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      def_optimize(AST_SymbolExport, function(self2) {
        return self2;
      });
      def_optimize(AST_SymbolRef, function(self2, compressor) {
        if (!compressor.option("ie8") && is_undeclared_ref(self2) && !compressor.find_parent(AST_With)) {
          switch (self2.name) {
            case "undefined":
              return make_node(AST_Undefined, self2).optimize(compressor);
            case "NaN":
              return make_node(AST_NaN, self2).optimize(compressor);
            case "Infinity":
              return make_node(AST_Infinity, self2).optimize(compressor);
          }
        }
        if (compressor.option("reduce_vars") && !compressor.is_lhs()) {
          return inline_into_symbolref(self2, compressor);
        } else {
          return self2;
        }
      });
      function is_atomic(lhs, self2) {
        return lhs instanceof AST_SymbolRef || lhs.TYPE === self2.TYPE;
      }
      def_optimize(AST_Undefined, function(self2, compressor) {
        if (compressor.option("unsafe_undefined")) {
          var undef = find_variable(compressor, "undefined");
          if (undef) {
            var ref = make_node(AST_SymbolRef, self2, {
              name: "undefined",
              scope: undef.scope,
              thedef: undef
            });
            set_flag(ref, UNDEFINED);
            return ref;
          }
        }
        var lhs = compressor.is_lhs();
        if (lhs && is_atomic(lhs, self2))
          return self2;
        return make_node(AST_UnaryPrefix, self2, {
          operator: "void",
          expression: make_node(AST_Number, self2, {
            value: 0
          })
        });
      });
      def_optimize(AST_Infinity, function(self2, compressor) {
        var lhs = compressor.is_lhs();
        if (lhs && is_atomic(lhs, self2))
          return self2;
        if (compressor.option("keep_infinity") && !(lhs && !is_atomic(lhs, self2)) && !find_variable(compressor, "Infinity")) {
          return self2;
        }
        return make_node(AST_Binary, self2, {
          operator: "/",
          left: make_node(AST_Number, self2, {
            value: 1
          }),
          right: make_node(AST_Number, self2, {
            value: 0
          })
        });
      });
      def_optimize(AST_NaN, function(self2, compressor) {
        var lhs = compressor.is_lhs();
        if (lhs && !is_atomic(lhs, self2) || find_variable(compressor, "NaN")) {
          return make_node(AST_Binary, self2, {
            operator: "/",
            left: make_node(AST_Number, self2, {
              value: 0
            }),
            right: make_node(AST_Number, self2, {
              value: 0
            })
          });
        }
        return self2;
      });
      const ASSIGN_OPS = makePredicate("+ - / * % >> << >>> | ^ &");
      const ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
      def_optimize(AST_Assign, function(self2, compressor) {
        if (self2.logical) {
          return self2.lift_sequences(compressor);
        }
        var def;
        if (self2.operator === "=" && self2.left instanceof AST_SymbolRef && self2.left.name !== "arguments" && !(def = self2.left.definition()).undeclared && self2.right.equivalent_to(self2.left)) {
          return self2.right;
        }
        if (compressor.option("dead_code") && self2.left instanceof AST_SymbolRef && (def = self2.left.definition()).scope === compressor.find_parent(AST_Lambda)) {
          var level = 0, node, parent = self2;
          do {
            node = parent;
            parent = compressor.parent(level++);
            if (parent instanceof AST_Exit) {
              if (in_try(level, parent))
                break;
              if (is_reachable(def.scope, [def]))
                break;
              if (self2.operator == "=")
                return self2.right;
              def.fixed = false;
              return make_node(AST_Binary, self2, {
                operator: self2.operator.slice(0, -1),
                left: self2.left,
                right: self2.right
              }).optimize(compressor);
            }
          } while (parent instanceof AST_Binary && parent.right === node || parent instanceof AST_Sequence && parent.tail_node() === node);
        }
        self2 = self2.lift_sequences(compressor);
        if (self2.operator == "=" && self2.left instanceof AST_SymbolRef && self2.right instanceof AST_Binary) {
          if (self2.right.left instanceof AST_SymbolRef && self2.right.left.name == self2.left.name && ASSIGN_OPS.has(self2.right.operator)) {
            self2.operator = self2.right.operator + "=";
            self2.right = self2.right.right;
          } else if (self2.right.right instanceof AST_SymbolRef && self2.right.right.name == self2.left.name && ASSIGN_OPS_COMMUTATIVE.has(self2.right.operator) && !self2.right.left.has_side_effects(compressor)) {
            self2.operator = self2.right.operator + "=";
            self2.right = self2.right.left;
          }
        }
        return self2;
        function in_try(level2, node2) {
          function may_assignment_throw() {
            const right = self2.right;
            self2.right = make_node(AST_Null, right);
            const may_throw = node2.may_throw(compressor);
            self2.right = right;
            return may_throw;
          }
          var stop_at = self2.left.definition().scope.get_defun_scope();
          var parent2;
          while ((parent2 = compressor.parent(level2++)) !== stop_at) {
            if (parent2 instanceof AST_Try) {
              if (parent2.bfinally)
                return true;
              if (parent2.bcatch && may_assignment_throw())
                return true;
            }
          }
        }
      });
      def_optimize(AST_DefaultAssign, function(self2, compressor) {
        if (!compressor.option("evaluate")) {
          return self2;
        }
        var evaluateRight = self2.right.evaluate(compressor);
        let lambda, iife;
        if (evaluateRight === void 0) {
          if ((lambda = compressor.parent()) instanceof AST_Lambda ? compressor.option("keep_fargs") === false || (iife = compressor.parent(1)).TYPE === "Call" && iife.expression === lambda : true) {
            self2 = self2.left;
          }
        } else if (evaluateRight !== self2.right) {
          evaluateRight = make_node_from_constant(evaluateRight, self2.right);
          self2.right = best_of_expression(evaluateRight, self2.right);
        }
        return self2;
      });
      function is_nullish_check(check, check_subject, compressor) {
        if (check_subject.may_throw(compressor))
          return false;
        let nullish_side;
        if (check instanceof AST_Binary && check.operator === "==" && ((nullish_side = is_nullish(check.left, compressor) && check.left) || (nullish_side = is_nullish(check.right, compressor) && check.right)) && (nullish_side === check.left ? check.right : check.left).equivalent_to(check_subject)) {
          return true;
        }
        if (check instanceof AST_Binary && check.operator === "||") {
          let null_cmp;
          let undefined_cmp;
          const find_comparison = (cmp) => {
            if (!(cmp instanceof AST_Binary && (cmp.operator === "===" || cmp.operator === "=="))) {
              return false;
            }
            let found = 0;
            let defined_side;
            if (cmp.left instanceof AST_Null) {
              found++;
              null_cmp = cmp;
              defined_side = cmp.right;
            }
            if (cmp.right instanceof AST_Null) {
              found++;
              null_cmp = cmp;
              defined_side = cmp.left;
            }
            if (is_undefined(cmp.left, compressor)) {
              found++;
              undefined_cmp = cmp;
              defined_side = cmp.right;
            }
            if (is_undefined(cmp.right, compressor)) {
              found++;
              undefined_cmp = cmp;
              defined_side = cmp.left;
            }
            if (found !== 1) {
              return false;
            }
            if (!defined_side.equivalent_to(check_subject)) {
              return false;
            }
            return true;
          };
          if (!find_comparison(check.left))
            return false;
          if (!find_comparison(check.right))
            return false;
          if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {
            return true;
          }
        }
        return false;
      }
      def_optimize(AST_Conditional, function(self2, compressor) {
        if (!compressor.option("conditionals"))
          return self2;
        if (self2.condition instanceof AST_Sequence) {
          var expressions = self2.condition.expressions.slice();
          self2.condition = expressions.pop();
          expressions.push(self2);
          return make_sequence(self2, expressions);
        }
        var cond = self2.condition.evaluate(compressor);
        if (cond !== self2.condition) {
          if (cond) {
            return maintain_this_binding(compressor.parent(), compressor.self(), self2.consequent);
          } else {
            return maintain_this_binding(compressor.parent(), compressor.self(), self2.alternative);
          }
        }
        var negated = cond.negate(compressor, first_in_statement(compressor));
        if (best_of(compressor, cond, negated) === negated) {
          self2 = make_node(AST_Conditional, self2, {
            condition: negated,
            consequent: self2.alternative,
            alternative: self2.consequent
          });
        }
        var condition = self2.condition;
        var consequent = self2.consequent;
        var alternative = self2.alternative;
        if (condition instanceof AST_SymbolRef && consequent instanceof AST_SymbolRef && condition.definition() === consequent.definition()) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: condition,
            right: alternative
          });
        }
        if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator === alternative.operator && consequent.logical === alternative.logical && consequent.left.equivalent_to(alternative.left) && (!self2.condition.has_side_effects(compressor) || consequent.operator == "=" && !consequent.left.has_side_effects(compressor))) {
          return make_node(AST_Assign, self2, {
            operator: consequent.operator,
            left: consequent.left,
            logical: consequent.logical,
            right: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: consequent.right,
              alternative: alternative.right
            })
          });
        }
        var arg_index;
        if (consequent instanceof AST_Call && alternative.TYPE === consequent.TYPE && consequent.args.length > 0 && consequent.args.length == alternative.args.length && consequent.expression.equivalent_to(alternative.expression) && !self2.condition.has_side_effects(compressor) && !consequent.expression.has_side_effects(compressor) && typeof (arg_index = single_arg_diff()) == "number") {
          var node = consequent.clone();
          node.args[arg_index] = make_node(AST_Conditional, self2, {
            condition: self2.condition,
            consequent: consequent.args[arg_index],
            alternative: alternative.args[arg_index]
          });
          return node;
        }
        if (alternative instanceof AST_Conditional && consequent.equivalent_to(alternative.consequent)) {
          return make_node(AST_Conditional, self2, {
            condition: make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: alternative.condition
            }),
            consequent,
            alternative: alternative.alternative
          }).optimize(compressor);
        }
        if (compressor.option("ecma") >= 2020 && is_nullish_check(condition, alternative, compressor)) {
          return make_node(AST_Binary, self2, {
            operator: "??",
            left: alternative,
            right: consequent
          }).optimize(compressor);
        }
        if (alternative instanceof AST_Sequence && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {
          return make_sequence(self2, [
            make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: make_sequence(self2, alternative.expressions.slice(0, -1))
            }),
            consequent
          ]).optimize(compressor);
        }
        if (alternative instanceof AST_Binary && alternative.operator == "&&" && consequent.equivalent_to(alternative.right)) {
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: alternative.left
            }),
            right: consequent
          }).optimize(compressor);
        }
        if (consequent instanceof AST_Conditional && consequent.alternative.equivalent_to(alternative)) {
          return make_node(AST_Conditional, self2, {
            condition: make_node(AST_Binary, self2, {
              left: self2.condition,
              operator: "&&",
              right: consequent.condition
            }),
            consequent: consequent.consequent,
            alternative
          });
        }
        if (consequent.equivalent_to(alternative)) {
          return make_sequence(self2, [
            self2.condition,
            consequent
          ]).optimize(compressor);
        }
        if (consequent instanceof AST_Binary && consequent.operator == "||" && consequent.right.equivalent_to(alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: make_node(AST_Binary, self2, {
              operator: "&&",
              left: self2.condition,
              right: consequent.left
            }),
            right: alternative
          }).optimize(compressor);
        }
        const in_bool = compressor.in_boolean_context();
        if (is_true(self2.consequent)) {
          if (is_false(self2.alternative)) {
            return booleanize(self2.condition);
          }
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: booleanize(self2.condition),
            right: self2.alternative
          });
        }
        if (is_false(self2.consequent)) {
          if (is_true(self2.alternative)) {
            return booleanize(self2.condition.negate(compressor));
          }
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: booleanize(self2.condition.negate(compressor)),
            right: self2.alternative
          });
        }
        if (is_true(self2.alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: booleanize(self2.condition.negate(compressor)),
            right: self2.consequent
          });
        }
        if (is_false(self2.alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: booleanize(self2.condition),
            right: self2.consequent
          });
        }
        return self2;
        function booleanize(node2) {
          if (node2.is_boolean())
            return node2;
          return make_node(AST_UnaryPrefix, node2, {
            operator: "!",
            expression: node2.negate(compressor)
          });
        }
        function is_true(node2) {
          return node2 instanceof AST_True || in_bool && node2 instanceof AST_Constant && node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && !node2.expression.getValue();
        }
        function is_false(node2) {
          return node2 instanceof AST_False || in_bool && node2 instanceof AST_Constant && !node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && node2.expression.getValue();
        }
        function single_arg_diff() {
          var a = consequent.args;
          var b = alternative.args;
          for (var i = 0, len = a.length; i < len; i++) {
            if (a[i] instanceof AST_Expansion)
              return;
            if (!a[i].equivalent_to(b[i])) {
              if (b[i] instanceof AST_Expansion)
                return;
              for (var j = i + 1; j < len; j++) {
                if (a[j] instanceof AST_Expansion)
                  return;
                if (!a[j].equivalent_to(b[j]))
                  return;
              }
              return i;
            }
          }
        }
      });
      def_optimize(AST_Boolean, function(self2, compressor) {
        if (compressor.in_boolean_context())
          return make_node(AST_Number, self2, {
            value: +self2.value
          });
        var p = compressor.parent();
        if (compressor.option("booleans_as_integers")) {
          if (p instanceof AST_Binary && (p.operator == "===" || p.operator == "!==")) {
            p.operator = p.operator.replace(/=$/, "");
          }
          return make_node(AST_Number, self2, {
            value: +self2.value
          });
        }
        if (compressor.option("booleans")) {
          if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
            return make_node(AST_Number, self2, {
              value: +self2.value
            });
          }
          return make_node(AST_UnaryPrefix, self2, {
            operator: "!",
            expression: make_node(AST_Number, self2, {
              value: 1 - self2.value
            })
          });
        }
        return self2;
      });
      function safe_to_flatten(value2, compressor) {
        if (value2 instanceof AST_SymbolRef) {
          value2 = value2.fixed_value();
        }
        if (!value2)
          return false;
        if (!(value2 instanceof AST_Lambda || value2 instanceof AST_Class))
          return true;
        if (!(value2 instanceof AST_Lambda && value2.contains_this()))
          return true;
        return compressor.parent() instanceof AST_New;
      }
      AST_PropAccess.DEFMETHOD("flatten_object", function(key, compressor) {
        if (!compressor.option("properties"))
          return;
        if (key === "__proto__")
          return;
        if (this instanceof AST_DotHash)
          return;
        var arrows = compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015;
        var expr = this.expression;
        if (expr instanceof AST_Object) {
          var props = expr.properties;
          for (var i = props.length; --i >= 0; ) {
            var prop = props[i];
            if ("" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key) {
              const all_props_flattenable = props.every((p) => (p instanceof AST_ObjectKeyVal || arrows && p instanceof AST_ConciseMethod && !p.value.is_generator) && !p.computed_key());
              if (!all_props_flattenable)
                return;
              if (!safe_to_flatten(prop.value, compressor))
                return;
              return make_node(AST_Sub, this, {
                expression: make_node(AST_Array, expr, {
                  elements: props.map(function(prop2) {
                    var v = prop2.value;
                    if (v instanceof AST_Accessor) {
                      v = make_node(AST_Function, v, v);
                    }
                    var k = prop2.key;
                    if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {
                      return make_sequence(prop2, [k, v]);
                    }
                    return v;
                  })
                }),
                property: make_node(AST_Number, this, {
                  value: i
                })
              });
            }
          }
        }
      });
      def_optimize(AST_Sub, function(self2, compressor) {
        var expr = self2.expression;
        var prop = self2.property;
        if (compressor.option("properties")) {
          var key = prop.evaluate(compressor);
          if (key !== prop) {
            if (typeof key == "string") {
              if (key == "undefined") {
                key = void 0;
              } else {
                var value2 = parseFloat(key);
                if (value2.toString() == key) {
                  key = value2;
                }
              }
            }
            prop = self2.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));
            var property = "" + key;
            if (is_basic_identifier_string(property) && property.length <= prop.size() + 1) {
              return make_node(AST_Dot, self2, {
                expression: expr,
                optional: self2.optional,
                property,
                quote: prop.quote
              }).optimize(compressor);
            }
          }
        }
        var fn;
        OPT_ARGUMENTS:
          if (compressor.option("arguments") && expr instanceof AST_SymbolRef && expr.name == "arguments" && expr.definition().orig.length == 1 && (fn = expr.scope) instanceof AST_Lambda && fn.uses_arguments && !(fn instanceof AST_Arrow) && prop instanceof AST_Number) {
            var index = prop.getValue();
            var params = /* @__PURE__ */ new Set();
            var argnames = fn.argnames;
            for (var n2 = 0; n2 < argnames.length; n2++) {
              if (!(argnames[n2] instanceof AST_SymbolFunarg)) {
                break OPT_ARGUMENTS;
              }
              var param = argnames[n2].name;
              if (params.has(param)) {
                break OPT_ARGUMENTS;
              }
              params.add(param);
            }
            var argname = fn.argnames[index];
            if (argname && compressor.has_directive("use strict")) {
              var def = argname.definition();
              if (!compressor.option("reduce_vars") || def.assignments || def.orig.length > 1) {
                argname = null;
              }
            } else if (!argname && !compressor.option("keep_fargs") && index < fn.argnames.length + 5) {
              while (index >= fn.argnames.length) {
                argname = fn.create_symbol(AST_SymbolFunarg, {
                  source: fn,
                  scope: fn,
                  tentative_name: "argument_" + fn.argnames.length
                });
                fn.argnames.push(argname);
              }
            }
            if (argname) {
              var sym = make_node(AST_SymbolRef, self2, argname);
              sym.reference({});
              clear_flag(argname, UNUSED);
              return sym;
            }
          }
        if (compressor.is_lhs())
          return self2;
        if (key !== prop) {
          var sub = self2.flatten_object(property, compressor);
          if (sub) {
            expr = self2.expression = sub.expression;
            prop = self2.property = sub.property;
          }
        }
        if (compressor.option("properties") && compressor.option("side_effects") && prop instanceof AST_Number && expr instanceof AST_Array) {
          var index = prop.getValue();
          var elements = expr.elements;
          var retValue = elements[index];
          FLATTEN:
            if (safe_to_flatten(retValue, compressor)) {
              var flatten = true;
              var values = [];
              for (var i = elements.length; --i > index; ) {
                var value2 = elements[i].drop_side_effect_free(compressor);
                if (value2) {
                  values.unshift(value2);
                  if (flatten && value2.has_side_effects(compressor))
                    flatten = false;
                }
              }
              if (retValue instanceof AST_Expansion)
                break FLATTEN;
              retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;
              if (!flatten)
                values.unshift(retValue);
              while (--i >= 0) {
                var value2 = elements[i];
                if (value2 instanceof AST_Expansion)
                  break FLATTEN;
                value2 = value2.drop_side_effect_free(compressor);
                if (value2)
                  values.unshift(value2);
                else
                  index--;
              }
              if (flatten) {
                values.push(retValue);
                return make_sequence(self2, values).optimize(compressor);
              } else
                return make_node(AST_Sub, self2, {
                  expression: make_node(AST_Array, expr, {
                    elements: values
                  }),
                  property: make_node(AST_Number, prop, {
                    value: index
                  })
                });
            }
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      def_optimize(AST_Chain, function(self2, compressor) {
        if (is_nullish(self2.expression, compressor)) {
          let parent = compressor.parent();
          if (parent instanceof AST_UnaryPrefix && parent.operator === "delete") {
            return make_node_from_constant(0, self2);
          }
          return make_node(AST_Undefined, self2);
        }
        if (self2.expression instanceof AST_PropAccess || self2.expression instanceof AST_Call) {
          return self2;
        } else {
          return self2.expression;
        }
      });
      def_optimize(AST_Dot, function(self2, compressor) {
        const parent = compressor.parent();
        if (compressor.is_lhs())
          return self2;
        if (compressor.option("unsafe_proto") && self2.expression instanceof AST_Dot && self2.expression.property == "prototype") {
          var exp = self2.expression.expression;
          if (is_undeclared_ref(exp))
            switch (exp.name) {
              case "Array":
                self2.expression = make_node(AST_Array, self2.expression, {
                  elements: []
                });
                break;
              case "Function":
                self2.expression = make_empty_function(self2.expression);
                break;
              case "Number":
                self2.expression = make_node(AST_Number, self2.expression, {
                  value: 0
                });
                break;
              case "Object":
                self2.expression = make_node(AST_Object, self2.expression, {
                  properties: []
                });
                break;
              case "RegExp":
                self2.expression = make_node(AST_RegExp, self2.expression, {
                  value: { source: "t", flags: "" }
                });
                break;
              case "String":
                self2.expression = make_node(AST_String, self2.expression, {
                  value: ""
                });
                break;
            }
        }
        if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {
          const sub = self2.flatten_object(self2.property, compressor);
          if (sub)
            return sub.optimize(compressor);
        }
        if (self2.expression instanceof AST_PropAccess && parent instanceof AST_PropAccess) {
          return self2;
        }
        let ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      function literals_in_boolean_context(self2, compressor) {
        if (compressor.in_boolean_context()) {
          return best_of(compressor, self2, make_sequence(self2, [
            self2,
            make_node(AST_True, self2)
          ]).optimize(compressor));
        }
        return self2;
      }
      function inline_array_like_spread(elements) {
        for (var i = 0; i < elements.length; i++) {
          var el = elements[i];
          if (el instanceof AST_Expansion) {
            var expr = el.expression;
            if (expr instanceof AST_Array && !expr.elements.some((elm) => elm instanceof AST_Hole)) {
              elements.splice(i, 1, ...expr.elements);
              i--;
            }
          }
        }
      }
      def_optimize(AST_Array, function(self2, compressor) {
        var optimized = literals_in_boolean_context(self2, compressor);
        if (optimized !== self2) {
          return optimized;
        }
        inline_array_like_spread(self2.elements);
        return self2;
      });
      function inline_object_prop_spread(props) {
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          if (prop instanceof AST_Expansion) {
            const expr = prop.expression;
            if (expr instanceof AST_Object && expr.properties.every((prop2) => prop2 instanceof AST_ObjectKeyVal)) {
              props.splice(i, 1, ...expr.properties);
              i--;
            } else if ((expr instanceof AST_Constant || expr.is_constant()) && !(expr instanceof AST_String)) {
              props.splice(i, 1);
              i--;
            }
          }
        }
      }
      def_optimize(AST_Object, function(self2, compressor) {
        var optimized = literals_in_boolean_context(self2, compressor);
        if (optimized !== self2) {
          return optimized;
        }
        inline_object_prop_spread(self2.properties);
        return self2;
      });
      def_optimize(AST_RegExp, literals_in_boolean_context);
      def_optimize(AST_Return, function(self2, compressor) {
        if (self2.value && is_undefined(self2.value, compressor)) {
          self2.value = null;
        }
        return self2;
      });
      def_optimize(AST_Arrow, opt_AST_Lambda);
      def_optimize(AST_Function, function(self2, compressor) {
        self2 = opt_AST_Lambda(self2, compressor);
        if (compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015 && !self2.name && !self2.is_generator && !self2.uses_arguments && !self2.pinned()) {
          const uses_this = walk(self2, (node) => {
            if (node instanceof AST_This)
              return walk_abort;
          });
          if (!uses_this)
            return make_node(AST_Arrow, self2, self2).optimize(compressor);
        }
        return self2;
      });
      def_optimize(AST_Class, function(self2) {
        for (let i = 0; i < self2.properties.length; i++) {
          const prop = self2.properties[i];
          if (prop instanceof AST_ClassStaticBlock && prop.body.length == 0) {
            self2.properties.splice(i, 1);
            i--;
          }
        }
        return self2;
      });
      def_optimize(AST_ClassStaticBlock, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        return self2;
      });
      def_optimize(AST_Yield, function(self2, compressor) {
        if (self2.expression && !self2.is_star && is_undefined(self2.expression, compressor)) {
          self2.expression = null;
        }
        return self2;
      });
      def_optimize(AST_TemplateString, function(self2, compressor) {
        if (!compressor.option("evaluate") || compressor.parent() instanceof AST_PrefixedTemplateString) {
          return self2;
        }
        var segments = [];
        for (var i = 0; i < self2.segments.length; i++) {
          var segment = self2.segments[i];
          if (segment instanceof AST_Node) {
            var result = segment.evaluate(compressor);
            if (result !== segment && (result + "").length <= segment.size() + "${}".length) {
              segments[segments.length - 1].value = segments[segments.length - 1].value + result + self2.segments[++i].value;
              continue;
            }
            if (segment instanceof AST_TemplateString) {
              var inners = segment.segments;
              segments[segments.length - 1].value += inners[0].value;
              for (var j = 1; j < inners.length; j++) {
                segment = inners[j];
                segments.push(segment);
              }
              continue;
            }
          }
          segments.push(segment);
        }
        self2.segments = segments;
        if (segments.length == 1) {
          return make_node(AST_String, self2, segments[0]);
        }
        if (segments.length === 3 && segments[1] instanceof AST_Node && (segments[1].is_string(compressor) || segments[1].is_number_or_bigint(compressor) || is_nullish(segments[1], compressor) || compressor.option("unsafe"))) {
          if (segments[2].value === "") {
            return make_node(AST_Binary, self2, {
              operator: "+",
              left: make_node(AST_String, self2, {
                value: segments[0].value
              }),
              right: segments[1]
            });
          }
          if (segments[0].value === "") {
            return make_node(AST_Binary, self2, {
              operator: "+",
              left: segments[1],
              right: make_node(AST_String, self2, {
                value: segments[2].value
              })
            });
          }
        }
        return self2;
      });
      def_optimize(AST_PrefixedTemplateString, function(self2) {
        return self2;
      });
      function lift_key(self2, compressor) {
        if (!compressor.option("computed_props"))
          return self2;
        if (!(self2.key instanceof AST_Constant))
          return self2;
        if (self2.key instanceof AST_String || self2.key instanceof AST_Number) {
          const key = self2.key.value.toString();
          if (key === "__proto__")
            return self2;
          if (key == "constructor" && compressor.parent() instanceof AST_Class)
            return self2;
          if (self2 instanceof AST_ObjectKeyVal) {
            self2.quote = self2.key.quote;
            self2.key = key;
          } else if (self2 instanceof AST_ClassProperty) {
            self2.quote = self2.key.quote;
            self2.key = make_node(AST_SymbolClassProperty, self2.key, {
              name: key
            });
          } else {
            self2.quote = self2.key.quote;
            self2.key = make_node(AST_SymbolMethod, self2.key, {
              name: key
            });
          }
        }
        return self2;
      }
      def_optimize(AST_ObjectProperty, lift_key);
      def_optimize(AST_ConciseMethod, function(self2, compressor) {
        lift_key(self2, compressor);
        if (compressor.option("arrows") && compressor.parent() instanceof AST_Object && !self2.value.is_generator && !self2.value.uses_arguments && !self2.value.pinned() && self2.value.body.length == 1 && self2.value.body[0] instanceof AST_Return && self2.value.body[0].value && !self2.value.contains_this()) {
          var arrow = make_node(AST_Arrow, self2.value, self2.value);
          arrow.async = self2.value.async;
          arrow.is_generator = self2.value.is_generator;
          return make_node(AST_ObjectKeyVal, self2, {
            key: self2.key instanceof AST_SymbolMethod ? self2.key.name : self2.key,
            value: arrow,
            quote: self2.quote
          });
        }
        return self2;
      });
      def_optimize(AST_ObjectKeyVal, function(self2, compressor) {
        lift_key(self2, compressor);
        var unsafe_methods = compressor.option("unsafe_methods");
        if (unsafe_methods && compressor.option("ecma") >= 2015 && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self2.key + ""))) {
          var key = self2.key;
          var value2 = self2.value;
          var is_arrow_with_block = value2 instanceof AST_Arrow && Array.isArray(value2.body) && !value2.contains_this();
          if ((is_arrow_with_block || value2 instanceof AST_Function) && !value2.name) {
            return make_node(AST_ConciseMethod, self2, {
              key: key instanceof AST_Node ? key : make_node(AST_SymbolMethod, self2, {
                name: key
              }),
              value: make_node(AST_Accessor, value2, value2),
              quote: self2.quote
            });
          }
        }
        return self2;
      });
      def_optimize(AST_Destructuring, function(self2, compressor) {
        if (compressor.option("pure_getters") == true && compressor.option("unused") && !self2.is_array && Array.isArray(self2.names) && !is_destructuring_export_decl(compressor) && !(self2.names[self2.names.length - 1] instanceof AST_Expansion)) {
          var keep = [];
          for (var i = 0; i < self2.names.length; i++) {
            var elem = self2.names[i];
            if (!(elem instanceof AST_ObjectKeyVal && typeof elem.key == "string" && elem.value instanceof AST_SymbolDeclaration && !should_retain(compressor, elem.value.definition()))) {
              keep.push(elem);
            }
          }
          if (keep.length != self2.names.length) {
            self2.names = keep;
          }
        }
        return self2;
        function is_destructuring_export_decl(compressor2) {
          var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];
          for (var a = 0, p = 0, len = ancestors.length; a < len; p++) {
            var parent = compressor2.parent(p);
            if (!parent)
              return false;
            if (a === 0 && parent.TYPE == "Destructuring")
              continue;
            if (!ancestors[a].test(parent.TYPE)) {
              return false;
            }
            a++;
          }
          return true;
        }
        function should_retain(compressor2, def) {
          if (def.references.length)
            return true;
          if (!def.global)
            return false;
          if (compressor2.toplevel.vars) {
            if (compressor2.top_retain) {
              return compressor2.top_retain(def);
            }
            return false;
          }
          return true;
        }
      });
      function* SourceMap(options) {
        options = defaults(options, {
          file: null,
          root: null,
          orig: null,
          files: {}
        });
        var orig_map;
        var generator = new sourceMap.SourceMapGenerator({
          file: options.file,
          sourceRoot: options.root
        });
        let sourcesContent = { __proto__: null };
        let files = options.files;
        for (var name in files)
          if (HOP(files, name)) {
            sourcesContent[name] = files[name];
          }
        if (options.orig) {
          orig_map = yield new sourceMap.SourceMapConsumer(options.orig);
          if (orig_map.sourcesContent) {
            orig_map.sources.forEach(function(source, i) {
              var content = orig_map.sourcesContent[i];
              if (content) {
                sourcesContent[source] = content;
              }
            });
          }
        }
        function add(source, gen_line, gen_col, orig_line, orig_col, name2) {
          let generatedPos = { line: gen_line, column: gen_col };
          if (orig_map) {
            var info = orig_map.originalPositionFor({
              line: orig_line,
              column: orig_col
            });
            if (info.source === null) {
              generator.addMapping({
                generated: generatedPos,
                original: null,
                source: null,
                name: null
              });
              return;
            }
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name2 = info.name || name2;
          }
          generator.addMapping({
            generated: generatedPos,
            original: { line: orig_line, column: orig_col },
            source,
            name: name2
          });
          generator.setSourceContent(source, sourcesContent[source]);
        }
        function clean(map) {
          const allNull = map.sourcesContent && map.sourcesContent.every((c) => c == null);
          if (allNull)
            delete map.sourcesContent;
          if (map.file === void 0)
            delete map.file;
          if (map.sourceRoot === void 0)
            delete map.sourceRoot;
          return map;
        }
        function getDecoded() {
          if (!generator.toDecodedMap)
            return null;
          return clean(generator.toDecodedMap());
        }
        function getEncoded() {
          return clean(generator.toJSON());
        }
        function destroy() {
          if (orig_map && orig_map.destroy)
            orig_map.destroy();
        }
        return {
          add,
          getDecoded,
          getEncoded,
          destroy
        };
      }
      var domprops = [
        "$&",
        "$'",
        "$*",
        "$+",
        "$1",
        "$2",
        "$3",
        "$4",
        "$5",
        "$6",
        "$7",
        "$8",
        "$9",
        "$_",
        "$`",
        "$input",
        "-moz-animation",
        "-moz-animation-delay",
        "-moz-animation-direction",
        "-moz-animation-duration",
        "-moz-animation-fill-mode",
        "-moz-animation-iteration-count",
        "-moz-animation-name",
        "-moz-animation-play-state",
        "-moz-animation-timing-function",
        "-moz-appearance",
        "-moz-backface-visibility",
        "-moz-border-end",
        "-moz-border-end-color",
        "-moz-border-end-style",
        "-moz-border-end-width",
        "-moz-border-image",
        "-moz-border-start",
        "-moz-border-start-color",
        "-moz-border-start-style",
        "-moz-border-start-width",
        "-moz-box-align",
        "-moz-box-direction",
        "-moz-box-flex",
        "-moz-box-ordinal-group",
        "-moz-box-orient",
        "-moz-box-pack",
        "-moz-box-sizing",
        "-moz-float-edge",
        "-moz-font-feature-settings",
        "-moz-font-language-override",
        "-moz-force-broken-image-icon",
        "-moz-hyphens",
        "-moz-image-region",
        "-moz-margin-end",
        "-moz-margin-start",
        "-moz-orient",
        "-moz-osx-font-smoothing",
        "-moz-outline-radius",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-padding-end",
        "-moz-padding-start",
        "-moz-perspective",
        "-moz-perspective-origin",
        "-moz-tab-size",
        "-moz-text-size-adjust",
        "-moz-transform",
        "-moz-transform-origin",
        "-moz-transform-style",
        "-moz-transition",
        "-moz-transition-delay",
        "-moz-transition-duration",
        "-moz-transition-property",
        "-moz-transition-timing-function",
        "-moz-user-focus",
        "-moz-user-input",
        "-moz-user-modify",
        "-moz-user-select",
        "-moz-window-dragging",
        "-webkit-align-content",
        "-webkit-align-items",
        "-webkit-align-self",
        "-webkit-animation",
        "-webkit-animation-delay",
        "-webkit-animation-direction",
        "-webkit-animation-duration",
        "-webkit-animation-fill-mode",
        "-webkit-animation-iteration-count",
        "-webkit-animation-name",
        "-webkit-animation-play-state",
        "-webkit-animation-timing-function",
        "-webkit-appearance",
        "-webkit-backface-visibility",
        "-webkit-background-clip",
        "-webkit-background-origin",
        "-webkit-background-size",
        "-webkit-border-bottom-left-radius",
        "-webkit-border-bottom-right-radius",
        "-webkit-border-image",
        "-webkit-border-radius",
        "-webkit-border-top-left-radius",
        "-webkit-border-top-right-radius",
        "-webkit-box-align",
        "-webkit-box-direction",
        "-webkit-box-flex",
        "-webkit-box-ordinal-group",
        "-webkit-box-orient",
        "-webkit-box-pack",
        "-webkit-box-shadow",
        "-webkit-box-sizing",
        "-webkit-clip-path",
        "-webkit-filter",
        "-webkit-flex",
        "-webkit-flex-basis",
        "-webkit-flex-direction",
        "-webkit-flex-flow",
        "-webkit-flex-grow",
        "-webkit-flex-shrink",
        "-webkit-flex-wrap",
        "-webkit-font-feature-settings",
        "-webkit-justify-content",
        "-webkit-line-clamp",
        "-webkit-mask",
        "-webkit-mask-clip",
        "-webkit-mask-composite",
        "-webkit-mask-image",
        "-webkit-mask-origin",
        "-webkit-mask-position",
        "-webkit-mask-position-x",
        "-webkit-mask-position-y",
        "-webkit-mask-repeat",
        "-webkit-mask-size",
        "-webkit-order",
        "-webkit-perspective",
        "-webkit-perspective-origin",
        "-webkit-text-fill-color",
        "-webkit-text-security",
        "-webkit-text-size-adjust",
        "-webkit-text-stroke",
        "-webkit-text-stroke-color",
        "-webkit-text-stroke-width",
        "-webkit-transform",
        "-webkit-transform-origin",
        "-webkit-transform-style",
        "-webkit-transition",
        "-webkit-transition-delay",
        "-webkit-transition-duration",
        "-webkit-transition-property",
        "-webkit-transition-timing-function",
        "-webkit-user-select",
        "@@iterator",
        "ABORT_ERR",
        "ACTIVE",
        "ACTIVE_ATTRIBUTES",
        "ACTIVE_TEXTURE",
        "ACTIVE_UNIFORMS",
        "ACTIVE_UNIFORM_BLOCKS",
        "ADDITION",
        "ALIASED_LINE_WIDTH_RANGE",
        "ALIASED_POINT_SIZE_RANGE",
        "ALL",
        "ALLOW_KEYBOARD_INPUT",
        "ALLPASS",
        "ALPHA",
        "ALPHA_BITS",
        "ALREADY_SIGNALED",
        "ALT_MASK",
        "ALWAYS",
        "ANY_SAMPLES_PASSED",
        "ANY_SAMPLES_PASSED_CONSERVATIVE",
        "ANY_TYPE",
        "ANY_UNORDERED_NODE_TYPE",
        "ARRAY_BUFFER",
        "ARRAY_BUFFER_BINDING",
        "ATTACHED_SHADERS",
        "ATTRIBUTE_NODE",
        "AT_TARGET",
        "AbortController",
        "AbortSignal",
        "AbsoluteOrientationSensor",
        "AbstractRange",
        "Accelerometer",
        "AddSearchProvider",
        "AggregateError",
        "AnalyserNode",
        "Animation",
        "AnimationEffect",
        "AnimationEvent",
        "AnimationPlaybackEvent",
        "AnimationTimeline",
        "AnonXMLHttpRequest",
        "Any",
        "AnyPermissions",
        "ApplicationCache",
        "ApplicationCacheErrorEvent",
        "Array",
        "ArrayBuffer",
        "ArrayType",
        "Atomics",
        "Attr",
        "Audio",
        "AudioBuffer",
        "AudioBufferSourceNode",
        "AudioContext",
        "AudioData",
        "AudioDecoder",
        "AudioDestinationNode",
        "AudioEncoder",
        "AudioListener",
        "AudioNode",
        "AudioParam",
        "AudioParamMap",
        "AudioProcessingEvent",
        "AudioScheduledSourceNode",
        "AudioSinkInfo",
        "AudioStreamTrack",
        "AudioWorklet",
        "AudioWorkletNode",
        "AuthenticatorAssertionResponse",
        "AuthenticatorAttestationResponse",
        "AuthenticatorResponse",
        "AutocompleteErrorEvent",
        "BACK",
        "BAD_BOUNDARYPOINTS_ERR",
        "BAD_REQUEST",
        "BANDPASS",
        "BLEND",
        "BLEND_COLOR",
        "BLEND_DST_ALPHA",
        "BLEND_DST_RGB",
        "BLEND_EQUATION",
        "BLEND_EQUATION_ALPHA",
        "BLEND_EQUATION_RGB",
        "BLEND_SRC_ALPHA",
        "BLEND_SRC_RGB",
        "BLUE",
        "BLUE_BITS",
        "BLUR",
        "BOOL",
        "BOOLEAN_TYPE",
        "BOOL_VEC2",
        "BOOL_VEC3",
        "BOOL_VEC4",
        "BOTH",
        "BROWSER_DEFAULT_WEBGL",
        "BUBBLING_PHASE",
        "BUFFER_SIZE",
        "BUFFER_USAGE",
        "BYTE",
        "BYTES_PER_ELEMENT",
        "BackgroundFetchManager",
        "BackgroundFetchRecord",
        "BackgroundFetchRegistration",
        "BarProp",
        "BarcodeDetector",
        "BaseAudioContext",
        "BaseHref",
        "BatteryManager",
        "BeforeInstallPromptEvent",
        "BeforeLoadEvent",
        "BeforeUnloadEvent",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "BiquadFilterNode",
        "Blob",
        "BlobEvent",
        "Bluetooth",
        "BluetoothCharacteristicProperties",
        "BluetoothDevice",
        "BluetoothRemoteGATTCharacteristic",
        "BluetoothRemoteGATTDescriptor",
        "BluetoothRemoteGATTServer",
        "BluetoothRemoteGATTService",
        "BluetoothUUID",
        "Boolean",
        "BroadcastChannel",
        "BrowserCaptureMediaStreamTrack",
        "BrowserInfo",
        "ByteLengthQueuingStrategy",
        "CAPTURING_PHASE",
        "CCW",
        "CDATASection",
        "CDATA_SECTION_NODE",
        "CHANGE",
        "CHARSET_RULE",
        "CHECKING",
        "CLAMP_TO_EDGE",
        "CLICK",
        "CLOSED",
        "CLOSING",
        "COLOR",
        "COLOR_ATTACHMENT0",
        "COLOR_ATTACHMENT1",
        "COLOR_ATTACHMENT10",
        "COLOR_ATTACHMENT11",
        "COLOR_ATTACHMENT12",
        "COLOR_ATTACHMENT13",
        "COLOR_ATTACHMENT14",
        "COLOR_ATTACHMENT15",
        "COLOR_ATTACHMENT2",
        "COLOR_ATTACHMENT3",
        "COLOR_ATTACHMENT4",
        "COLOR_ATTACHMENT5",
        "COLOR_ATTACHMENT6",
        "COLOR_ATTACHMENT7",
        "COLOR_ATTACHMENT8",
        "COLOR_ATTACHMENT9",
        "COLOR_BUFFER_BIT",
        "COLOR_CLEAR_VALUE",
        "COLOR_WRITEMASK",
        "COMMENT_NODE",
        "COMPARE_REF_TO_TEXTURE",
        "COMPILE_STATUS",
        "COMPLETION_STATUS_KHR",
        "COMPRESSED_RGBA_S3TC_DXT1_EXT",
        "COMPRESSED_RGBA_S3TC_DXT3_EXT",
        "COMPRESSED_RGBA_S3TC_DXT5_EXT",
        "COMPRESSED_RGB_S3TC_DXT1_EXT",
        "COMPRESSED_TEXTURE_FORMATS",
        "COMPUTE",
        "CONDITION_SATISFIED",
        "CONFIGURATION_UNSUPPORTED",
        "CONNECTING",
        "CONSTANT_ALPHA",
        "CONSTANT_COLOR",
        "CONSTRAINT_ERR",
        "CONTEXT_LOST_WEBGL",
        "CONTROL_MASK",
        "COPY_DST",
        "COPY_READ_BUFFER",
        "COPY_READ_BUFFER_BINDING",
        "COPY_SRC",
        "COPY_WRITE_BUFFER",
        "COPY_WRITE_BUFFER_BINDING",
        "COUNTER_STYLE_RULE",
        "CSS",
        "CSS2Properties",
        "CSSAnimation",
        "CSSCharsetRule",
        "CSSConditionRule",
        "CSSContainerRule",
        "CSSCounterStyleRule",
        "CSSFontFaceRule",
        "CSSFontFeatureValuesRule",
        "CSSFontPaletteValuesRule",
        "CSSGroupingRule",
        "CSSImageValue",
        "CSSImportRule",
        "CSSKeyframeRule",
        "CSSKeyframesRule",
        "CSSKeywordValue",
        "CSSLayerBlockRule",
        "CSSLayerStatementRule",
        "CSSMarginRule",
        "CSSMathClamp",
        "CSSMathInvert",
        "CSSMathMax",
        "CSSMathMin",
        "CSSMathNegate",
        "CSSMathProduct",
        "CSSMathSum",
        "CSSMathValue",
        "CSSMatrixComponent",
        "CSSMediaRule",
        "CSSMozDocumentRule",
        "CSSNameSpaceRule",
        "CSSNamespaceRule",
        "CSSNestedDeclarations",
        "CSSNumericArray",
        "CSSNumericValue",
        "CSSPageDescriptors",
        "CSSPageRule",
        "CSSPerspective",
        "CSSPositionTryDescriptors",
        "CSSPositionTryRule",
        "CSSPositionValue",
        "CSSPrimitiveValue",
        "CSSPropertyRule",
        "CSSRotate",
        "CSSRule",
        "CSSRuleList",
        "CSSScale",
        "CSSScopeRule",
        "CSSSkew",
        "CSSSkewX",
        "CSSSkewY",
        "CSSStartingStyleRule",
        "CSSStyleDeclaration",
        "CSSStyleRule",
        "CSSStyleSheet",
        "CSSStyleValue",
        "CSSSupportsRule",
        "CSSTransformComponent",
        "CSSTransformValue",
        "CSSTransition",
        "CSSTranslate",
        "CSSUnitValue",
        "CSSUnknownRule",
        "CSSUnparsedValue",
        "CSSValue",
        "CSSValueList",
        "CSSVariableReferenceValue",
        "CSSVariablesDeclaration",
        "CSSVariablesRule",
        "CSSViewTransitionRule",
        "CSSViewportRule",
        "CSS_ATTR",
        "CSS_CM",
        "CSS_COUNTER",
        "CSS_CUSTOM",
        "CSS_DEG",
        "CSS_DIMENSION",
        "CSS_EMS",
        "CSS_EXS",
        "CSS_FILTER_BLUR",
        "CSS_FILTER_BRIGHTNESS",
        "CSS_FILTER_CONTRAST",
        "CSS_FILTER_CUSTOM",
        "CSS_FILTER_DROP_SHADOW",
        "CSS_FILTER_GRAYSCALE",
        "CSS_FILTER_HUE_ROTATE",
        "CSS_FILTER_INVERT",
        "CSS_FILTER_OPACITY",
        "CSS_FILTER_REFERENCE",
        "CSS_FILTER_SATURATE",
        "CSS_FILTER_SEPIA",
        "CSS_GRAD",
        "CSS_HZ",
        "CSS_IDENT",
        "CSS_IN",
        "CSS_INHERIT",
        "CSS_KHZ",
        "CSS_MATRIX",
        "CSS_MATRIX3D",
        "CSS_MM",
        "CSS_MS",
        "CSS_NUMBER",
        "CSS_PC",
        "CSS_PERCENTAGE",
        "CSS_PERSPECTIVE",
        "CSS_PRIMITIVE_VALUE",
        "CSS_PT",
        "CSS_PX",
        "CSS_RAD",
        "CSS_RECT",
        "CSS_RGBCOLOR",
        "CSS_ROTATE",
        "CSS_ROTATE3D",
        "CSS_ROTATEX",
        "CSS_ROTATEY",
        "CSS_ROTATEZ",
        "CSS_S",
        "CSS_SCALE",
        "CSS_SCALE3D",
        "CSS_SCALEX",
        "CSS_SCALEY",
        "CSS_SCALEZ",
        "CSS_SKEW",
        "CSS_SKEWX",
        "CSS_SKEWY",
        "CSS_STRING",
        "CSS_TRANSLATE",
        "CSS_TRANSLATE3D",
        "CSS_TRANSLATEX",
        "CSS_TRANSLATEY",
        "CSS_TRANSLATEZ",
        "CSS_UNKNOWN",
        "CSS_URI",
        "CSS_VALUE_LIST",
        "CSS_VH",
        "CSS_VMAX",
        "CSS_VMIN",
        "CSS_VW",
        "CULL_FACE",
        "CULL_FACE_MODE",
        "CURRENT_PROGRAM",
        "CURRENT_QUERY",
        "CURRENT_VERTEX_ATTRIB",
        "CUSTOM",
        "CW",
        "Cache",
        "CacheStorage",
        "CanvasCaptureMediaStream",
        "CanvasCaptureMediaStreamTrack",
        "CanvasGradient",
        "CanvasPattern",
        "CanvasRenderingContext2D",
        "CaptureController",
        "CaretPosition",
        "ChannelMergerNode",
        "ChannelSplitterNode",
        "ChapterInformation",
        "CharacterBoundsUpdateEvent",
        "CharacterData",
        "ClientRect",
        "ClientRectList",
        "Clipboard",
        "ClipboardEvent",
        "ClipboardItem",
        "CloseEvent",
        "CloseWatcher",
        "Collator",
        "ColorArray",
        "ColorValue",
        "CommandEvent",
        "Comment",
        "CompileError",
        "CompositionEvent",
        "CompressionStream",
        "Console",
        "ConstantSourceNode",
        "ContentVisibilityAutoStateChangeEvent",
        "ContextFilter",
        "ContextType",
        "Controllers",
        "ConvolverNode",
        "CookieChangeEvent",
        "CookieStore",
        "CookieStoreManager",
        "CountQueuingStrategy",
        "Counter",
        "CreateType",
        "Credential",
        "CredentialsContainer",
        "CropTarget",
        "Crypto",
        "CryptoKey",
        "CustomElementRegistry",
        "CustomEvent",
        "CustomStateSet",
        "DATABASE_ERR",
        "DATA_CLONE_ERR",
        "DATA_ERR",
        "DBLCLICK",
        "DECR",
        "DECR_WRAP",
        "DELETE_STATUS",
        "DEPTH",
        "DEPTH24_STENCIL8",
        "DEPTH32F_STENCIL8",
        "DEPTH_ATTACHMENT",
        "DEPTH_BITS",
        "DEPTH_BUFFER_BIT",
        "DEPTH_CLEAR_VALUE",
        "DEPTH_COMPONENT",
        "DEPTH_COMPONENT16",
        "DEPTH_COMPONENT24",
        "DEPTH_COMPONENT32F",
        "DEPTH_FUNC",
        "DEPTH_RANGE",
        "DEPTH_STENCIL",
        "DEPTH_STENCIL_ATTACHMENT",
        "DEPTH_TEST",
        "DEPTH_WRITEMASK",
        "DEVICE_INELIGIBLE",
        "DIRECTION_DOWN",
        "DIRECTION_LEFT",
        "DIRECTION_RIGHT",
        "DIRECTION_UP",
        "DISABLED",
        "DISPATCH_REQUEST_ERR",
        "DITHER",
        "DOCUMENT_FRAGMENT_NODE",
        "DOCUMENT_NODE",
        "DOCUMENT_POSITION_CONTAINED_BY",
        "DOCUMENT_POSITION_CONTAINS",
        "DOCUMENT_POSITION_DISCONNECTED",
        "DOCUMENT_POSITION_FOLLOWING",
        "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
        "DOCUMENT_POSITION_PRECEDING",
        "DOCUMENT_TYPE_NODE",
        "DOMCursor",
        "DOMError",
        "DOMException",
        "DOMImplementation",
        "DOMImplementationLS",
        "DOMMatrix",
        "DOMMatrixReadOnly",
        "DOMParser",
        "DOMPoint",
        "DOMPointReadOnly",
        "DOMQuad",
        "DOMRect",
        "DOMRectList",
        "DOMRectReadOnly",
        "DOMRequest",
        "DOMSTRING_SIZE_ERR",
        "DOMSettableTokenList",
        "DOMStringList",
        "DOMStringMap",
        "DOMTokenList",
        "DOMTransactionEvent",
        "DOM_DELTA_LINE",
        "DOM_DELTA_PAGE",
        "DOM_DELTA_PIXEL",
        "DOM_INPUT_METHOD_DROP",
        "DOM_INPUT_METHOD_HANDWRITING",
        "DOM_INPUT_METHOD_IME",
        "DOM_INPUT_METHOD_KEYBOARD",
        "DOM_INPUT_METHOD_MULTIMODAL",
        "DOM_INPUT_METHOD_OPTION",
        "DOM_INPUT_METHOD_PASTE",
        "DOM_INPUT_METHOD_SCRIPT",
        "DOM_INPUT_METHOD_UNKNOWN",
        "DOM_INPUT_METHOD_VOICE",
        "DOM_KEY_LOCATION_JOYSTICK",
        "DOM_KEY_LOCATION_LEFT",
        "DOM_KEY_LOCATION_MOBILE",
        "DOM_KEY_LOCATION_NUMPAD",
        "DOM_KEY_LOCATION_RIGHT",
        "DOM_KEY_LOCATION_STANDARD",
        "DOM_VK_0",
        "DOM_VK_1",
        "DOM_VK_2",
        "DOM_VK_3",
        "DOM_VK_4",
        "DOM_VK_5",
        "DOM_VK_6",
        "DOM_VK_7",
        "DOM_VK_8",
        "DOM_VK_9",
        "DOM_VK_A",
        "DOM_VK_ACCEPT",
        "DOM_VK_ADD",
        "DOM_VK_ALT",
        "DOM_VK_ALTGR",
        "DOM_VK_AMPERSAND",
        "DOM_VK_ASTERISK",
        "DOM_VK_AT",
        "DOM_VK_ATTN",
        "DOM_VK_B",
        "DOM_VK_BACKSPACE",
        "DOM_VK_BACK_QUOTE",
        "DOM_VK_BACK_SLASH",
        "DOM_VK_BACK_SPACE",
        "DOM_VK_C",
        "DOM_VK_CANCEL",
        "DOM_VK_CAPS_LOCK",
        "DOM_VK_CIRCUMFLEX",
        "DOM_VK_CLEAR",
        "DOM_VK_CLOSE_BRACKET",
        "DOM_VK_CLOSE_CURLY_BRACKET",
        "DOM_VK_CLOSE_PAREN",
        "DOM_VK_COLON",
        "DOM_VK_COMMA",
        "DOM_VK_CONTEXT_MENU",
        "DOM_VK_CONTROL",
        "DOM_VK_CONVERT",
        "DOM_VK_CRSEL",
        "DOM_VK_CTRL",
        "DOM_VK_D",
        "DOM_VK_DECIMAL",
        "DOM_VK_DELETE",
        "DOM_VK_DIVIDE",
        "DOM_VK_DOLLAR",
        "DOM_VK_DOUBLE_QUOTE",
        "DOM_VK_DOWN",
        "DOM_VK_E",
        "DOM_VK_EISU",
        "DOM_VK_END",
        "DOM_VK_ENTER",
        "DOM_VK_EQUALS",
        "DOM_VK_EREOF",
        "DOM_VK_ESCAPE",
        "DOM_VK_EXCLAMATION",
        "DOM_VK_EXECUTE",
        "DOM_VK_EXSEL",
        "DOM_VK_F",
        "DOM_VK_F1",
        "DOM_VK_F10",
        "DOM_VK_F11",
        "DOM_VK_F12",
        "DOM_VK_F13",
        "DOM_VK_F14",
        "DOM_VK_F15",
        "DOM_VK_F16",
        "DOM_VK_F17",
        "DOM_VK_F18",
        "DOM_VK_F19",
        "DOM_VK_F2",
        "DOM_VK_F20",
        "DOM_VK_F21",
        "DOM_VK_F22",
        "DOM_VK_F23",
        "DOM_VK_F24",
        "DOM_VK_F25",
        "DOM_VK_F26",
        "DOM_VK_F27",
        "DOM_VK_F28",
        "DOM_VK_F29",
        "DOM_VK_F3",
        "DOM_VK_F30",
        "DOM_VK_F31",
        "DOM_VK_F32",
        "DOM_VK_F33",
        "DOM_VK_F34",
        "DOM_VK_F35",
        "DOM_VK_F36",
        "DOM_VK_F4",
        "DOM_VK_F5",
        "DOM_VK_F6",
        "DOM_VK_F7",
        "DOM_VK_F8",
        "DOM_VK_F9",
        "DOM_VK_FINAL",
        "DOM_VK_FRONT",
        "DOM_VK_G",
        "DOM_VK_GREATER_THAN",
        "DOM_VK_H",
        "DOM_VK_HANGUL",
        "DOM_VK_HANJA",
        "DOM_VK_HASH",
        "DOM_VK_HELP",
        "DOM_VK_HK_TOGGLE",
        "DOM_VK_HOME",
        "DOM_VK_HYPHEN_MINUS",
        "DOM_VK_I",
        "DOM_VK_INSERT",
        "DOM_VK_J",
        "DOM_VK_JUNJA",
        "DOM_VK_K",
        "DOM_VK_KANA",
        "DOM_VK_KANJI",
        "DOM_VK_L",
        "DOM_VK_LEFT",
        "DOM_VK_LEFT_TAB",
        "DOM_VK_LESS_THAN",
        "DOM_VK_M",
        "DOM_VK_META",
        "DOM_VK_MODECHANGE",
        "DOM_VK_MULTIPLY",
        "DOM_VK_N",
        "DOM_VK_NONCONVERT",
        "DOM_VK_NUMPAD0",
        "DOM_VK_NUMPAD1",
        "DOM_VK_NUMPAD2",
        "DOM_VK_NUMPAD3",
        "DOM_VK_NUMPAD4",
        "DOM_VK_NUMPAD5",
        "DOM_VK_NUMPAD6",
        "DOM_VK_NUMPAD7",
        "DOM_VK_NUMPAD8",
        "DOM_VK_NUMPAD9",
        "DOM_VK_NUM_LOCK",
        "DOM_VK_O",
        "DOM_VK_OEM_1",
        "DOM_VK_OEM_102",
        "DOM_VK_OEM_2",
        "DOM_VK_OEM_3",
        "DOM_VK_OEM_4",
        "DOM_VK_OEM_5",
        "DOM_VK_OEM_6",
        "DOM_VK_OEM_7",
        "DOM_VK_OEM_8",
        "DOM_VK_OEM_COMMA",
        "DOM_VK_OEM_MINUS",
        "DOM_VK_OEM_PERIOD",
        "DOM_VK_OEM_PLUS",
        "DOM_VK_OPEN_BRACKET",
        "DOM_VK_OPEN_CURLY_BRACKET",
        "DOM_VK_OPEN_PAREN",
        "DOM_VK_P",
        "DOM_VK_PA1",
        "DOM_VK_PAGEDOWN",
        "DOM_VK_PAGEUP",
        "DOM_VK_PAGE_DOWN",
        "DOM_VK_PAGE_UP",
        "DOM_VK_PAUSE",
        "DOM_VK_PERCENT",
        "DOM_VK_PERIOD",
        "DOM_VK_PIPE",
        "DOM_VK_PLAY",
        "DOM_VK_PLUS",
        "DOM_VK_PRINT",
        "DOM_VK_PRINTSCREEN",
        "DOM_VK_PROCESSKEY",
        "DOM_VK_PROPERITES",
        "DOM_VK_Q",
        "DOM_VK_QUESTION_MARK",
        "DOM_VK_QUOTE",
        "DOM_VK_R",
        "DOM_VK_REDO",
        "DOM_VK_RETURN",
        "DOM_VK_RIGHT",
        "DOM_VK_S",
        "DOM_VK_SCROLL_LOCK",
        "DOM_VK_SELECT",
        "DOM_VK_SEMICOLON",
        "DOM_VK_SEPARATOR",
        "DOM_VK_SHIFT",
        "DOM_VK_SLASH",
        "DOM_VK_SLEEP",
        "DOM_VK_SPACE",
        "DOM_VK_SUBTRACT",
        "DOM_VK_T",
        "DOM_VK_TAB",
        "DOM_VK_TILDE",
        "DOM_VK_U",
        "DOM_VK_UNDERSCORE",
        "DOM_VK_UNDO",
        "DOM_VK_UNICODE",
        "DOM_VK_UP",
        "DOM_VK_V",
        "DOM_VK_VOLUME_DOWN",
        "DOM_VK_VOLUME_MUTE",
        "DOM_VK_VOLUME_UP",
        "DOM_VK_W",
        "DOM_VK_WIN",
        "DOM_VK_WINDOW",
        "DOM_VK_WIN_ICO_00",
        "DOM_VK_WIN_ICO_CLEAR",
        "DOM_VK_WIN_ICO_HELP",
        "DOM_VK_WIN_OEM_ATTN",
        "DOM_VK_WIN_OEM_AUTO",
        "DOM_VK_WIN_OEM_BACKTAB",
        "DOM_VK_WIN_OEM_CLEAR",
        "DOM_VK_WIN_OEM_COPY",
        "DOM_VK_WIN_OEM_CUSEL",
        "DOM_VK_WIN_OEM_ENLW",
        "DOM_VK_WIN_OEM_FINISH",
        "DOM_VK_WIN_OEM_FJ_JISHO",
        "DOM_VK_WIN_OEM_FJ_LOYA",
        "DOM_VK_WIN_OEM_FJ_MASSHOU",
        "DOM_VK_WIN_OEM_FJ_ROYA",
        "DOM_VK_WIN_OEM_FJ_TOUROKU",
        "DOM_VK_WIN_OEM_JUMP",
        "DOM_VK_WIN_OEM_PA1",
        "DOM_VK_WIN_OEM_PA2",
        "DOM_VK_WIN_OEM_PA3",
        "DOM_VK_WIN_OEM_RESET",
        "DOM_VK_WIN_OEM_WSCTRL",
        "DOM_VK_X",
        "DOM_VK_XF86XK_ADD_FAVORITE",
        "DOM_VK_XF86XK_APPLICATION_LEFT",
        "DOM_VK_XF86XK_APPLICATION_RIGHT",
        "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
        "DOM_VK_XF86XK_AUDIO_FORWARD",
        "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
        "DOM_VK_XF86XK_AUDIO_MEDIA",
        "DOM_VK_XF86XK_AUDIO_MUTE",
        "DOM_VK_XF86XK_AUDIO_NEXT",
        "DOM_VK_XF86XK_AUDIO_PAUSE",
        "DOM_VK_XF86XK_AUDIO_PLAY",
        "DOM_VK_XF86XK_AUDIO_PREV",
        "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
        "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
        "DOM_VK_XF86XK_AUDIO_RECORD",
        "DOM_VK_XF86XK_AUDIO_REPEAT",
        "DOM_VK_XF86XK_AUDIO_REWIND",
        "DOM_VK_XF86XK_AUDIO_STOP",
        "DOM_VK_XF86XK_AWAY",
        "DOM_VK_XF86XK_BACK",
        "DOM_VK_XF86XK_BACK_FORWARD",
        "DOM_VK_XF86XK_BATTERY",
        "DOM_VK_XF86XK_BLUE",
        "DOM_VK_XF86XK_BLUETOOTH",
        "DOM_VK_XF86XK_BOOK",
        "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
        "DOM_VK_XF86XK_CALCULATOR",
        "DOM_VK_XF86XK_CALENDAR",
        "DOM_VK_XF86XK_CD",
        "DOM_VK_XF86XK_CLOSE",
        "DOM_VK_XF86XK_COMMUNITY",
        "DOM_VK_XF86XK_CONTRAST_ADJUST",
        "DOM_VK_XF86XK_COPY",
        "DOM_VK_XF86XK_CUT",
        "DOM_VK_XF86XK_CYCLE_ANGLE",
        "DOM_VK_XF86XK_DISPLAY",
        "DOM_VK_XF86XK_DOCUMENTS",
        "DOM_VK_XF86XK_DOS",
        "DOM_VK_XF86XK_EJECT",
        "DOM_VK_XF86XK_EXCEL",
        "DOM_VK_XF86XK_EXPLORER",
        "DOM_VK_XF86XK_FAVORITES",
        "DOM_VK_XF86XK_FINANCE",
        "DOM_VK_XF86XK_FORWARD",
        "DOM_VK_XF86XK_FRAME_BACK",
        "DOM_VK_XF86XK_FRAME_FORWARD",
        "DOM_VK_XF86XK_GAME",
        "DOM_VK_XF86XK_GO",
        "DOM_VK_XF86XK_GREEN",
        "DOM_VK_XF86XK_HIBERNATE",
        "DOM_VK_XF86XK_HISTORY",
        "DOM_VK_XF86XK_HOME_PAGE",
        "DOM_VK_XF86XK_HOT_LINKS",
        "DOM_VK_XF86XK_I_TOUCH",
        "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
        "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
        "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
        "DOM_VK_XF86XK_LAUNCH0",
        "DOM_VK_XF86XK_LAUNCH1",
        "DOM_VK_XF86XK_LAUNCH2",
        "DOM_VK_XF86XK_LAUNCH3",
        "DOM_VK_XF86XK_LAUNCH4",
        "DOM_VK_XF86XK_LAUNCH5",
        "DOM_VK_XF86XK_LAUNCH6",
        "DOM_VK_XF86XK_LAUNCH7",
        "DOM_VK_XF86XK_LAUNCH8",
        "DOM_VK_XF86XK_LAUNCH9",
        "DOM_VK_XF86XK_LAUNCH_A",
        "DOM_VK_XF86XK_LAUNCH_B",
        "DOM_VK_XF86XK_LAUNCH_C",
        "DOM_VK_XF86XK_LAUNCH_D",
        "DOM_VK_XF86XK_LAUNCH_E",
        "DOM_VK_XF86XK_LAUNCH_F",
        "DOM_VK_XF86XK_LIGHT_BULB",
        "DOM_VK_XF86XK_LOG_OFF",
        "DOM_VK_XF86XK_MAIL",
        "DOM_VK_XF86XK_MAIL_FORWARD",
        "DOM_VK_XF86XK_MARKET",
        "DOM_VK_XF86XK_MEETING",
        "DOM_VK_XF86XK_MEMO",
        "DOM_VK_XF86XK_MENU_KB",
        "DOM_VK_XF86XK_MENU_PB",
        "DOM_VK_XF86XK_MESSENGER",
        "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
        "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
        "DOM_VK_XF86XK_MUSIC",
        "DOM_VK_XF86XK_MY_COMPUTER",
        "DOM_VK_XF86XK_MY_SITES",
        "DOM_VK_XF86XK_NEW",
        "DOM_VK_XF86XK_NEWS",
        "DOM_VK_XF86XK_OFFICE_HOME",
        "DOM_VK_XF86XK_OPEN",
        "DOM_VK_XF86XK_OPEN_URL",
        "DOM_VK_XF86XK_OPTION",
        "DOM_VK_XF86XK_PASTE",
        "DOM_VK_XF86XK_PHONE",
        "DOM_VK_XF86XK_PICTURES",
        "DOM_VK_XF86XK_POWER_DOWN",
        "DOM_VK_XF86XK_POWER_OFF",
        "DOM_VK_XF86XK_RED",
        "DOM_VK_XF86XK_REFRESH",
        "DOM_VK_XF86XK_RELOAD",
        "DOM_VK_XF86XK_REPLY",
        "DOM_VK_XF86XK_ROCKER_DOWN",
        "DOM_VK_XF86XK_ROCKER_ENTER",
        "DOM_VK_XF86XK_ROCKER_UP",
        "DOM_VK_XF86XK_ROTATE_WINDOWS",
        "DOM_VK_XF86XK_ROTATION_KB",
        "DOM_VK_XF86XK_ROTATION_PB",
        "DOM_VK_XF86XK_SAVE",
        "DOM_VK_XF86XK_SCREEN_SAVER",
        "DOM_VK_XF86XK_SCROLL_CLICK",
        "DOM_VK_XF86XK_SCROLL_DOWN",
        "DOM_VK_XF86XK_SCROLL_UP",
        "DOM_VK_XF86XK_SEARCH",
        "DOM_VK_XF86XK_SEND",
        "DOM_VK_XF86XK_SHOP",
        "DOM_VK_XF86XK_SPELL",
        "DOM_VK_XF86XK_SPLIT_SCREEN",
        "DOM_VK_XF86XK_STANDBY",
        "DOM_VK_XF86XK_START",
        "DOM_VK_XF86XK_STOP",
        "DOM_VK_XF86XK_SUBTITLE",
        "DOM_VK_XF86XK_SUPPORT",
        "DOM_VK_XF86XK_SUSPEND",
        "DOM_VK_XF86XK_TASK_PANE",
        "DOM_VK_XF86XK_TERMINAL",
        "DOM_VK_XF86XK_TIME",
        "DOM_VK_XF86XK_TOOLS",
        "DOM_VK_XF86XK_TOP_MENU",
        "DOM_VK_XF86XK_TO_DO_LIST",
        "DOM_VK_XF86XK_TRAVEL",
        "DOM_VK_XF86XK_USER1KB",
        "DOM_VK_XF86XK_USER2KB",
        "DOM_VK_XF86XK_USER_PB",
        "DOM_VK_XF86XK_UWB",
        "DOM_VK_XF86XK_VENDOR_HOME",
        "DOM_VK_XF86XK_VIDEO",
        "DOM_VK_XF86XK_VIEW",
        "DOM_VK_XF86XK_WAKE_UP",
        "DOM_VK_XF86XK_WEB_CAM",
        "DOM_VK_XF86XK_WHEEL_BUTTON",
        "DOM_VK_XF86XK_WLAN",
        "DOM_VK_XF86XK_WORD",
        "DOM_VK_XF86XK_WWW",
        "DOM_VK_XF86XK_XFER",
        "DOM_VK_XF86XK_YELLOW",
        "DOM_VK_XF86XK_ZOOM_IN",
        "DOM_VK_XF86XK_ZOOM_OUT",
        "DOM_VK_Y",
        "DOM_VK_Z",
        "DOM_VK_ZOOM",
        "DONE",
        "DONT_CARE",
        "DOWNLOADING",
        "DRAGDROP",
        "DRAW_BUFFER0",
        "DRAW_BUFFER1",
        "DRAW_BUFFER10",
        "DRAW_BUFFER11",
        "DRAW_BUFFER12",
        "DRAW_BUFFER13",
        "DRAW_BUFFER14",
        "DRAW_BUFFER15",
        "DRAW_BUFFER2",
        "DRAW_BUFFER3",
        "DRAW_BUFFER4",
        "DRAW_BUFFER5",
        "DRAW_BUFFER6",
        "DRAW_BUFFER7",
        "DRAW_BUFFER8",
        "DRAW_BUFFER9",
        "DRAW_FRAMEBUFFER",
        "DRAW_FRAMEBUFFER_BINDING",
        "DST_ALPHA",
        "DST_COLOR",
        "DYNAMIC_COPY",
        "DYNAMIC_DRAW",
        "DYNAMIC_READ",
        "DataChannel",
        "DataTransfer",
        "DataTransferItem",
        "DataTransferItemList",
        "DataView",
        "Date",
        "DateTimeFormat",
        "DecompressionStream",
        "DelayNode",
        "DelegatedInkTrailPresenter",
        "DeprecationReportBody",
        "DesktopNotification",
        "DesktopNotificationCenter",
        "Details",
        "DeviceLightEvent",
        "DeviceMotionEvent",
        "DeviceMotionEventAcceleration",
        "DeviceMotionEventRotationRate",
        "DeviceOrientationEvent",
        "DeviceProximityEvent",
        "DeviceStorage",
        "DeviceStorageChangeEvent",
        "Directory",
        "DisplayNames",
        "Document",
        "DocumentFragment",
        "DocumentPictureInPicture",
        "DocumentPictureInPictureEvent",
        "DocumentTimeline",
        "DocumentType",
        "DragEvent",
        "DurationFormat",
        "DynamicsCompressorNode",
        "E",
        "ELEMENT_ARRAY_BUFFER",
        "ELEMENT_ARRAY_BUFFER_BINDING",
        "ELEMENT_NODE",
        "EMPTY",
        "ENCODING_ERR",
        "ENDED",
        "END_TO_END",
        "END_TO_START",
        "ENTITY_NODE",
        "ENTITY_REFERENCE_NODE",
        "EPSILON",
        "EQUAL",
        "EQUALPOWER",
        "ERROR",
        "EXPONENTIAL_DISTANCE",
        "EditContext",
        "Element",
        "ElementInternals",
        "ElementQuery",
        "EncodedAudioChunk",
        "EncodedVideoChunk",
        "EnterPictureInPictureEvent",
        "Entity",
        "EntityReference",
        "Error",
        "ErrorEvent",
        "EvalError",
        "Event",
        "EventCounts",
        "EventException",
        "EventSource",
        "EventTarget",
        "Exception",
        "ExtensionContext",
        "ExtensionDisabledReason",
        "ExtensionInfo",
        "ExtensionInstallType",
        "ExtensionType",
        "External",
        "EyeDropper",
        "FASTEST",
        "FIDOSDK",
        "FILTER_ACCEPT",
        "FILTER_INTERRUPT",
        "FILTER_REJECT",
        "FILTER_SKIP",
        "FINISHED_STATE",
        "FIRST_ORDERED_NODE_TYPE",
        "FLOAT",
        "FLOAT_32_UNSIGNED_INT_24_8_REV",
        "FLOAT_MAT2",
        "FLOAT_MAT2x3",
        "FLOAT_MAT2x4",
        "FLOAT_MAT3",
        "FLOAT_MAT3x2",
        "FLOAT_MAT3x4",
        "FLOAT_MAT4",
        "FLOAT_MAT4x2",
        "FLOAT_MAT4x3",
        "FLOAT_VEC2",
        "FLOAT_VEC3",
        "FLOAT_VEC4",
        "FOCUS",
        "FONT_FACE_RULE",
        "FONT_FEATURE_VALUES_RULE",
        "FRAGMENT",
        "FRAGMENT_SHADER",
        "FRAGMENT_SHADER_DERIVATIVE_HINT",
        "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
        "FRAMEBUFFER",
        "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
        "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
        "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
        "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
        "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
        "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
        "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
        "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
        "FRAMEBUFFER_BINDING",
        "FRAMEBUFFER_COMPLETE",
        "FRAMEBUFFER_DEFAULT",
        "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
        "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
        "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
        "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
        "FRAMEBUFFER_UNSUPPORTED",
        "FRONT",
        "FRONT_AND_BACK",
        "FRONT_FACE",
        "FUNC_ADD",
        "FUNC_REVERSE_SUBTRACT",
        "FUNC_SUBTRACT",
        "FeaturePolicy",
        "FeaturePolicyViolationReportBody",
        "FederatedCredential",
        "Feed",
        "FeedEntry",
        "Fence",
        "FencedFrameConfig",
        "File",
        "FileError",
        "FileList",
        "FileReader",
        "FileSystem",
        "FileSystemDirectoryEntry",
        "FileSystemDirectoryHandle",
        "FileSystemDirectoryReader",
        "FileSystemEntry",
        "FileSystemFileEntry",
        "FileSystemFileHandle",
        "FileSystemHandle",
        "FileSystemWritableFileStream",
        "FinalizationRegistry",
        "FindInPage",
        "Float16Array",
        "Float32Array",
        "Float64Array",
        "FocusEvent",
        "FontData",
        "FontFace",
        "FontFaceSet",
        "FontFaceSetLoadEvent",
        "FormData",
        "FormDataEvent",
        "FragmentDirective",
        "Function",
        "GENERATE_MIPMAP_HINT",
        "GEQUAL",
        "GPU",
        "GPUAdapter",
        "GPUAdapterInfo",
        "GPUBindGroup",
        "GPUBindGroupLayout",
        "GPUBuffer",
        "GPUBufferUsage",
        "GPUCanvasContext",
        "GPUColorWrite",
        "GPUCommandBuffer",
        "GPUCommandEncoder",
        "GPUCompilationInfo",
        "GPUCompilationMessage",
        "GPUComputePassEncoder",
        "GPUComputePipeline",
        "GPUDevice",
        "GPUDeviceLostInfo",
        "GPUError",
        "GPUExternalTexture",
        "GPUInternalError",
        "GPUMapMode",
        "GPUOutOfMemoryError",
        "GPUPipelineError",
        "GPUPipelineLayout",
        "GPUQuerySet",
        "GPUQueue",
        "GPURenderBundle",
        "GPURenderBundleEncoder",
        "GPURenderPassEncoder",
        "GPURenderPipeline",
        "GPUSampler",
        "GPUShaderModule",
        "GPUShaderStage",
        "GPUSupportedFeatures",
        "GPUSupportedLimits",
        "GPUTexture",
        "GPUTextureUsage",
        "GPUTextureView",
        "GPUUncapturedErrorEvent",
        "GPUValidationError",
        "GREATER",
        "GREEN",
        "GREEN_BITS",
        "GainNode",
        "Gamepad",
        "GamepadAxisMoveEvent",
        "GamepadButton",
        "GamepadButtonEvent",
        "GamepadEvent",
        "GamepadHapticActuator",
        "GamepadPose",
        "Geolocation",
        "GeolocationCoordinates",
        "GeolocationPosition",
        "GeolocationPositionError",
        "GestureEvent",
        "GetInfo",
        "Global",
        "GravitySensor",
        "Gyroscope",
        "HALF_FLOAT",
        "HAVE_CURRENT_DATA",
        "HAVE_ENOUGH_DATA",
        "HAVE_FUTURE_DATA",
        "HAVE_METADATA",
        "HAVE_NOTHING",
        "HEADERS_RECEIVED",
        "HID",
        "HIDConnectionEvent",
        "HIDDEN",
        "HIDDevice",
        "HIDInputReportEvent",
        "HIERARCHY_REQUEST_ERR",
        "HIGHPASS",
        "HIGHSHELF",
        "HIGH_FLOAT",
        "HIGH_INT",
        "HORIZONTAL",
        "HORIZONTAL_AXIS",
        "HRTF",
        "HTMLAllCollection",
        "HTMLAnchorElement",
        "HTMLAppletElement",
        "HTMLAreaElement",
        "HTMLAudioElement",
        "HTMLBRElement",
        "HTMLBaseElement",
        "HTMLBaseFontElement",
        "HTMLBlockquoteElement",
        "HTMLBodyElement",
        "HTMLButtonElement",
        "HTMLCanvasElement",
        "HTMLCollection",
        "HTMLCommandElement",
        "HTMLContentElement",
        "HTMLDListElement",
        "HTMLDataElement",
        "HTMLDataListElement",
        "HTMLDetailsElement",
        "HTMLDialogElement",
        "HTMLDirectoryElement",
        "HTMLDivElement",
        "HTMLDocument",
        "HTMLElement",
        "HTMLEmbedElement",
        "HTMLFencedFrameElement",
        "HTMLFieldSetElement",
        "HTMLFontElement",
        "HTMLFormControlsCollection",
        "HTMLFormElement",
        "HTMLFrameElement",
        "HTMLFrameSetElement",
        "HTMLHRElement",
        "HTMLHeadElement",
        "HTMLHeadingElement",
        "HTMLHtmlElement",
        "HTMLIFrameElement",
        "HTMLImageElement",
        "HTMLInputElement",
        "HTMLIsIndexElement",
        "HTMLKeygenElement",
        "HTMLLIElement",
        "HTMLLabelElement",
        "HTMLLegendElement",
        "HTMLLinkElement",
        "HTMLMapElement",
        "HTMLMarqueeElement",
        "HTMLMediaElement",
        "HTMLMenuElement",
        "HTMLMenuItemElement",
        "HTMLMetaElement",
        "HTMLMeterElement",
        "HTMLModElement",
        "HTMLOListElement",
        "HTMLObjectElement",
        "HTMLOptGroupElement",
        "HTMLOptionElement",
        "HTMLOptionsCollection",
        "HTMLOutputElement",
        "HTMLParagraphElement",
        "HTMLParamElement",
        "HTMLPictureElement",
        "HTMLPreElement",
        "HTMLProgressElement",
        "HTMLPropertiesCollection",
        "HTMLQuoteElement",
        "HTMLScriptElement",
        "HTMLSelectElement",
        "HTMLShadowElement",
        "HTMLSlotElement",
        "HTMLSourceElement",
        "HTMLSpanElement",
        "HTMLStyleElement",
        "HTMLTableCaptionElement",
        "HTMLTableCellElement",
        "HTMLTableColElement",
        "HTMLTableElement",
        "HTMLTableRowElement",
        "HTMLTableSectionElement",
        "HTMLTemplateElement",
        "HTMLTextAreaElement",
        "HTMLTimeElement",
        "HTMLTitleElement",
        "HTMLTrackElement",
        "HTMLUListElement",
        "HTMLUnknownElement",
        "HTMLVideoElement",
        "HashChangeEvent",
        "Headers",
        "Highlight",
        "HighlightRegistry",
        "History",
        "Hz",
        "ICE_CHECKING",
        "ICE_CLOSED",
        "ICE_COMPLETED",
        "ICE_CONNECTED",
        "ICE_FAILED",
        "ICE_GATHERING",
        "ICE_WAITING",
        "IDBCursor",
        "IDBCursorWithValue",
        "IDBDatabase",
        "IDBDatabaseException",
        "IDBFactory",
        "IDBFileHandle",
        "IDBFileRequest",
        "IDBIndex",
        "IDBKeyRange",
        "IDBMutableFile",
        "IDBObjectStore",
        "IDBOpenDBRequest",
        "IDBRequest",
        "IDBTransaction",
        "IDBVersionChangeEvent",
        "IDLE",
        "IIRFilterNode",
        "IMPLEMENTATION_COLOR_READ_FORMAT",
        "IMPLEMENTATION_COLOR_READ_TYPE",
        "IMPORT_RULE",
        "INCR",
        "INCR_WRAP",
        "INDEX",
        "INDEX_SIZE_ERR",
        "INDIRECT",
        "INT",
        "INTERLEAVED_ATTRIBS",
        "INT_2_10_10_10_REV",
        "INT_SAMPLER_2D",
        "INT_SAMPLER_2D_ARRAY",
        "INT_SAMPLER_3D",
        "INT_SAMPLER_CUBE",
        "INT_VEC2",
        "INT_VEC3",
        "INT_VEC4",
        "INUSE_ATTRIBUTE_ERR",
        "INVALID_ACCESS_ERR",
        "INVALID_CHARACTER_ERR",
        "INVALID_ENUM",
        "INVALID_EXPRESSION_ERR",
        "INVALID_FRAMEBUFFER_OPERATION",
        "INVALID_INDEX",
        "INVALID_MODIFICATION_ERR",
        "INVALID_NODE_TYPE_ERR",
        "INVALID_OPERATION",
        "INVALID_STATE_ERR",
        "INVALID_VALUE",
        "INVERSE_DISTANCE",
        "INVERT",
        "IceCandidate",
        "IconInfo",
        "IdentityCredential",
        "IdentityCredentialError",
        "IdentityProvider",
        "IdleDeadline",
        "IdleDetector",
        "Image",
        "ImageBitmap",
        "ImageBitmapRenderingContext",
        "ImageCapture",
        "ImageData",
        "ImageDataType",
        "ImageDecoder",
        "ImageTrack",
        "ImageTrackList",
        "Infinity",
        "Ink",
        "InputDeviceCapabilities",
        "InputDeviceInfo",
        "InputEvent",
        "InputMethodContext",
        "InstallTrigger",
        "InstallTriggerImpl",
        "Instance",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Intent",
        "InternalError",
        "IntersectionObserver",
        "IntersectionObserverEntry",
        "Intl",
        "IsSearchProviderInstalled",
        "Iterator",
        "JSON",
        "JSTag",
        "KEEP",
        "KEYDOWN",
        "KEYFRAMES_RULE",
        "KEYFRAME_RULE",
        "KEYPRESS",
        "KEYUP",
        "KeyEvent",
        "Keyboard",
        "KeyboardEvent",
        "KeyboardLayoutMap",
        "KeyframeEffect",
        "LENGTHADJUST_SPACING",
        "LENGTHADJUST_SPACINGANDGLYPHS",
        "LENGTHADJUST_UNKNOWN",
        "LEQUAL",
        "LESS",
        "LINEAR",
        "LINEAR_DISTANCE",
        "LINEAR_MIPMAP_LINEAR",
        "LINEAR_MIPMAP_NEAREST",
        "LINES",
        "LINE_LOOP",
        "LINE_STRIP",
        "LINE_WIDTH",
        "LINK_STATUS",
        "LIVE",
        "LN10",
        "LN2",
        "LOADED",
        "LOADING",
        "LOG10E",
        "LOG2E",
        "LOWPASS",
        "LOWSHELF",
        "LOW_FLOAT",
        "LOW_INT",
        "LSException",
        "LSParserFilter",
        "LUMINANCE",
        "LUMINANCE_ALPHA",
        "LanguageCode",
        "LargestContentfulPaint",
        "LaunchParams",
        "LaunchQueue",
        "LaunchType",
        "LayoutShift",
        "LayoutShiftAttribution",
        "LinearAccelerationSensor",
        "LinkError",
        "ListFormat",
        "LocalMediaStream",
        "Locale",
        "Location",
        "Lock",
        "LockManager",
        "MAP_READ",
        "MAP_WRITE",
        "MARGIN_RULE",
        "MAX",
        "MAX_3D_TEXTURE_SIZE",
        "MAX_ARRAY_TEXTURE_LAYERS",
        "MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND",
        "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
        "MAX_COLOR_ATTACHMENTS",
        "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
        "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
        "MAX_COMBINED_UNIFORM_BLOCKS",
        "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
        "MAX_CUBE_MAP_TEXTURE_SIZE",
        "MAX_DRAW_BUFFERS",
        "MAX_ELEMENTS_INDICES",
        "MAX_ELEMENTS_VERTICES",
        "MAX_ELEMENT_INDEX",
        "MAX_FRAGMENT_INPUT_COMPONENTS",
        "MAX_FRAGMENT_UNIFORM_BLOCKS",
        "MAX_FRAGMENT_UNIFORM_COMPONENTS",
        "MAX_FRAGMENT_UNIFORM_VECTORS",
        "MAX_PROGRAM_TEXEL_OFFSET",
        "MAX_RENDERBUFFER_SIZE",
        "MAX_SAFE_INTEGER",
        "MAX_SAMPLES",
        "MAX_SERVER_WAIT_TIMEOUT",
        "MAX_TEXTURE_IMAGE_UNITS",
        "MAX_TEXTURE_LOD_BIAS",
        "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
        "MAX_TEXTURE_SIZE",
        "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
        "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
        "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
        "MAX_UNIFORM_BLOCK_SIZE",
        "MAX_UNIFORM_BUFFER_BINDINGS",
        "MAX_VALUE",
        "MAX_VARYING_COMPONENTS",
        "MAX_VARYING_VECTORS",
        "MAX_VERTEX_ATTRIBS",
        "MAX_VERTEX_OUTPUT_COMPONENTS",
        "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
        "MAX_VERTEX_UNIFORM_BLOCKS",
        "MAX_VERTEX_UNIFORM_COMPONENTS",
        "MAX_VERTEX_UNIFORM_VECTORS",
        "MAX_VIEWPORT_DIMS",
        "MEDIA_ERR_ABORTED",
        "MEDIA_ERR_DECODE",
        "MEDIA_ERR_ENCRYPTED",
        "MEDIA_ERR_NETWORK",
        "MEDIA_ERR_SRC_NOT_SUPPORTED",
        "MEDIA_KEYERR_CLIENT",
        "MEDIA_KEYERR_DOMAIN",
        "MEDIA_KEYERR_HARDWARECHANGE",
        "MEDIA_KEYERR_OUTPUT",
        "MEDIA_KEYERR_SERVICE",
        "MEDIA_KEYERR_UNKNOWN",
        "MEDIA_RULE",
        "MEDIUM_FLOAT",
        "MEDIUM_INT",
        "META_MASK",
        "MIDIAccess",
        "MIDIConnectionEvent",
        "MIDIInput",
        "MIDIInputMap",
        "MIDIMessageEvent",
        "MIDIOutput",
        "MIDIOutputMap",
        "MIDIPort",
        "MIN",
        "MIN_PROGRAM_TEXEL_OFFSET",
        "MIN_SAFE_INTEGER",
        "MIN_VALUE",
        "MIRRORED_REPEAT",
        "MODE_ASYNCHRONOUS",
        "MODE_SYNCHRONOUS",
        "MODIFICATION",
        "MOUSEDOWN",
        "MOUSEDRAG",
        "MOUSEMOVE",
        "MOUSEOUT",
        "MOUSEOVER",
        "MOUSEUP",
        "MOZ_KEYFRAMES_RULE",
        "MOZ_KEYFRAME_RULE",
        "MOZ_SOURCE_CURSOR",
        "MOZ_SOURCE_ERASER",
        "MOZ_SOURCE_KEYBOARD",
        "MOZ_SOURCE_MOUSE",
        "MOZ_SOURCE_PEN",
        "MOZ_SOURCE_TOUCH",
        "MOZ_SOURCE_UNKNOWN",
        "MSGESTURE_FLAG_BEGIN",
        "MSGESTURE_FLAG_CANCEL",
        "MSGESTURE_FLAG_END",
        "MSGESTURE_FLAG_INERTIA",
        "MSGESTURE_FLAG_NONE",
        "MSPOINTER_TYPE_MOUSE",
        "MSPOINTER_TYPE_PEN",
        "MSPOINTER_TYPE_TOUCH",
        "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
        "MS_ASYNC_CALLBACK_STATUS_CANCEL",
        "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
        "MS_ASYNC_CALLBACK_STATUS_ERROR",
        "MS_ASYNC_CALLBACK_STATUS_JOIN",
        "MS_ASYNC_OP_STATUS_CANCELED",
        "MS_ASYNC_OP_STATUS_ERROR",
        "MS_ASYNC_OP_STATUS_SUCCESS",
        "MS_MANIPULATION_STATE_ACTIVE",
        "MS_MANIPULATION_STATE_CANCELLED",
        "MS_MANIPULATION_STATE_COMMITTED",
        "MS_MANIPULATION_STATE_DRAGGING",
        "MS_MANIPULATION_STATE_INERTIA",
        "MS_MANIPULATION_STATE_PRESELECT",
        "MS_MANIPULATION_STATE_SELECTING",
        "MS_MANIPULATION_STATE_STOPPED",
        "MS_MEDIA_ERR_ENCRYPTED",
        "MS_MEDIA_KEYERR_CLIENT",
        "MS_MEDIA_KEYERR_DOMAIN",
        "MS_MEDIA_KEYERR_HARDWARECHANGE",
        "MS_MEDIA_KEYERR_OUTPUT",
        "MS_MEDIA_KEYERR_SERVICE",
        "MS_MEDIA_KEYERR_UNKNOWN",
        "Map",
        "Math",
        "MathMLElement",
        "MediaCapabilities",
        "MediaCapabilitiesInfo",
        "MediaController",
        "MediaDeviceInfo",
        "MediaDevices",
        "MediaElementAudioSourceNode",
        "MediaEncryptedEvent",
        "MediaError",
        "MediaKeyError",
        "MediaKeyEvent",
        "MediaKeyMessageEvent",
        "MediaKeyNeededEvent",
        "MediaKeySession",
        "MediaKeyStatusMap",
        "MediaKeySystemAccess",
        "MediaKeys",
        "MediaList",
        "MediaMetadata",
        "MediaQueryList",
        "MediaQueryListEvent",
        "MediaRecorder",
        "MediaRecorderErrorEvent",
        "MediaSession",
        "MediaSettingsRange",
        "MediaSource",
        "MediaSourceHandle",
        "MediaStream",
        "MediaStreamAudioDestinationNode",
        "MediaStreamAudioSourceNode",
        "MediaStreamEvent",
        "MediaStreamTrack",
        "MediaStreamTrackAudioSourceNode",
        "MediaStreamTrackAudioStats",
        "MediaStreamTrackEvent",
        "MediaStreamTrackGenerator",
        "MediaStreamTrackProcessor",
        "MediaStreamTrackVideoStats",
        "Memory",
        "MessageChannel",
        "MessageEvent",
        "MessagePort",
        "MessageSender",
        "Methods",
        "MimeType",
        "MimeTypeArray",
        "Module",
        "MouseEvent",
        "MouseScrollEvent",
        "MozAnimation",
        "MozAnimationDelay",
        "MozAnimationDirection",
        "MozAnimationDuration",
        "MozAnimationFillMode",
        "MozAnimationIterationCount",
        "MozAnimationName",
        "MozAnimationPlayState",
        "MozAnimationTimingFunction",
        "MozAppearance",
        "MozBackfaceVisibility",
        "MozBinding",
        "MozBorderBottomColors",
        "MozBorderEnd",
        "MozBorderEndColor",
        "MozBorderEndStyle",
        "MozBorderEndWidth",
        "MozBorderImage",
        "MozBorderLeftColors",
        "MozBorderRightColors",
        "MozBorderStart",
        "MozBorderStartColor",
        "MozBorderStartStyle",
        "MozBorderStartWidth",
        "MozBorderTopColors",
        "MozBoxAlign",
        "MozBoxDirection",
        "MozBoxFlex",
        "MozBoxOrdinalGroup",
        "MozBoxOrient",
        "MozBoxPack",
        "MozBoxSizing",
        "MozCSSKeyframeRule",
        "MozCSSKeyframesRule",
        "MozColumnCount",
        "MozColumnFill",
        "MozColumnGap",
        "MozColumnRule",
        "MozColumnRuleColor",
        "MozColumnRuleStyle",
        "MozColumnRuleWidth",
        "MozColumnWidth",
        "MozColumns",
        "MozContactChangeEvent",
        "MozFloatEdge",
        "MozFontFeatureSettings",
        "MozFontLanguageOverride",
        "MozForceBrokenImageIcon",
        "MozHyphens",
        "MozImageRegion",
        "MozMarginEnd",
        "MozMarginStart",
        "MozMmsEvent",
        "MozMmsMessage",
        "MozMobileMessageThread",
        "MozOSXFontSmoothing",
        "MozOrient",
        "MozOsxFontSmoothing",
        "MozOutlineRadius",
        "MozOutlineRadiusBottomleft",
        "MozOutlineRadiusBottomright",
        "MozOutlineRadiusTopleft",
        "MozOutlineRadiusTopright",
        "MozPaddingEnd",
        "MozPaddingStart",
        "MozPerspective",
        "MozPerspectiveOrigin",
        "MozPowerManager",
        "MozSettingsEvent",
        "MozSmsEvent",
        "MozSmsMessage",
        "MozStackSizing",
        "MozTabSize",
        "MozTextAlignLast",
        "MozTextDecorationColor",
        "MozTextDecorationLine",
        "MozTextDecorationStyle",
        "MozTextSizeAdjust",
        "MozTransform",
        "MozTransformOrigin",
        "MozTransformStyle",
        "MozTransition",
        "MozTransitionDelay",
        "MozTransitionDuration",
        "MozTransitionProperty",
        "MozTransitionTimingFunction",
        "MozUserFocus",
        "MozUserInput",
        "MozUserModify",
        "MozUserSelect",
        "MozWindowDragging",
        "MozWindowShadow",
        "MutationEvent",
        "MutationObserver",
        "MutationRecord",
        "MutedInfo",
        "MutedInfoReason",
        "NAMESPACE_ERR",
        "NAMESPACE_RULE",
        "NEAREST",
        "NEAREST_MIPMAP_LINEAR",
        "NEAREST_MIPMAP_NEAREST",
        "NEGATIVE_INFINITY",
        "NETWORK_EMPTY",
        "NETWORK_ERR",
        "NETWORK_IDLE",
        "NETWORK_LOADED",
        "NETWORK_LOADING",
        "NETWORK_NO_SOURCE",
        "NEVER",
        "NEW",
        "NEXT",
        "NEXT_NO_DUPLICATE",
        "NICEST",
        "NODE_AFTER",
        "NODE_BEFORE",
        "NODE_BEFORE_AND_AFTER",
        "NODE_INSIDE",
        "NONE",
        "NON_TRANSIENT_ERR",
        "NOTATION_NODE",
        "NOTCH",
        "NOTEQUAL",
        "NOT_ALLOWED_ERR",
        "NOT_FOUND_ERR",
        "NOT_READABLE_ERR",
        "NOT_SUPPORTED_ERR",
        "NO_DATA_ALLOWED_ERR",
        "NO_ERR",
        "NO_ERROR",
        "NO_MODIFICATION_ALLOWED_ERR",
        "NUMBER_TYPE",
        "NUM_COMPRESSED_TEXTURE_FORMATS",
        "NaN",
        "NamedNodeMap",
        "NavigateEvent",
        "Navigation",
        "NavigationActivation",
        "NavigationCurrentEntryChangeEvent",
        "NavigationDestination",
        "NavigationHistoryEntry",
        "NavigationPreloadManager",
        "NavigationTransition",
        "Navigator",
        "NavigatorLogin",
        "NavigatorManagedData",
        "NavigatorUAData",
        "NearbyLinks",
        "NetworkInformation",
        "Node",
        "NodeFilter",
        "NodeIterator",
        "NodeList",
        "NotRestoredReasonDetails",
        "NotRestoredReasons",
        "Notation",
        "Notification",
        "NotifyPaintEvent",
        "Number",
        "NumberFormat",
        "OBJECT_TYPE",
        "OBSOLETE",
        "OK",
        "ONE",
        "ONE_MINUS_CONSTANT_ALPHA",
        "ONE_MINUS_CONSTANT_COLOR",
        "ONE_MINUS_DST_ALPHA",
        "ONE_MINUS_DST_COLOR",
        "ONE_MINUS_SRC_ALPHA",
        "ONE_MINUS_SRC_COLOR",
        "OPEN",
        "OPENED",
        "OPENING",
        "ORDERED_NODE_ITERATOR_TYPE",
        "ORDERED_NODE_SNAPSHOT_TYPE",
        "OTHER_ERROR",
        "OTPCredential",
        "OUT_OF_MEMORY",
        "Object",
        "OfflineAudioCompletionEvent",
        "OfflineAudioContext",
        "OfflineResourceList",
        "OffscreenCanvas",
        "OffscreenCanvasRenderingContext2D",
        "OnClickData",
        "OnInstalledReason",
        "OnPerformanceWarningCategory",
        "OnPerformanceWarningSeverity",
        "OnRestartRequiredReason",
        "Option",
        "OrientationSensor",
        "OscillatorNode",
        "OverconstrainedError",
        "OverflowEvent",
        "PACK_ALIGNMENT",
        "PACK_ROW_LENGTH",
        "PACK_SKIP_PIXELS",
        "PACK_SKIP_ROWS",
        "PAGE_RULE",
        "PARSE_ERR",
        "PATHSEG_ARC_ABS",
        "PATHSEG_ARC_REL",
        "PATHSEG_CLOSEPATH",
        "PATHSEG_CURVETO_CUBIC_ABS",
        "PATHSEG_CURVETO_CUBIC_REL",
        "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
        "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
        "PATHSEG_CURVETO_QUADRATIC_ABS",
        "PATHSEG_CURVETO_QUADRATIC_REL",
        "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
        "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
        "PATHSEG_LINETO_ABS",
        "PATHSEG_LINETO_HORIZONTAL_ABS",
        "PATHSEG_LINETO_HORIZONTAL_REL",
        "PATHSEG_LINETO_REL",
        "PATHSEG_LINETO_VERTICAL_ABS",
        "PATHSEG_LINETO_VERTICAL_REL",
        "PATHSEG_MOVETO_ABS",
        "PATHSEG_MOVETO_REL",
        "PATHSEG_UNKNOWN",
        "PATH_EXISTS_ERR",
        "PEAKING",
        "PERMISSION_DENIED",
        "PERSISTENT",
        "PI",
        "PIXEL_PACK_BUFFER",
        "PIXEL_PACK_BUFFER_BINDING",
        "PIXEL_UNPACK_BUFFER",
        "PIXEL_UNPACK_BUFFER_BINDING",
        "PLAYING_STATE",
        "POINTS",
        "POLYGON_OFFSET_FACTOR",
        "POLYGON_OFFSET_FILL",
        "POLYGON_OFFSET_UNITS",
        "POSITION_UNAVAILABLE",
        "POSITIVE_INFINITY",
        "PREV",
        "PREV_NO_DUPLICATE",
        "PROCESSING_INSTRUCTION_NODE",
        "PageChangeEvent",
        "PageRevealEvent",
        "PageSettings",
        "PageSwapEvent",
        "PageTransitionEvent",
        "PaintRequest",
        "PaintRequestList",
        "PannerNode",
        "PasswordCredential",
        "Path2D",
        "PaymentAddress",
        "PaymentInstruments",
        "PaymentManager",
        "PaymentMethodChangeEvent",
        "PaymentRequest",
        "PaymentRequestUpdateEvent",
        "PaymentResponse",
        "Performance",
        "PerformanceElementTiming",
        "PerformanceEntry",
        "PerformanceEventTiming",
        "PerformanceLongAnimationFrameTiming",
        "PerformanceLongTaskTiming",
        "PerformanceMark",
        "PerformanceMeasure",
        "PerformanceNavigation",
        "PerformanceNavigationTiming",
        "PerformanceObserver",
        "PerformanceObserverEntryList",
        "PerformancePaintTiming",
        "PerformanceResourceTiming",
        "PerformanceScriptTiming",
        "PerformanceServerTiming",
        "PerformanceTiming",
        "PeriodicSyncManager",
        "PeriodicWave",
        "PermissionStatus",
        "Permissions",
        "PhotoCapabilities",
        "PictureInPictureEvent",
        "PictureInPictureWindow",
        "PlatformArch",
        "PlatformInfo",
        "PlatformNaclArch",
        "PlatformOs",
        "Plugin",
        "PluginArray",
        "PluralRules",
        "PointerEvent",
        "PopStateEvent",
        "PopupBlockedEvent",
        "Port",
        "Presentation",
        "PresentationAvailability",
        "PresentationConnection",
        "PresentationConnectionAvailableEvent",
        "PresentationConnectionCloseEvent",
        "PresentationConnectionList",
        "PresentationReceiver",
        "PresentationRequest",
        "PressureObserver",
        "PressureRecord",
        "ProcessingInstruction",
        "Profiler",
        "ProgressEvent",
        "Promise",
        "PromiseRejectionEvent",
        "PropertyNodeList",
        "ProtectedAudience",
        "Proxy",
        "PublicKeyCredential",
        "PushManager",
        "PushSubscription",
        "PushSubscriptionOptions",
        "Q",
        "QUERY_RESOLVE",
        "QUERY_RESULT",
        "QUERY_RESULT_AVAILABLE",
        "QUOTA_ERR",
        "QUOTA_EXCEEDED_ERR",
        "QueryInterface",
        "R11F_G11F_B10F",
        "R16F",
        "R16I",
        "R16UI",
        "R32F",
        "R32I",
        "R32UI",
        "R8",
        "R8I",
        "R8UI",
        "R8_SNORM",
        "RASTERIZER_DISCARD",
        "READ",
        "READ_BUFFER",
        "READ_FRAMEBUFFER",
        "READ_FRAMEBUFFER_BINDING",
        "READ_ONLY",
        "READ_ONLY_ERR",
        "READ_WRITE",
        "RED",
        "RED_BITS",
        "RED_INTEGER",
        "REMOVAL",
        "RENDERBUFFER",
        "RENDERBUFFER_ALPHA_SIZE",
        "RENDERBUFFER_BINDING",
        "RENDERBUFFER_BLUE_SIZE",
        "RENDERBUFFER_DEPTH_SIZE",
        "RENDERBUFFER_GREEN_SIZE",
        "RENDERBUFFER_HEIGHT",
        "RENDERBUFFER_INTERNAL_FORMAT",
        "RENDERBUFFER_RED_SIZE",
        "RENDERBUFFER_SAMPLES",
        "RENDERBUFFER_STENCIL_SIZE",
        "RENDERBUFFER_WIDTH",
        "RENDERER",
        "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
        "RENDERING_INTENT_AUTO",
        "RENDERING_INTENT_PERCEPTUAL",
        "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
        "RENDERING_INTENT_SATURATION",
        "RENDERING_INTENT_UNKNOWN",
        "RENDER_ATTACHMENT",
        "REPEAT",
        "REPLACE",
        "RG",
        "RG16F",
        "RG16I",
        "RG16UI",
        "RG32F",
        "RG32I",
        "RG32UI",
        "RG8",
        "RG8I",
        "RG8UI",
        "RG8_SNORM",
        "RGB",
        "RGB10_A2",
        "RGB10_A2UI",
        "RGB16F",
        "RGB16I",
        "RGB16UI",
        "RGB32F",
        "RGB32I",
        "RGB32UI",
        "RGB565",
        "RGB5_A1",
        "RGB8",
        "RGB8I",
        "RGB8UI",
        "RGB8_SNORM",
        "RGB9_E5",
        "RGBA",
        "RGBA16F",
        "RGBA16I",
        "RGBA16UI",
        "RGBA32F",
        "RGBA32I",
        "RGBA32UI",
        "RGBA4",
        "RGBA8",
        "RGBA8I",
        "RGBA8UI",
        "RGBA8_SNORM",
        "RGBA_INTEGER",
        "RGBColor",
        "RGB_INTEGER",
        "RG_INTEGER",
        "ROTATION_CLOCKWISE",
        "ROTATION_COUNTERCLOCKWISE",
        "RTCCertificate",
        "RTCDTMFSender",
        "RTCDTMFToneChangeEvent",
        "RTCDataChannel",
        "RTCDataChannelEvent",
        "RTCDtlsTransport",
        "RTCEncodedAudioFrame",
        "RTCEncodedVideoFrame",
        "RTCError",
        "RTCErrorEvent",
        "RTCIceCandidate",
        "RTCIceTransport",
        "RTCPeerConnection",
        "RTCPeerConnectionIceErrorEvent",
        "RTCPeerConnectionIceEvent",
        "RTCRtpReceiver",
        "RTCRtpScriptTransform",
        "RTCRtpSender",
        "RTCRtpTransceiver",
        "RTCSctpTransport",
        "RTCSessionDescription",
        "RTCStatsReport",
        "RTCTrackEvent",
        "RadioNodeList",
        "Range",
        "RangeError",
        "RangeException",
        "ReadableByteStreamController",
        "ReadableStream",
        "ReadableStreamBYOBReader",
        "ReadableStreamBYOBRequest",
        "ReadableStreamDefaultController",
        "ReadableStreamDefaultReader",
        "RecordErrorEvent",
        "Rect",
        "ReferenceError",
        "Reflect",
        "RegExp",
        "RelativeOrientationSensor",
        "RelativeTimeFormat",
        "RemotePlayback",
        "Report",
        "ReportBody",
        "ReportingObserver",
        "Request",
        "RequestUpdateCheckStatus",
        "ResizeObserver",
        "ResizeObserverEntry",
        "ResizeObserverSize",
        "Response",
        "RuntimeError",
        "SAMPLER_2D",
        "SAMPLER_2D_ARRAY",
        "SAMPLER_2D_ARRAY_SHADOW",
        "SAMPLER_2D_SHADOW",
        "SAMPLER_3D",
        "SAMPLER_BINDING",
        "SAMPLER_CUBE",
        "SAMPLER_CUBE_SHADOW",
        "SAMPLES",
        "SAMPLE_ALPHA_TO_COVERAGE",
        "SAMPLE_BUFFERS",
        "SAMPLE_COVERAGE",
        "SAMPLE_COVERAGE_INVERT",
        "SAMPLE_COVERAGE_VALUE",
        "SAWTOOTH",
        "SCHEDULED_STATE",
        "SCISSOR_BOX",
        "SCISSOR_TEST",
        "SCROLL_PAGE_DOWN",
        "SCROLL_PAGE_UP",
        "SDP_ANSWER",
        "SDP_OFFER",
        "SDP_PRANSWER",
        "SECURITY_ERR",
        "SELECT",
        "SEPARATE_ATTRIBS",
        "SERIALIZE_ERR",
        "SEVERITY_ERROR",
        "SEVERITY_FATAL_ERROR",
        "SEVERITY_WARNING",
        "SHADER_COMPILER",
        "SHADER_TYPE",
        "SHADING_LANGUAGE_VERSION",
        "SHIFT_MASK",
        "SHORT",
        "SHOWING",
        "SHOW_ALL",
        "SHOW_ATTRIBUTE",
        "SHOW_CDATA_SECTION",
        "SHOW_COMMENT",
        "SHOW_DOCUMENT",
        "SHOW_DOCUMENT_FRAGMENT",
        "SHOW_DOCUMENT_TYPE",
        "SHOW_ELEMENT",
        "SHOW_ENTITY",
        "SHOW_ENTITY_REFERENCE",
        "SHOW_NOTATION",
        "SHOW_PROCESSING_INSTRUCTION",
        "SHOW_TEXT",
        "SIGNALED",
        "SIGNED_NORMALIZED",
        "SINE",
        "SOUNDFIELD",
        "SQLException",
        "SQRT1_2",
        "SQRT2",
        "SQUARE",
        "SRC_ALPHA",
        "SRC_ALPHA_SATURATE",
        "SRC_COLOR",
        "SRGB",
        "SRGB8",
        "SRGB8_ALPHA8",
        "START_TO_END",
        "START_TO_START",
        "STATIC_COPY",
        "STATIC_DRAW",
        "STATIC_READ",
        "STENCIL",
        "STENCIL_ATTACHMENT",
        "STENCIL_BACK_FAIL",
        "STENCIL_BACK_FUNC",
        "STENCIL_BACK_PASS_DEPTH_FAIL",
        "STENCIL_BACK_PASS_DEPTH_PASS",
        "STENCIL_BACK_REF",
        "STENCIL_BACK_VALUE_MASK",
        "STENCIL_BACK_WRITEMASK",
        "STENCIL_BITS",
        "STENCIL_BUFFER_BIT",
        "STENCIL_CLEAR_VALUE",
        "STENCIL_FAIL",
        "STENCIL_FUNC",
        "STENCIL_INDEX",
        "STENCIL_INDEX8",
        "STENCIL_PASS_DEPTH_FAIL",
        "STENCIL_PASS_DEPTH_PASS",
        "STENCIL_REF",
        "STENCIL_TEST",
        "STENCIL_VALUE_MASK",
        "STENCIL_WRITEMASK",
        "STORAGE",
        "STORAGE_BINDING",
        "STREAM_COPY",
        "STREAM_DRAW",
        "STREAM_READ",
        "STRING_TYPE",
        "STYLE_RULE",
        "SUBPIXEL_BITS",
        "SUPPORTS_RULE",
        "SVGAElement",
        "SVGAltGlyphDefElement",
        "SVGAltGlyphElement",
        "SVGAltGlyphItemElement",
        "SVGAngle",
        "SVGAnimateColorElement",
        "SVGAnimateElement",
        "SVGAnimateMotionElement",
        "SVGAnimateTransformElement",
        "SVGAnimatedAngle",
        "SVGAnimatedBoolean",
        "SVGAnimatedEnumeration",
        "SVGAnimatedInteger",
        "SVGAnimatedLength",
        "SVGAnimatedLengthList",
        "SVGAnimatedNumber",
        "SVGAnimatedNumberList",
        "SVGAnimatedPreserveAspectRatio",
        "SVGAnimatedRect",
        "SVGAnimatedString",
        "SVGAnimatedTransformList",
        "SVGAnimationElement",
        "SVGCircleElement",
        "SVGClipPathElement",
        "SVGColor",
        "SVGComponentTransferFunctionElement",
        "SVGCursorElement",
        "SVGDefsElement",
        "SVGDescElement",
        "SVGDiscardElement",
        "SVGDocument",
        "SVGElement",
        "SVGElementInstance",
        "SVGElementInstanceList",
        "SVGEllipseElement",
        "SVGException",
        "SVGFEBlendElement",
        "SVGFEColorMatrixElement",
        "SVGFEComponentTransferElement",
        "SVGFECompositeElement",
        "SVGFEConvolveMatrixElement",
        "SVGFEDiffuseLightingElement",
        "SVGFEDisplacementMapElement",
        "SVGFEDistantLightElement",
        "SVGFEDropShadowElement",
        "SVGFEFloodElement",
        "SVGFEFuncAElement",
        "SVGFEFuncBElement",
        "SVGFEFuncGElement",
        "SVGFEFuncRElement",
        "SVGFEGaussianBlurElement",
        "SVGFEImageElement",
        "SVGFEMergeElement",
        "SVGFEMergeNodeElement",
        "SVGFEMorphologyElement",
        "SVGFEOffsetElement",
        "SVGFEPointLightElement",
        "SVGFESpecularLightingElement",
        "SVGFESpotLightElement",
        "SVGFETileElement",
        "SVGFETurbulenceElement",
        "SVGFilterElement",
        "SVGFontElement",
        "SVGFontFaceElement",
        "SVGFontFaceFormatElement",
        "SVGFontFaceNameElement",
        "SVGFontFaceSrcElement",
        "SVGFontFaceUriElement",
        "SVGForeignObjectElement",
        "SVGGElement",
        "SVGGeometryElement",
        "SVGGlyphElement",
        "SVGGlyphRefElement",
        "SVGGradientElement",
        "SVGGraphicsElement",
        "SVGHKernElement",
        "SVGImageElement",
        "SVGLength",
        "SVGLengthList",
        "SVGLineElement",
        "SVGLinearGradientElement",
        "SVGMPathElement",
        "SVGMarkerElement",
        "SVGMaskElement",
        "SVGMatrix",
        "SVGMetadataElement",
        "SVGMissingGlyphElement",
        "SVGNumber",
        "SVGNumberList",
        "SVGPaint",
        "SVGPathElement",
        "SVGPathSeg",
        "SVGPathSegArcAbs",
        "SVGPathSegArcRel",
        "SVGPathSegClosePath",
        "SVGPathSegCurvetoCubicAbs",
        "SVGPathSegCurvetoCubicRel",
        "SVGPathSegCurvetoCubicSmoothAbs",
        "SVGPathSegCurvetoCubicSmoothRel",
        "SVGPathSegCurvetoQuadraticAbs",
        "SVGPathSegCurvetoQuadraticRel",
        "SVGPathSegCurvetoQuadraticSmoothAbs",
        "SVGPathSegCurvetoQuadraticSmoothRel",
        "SVGPathSegLinetoAbs",
        "SVGPathSegLinetoHorizontalAbs",
        "SVGPathSegLinetoHorizontalRel",
        "SVGPathSegLinetoRel",
        "SVGPathSegLinetoVerticalAbs",
        "SVGPathSegLinetoVerticalRel",
        "SVGPathSegList",
        "SVGPathSegMovetoAbs",
        "SVGPathSegMovetoRel",
        "SVGPatternElement",
        "SVGPoint",
        "SVGPointList",
        "SVGPolygonElement",
        "SVGPolylineElement",
        "SVGPreserveAspectRatio",
        "SVGRadialGradientElement",
        "SVGRect",
        "SVGRectElement",
        "SVGRenderingIntent",
        "SVGSVGElement",
        "SVGScriptElement",
        "SVGSetElement",
        "SVGStopElement",
        "SVGStringList",
        "SVGStyleElement",
        "SVGSwitchElement",
        "SVGSymbolElement",
        "SVGTRefElement",
        "SVGTSpanElement",
        "SVGTextContentElement",
        "SVGTextElement",
        "SVGTextPathElement",
        "SVGTextPositioningElement",
        "SVGTitleElement",
        "SVGTransform",
        "SVGTransformList",
        "SVGUnitTypes",
        "SVGUseElement",
        "SVGVKernElement",
        "SVGViewElement",
        "SVGViewSpec",
        "SVGZoomAndPan",
        "SVGZoomEvent",
        "SVG_ANGLETYPE_DEG",
        "SVG_ANGLETYPE_GRAD",
        "SVG_ANGLETYPE_RAD",
        "SVG_ANGLETYPE_UNKNOWN",
        "SVG_ANGLETYPE_UNSPECIFIED",
        "SVG_CHANNEL_A",
        "SVG_CHANNEL_B",
        "SVG_CHANNEL_G",
        "SVG_CHANNEL_R",
        "SVG_CHANNEL_UNKNOWN",
        "SVG_COLORTYPE_CURRENTCOLOR",
        "SVG_COLORTYPE_RGBCOLOR",
        "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
        "SVG_COLORTYPE_UNKNOWN",
        "SVG_EDGEMODE_DUPLICATE",
        "SVG_EDGEMODE_NONE",
        "SVG_EDGEMODE_UNKNOWN",
        "SVG_EDGEMODE_WRAP",
        "SVG_FEBLEND_MODE_COLOR",
        "SVG_FEBLEND_MODE_COLOR_BURN",
        "SVG_FEBLEND_MODE_COLOR_DODGE",
        "SVG_FEBLEND_MODE_DARKEN",
        "SVG_FEBLEND_MODE_DIFFERENCE",
        "SVG_FEBLEND_MODE_EXCLUSION",
        "SVG_FEBLEND_MODE_HARD_LIGHT",
        "SVG_FEBLEND_MODE_HUE",
        "SVG_FEBLEND_MODE_LIGHTEN",
        "SVG_FEBLEND_MODE_LUMINOSITY",
        "SVG_FEBLEND_MODE_MULTIPLY",
        "SVG_FEBLEND_MODE_NORMAL",
        "SVG_FEBLEND_MODE_OVERLAY",
        "SVG_FEBLEND_MODE_SATURATION",
        "SVG_FEBLEND_MODE_SCREEN",
        "SVG_FEBLEND_MODE_SOFT_LIGHT",
        "SVG_FEBLEND_MODE_UNKNOWN",
        "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
        "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
        "SVG_FECOLORMATRIX_TYPE_MATRIX",
        "SVG_FECOLORMATRIX_TYPE_SATURATE",
        "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
        "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
        "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
        "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
        "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
        "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
        "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
        "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
        "SVG_FECOMPOSITE_OPERATOR_ATOP",
        "SVG_FECOMPOSITE_OPERATOR_IN",
        "SVG_FECOMPOSITE_OPERATOR_LIGHTER",
        "SVG_FECOMPOSITE_OPERATOR_OUT",
        "SVG_FECOMPOSITE_OPERATOR_OVER",
        "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
        "SVG_FECOMPOSITE_OPERATOR_XOR",
        "SVG_INVALID_VALUE_ERR",
        "SVG_LENGTHTYPE_CM",
        "SVG_LENGTHTYPE_EMS",
        "SVG_LENGTHTYPE_EXS",
        "SVG_LENGTHTYPE_IN",
        "SVG_LENGTHTYPE_MM",
        "SVG_LENGTHTYPE_NUMBER",
        "SVG_LENGTHTYPE_PC",
        "SVG_LENGTHTYPE_PERCENTAGE",
        "SVG_LENGTHTYPE_PT",
        "SVG_LENGTHTYPE_PX",
        "SVG_LENGTHTYPE_UNKNOWN",
        "SVG_MARKERUNITS_STROKEWIDTH",
        "SVG_MARKERUNITS_UNKNOWN",
        "SVG_MARKERUNITS_USERSPACEONUSE",
        "SVG_MARKER_ORIENT_ANGLE",
        "SVG_MARKER_ORIENT_AUTO",
        "SVG_MARKER_ORIENT_AUTO_START_REVERSE",
        "SVG_MARKER_ORIENT_UNKNOWN",
        "SVG_MASKTYPE_ALPHA",
        "SVG_MASKTYPE_LUMINANCE",
        "SVG_MATRIX_NOT_INVERTABLE",
        "SVG_MEETORSLICE_MEET",
        "SVG_MEETORSLICE_SLICE",
        "SVG_MEETORSLICE_UNKNOWN",
        "SVG_MORPHOLOGY_OPERATOR_DILATE",
        "SVG_MORPHOLOGY_OPERATOR_ERODE",
        "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
        "SVG_PAINTTYPE_CURRENTCOLOR",
        "SVG_PAINTTYPE_NONE",
        "SVG_PAINTTYPE_RGBCOLOR",
        "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
        "SVG_PAINTTYPE_UNKNOWN",
        "SVG_PAINTTYPE_URI",
        "SVG_PAINTTYPE_URI_CURRENTCOLOR",
        "SVG_PAINTTYPE_URI_NONE",
        "SVG_PAINTTYPE_URI_RGBCOLOR",
        "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
        "SVG_PRESERVEASPECTRATIO_NONE",
        "SVG_PRESERVEASPECTRATIO_UNKNOWN",
        "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
        "SVG_PRESERVEASPECTRATIO_XMAXYMID",
        "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
        "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
        "SVG_PRESERVEASPECTRATIO_XMIDYMID",
        "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
        "SVG_PRESERVEASPECTRATIO_XMINYMAX",
        "SVG_PRESERVEASPECTRATIO_XMINYMID",
        "SVG_PRESERVEASPECTRATIO_XMINYMIN",
        "SVG_SPREADMETHOD_PAD",
        "SVG_SPREADMETHOD_REFLECT",
        "SVG_SPREADMETHOD_REPEAT",
        "SVG_SPREADMETHOD_UNKNOWN",
        "SVG_STITCHTYPE_NOSTITCH",
        "SVG_STITCHTYPE_STITCH",
        "SVG_STITCHTYPE_UNKNOWN",
        "SVG_TRANSFORM_MATRIX",
        "SVG_TRANSFORM_ROTATE",
        "SVG_TRANSFORM_SCALE",
        "SVG_TRANSFORM_SKEWX",
        "SVG_TRANSFORM_SKEWY",
        "SVG_TRANSFORM_TRANSLATE",
        "SVG_TRANSFORM_UNKNOWN",
        "SVG_TURBULENCE_TYPE_FRACTALNOISE",
        "SVG_TURBULENCE_TYPE_TURBULENCE",
        "SVG_TURBULENCE_TYPE_UNKNOWN",
        "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
        "SVG_UNIT_TYPE_UNKNOWN",
        "SVG_UNIT_TYPE_USERSPACEONUSE",
        "SVG_WRONG_TYPE_ERR",
        "SVG_ZOOMANDPAN_DISABLE",
        "SVG_ZOOMANDPAN_MAGNIFY",
        "SVG_ZOOMANDPAN_UNKNOWN",
        "SYNC_CONDITION",
        "SYNC_FENCE",
        "SYNC_FLAGS",
        "SYNC_FLUSH_COMMANDS_BIT",
        "SYNC_GPU_COMMANDS_COMPLETE",
        "SYNC_STATUS",
        "SYNTAX_ERR",
        "SavedPages",
        "Scheduler",
        "Scheduling",
        "Screen",
        "ScreenDetailed",
        "ScreenDetails",
        "ScreenOrientation",
        "Script",
        "ScriptProcessorNode",
        "ScrollAreaEvent",
        "ScrollTimeline",
        "SecurityPolicyViolationEvent",
        "Segmenter",
        "Selection",
        "Sensor",
        "SensorErrorEvent",
        "Serial",
        "SerialPort",
        "ServiceWorker",
        "ServiceWorkerContainer",
        "ServiceWorkerRegistration",
        "SessionDescription",
        "Set",
        "ShadowRoot",
        "SharedArrayBuffer",
        "SharedStorage",
        "SharedStorageWorklet",
        "SharedWorker",
        "SharingState",
        "SimpleGestureEvent",
        "SnapEvent",
        "SourceBuffer",
        "SourceBufferList",
        "SpeechSynthesis",
        "SpeechSynthesisErrorEvent",
        "SpeechSynthesisEvent",
        "SpeechSynthesisUtterance",
        "SpeechSynthesisVoice",
        "StaticRange",
        "StereoPannerNode",
        "StopIteration",
        "Storage",
        "StorageBucket",
        "StorageBucketManager",
        "StorageEvent",
        "StorageManager",
        "String",
        "StructType",
        "StylePropertyMap",
        "StylePropertyMapReadOnly",
        "StyleSheet",
        "StyleSheetList",
        "SubmitEvent",
        "SubtleCrypto",
        "Symbol",
        "SyncManager",
        "SyntaxError",
        "TAB_ID_NONE",
        "TAB_INDEX_NONE",
        "TEMPORARY",
        "TEXTPATH_METHODTYPE_ALIGN",
        "TEXTPATH_METHODTYPE_STRETCH",
        "TEXTPATH_METHODTYPE_UNKNOWN",
        "TEXTPATH_SPACINGTYPE_AUTO",
        "TEXTPATH_SPACINGTYPE_EXACT",
        "TEXTPATH_SPACINGTYPE_UNKNOWN",
        "TEXTURE",
        "TEXTURE0",
        "TEXTURE1",
        "TEXTURE10",
        "TEXTURE11",
        "TEXTURE12",
        "TEXTURE13",
        "TEXTURE14",
        "TEXTURE15",
        "TEXTURE16",
        "TEXTURE17",
        "TEXTURE18",
        "TEXTURE19",
        "TEXTURE2",
        "TEXTURE20",
        "TEXTURE21",
        "TEXTURE22",
        "TEXTURE23",
        "TEXTURE24",
        "TEXTURE25",
        "TEXTURE26",
        "TEXTURE27",
        "TEXTURE28",
        "TEXTURE29",
        "TEXTURE3",
        "TEXTURE30",
        "TEXTURE31",
        "TEXTURE4",
        "TEXTURE5",
        "TEXTURE6",
        "TEXTURE7",
        "TEXTURE8",
        "TEXTURE9",
        "TEXTURE_2D",
        "TEXTURE_2D_ARRAY",
        "TEXTURE_3D",
        "TEXTURE_BASE_LEVEL",
        "TEXTURE_BINDING",
        "TEXTURE_BINDING_2D",
        "TEXTURE_BINDING_2D_ARRAY",
        "TEXTURE_BINDING_3D",
        "TEXTURE_BINDING_CUBE_MAP",
        "TEXTURE_COMPARE_FUNC",
        "TEXTURE_COMPARE_MODE",
        "TEXTURE_CUBE_MAP",
        "TEXTURE_CUBE_MAP_NEGATIVE_X",
        "TEXTURE_CUBE_MAP_NEGATIVE_Y",
        "TEXTURE_CUBE_MAP_NEGATIVE_Z",
        "TEXTURE_CUBE_MAP_POSITIVE_X",
        "TEXTURE_CUBE_MAP_POSITIVE_Y",
        "TEXTURE_CUBE_MAP_POSITIVE_Z",
        "TEXTURE_IMMUTABLE_FORMAT",
        "TEXTURE_IMMUTABLE_LEVELS",
        "TEXTURE_MAG_FILTER",
        "TEXTURE_MAX_ANISOTROPY_EXT",
        "TEXTURE_MAX_LEVEL",
        "TEXTURE_MAX_LOD",
        "TEXTURE_MIN_FILTER",
        "TEXTURE_MIN_LOD",
        "TEXTURE_WRAP_R",
        "TEXTURE_WRAP_S",
        "TEXTURE_WRAP_T",
        "TEXT_NODE",
        "TIMEOUT",
        "TIMEOUT_ERR",
        "TIMEOUT_EXPIRED",
        "TIMEOUT_IGNORED",
        "TOO_LARGE_ERR",
        "TRANSACTION_INACTIVE_ERR",
        "TRANSFORM_FEEDBACK",
        "TRANSFORM_FEEDBACK_ACTIVE",
        "TRANSFORM_FEEDBACK_BINDING",
        "TRANSFORM_FEEDBACK_BUFFER",
        "TRANSFORM_FEEDBACK_BUFFER_BINDING",
        "TRANSFORM_FEEDBACK_BUFFER_MODE",
        "TRANSFORM_FEEDBACK_BUFFER_SIZE",
        "TRANSFORM_FEEDBACK_BUFFER_START",
        "TRANSFORM_FEEDBACK_PAUSED",
        "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
        "TRANSFORM_FEEDBACK_VARYINGS",
        "TRIANGLE",
        "TRIANGLES",
        "TRIANGLE_FAN",
        "TRIANGLE_STRIP",
        "TYPE_BACK_FORWARD",
        "TYPE_ERR",
        "TYPE_MISMATCH_ERR",
        "TYPE_NAVIGATE",
        "TYPE_RELOAD",
        "TYPE_RESERVED",
        "Tab",
        "TabStatus",
        "Table",
        "Tag",
        "TaskAttributionTiming",
        "TaskController",
        "TaskPriorityChangeEvent",
        "TaskSignal",
        "Text",
        "TextDecoder",
        "TextDecoderStream",
        "TextEncoder",
        "TextEncoderStream",
        "TextEvent",
        "TextFormat",
        "TextFormatUpdateEvent",
        "TextMetrics",
        "TextTrack",
        "TextTrackCue",
        "TextTrackCueList",
        "TextTrackList",
        "TextUpdateEvent",
        "TimeEvent",
        "TimeRanges",
        "ToggleEvent",
        "Touch",
        "TouchEvent",
        "TouchList",
        "TrackEvent",
        "TransformStream",
        "TransformStreamDefaultController",
        "TransitionEvent",
        "TreeWalker",
        "TrustedHTML",
        "TrustedScript",
        "TrustedScriptURL",
        "TrustedTypePolicy",
        "TrustedTypePolicyFactory",
        "TypeError",
        "TypedObject",
        "U2F",
        "UIEvent",
        "UNCACHED",
        "UNIFORM",
        "UNIFORM_ARRAY_STRIDE",
        "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
        "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
        "UNIFORM_BLOCK_BINDING",
        "UNIFORM_BLOCK_DATA_SIZE",
        "UNIFORM_BLOCK_INDEX",
        "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
        "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
        "UNIFORM_BUFFER",
        "UNIFORM_BUFFER_BINDING",
        "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
        "UNIFORM_BUFFER_SIZE",
        "UNIFORM_BUFFER_START",
        "UNIFORM_IS_ROW_MAJOR",
        "UNIFORM_MATRIX_STRIDE",
        "UNIFORM_OFFSET",
        "UNIFORM_SIZE",
        "UNIFORM_TYPE",
        "UNKNOWN_ERR",
        "UNKNOWN_RULE",
        "UNMASKED_RENDERER_WEBGL",
        "UNMASKED_VENDOR_WEBGL",
        "UNORDERED_NODE_ITERATOR_TYPE",
        "UNORDERED_NODE_SNAPSHOT_TYPE",
        "UNPACK_ALIGNMENT",
        "UNPACK_COLORSPACE_CONVERSION_WEBGL",
        "UNPACK_FLIP_Y_WEBGL",
        "UNPACK_IMAGE_HEIGHT",
        "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
        "UNPACK_ROW_LENGTH",
        "UNPACK_SKIP_IMAGES",
        "UNPACK_SKIP_PIXELS",
        "UNPACK_SKIP_ROWS",
        "UNSCHEDULED_STATE",
        "UNSENT",
        "UNSIGNALED",
        "UNSIGNED_BYTE",
        "UNSIGNED_INT",
        "UNSIGNED_INT_10F_11F_11F_REV",
        "UNSIGNED_INT_24_8",
        "UNSIGNED_INT_2_10_10_10_REV",
        "UNSIGNED_INT_5_9_9_9_REV",
        "UNSIGNED_INT_SAMPLER_2D",
        "UNSIGNED_INT_SAMPLER_2D_ARRAY",
        "UNSIGNED_INT_SAMPLER_3D",
        "UNSIGNED_INT_SAMPLER_CUBE",
        "UNSIGNED_INT_VEC2",
        "UNSIGNED_INT_VEC3",
        "UNSIGNED_INT_VEC4",
        "UNSIGNED_NORMALIZED",
        "UNSIGNED_SHORT",
        "UNSIGNED_SHORT_4_4_4_4",
        "UNSIGNED_SHORT_5_5_5_1",
        "UNSIGNED_SHORT_5_6_5",
        "UNSPECIFIED_EVENT_TYPE_ERR",
        "UPDATEREADY",
        "URIError",
        "URL",
        "URLPattern",
        "URLSearchParams",
        "URLUnencoded",
        "URL_MISMATCH_ERR",
        "USB",
        "USBAlternateInterface",
        "USBConfiguration",
        "USBConnectionEvent",
        "USBDevice",
        "USBEndpoint",
        "USBInTransferResult",
        "USBInterface",
        "USBIsochronousInTransferPacket",
        "USBIsochronousInTransferResult",
        "USBIsochronousOutTransferPacket",
        "USBIsochronousOutTransferResult",
        "USBOutTransferResult",
        "UTC",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "UpdateFilter",
        "UpdatePropertyName",
        "UserActivation",
        "UserMessageHandler",
        "UserMessageHandlersNamespace",
        "UserProximityEvent",
        "VALIDATE_STATUS",
        "VALIDATION_ERR",
        "VARIABLES_RULE",
        "VENDOR",
        "VERSION",
        "VERSION_CHANGE",
        "VERSION_ERR",
        "VERTEX",
        "VERTEX_ARRAY_BINDING",
        "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
        "VERTEX_ATTRIB_ARRAY_DIVISOR",
        "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
        "VERTEX_ATTRIB_ARRAY_ENABLED",
        "VERTEX_ATTRIB_ARRAY_INTEGER",
        "VERTEX_ATTRIB_ARRAY_NORMALIZED",
        "VERTEX_ATTRIB_ARRAY_POINTER",
        "VERTEX_ATTRIB_ARRAY_SIZE",
        "VERTEX_ATTRIB_ARRAY_STRIDE",
        "VERTEX_ATTRIB_ARRAY_TYPE",
        "VERTEX_SHADER",
        "VERTICAL",
        "VERTICAL_AXIS",
        "VER_ERR",
        "VIEWPORT",
        "VIEWPORT_RULE",
        "VRDisplay",
        "VRDisplayCapabilities",
        "VRDisplayEvent",
        "VREyeParameters",
        "VRFieldOfView",
        "VRFrameData",
        "VRPose",
        "VRStageParameters",
        "VTTCue",
        "VTTRegion",
        "ValidityState",
        "VideoColorSpace",
        "VideoDecoder",
        "VideoEncoder",
        "VideoFrame",
        "VideoPlaybackQuality",
        "VideoStreamTrack",
        "ViewTimeline",
        "ViewTransition",
        "ViewTransitionTypeSet",
        "ViewType",
        "VirtualKeyboard",
        "VirtualKeyboardGeometryChangeEvent",
        "VisibilityStateEntry",
        "VisualViewport",
        "WAIT_FAILED",
        "WEBKIT_FILTER_RULE",
        "WEBKIT_KEYFRAMES_RULE",
        "WEBKIT_KEYFRAME_RULE",
        "WEBKIT_REGION_RULE",
        "WGSLLanguageFeatures",
        "WINDOW_ID_CURRENT",
        "WINDOW_ID_NONE",
        "WRITE",
        "WRONG_DOCUMENT_ERR",
        "WakeLock",
        "WakeLockSentinel",
        "WasmAnyRef",
        "WaveShaperNode",
        "WeakMap",
        "WeakRef",
        "WeakSet",
        "WebAssembly",
        "WebGL2RenderingContext",
        "WebGLActiveInfo",
        "WebGLBuffer",
        "WebGLContextEvent",
        "WebGLFramebuffer",
        "WebGLObject",
        "WebGLProgram",
        "WebGLQuery",
        "WebGLRenderbuffer",
        "WebGLRenderingContext",
        "WebGLSampler",
        "WebGLShader",
        "WebGLShaderPrecisionFormat",
        "WebGLSync",
        "WebGLTexture",
        "WebGLTransformFeedback",
        "WebGLUniformLocation",
        "WebGLVertexArray",
        "WebGLVertexArrayObject",
        "WebKitAnimationEvent",
        "WebKitBlobBuilder",
        "WebKitCSSFilterRule",
        "WebKitCSSFilterValue",
        "WebKitCSSKeyframeRule",
        "WebKitCSSKeyframesRule",
        "WebKitCSSMatrix",
        "WebKitCSSRegionRule",
        "WebKitCSSTransformValue",
        "WebKitDataCue",
        "WebKitGamepad",
        "WebKitMediaKeyError",
        "WebKitMediaKeyMessageEvent",
        "WebKitMediaKeySession",
        "WebKitMediaKeys",
        "WebKitMediaSource",
        "WebKitMutationObserver",
        "WebKitNamespace",
        "WebKitPlaybackTargetAvailabilityEvent",
        "WebKitPoint",
        "WebKitShadowRoot",
        "WebKitSourceBuffer",
        "WebKitSourceBufferList",
        "WebKitTransitionEvent",
        "WebSocket",
        "WebSocketError",
        "WebSocketStream",
        "WebTransport",
        "WebTransportBidirectionalStream",
        "WebTransportDatagramDuplexStream",
        "WebTransportError",
        "WebTransportReceiveStream",
        "WebTransportSendStream",
        "WebkitAlignContent",
        "WebkitAlignItems",
        "WebkitAlignSelf",
        "WebkitAnimation",
        "WebkitAnimationDelay",
        "WebkitAnimationDirection",
        "WebkitAnimationDuration",
        "WebkitAnimationFillMode",
        "WebkitAnimationIterationCount",
        "WebkitAnimationName",
        "WebkitAnimationPlayState",
        "WebkitAnimationTimingFunction",
        "WebkitAppearance",
        "WebkitBackfaceVisibility",
        "WebkitBackgroundClip",
        "WebkitBackgroundOrigin",
        "WebkitBackgroundSize",
        "WebkitBorderBottomLeftRadius",
        "WebkitBorderBottomRightRadius",
        "WebkitBorderImage",
        "WebkitBorderRadius",
        "WebkitBorderTopLeftRadius",
        "WebkitBorderTopRightRadius",
        "WebkitBoxAlign",
        "WebkitBoxDirection",
        "WebkitBoxFlex",
        "WebkitBoxOrdinalGroup",
        "WebkitBoxOrient",
        "WebkitBoxPack",
        "WebkitBoxShadow",
        "WebkitBoxSizing",
        "WebkitClipPath",
        "WebkitFilter",
        "WebkitFlex",
        "WebkitFlexBasis",
        "WebkitFlexDirection",
        "WebkitFlexFlow",
        "WebkitFlexGrow",
        "WebkitFlexShrink",
        "WebkitFlexWrap",
        "WebkitFontFeatureSettings",
        "WebkitJustifyContent",
        "WebkitLineClamp",
        "WebkitMask",
        "WebkitMaskClip",
        "WebkitMaskComposite",
        "WebkitMaskImage",
        "WebkitMaskOrigin",
        "WebkitMaskPosition",
        "WebkitMaskPositionX",
        "WebkitMaskPositionY",
        "WebkitMaskRepeat",
        "WebkitMaskSize",
        "WebkitOrder",
        "WebkitPerspective",
        "WebkitPerspectiveOrigin",
        "WebkitTextFillColor",
        "WebkitTextSecurity",
        "WebkitTextSizeAdjust",
        "WebkitTextStroke",
        "WebkitTextStrokeColor",
        "WebkitTextStrokeWidth",
        "WebkitTransform",
        "WebkitTransformOrigin",
        "WebkitTransformStyle",
        "WebkitTransition",
        "WebkitTransitionDelay",
        "WebkitTransitionDuration",
        "WebkitTransitionProperty",
        "WebkitTransitionTimingFunction",
        "WebkitUserSelect",
        "WheelEvent",
        "Window",
        "WindowControlsOverlay",
        "WindowControlsOverlayGeometryChangeEvent",
        "WindowState",
        "WindowType",
        "Worker",
        "Worklet",
        "WritableStream",
        "WritableStreamDefaultController",
        "WritableStreamDefaultWriter",
        "XMLDocument",
        "XMLHttpRequest",
        "XMLHttpRequestEventTarget",
        "XMLHttpRequestException",
        "XMLHttpRequestProgressEvent",
        "XMLHttpRequestUpload",
        "XMLSerializer",
        "XMLStylesheetProcessingInstruction",
        "XPathEvaluator",
        "XPathException",
        "XPathExpression",
        "XPathNSResolver",
        "XPathResult",
        "XRAnchor",
        "XRAnchorSet",
        "XRBoundedReferenceSpace",
        "XRCPUDepthInformation",
        "XRCamera",
        "XRDOMOverlayState",
        "XRDepthInformation",
        "XRFrame",
        "XRHand",
        "XRHitTestResult",
        "XRHitTestSource",
        "XRInputSource",
        "XRInputSourceArray",
        "XRInputSourceEvent",
        "XRInputSourcesChangeEvent",
        "XRJointPose",
        "XRJointSpace",
        "XRLayer",
        "XRLightEstimate",
        "XRLightProbe",
        "XRPose",
        "XRRay",
        "XRReferenceSpace",
        "XRReferenceSpaceEvent",
        "XRRenderState",
        "XRRigidTransform",
        "XRSession",
        "XRSessionEvent",
        "XRSpace",
        "XRSystem",
        "XRTransientInputHitTestResult",
        "XRTransientInputHitTestSource",
        "XRView",
        "XRViewerPose",
        "XRViewport",
        "XRWebGLBinding",
        "XRWebGLDepthInformation",
        "XRWebGLLayer",
        "XSLTProcessor",
        "ZERO",
        "ZoomSettings",
        "ZoomSettingsMode",
        "ZoomSettingsScope",
        "_XD0M_",
        "_YD0M_",
        "__REACT_DEVTOOLS_GLOBAL_HOOK__",
        "__brand",
        "__defineGetter__",
        "__defineSetter__",
        "__lookupGetter__",
        "__lookupSetter__",
        "__opera",
        "__proto__",
        "_browserjsran",
        "a",
        "aLink",
        "abbr",
        "abort",
        "aborted",
        "aboutConfigPrefs",
        "abs",
        "absolute",
        "acceleration",
        "accelerationIncludingGravity",
        "accelerator",
        "accent-color",
        "accentColor",
        "accept",
        "acceptCharset",
        "acceptNode",
        "access",
        "accessKey",
        "accessKeyLabel",
        "accuracy",
        "acos",
        "acosh",
        "action",
        "actionURL",
        "actions",
        "activated",
        "activation",
        "activationStart",
        "active",
        "activeCues",
        "activeElement",
        "activeSourceBuffers",
        "activeSourceCount",
        "activeTexture",
        "activeVRDisplays",
        "activityLog",
        "actualBoundingBoxAscent",
        "actualBoundingBoxDescent",
        "actualBoundingBoxLeft",
        "actualBoundingBoxRight",
        "adAuctionComponents",
        "adAuctionHeaders",
        "add",
        "addAll",
        "addBehavior",
        "addCandidate",
        "addColorStop",
        "addCue",
        "addElement",
        "addEventListener",
        "addFilter",
        "addFromString",
        "addFromUri",
        "addIceCandidate",
        "addImport",
        "addListener",
        "addModule",
        "addNamed",
        "addPageRule",
        "addPath",
        "addPointer",
        "addRange",
        "addRegion",
        "addRule",
        "addSearchEngine",
        "addSourceBuffer",
        "addStream",
        "addTextTrack",
        "addTrack",
        "addTransceiver",
        "addWakeLockListener",
        "added",
        "addedNodes",
        "additionalName",
        "additiveSymbols",
        "addons",
        "address",
        "addressLine",
        "addressModeU",
        "addressModeV",
        "addressModeW",
        "adoptNode",
        "adoptedCallback",
        "adoptedStyleSheets",
        "adr",
        "advance",
        "after",
        "alarms",
        "album",
        "alert",
        "algorithm",
        "align",
        "align-content",
        "align-items",
        "align-self",
        "alignContent",
        "alignItems",
        "alignSelf",
        "alignmentBaseline",
        "alinkColor",
        "all",
        "allSettled",
        "allocationSize",
        "allow",
        "allowFullscreen",
        "allowPaymentRequest",
        "allowedDirections",
        "allowedFeatures",
        "allowedToPlay",
        "allowsFeature",
        "alpha",
        "alphaMode",
        "alphaToCoverageEnabled",
        "alphabeticBaseline",
        "alt",
        "altGraphKey",
        "altHtml",
        "altKey",
        "altLeft",
        "alternate",
        "alternateSetting",
        "alternates",
        "altitude",
        "altitudeAccuracy",
        "altitudeAngle",
        "amplitude",
        "ancestorOrigins",
        "anchor",
        "anchorNode",
        "anchorOffset",
        "anchorSpace",
        "anchors",
        "and",
        "angle",
        "angularAcceleration",
        "angularVelocity",
        "animVal",
        "animate",
        "animated",
        "animatedInstanceRoot",
        "animatedNormalizedPathSegList",
        "animatedPathSegList",
        "animatedPoints",
        "animation",
        "animation-composition",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "animationComposition",
        "animationDelay",
        "animationDirection",
        "animationDuration",
        "animationFillMode",
        "animationIterationCount",
        "animationName",
        "animationPlayState",
        "animationStartTime",
        "animationTimingFunction",
        "animationsPaused",
        "anniversary",
        "antialias",
        "anticipatedRemoval",
        "any",
        "app",
        "appCodeName",
        "appMinorVersion",
        "appName",
        "appNotifications",
        "appVersion",
        "appearance",
        "append",
        "appendBuffer",
        "appendChild",
        "appendData",
        "appendItem",
        "appendMedium",
        "appendNamed",
        "appendRule",
        "appendStream",
        "appendWindowEnd",
        "appendWindowStart",
        "applets",
        "applicationCache",
        "applicationServerKey",
        "apply",
        "applyConstraints",
        "applyElement",
        "arc",
        "arcTo",
        "arch",
        "architecture",
        "archive",
        "areas",
        "arguments",
        "ariaAtomic",
        "ariaAutoComplete",
        "ariaBrailleLabel",
        "ariaBrailleRoleDescription",
        "ariaBusy",
        "ariaChecked",
        "ariaColCount",
        "ariaColIndex",
        "ariaColIndexText",
        "ariaColSpan",
        "ariaCurrent",
        "ariaDescription",
        "ariaDisabled",
        "ariaExpanded",
        "ariaHasPopup",
        "ariaHidden",
        "ariaInvalid",
        "ariaKeyShortcuts",
        "ariaLabel",
        "ariaLevel",
        "ariaLive",
        "ariaModal",
        "ariaMultiLine",
        "ariaMultiSelectable",
        "ariaOrientation",
        "ariaPlaceholder",
        "ariaPosInSet",
        "ariaPressed",
        "ariaReadOnly",
        "ariaRelevant",
        "ariaRequired",
        "ariaRoleDescription",
        "ariaRowCount",
        "ariaRowIndex",
        "ariaRowIndexText",
        "ariaRowSpan",
        "ariaSelected",
        "ariaSetSize",
        "ariaSort",
        "ariaValueMax",
        "ariaValueMin",
        "ariaValueNow",
        "ariaValueText",
        "arrayBuffer",
        "arrayLayerCount",
        "arrayStride",
        "artist",
        "artwork",
        "as",
        "asIntN",
        "asUintN",
        "ascentOverride",
        "asin",
        "asinh",
        "aspect",
        "aspect-ratio",
        "aspectRatio",
        "assert",
        "assign",
        "assignedElements",
        "assignedNodes",
        "assignedSlot",
        "async",
        "asyncDispose",
        "asyncIterator",
        "at",
        "atEnd",
        "atan",
        "atan2",
        "atanh",
        "atob",
        "attachEvent",
        "attachInternals",
        "attachShader",
        "attachShadow",
        "attachedElements",
        "attachments",
        "attack",
        "attestationObject",
        "attrChange",
        "attrName",
        "attributeChangedCallback",
        "attributeFilter",
        "attributeName",
        "attributeNamespace",
        "attributeOldValue",
        "attributeStyleMap",
        "attributes",
        "attribution",
        "attributionSrc",
        "audioBitrateMode",
        "audioBitsPerSecond",
        "audioTracks",
        "audioWorklet",
        "authenticatedSignedWrites",
        "authenticatorAttachment",
        "authenticatorData",
        "autoIncrement",
        "autobuffer",
        "autocapitalize",
        "autocomplete",
        "autocorrect",
        "autofocus",
        "automationRate",
        "autoplay",
        "availHeight",
        "availLeft",
        "availTop",
        "availWidth",
        "availability",
        "available",
        "averageLatency",
        "aversion",
        "ax",
        "axes",
        "axis",
        "ay",
        "azimuth",
        "azimuthAngle",
        "b",
        "back",
        "backdrop-filter",
        "backdropFilter",
        "backends",
        "backface-visibility",
        "backfaceVisibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-position-x",
        "background-position-y",
        "background-repeat",
        "background-size",
        "backgroundAttachment",
        "backgroundBlendMode",
        "backgroundClip",
        "backgroundColor",
        "backgroundFetch",
        "backgroundImage",
        "backgroundOrigin",
        "backgroundPosition",
        "backgroundPositionX",
        "backgroundPositionY",
        "backgroundRepeat",
        "backgroundSize",
        "badInput",
        "badge",
        "balance",
        "baseArrayLayer",
        "baseFrequencyX",
        "baseFrequencyY",
        "baseLatency",
        "baseLayer",
        "baseMipLevel",
        "baseNode",
        "baseOffset",
        "basePalette",
        "baseURI",
        "baseVal",
        "baseline-source",
        "baselineShift",
        "baselineSource",
        "battery",
        "bday",
        "before",
        "beginComputePass",
        "beginElement",
        "beginElementAt",
        "beginOcclusionQuery",
        "beginPath",
        "beginQuery",
        "beginRenderPass",
        "beginTransformFeedback",
        "beginningOfPassWriteIndex",
        "behavior",
        "behaviorCookie",
        "behaviorPart",
        "behaviorUrns",
        "beta",
        "bezierCurveTo",
        "bgColor",
        "bgProperties",
        "bias",
        "big",
        "bigint64",
        "biguint64",
        "binaryType",
        "bind",
        "bindAttribLocation",
        "bindBuffer",
        "bindBufferBase",
        "bindBufferRange",
        "bindFramebuffer",
        "bindGroupLayouts",
        "bindRenderbuffer",
        "bindSampler",
        "bindTexture",
        "bindTransformFeedback",
        "bindVertexArray",
        "binding",
        "bitness",
        "blend",
        "blendColor",
        "blendEquation",
        "blendEquationSeparate",
        "blendFunc",
        "blendFuncSeparate",
        "blink",
        "blitFramebuffer",
        "blob",
        "block-size",
        "blockDirection",
        "blockSize",
        "blockedURI",
        "blocking",
        "blockingDuration",
        "blue",
        "bluetooth",
        "blur",
        "body",
        "bodyUsed",
        "bold",
        "bookmarks",
        "booleanValue",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-end-end-radius",
        "border-end-start-radius",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-start-end-radius",
        "border-start-start-radius",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "borderBlock",
        "borderBlockColor",
        "borderBlockEnd",
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth",
        "borderBlockStart",
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth",
        "borderBlockStyle",
        "borderBlockWidth",
        "borderBottom",
        "borderBottomColor",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderBottomStyle",
        "borderBottomWidth",
        "borderBoxSize",
        "borderCollapse",
        "borderColor",
        "borderColorDark",
        "borderColorLight",
        "borderEndEndRadius",
        "borderEndStartRadius",
        "borderImage",
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth",
        "borderInline",
        "borderInlineColor",
        "borderInlineEnd",
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth",
        "borderInlineStart",
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth",
        "borderInlineStyle",
        "borderInlineWidth",
        "borderLeft",
        "borderLeftColor",
        "borderLeftStyle",
        "borderLeftWidth",
        "borderRadius",
        "borderRight",
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth",
        "borderSpacing",
        "borderStartEndRadius",
        "borderStartStartRadius",
        "borderStyle",
        "borderTop",
        "borderTopColor",
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderTopStyle",
        "borderTopWidth",
        "borderWidth",
        "bottom",
        "bottomMargin",
        "bound",
        "boundElements",
        "boundingClientRect",
        "boundingHeight",
        "boundingLeft",
        "boundingRect",
        "boundingTop",
        "boundingWidth",
        "bounds",
        "boundsGeometry",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "boxDecorationBreak",
        "boxShadow",
        "boxSizing",
        "brand",
        "brands",
        "break-after",
        "break-before",
        "break-inside",
        "breakAfter",
        "breakBefore",
        "breakInside",
        "broadcast",
        "browser",
        "browserLanguage",
        "browserSettings",
        "browsingData",
        "browsingTopics",
        "btoa",
        "bubbles",
        "buffer",
        "bufferData",
        "bufferDepth",
        "bufferSize",
        "bufferSubData",
        "buffered",
        "bufferedAmount",
        "bufferedAmountLowThreshold",
        "buffers",
        "buildID",
        "buildNumber",
        "button",
        "buttonID",
        "buttons",
        "byobRequest",
        "byteLength",
        "byteOffset",
        "bytes",
        "bytesPerRow",
        "bytesWritten",
        "c",
        "cache",
        "caches",
        "call",
        "caller",
        "camera",
        "canBeFormatted",
        "canBeMounted",
        "canBeShared",
        "canConstructInDedicatedWorker",
        "canGoBack",
        "canGoForward",
        "canHaveChildren",
        "canHaveHTML",
        "canInsertDTMF",
        "canIntercept",
        "canLoadAdAuctionFencedFrame",
        "canLoadOpaqueURL",
        "canMakePayment",
        "canParse",
        "canPlayType",
        "canPresent",
        "canShare",
        "canTransition",
        "canTrickleIceCandidates",
        "cancel",
        "cancelAndHoldAtTime",
        "cancelAnimationFrame",
        "cancelBubble",
        "cancelIdleCallback",
        "cancelScheduledValues",
        "cancelVideoFrameCallback",
        "cancelWatchAvailability",
        "cancelable",
        "candidate",
        "canonicalUUID",
        "canvas",
        "cap",
        "capabilities",
        "caption",
        "caption-side",
        "captionSide",
        "captivePortal",
        "capture",
        "captureEvents",
        "captureStackTrace",
        "captureStream",
        "captureTab",
        "captureVisibleTab",
        "caret-color",
        "caretBidiLevel",
        "caretColor",
        "caretPositionFromPoint",
        "caretRangeFromPoint",
        "cast",
        "catch",
        "category",
        "cbrt",
        "cd",
        "ceil",
        "cellIndex",
        "cellPadding",
        "cellSpacing",
        "cells",
        "ch",
        "chOff",
        "chain",
        "challenge",
        "changeType",
        "changed",
        "changedTouches",
        "channel",
        "channelCount",
        "channelCountMode",
        "channelInterpretation",
        "chapterInfo",
        "char",
        "charAt",
        "charCode",
        "charCodeAt",
        "charIndex",
        "charLength",
        "characterBounds",
        "characterBoundsRangeStart",
        "characterData",
        "characterDataOldValue",
        "characterSet",
        "characteristic",
        "charging",
        "chargingTime",
        "charset",
        "check",
        "checkDCE",
        "checkEnclosure",
        "checkFramebufferStatus",
        "checkIntersection",
        "checkValidity",
        "checkVisibility",
        "checked",
        "childElementCount",
        "childList",
        "childNodes",
        "children",
        "chrome",
        "ciphertext",
        "cite",
        "city",
        "claimInterface",
        "claimed",
        "classList",
        "className",
        "classid",
        "clear",
        "clearAppBadge",
        "clearAttributes",
        "clearBuffer",
        "clearBufferfi",
        "clearBufferfv",
        "clearBufferiv",
        "clearBufferuiv",
        "clearColor",
        "clearData",
        "clearDepth",
        "clearHalt",
        "clearImmediate",
        "clearInterval",
        "clearLiveSeekableRange",
        "clearMarks",
        "clearMaxGCPauseAccumulator",
        "clearMeasures",
        "clearOriginJoinedAdInterestGroups",
        "clearParameters",
        "clearRect",
        "clearResourceTimings",
        "clearShadow",
        "clearStencil",
        "clearTimeout",
        "clearValue",
        "clearWatch",
        "click",
        "clickCount",
        "clientDataJSON",
        "clientHeight",
        "clientInformation",
        "clientLeft",
        "clientRect",
        "clientRects",
        "clientTop",
        "clientWaitSync",
        "clientWidth",
        "clientX",
        "clientY",
        "clip",
        "clip-path",
        "clip-rule",
        "clipBottom",
        "clipLeft",
        "clipPath",
        "clipPathUnits",
        "clipRight",
        "clipRule",
        "clipTop",
        "clipboard",
        "clipboardData",
        "clonable",
        "clone",
        "cloneContents",
        "cloneNode",
        "cloneRange",
        "close",
        "closeCode",
        "closePath",
        "closed",
        "closest",
        "clz",
        "clz32",
        "cm",
        "cmp",
        "code",
        "codeBase",
        "codePointAt",
        "codeType",
        "codedHeight",
        "codedRect",
        "codedWidth",
        "colSpan",
        "collapse",
        "collapseToEnd",
        "collapseToStart",
        "collapsed",
        "collect",
        "collections",
        "colno",
        "color",
        "color-adjust",
        "color-interpolation",
        "color-interpolation-filters",
        "color-scheme",
        "colorAdjust",
        "colorAttachments",
        "colorDepth",
        "colorFormats",
        "colorInterpolation",
        "colorInterpolationFilters",
        "colorMask",
        "colorScheme",
        "colorSpace",
        "colorType",
        "cols",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columnCount",
        "columnFill",
        "columnGap",
        "columnNumber",
        "columnRule",
        "columnRuleColor",
        "columnRuleStyle",
        "columnRuleWidth",
        "columnSpan",
        "columnWidth",
        "columns",
        "command",
        "commands",
        "commit",
        "commitLoadTime",
        "commitPreferences",
        "commitStyles",
        "commonAncestorContainer",
        "compact",
        "compare",
        "compareBoundaryPoints",
        "compareDocumentPosition",
        "compareEndPoints",
        "compareExchange",
        "compareNode",
        "comparePoint",
        "compatMode",
        "compatible",
        "compile",
        "compileShader",
        "compileStreaming",
        "complete",
        "completed",
        "component",
        "componentFromPoint",
        "composed",
        "composedPath",
        "composite",
        "compositionEndOffset",
        "compositionStartOffset",
        "compressedTexImage2D",
        "compressedTexImage3D",
        "compressedTexSubImage2D",
        "compressedTexSubImage3D",
        "compute",
        "computedStyleMap",
        "concat",
        "conditionText",
        "coneInnerAngle",
        "coneOuterAngle",
        "coneOuterGain",
        "config",
        "configurable",
        "configuration",
        "configurationName",
        "configurationValue",
        "configurations",
        "configure",
        "confirm",
        "confirmComposition",
        "confirmSiteSpecificTrackingException",
        "confirmWebWideTrackingException",
        "congestionControl",
        "connect",
        "connectEnd",
        "connectNative",
        "connectShark",
        "connectStart",
        "connected",
        "connectedCallback",
        "connection",
        "connectionInfo",
        "connectionList",
        "connectionSpeed",
        "connectionState",
        "connections",
        "console",
        "consolidate",
        "constants",
        "constraint",
        "constrictionActive",
        "construct",
        "constructor",
        "contactID",
        "contain",
        "contain-intrinsic-block-size",
        "contain-intrinsic-height",
        "contain-intrinsic-inline-size",
        "contain-intrinsic-size",
        "contain-intrinsic-width",
        "containIntrinsicBlockSize",
        "containIntrinsicHeight",
        "containIntrinsicInlineSize",
        "containIntrinsicSize",
        "containIntrinsicWidth",
        "container",
        "container-name",
        "container-type",
        "containerId",
        "containerName",
        "containerQuery",
        "containerSrc",
        "containerType",
        "contains",
        "containsNode",
        "content",
        "content-visibility",
        "contentBoxSize",
        "contentDocument",
        "contentEditable",
        "contentHint",
        "contentOverflow",
        "contentRect",
        "contentScriptType",
        "contentStyleType",
        "contentType",
        "contentVisibility",
        "contentWindow",
        "context",
        "contextId",
        "contextIds",
        "contextMenu",
        "contextMenus",
        "contextType",
        "contextTypes",
        "contextmenu",
        "contextualIdentities",
        "continue",
        "continuePrimaryKey",
        "continuous",
        "control",
        "controlTransferIn",
        "controlTransferOut",
        "controller",
        "controls",
        "controlsList",
        "convertPointFromNode",
        "convertQuadFromNode",
        "convertRectFromNode",
        "convertToBlob",
        "convertToSpecifiedUnits",
        "cookie",
        "cookieEnabled",
        "cookieStore",
        "cookies",
        "coords",
        "copyBufferSubData",
        "copyBufferToBuffer",
        "copyBufferToTexture",
        "copyExternalImageToTexture",
        "copyFromChannel",
        "copyTexImage2D",
        "copyTexSubImage2D",
        "copyTexSubImage3D",
        "copyTextureToBuffer",
        "copyTextureToTexture",
        "copyTo",
        "copyToChannel",
        "copyWithin",
        "correspondingElement",
        "correspondingUseElement",
        "corruptedVideoFrames",
        "cos",
        "cosh",
        "count",
        "countReset",
        "counter-increment",
        "counter-reset",
        "counter-set",
        "counterIncrement",
        "counterReset",
        "counterSet",
        "country",
        "cpuClass",
        "cpuSleepAllowed",
        "cqb",
        "cqh",
        "cqi",
        "cqmax",
        "cqmin",
        "cqw",
        "create",
        "createAnalyser",
        "createAnchor",
        "createAnswer",
        "createAttribute",
        "createAttributeNS",
        "createAuctionNonce",
        "createBidirectionalStream",
        "createBindGroup",
        "createBindGroupLayout",
        "createBiquadFilter",
        "createBuffer",
        "createBufferSource",
        "createCDATASection",
        "createCSSStyleSheet",
        "createCaption",
        "createChannelMerger",
        "createChannelSplitter",
        "createCommandEncoder",
        "createComment",
        "createComputePipeline",
        "createComputePipelineAsync",
        "createConicGradient",
        "createConstantSource",
        "createContextualFragment",
        "createControlRange",
        "createConvolver",
        "createDTMFSender",
        "createDataChannel",
        "createDelay",
        "createDelayNode",
        "createDocument",
        "createDocumentFragment",
        "createDocumentType",
        "createDynamicsCompressor",
        "createElement",
        "createElementNS",
        "createEncodedStreams",
        "createEntityReference",
        "createEvent",
        "createEventObject",
        "createExpression",
        "createFramebuffer",
        "createFunction",
        "createGain",
        "createGainNode",
        "createHTML",
        "createHTMLDocument",
        "createIIRFilter",
        "createImageBitmap",
        "createImageData",
        "createIndex",
        "createJavaScriptNode",
        "createLinearGradient",
        "createMediaElementSource",
        "createMediaKeys",
        "createMediaStreamDestination",
        "createMediaStreamSource",
        "createMediaStreamTrackSource",
        "createMutableFile",
        "createNSResolver",
        "createNodeIterator",
        "createNotification",
        "createObjectStore",
        "createObjectURL",
        "createOffer",
        "createOscillator",
        "createPanner",
        "createPattern",
        "createPeriodicWave",
        "createPipelineLayout",
        "createPolicy",
        "createPopup",
        "createProcessingInstruction",
        "createProgram",
        "createQuery",
        "createQuerySet",
        "createRadialGradient",
        "createRange",
        "createRangeCollection",
        "createReader",
        "createRenderBundleEncoder",
        "createRenderPipeline",
        "createRenderPipelineAsync",
        "createRenderbuffer",
        "createSVGAngle",
        "createSVGLength",
        "createSVGMatrix",
        "createSVGNumber",
        "createSVGPathSegArcAbs",
        "createSVGPathSegArcRel",
        "createSVGPathSegClosePath",
        "createSVGPathSegCurvetoCubicAbs",
        "createSVGPathSegCurvetoCubicRel",
        "createSVGPathSegCurvetoCubicSmoothAbs",
        "createSVGPathSegCurvetoCubicSmoothRel",
        "createSVGPathSegCurvetoQuadraticAbs",
        "createSVGPathSegCurvetoQuadraticRel",
        "createSVGPathSegCurvetoQuadraticSmoothAbs",
        "createSVGPathSegCurvetoQuadraticSmoothRel",
        "createSVGPathSegLinetoAbs",
        "createSVGPathSegLinetoHorizontalAbs",
        "createSVGPathSegLinetoHorizontalRel",
        "createSVGPathSegLinetoRel",
        "createSVGPathSegLinetoVerticalAbs",
        "createSVGPathSegLinetoVerticalRel",
        "createSVGPathSegMovetoAbs",
        "createSVGPathSegMovetoRel",
        "createSVGPoint",
        "createSVGRect",
        "createSVGTransform",
        "createSVGTransformFromMatrix",
        "createSampler",
        "createScript",
        "createScriptProcessor",
        "createScriptURL",
        "createSession",
        "createShader",
        "createShaderModule",
        "createShadowRoot",
        "createStereoPanner",
        "createStyleSheet",
        "createTBody",
        "createTFoot",
        "createTHead",
        "createTask",
        "createTextNode",
        "createTextRange",
        "createTexture",
        "createTouch",
        "createTouchList",
        "createTransformFeedback",
        "createTreeWalker",
        "createUnidirectionalStream",
        "createVertexArray",
        "createView",
        "createWaveShaper",
        "createWorklet",
        "createWritable",
        "creationTime",
        "credentialless",
        "credentials",
        "criticalCHRestart",
        "cropTo",
        "crossOrigin",
        "crossOriginIsolated",
        "crypto",
        "csi",
        "csp",
        "cssFloat",
        "cssRules",
        "cssText",
        "cssValueType",
        "ctrlKey",
        "ctrlLeft",
        "cues",
        "cullFace",
        "cullMode",
        "currentCSSZoom",
        "currentDirection",
        "currentEntry",
        "currentLocalDescription",
        "currentNode",
        "currentPage",
        "currentRect",
        "currentRemoteDescription",
        "currentScale",
        "currentScreen",
        "currentScript",
        "currentSrc",
        "currentState",
        "currentStyle",
        "currentTarget",
        "currentTime",
        "currentTranslate",
        "currentView",
        "cursor",
        "curve",
        "customElements",
        "customError",
        "cx",
        "cy",
        "d",
        "data",
        "dataFld",
        "dataFormatAs",
        "dataLoss",
        "dataLossMessage",
        "dataPageSize",
        "dataSrc",
        "dataTransfer",
        "database",
        "databases",
        "datagrams",
        "dataset",
        "dateTime",
        "db",
        "debug",
        "debuggerEnabled",
        "declarativeNetRequest",
        "declare",
        "decode",
        "decodeAudioData",
        "decodeQueueSize",
        "decodeURI",
        "decodeURIComponent",
        "decodedBodySize",
        "decoding",
        "decodingInfo",
        "decrypt",
        "default",
        "defaultCharset",
        "defaultChecked",
        "defaultMuted",
        "defaultPlaybackRate",
        "defaultPolicy",
        "defaultPrevented",
        "defaultQueue",
        "defaultRequest",
        "defaultSelected",
        "defaultStatus",
        "defaultURL",
        "defaultValue",
        "defaultView",
        "defaultstatus",
        "defer",
        "define",
        "defineMagicFunction",
        "defineMagicVariable",
        "defineProperties",
        "defineProperty",
        "deg",
        "delay",
        "delayTime",
        "delegatesFocus",
        "delete",
        "deleteBuffer",
        "deleteCaption",
        "deleteCell",
        "deleteContents",
        "deleteData",
        "deleteDatabase",
        "deleteFramebuffer",
        "deleteFromDocument",
        "deleteIndex",
        "deleteMedium",
        "deleteObjectStore",
        "deleteProgram",
        "deleteProperty",
        "deleteQuery",
        "deleteRenderbuffer",
        "deleteRow",
        "deleteRule",
        "deleteSampler",
        "deleteShader",
        "deleteSync",
        "deleteTFoot",
        "deleteTHead",
        "deleteTexture",
        "deleteTransformFeedback",
        "deleteVertexArray",
        "deleted",
        "deliverChangeRecords",
        "deliveredFrames",
        "deliveredFramesDuration",
        "delivery",
        "deliveryInfo",
        "deliveryStatus",
        "deliveryTimestamp",
        "deliveryType",
        "delta",
        "deltaMode",
        "deltaX",
        "deltaY",
        "deltaZ",
        "dependentLocality",
        "deprecatedReplaceInURN",
        "deprecatedRunAdAuctionEnforcesKAnonymity",
        "deprecatedURNToURL",
        "depthBias",
        "depthBiasClamp",
        "depthBiasSlopeScale",
        "depthClearValue",
        "depthCompare",
        "depthDataFormat",
        "depthFailOp",
        "depthFar",
        "depthFunc",
        "depthLoadOp",
        "depthMask",
        "depthNear",
        "depthOrArrayLayers",
        "depthRange",
        "depthReadOnly",
        "depthStencil",
        "depthStencilAttachment",
        "depthStencilFormat",
        "depthStoreOp",
        "depthUsage",
        "depthWriteEnabled",
        "deref",
        "deriveBits",
        "deriveKey",
        "descentOverride",
        "description",
        "deselectAll",
        "designMode",
        "desiredSize",
        "destination",
        "destinationURL",
        "destroy",
        "detach",
        "detachEvent",
        "detachShader",
        "detached",
        "detail",
        "details",
        "detect",
        "detectLanguage",
        "detune",
        "device",
        "deviceClass",
        "deviceId",
        "deviceMemory",
        "devicePixelContentBoxSize",
        "devicePixelRatio",
        "deviceProtocol",
        "deviceSubclass",
        "deviceVersionMajor",
        "deviceVersionMinor",
        "deviceVersionSubminor",
        "deviceXDPI",
        "deviceYDPI",
        "devtools",
        "devtools_panels",
        "didTimeout",
        "difference",
        "diffuseConstant",
        "digest",
        "dimension",
        "dimensions",
        "dir",
        "dirName",
        "direction",
        "dirxml",
        "disable",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "disableVertexAttribArray",
        "disabled",
        "discard",
        "discardedFrames",
        "dischargingTime",
        "disconnect",
        "disconnectShark",
        "disconnectedCallback",
        "dispatchEvent",
        "dispatchWorkgroups",
        "dispatchWorkgroupsIndirect",
        "display",
        "displayHeight",
        "displayId",
        "displayName",
        "displayWidth",
        "dispose",
        "disposition",
        "distanceModel",
        "div",
        "divisor",
        "djsapi",
        "djsproxy",
        "dns",
        "doImport",
        "doNotTrack",
        "doScroll",
        "doctype",
        "document",
        "documentElement",
        "documentId",
        "documentIds",
        "documentLifecycle",
        "documentMode",
        "documentOrigin",
        "documentOrigins",
        "documentPictureInPicture",
        "documentURI",
        "documentUrl",
        "documentUrls",
        "dolphin",
        "dolphinGameCenter",
        "dolphininfo",
        "dolphinmeta",
        "dom",
        "domComplete",
        "domContentLoadedEventEnd",
        "domContentLoadedEventStart",
        "domInteractive",
        "domLoading",
        "domOverlayState",
        "domain",
        "domainLookupEnd",
        "domainLookupStart",
        "dominant-baseline",
        "dominantBaseline",
        "done",
        "dopplerFactor",
        "dotAll",
        "downDegrees",
        "downlink",
        "download",
        "downloadRequest",
        "downloadTotal",
        "downloaded",
        "downloads",
        "dpcm",
        "dpi",
        "dppx",
        "dragDrop",
        "draggable",
        "draw",
        "drawArrays",
        "drawArraysInstanced",
        "drawArraysInstancedANGLE",
        "drawBuffers",
        "drawCustomFocusRing",
        "drawElements",
        "drawElementsInstanced",
        "drawElementsInstancedANGLE",
        "drawFocusIfNeeded",
        "drawImage",
        "drawImageFromRect",
        "drawIndexed",
        "drawIndexedIndirect",
        "drawIndirect",
        "drawRangeElements",
        "drawSystemFocusRing",
        "drawingBufferColorSpace",
        "drawingBufferFormat",
        "drawingBufferHeight",
        "drawingBufferStorage",
        "drawingBufferWidth",
        "drop",
        "dropEffect",
        "droppedVideoFrames",
        "dropzone",
        "dstFactor",
        "dtmf",
        "dump",
        "dumpProfile",
        "duplex",
        "duplicate",
        "durability",
        "duration",
        "dvb",
        "dvh",
        "dvi",
        "dvmax",
        "dvmin",
        "dvname",
        "dvnum",
        "dvw",
        "dx",
        "dy",
        "dynamicId",
        "dynsrc",
        "e",
        "edgeMode",
        "editContext",
        "effect",
        "effectAllowed",
        "effectiveDirective",
        "effectiveType",
        "effects",
        "elapsedTime",
        "element",
        "elementFromPoint",
        "elementTiming",
        "elements",
        "elementsFromPoint",
        "elevation",
        "ellipse",
        "em",
        "emHeightAscent",
        "emHeightDescent",
        "email",
        "embeds",
        "emit",
        "emma",
        "empty",
        "empty-cells",
        "emptyCells",
        "emptyHTML",
        "emptyScript",
        "emulatedPosition",
        "enable",
        "enableBackground",
        "enableDelegations",
        "enableStyleSheetsForSet",
        "enableVertexAttribArray",
        "enabled",
        "enabledFeatures",
        "enabledPlugin",
        "encode",
        "encodeInto",
        "encodeQueueSize",
        "encodeURI",
        "encodeURIComponent",
        "encodedBodySize",
        "encoding",
        "encodingInfo",
        "encrypt",
        "enctype",
        "end",
        "endContainer",
        "endElement",
        "endElementAt",
        "endOcclusionQuery",
        "endOfPassWriteIndex",
        "endOfStream",
        "endOffset",
        "endQuery",
        "endTime",
        "endTransformFeedback",
        "ended",
        "endpoint",
        "endpointNumber",
        "endpoints",
        "endsWith",
        "enqueue",
        "enterKeyHint",
        "entities",
        "entries",
        "entry",
        "entryPoint",
        "entryType",
        "enumerable",
        "enumerate",
        "enumerateDevices",
        "enumerateEditable",
        "environmentBlendMode",
        "equals",
        "error",
        "errorCode",
        "errorDetail",
        "errorText",
        "escape",
        "estimate",
        "eval",
        "evaluate",
        "event",
        "eventCounts",
        "eventPhase",
        "events",
        "every",
        "ex",
        "exception",
        "exchange",
        "exec",
        "execCommand",
        "execCommandShowHelp",
        "execScript",
        "executeBundles",
        "executionStart",
        "exitFullscreen",
        "exitPictureInPicture",
        "exitPointerLock",
        "exitPresent",
        "exp",
        "expand",
        "expandEntityReferences",
        "expando",
        "expansion",
        "expectedImprovement",
        "experiments",
        "expiration",
        "expirationTime",
        "expires",
        "expiryDate",
        "explicitOriginalTarget",
        "expm1",
        "exponent",
        "exponentialRampToValueAtTime",
        "exportKey",
        "exports",
        "extend",
        "extension",
        "extensionTypes",
        "extensions",
        "extentNode",
        "extentOffset",
        "external",
        "externalResourcesRequired",
        "externalTexture",
        "extractContents",
        "extractable",
        "eye",
        "f",
        "f16round",
        "face",
        "factoryReset",
        "failOp",
        "failureReason",
        "fallback",
        "family",
        "familyName",
        "farthestViewportElement",
        "fastSeek",
        "fatal",
        "featureId",
        "featurePolicy",
        "featureSettings",
        "features",
        "fence",
        "fenceSync",
        "fetch",
        "fetchPriority",
        "fetchStart",
        "fftSize",
        "fgColor",
        "fieldOfView",
        "file",
        "fileCreatedDate",
        "fileHandle",
        "fileModifiedDate",
        "fileName",
        "fileSize",
        "fileUpdatedDate",
        "filename",
        "files",
        "filesystem",
        "fill",
        "fill-opacity",
        "fill-rule",
        "fillJointRadii",
        "fillLightMode",
        "fillOpacity",
        "fillPoses",
        "fillRect",
        "fillRule",
        "fillStyle",
        "fillText",
        "filter",
        "filterResX",
        "filterResY",
        "filterUnits",
        "filters",
        "finally",
        "find",
        "findIndex",
        "findLast",
        "findLastIndex",
        "findRule",
        "findText",
        "finish",
        "finishDocumentLoadTime",
        "finishLoadTime",
        "finished",
        "fireEvent",
        "firesTouchEvents",
        "firstChild",
        "firstElementChild",
        "firstInterimResponseStart",
        "firstPage",
        "firstPaintAfterLoadTime",
        "firstPaintTime",
        "firstUIEventTimestamp",
        "fixed",
        "flags",
        "flat",
        "flatMap",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "flexBasis",
        "flexDirection",
        "flexFlow",
        "flexGrow",
        "flexShrink",
        "flexWrap",
        "flipX",
        "flipY",
        "float",
        "float32",
        "float64",
        "flood-color",
        "flood-opacity",
        "floodColor",
        "floodOpacity",
        "floor",
        "flush",
        "focus",
        "focusNode",
        "focusOffset",
        "font",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-optical-sizing",
        "font-palette",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-synthesis-position",
        "font-synthesis-small-caps",
        "font-synthesis-style",
        "font-synthesis-weight",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "fontBoundingBoxAscent",
        "fontBoundingBoxDescent",
        "fontFamily",
        "fontFeatureSettings",
        "fontKerning",
        "fontLanguageOverride",
        "fontOpticalSizing",
        "fontPalette",
        "fontSize",
        "fontSizeAdjust",
        "fontSmoothingEnabled",
        "fontStretch",
        "fontStyle",
        "fontSynthesis",
        "fontSynthesisPosition",
        "fontSynthesisSmallCaps",
        "fontSynthesisStyle",
        "fontSynthesisWeight",
        "fontVariant",
        "fontVariantAlternates",
        "fontVariantCaps",
        "fontVariantEastAsian",
        "fontVariantLigatures",
        "fontVariantNumeric",
        "fontVariantPosition",
        "fontVariationSettings",
        "fontWeight",
        "fontcolor",
        "fontfaces",
        "fonts",
        "fontsize",
        "for",
        "forEach",
        "force",
        "forceFallbackAdapter",
        "forceRedraw",
        "forced-color-adjust",
        "forcedColorAdjust",
        "forcedStyleAndLayoutDuration",
        "forget",
        "form",
        "formAction",
        "formData",
        "formEnctype",
        "formMethod",
        "formNoValidate",
        "formTarget",
        "format",
        "formatToParts",
        "forms",
        "forward",
        "forwardX",
        "forwardY",
        "forwardZ",
        "foundation",
        "fr",
        "fragment",
        "fragmentDirective",
        "frame",
        "frameBorder",
        "frameCount",
        "frameElement",
        "frameId",
        "frameIds",
        "frameSpacing",
        "framebuffer",
        "framebufferHeight",
        "framebufferRenderbuffer",
        "framebufferTexture2D",
        "framebufferTextureLayer",
        "framebufferWidth",
        "frames",
        "freeSpace",
        "freeze",
        "frequency",
        "frequencyBinCount",
        "from",
        "fromAsync",
        "fromBase64",
        "fromCharCode",
        "fromCodePoint",
        "fromElement",
        "fromEntries",
        "fromFloat32Array",
        "fromFloat64Array",
        "fromHex",
        "fromMatrix",
        "fromPoint",
        "fromQuad",
        "fromRect",
        "frontFace",
        "fround",
        "fullName",
        "fullPath",
        "fullRange",
        "fullScreen",
        "fullVersionList",
        "fullscreen",
        "fullscreenElement",
        "fullscreenEnabled",
        "fx",
        "fy",
        "g",
        "gain",
        "gamepad",
        "gamma",
        "gap",
        "gatheringState",
        "gatt",
        "geckoProfiler",
        "genderIdentity",
        "generateCertificate",
        "generateKey",
        "generateMipmap",
        "generateRequest",
        "geolocation",
        "gestureObject",
        "get",
        "getAcceptLanguages",
        "getActiveAttrib",
        "getActiveUniform",
        "getActiveUniformBlockName",
        "getActiveUniformBlockParameter",
        "getActiveUniforms",
        "getAdjacentText",
        "getAll",
        "getAllKeys",
        "getAllResponseHeaders",
        "getAllowlistForFeature",
        "getAnimations",
        "getAsFile",
        "getAsFileSystemHandle",
        "getAsString",
        "getAttachedShaders",
        "getAttribLocation",
        "getAttribute",
        "getAttributeNS",
        "getAttributeNames",
        "getAttributeNode",
        "getAttributeNodeNS",
        "getAttributeType",
        "getAudioTracks",
        "getAuthenticatorData",
        "getAutoplayPolicy",
        "getAvailability",
        "getBBox",
        "getBackgroundPage",
        "getBadgeBackgroundColor",
        "getBadgeText",
        "getBadgeTextColor",
        "getBattery",
        "getBigInt64",
        "getBigUint64",
        "getBindGroupLayout",
        "getBlob",
        "getBookmark",
        "getBoundingClientRect",
        "getBounds",
        "getBoxQuads",
        "getBrowserInfo",
        "getBufferParameter",
        "getBufferSubData",
        "getByteFrequencyData",
        "getByteTimeDomainData",
        "getCSSCanvasContext",
        "getCTM",
        "getCameraImage",
        "getCandidateWindowClientRect",
        "getCanonicalLocales",
        "getCapabilities",
        "getCaptureHandle",
        "getChannelData",
        "getCharNumAtPosition",
        "getCharacteristic",
        "getCharacteristics",
        "getClientExtensionResults",
        "getClientRect",
        "getClientRects",
        "getCoalescedEvents",
        "getCompilationInfo",
        "getCompositionAlternatives",
        "getComputedStyle",
        "getComputedTextLength",
        "getComputedTiming",
        "getConfiguration",
        "getConstraints",
        "getContext",
        "getContextAttributes",
        "getContexts",
        "getContributingSources",
        "getCounterValue",
        "getCueAsHTML",
        "getCueById",
        "getCurrent",
        "getCurrentPosition",
        "getCurrentTexture",
        "getCurrentTime",
        "getData",
        "getDatabaseNames",
        "getDate",
        "getDay",
        "getDefaultComputedStyle",
        "getDepthInMeters",
        "getDepthInformation",
        "getDescriptor",
        "getDescriptors",
        "getDestinationInsertionPoints",
        "getDevices",
        "getDirectory",
        "getDirectoryHandle",
        "getDisplayMedia",
        "getDistributedNodes",
        "getEditable",
        "getElementById",
        "getElementsByClassName",
        "getElementsByName",
        "getElementsByTagName",
        "getElementsByTagNameNS",
        "getEnclosureList",
        "getEndPositionOfChar",
        "getEntries",
        "getEntriesByName",
        "getEntriesByType",
        "getError",
        "getExtension",
        "getExtentOfChar",
        "getEyeParameters",
        "getFeature",
        "getFiberRoots",
        "getFile",
        "getFileHandle",
        "getFiles",
        "getFilesAndDirectories",
        "getFingerprints",
        "getFloat16",
        "getFloat32",
        "getFloat64",
        "getFloatFrequencyData",
        "getFloatTimeDomainData",
        "getFloatValue",
        "getFragDataLocation",
        "getFrameData",
        "getFrameId",
        "getFramebufferAttachmentParameter",
        "getFrequencyResponse",
        "getFullYear",
        "getGamepads",
        "getHTML",
        "getHeaderExtensionsToNegotiate",
        "getHighEntropyValues",
        "getHitTestResults",
        "getHitTestResultsForTransientInput",
        "getHours",
        "getIdentityAssertion",
        "getIds",
        "getImageData",
        "getIndexedParameter",
        "getInfo",
        "getInnerHTML",
        "getInstalledRelatedApps",
        "getInt16",
        "getInt32",
        "getInt8",
        "getInterestGroupAdAuctionData",
        "getInternalModuleRanges",
        "getInternalformatParameter",
        "getIntersectionList",
        "getItem",
        "getItems",
        "getJointPose",
        "getKey",
        "getKeyframes",
        "getLastFocused",
        "getLayers",
        "getLayoutMap",
        "getLightEstimate",
        "getLineDash",
        "getLocalCandidates",
        "getLocalParameters",
        "getLocalStreams",
        "getManagedConfiguration",
        "getManifest",
        "getMappedRange",
        "getMarks",
        "getMatchedCSSRules",
        "getMaxGCPauseSinceClear",
        "getMeasures",
        "getMessage",
        "getMetadata",
        "getMilliseconds",
        "getMinutes",
        "getModifierState",
        "getMonth",
        "getName",
        "getNamedItem",
        "getNamedItemNS",
        "getNativeFramebufferScaleFactor",
        "getNegotiatedHeaderExtensions",
        "getNestedConfigs",
        "getNotifications",
        "getNotifier",
        "getNumberOfChars",
        "getOffsetReferenceSpace",
        "getOutputTimestamp",
        "getOverrideHistoryNavigationMode",
        "getOverrideStyle",
        "getOwnPropertyDescriptor",
        "getOwnPropertyDescriptors",
        "getOwnPropertyNames",
        "getOwnPropertySymbols",
        "getPackageDirectoryEntry",
        "getParameter",
        "getParameters",
        "getParent",
        "getPathSegAtLength",
        "getPermissionWarningsByManifest",
        "getPhotoCapabilities",
        "getPhotoSettings",
        "getPlatformInfo",
        "getPointAtLength",
        "getPopup",
        "getPorts",
        "getPose",
        "getPredictedEvents",
        "getPreference",
        "getPreferenceDefault",
        "getPreferredCanvasFormat",
        "getPresentationAttribute",
        "getPreventDefault",
        "getPrimaryService",
        "getPrimaryServices",
        "getProgramInfoLog",
        "getProgramParameter",
        "getPropertyCSSValue",
        "getPropertyPriority",
        "getPropertyShorthand",
        "getPropertyType",
        "getPropertyValue",
        "getPrototypeOf",
        "getPublicKey",
        "getPublicKeyAlgorithm",
        "getQuery",
        "getQueryParameter",
        "getRGBColorValue",
        "getRandomValues",
        "getRangeAt",
        "getReader",
        "getReceivers",
        "getRectValue",
        "getReflectionCubeMap",
        "getRegistration",
        "getRegistrations",
        "getRemoteCandidates",
        "getRemoteCertificates",
        "getRemoteParameters",
        "getRemoteStreams",
        "getRenderbufferParameter",
        "getResponseHeader",
        "getRoot",
        "getRootNode",
        "getRotationOfChar",
        "getSVGDocument",
        "getSamplerParameter",
        "getScreenCTM",
        "getScreenDetails",
        "getSeconds",
        "getSelectedCandidatePair",
        "getSelection",
        "getSelf",
        "getSenders",
        "getService",
        "getSetCookie",
        "getSettings",
        "getShaderInfoLog",
        "getShaderParameter",
        "getShaderPrecisionFormat",
        "getShaderSource",
        "getSignals",
        "getSimpleDuration",
        "getSiteIcons",
        "getSources",
        "getSpeculativeParserUrls",
        "getStartPositionOfChar",
        "getStartTime",
        "getState",
        "getStats",
        "getStatusForPolicy",
        "getStorageUpdates",
        "getStreamById",
        "getStringValue",
        "getSubStringLength",
        "getSubscription",
        "getSubscriptions",
        "getSupportedConstraints",
        "getSupportedExtensions",
        "getSupportedFormats",
        "getSyncParameter",
        "getSynchronizationSources",
        "getTags",
        "getTargetRanges",
        "getTexParameter",
        "getTextFormats",
        "getTime",
        "getTimezoneOffset",
        "getTiming",
        "getTitle",
        "getTitlebarAreaRect",
        "getTotalLength",
        "getTrackById",
        "getTracks",
        "getTransceivers",
        "getTransform",
        "getTransformFeedbackVarying",
        "getTransformToElement",
        "getTransports",
        "getType",
        "getTypeMapping",
        "getUILanguage",
        "getURL",
        "getUTCDate",
        "getUTCDay",
        "getUTCFullYear",
        "getUTCHours",
        "getUTCMilliseconds",
        "getUTCMinutes",
        "getUTCMonth",
        "getUTCSeconds",
        "getUint16",
        "getUint32",
        "getUint8",
        "getUniform",
        "getUniformBlockIndex",
        "getUniformIndices",
        "getUniformLocation",
        "getUserInfo",
        "getUserMedia",
        "getUserSettings",
        "getVRDisplays",
        "getValues",
        "getVarDate",
        "getVariableValue",
        "getVertexAttrib",
        "getVertexAttribOffset",
        "getVideoPlaybackQuality",
        "getVideoTracks",
        "getViewerPose",
        "getViewport",
        "getViews",
        "getVoices",
        "getWakeLockState",
        "getWriter",
        "getYear",
        "getZoom",
        "getZoomSettings",
        "givenName",
        "global",
        "globalAlpha",
        "globalCompositeOperation",
        "globalPrivacyControl",
        "globalThis",
        "glyphOrientationHorizontal",
        "glyphOrientationVertical",
        "glyphRef",
        "go",
        "goBack",
        "goForward",
        "gpu",
        "grabFrame",
        "grad",
        "gradientTransform",
        "gradientUnits",
        "grammars",
        "green",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-gap",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-gap",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "gridArea",
        "gridAutoColumns",
        "gridAutoFlow",
        "gridAutoRows",
        "gridColumn",
        "gridColumnEnd",
        "gridColumnGap",
        "gridColumnStart",
        "gridGap",
        "gridRow",
        "gridRowEnd",
        "gridRowGap",
        "gridRowStart",
        "gridTemplate",
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows",
        "gripSpace",
        "group",
        "groupBy",
        "groupCollapsed",
        "groupEnd",
        "groupId",
        "groups",
        "grow",
        "growable",
        "guestProcessId",
        "guestRenderFrameRoutingId",
        "hadRecentInput",
        "hand",
        "handedness",
        "hangingBaseline",
        "hapticActuators",
        "hardwareConcurrency",
        "has",
        "hasAttribute",
        "hasAttributeNS",
        "hasAttributes",
        "hasBeenActive",
        "hasChildNodes",
        "hasComposition",
        "hasDynamicOffset",
        "hasEnrolledInstrument",
        "hasExtension",
        "hasExternalDisplay",
        "hasFeature",
        "hasFocus",
        "hasIndices",
        "hasInstance",
        "hasLayout",
        "hasOrientation",
        "hasOwn",
        "hasOwnProperty",
        "hasPointerCapture",
        "hasPosition",
        "hasPrivateToken",
        "hasReading",
        "hasRedemptionRecord",
        "hasRegExpGroups",
        "hasStorageAccess",
        "hasUAVisualTransition",
        "hasUnpartitionedCookieAccess",
        "hash",
        "hashChange",
        "head",
        "headers",
        "heading",
        "height",
        "hid",
        "hidden",
        "hide",
        "hideFocus",
        "hidePopover",
        "high",
        "highWaterMark",
        "highlight",
        "highlights",
        "hint",
        "hints",
        "history",
        "honorificPrefix",
        "honorificSuffix",
        "horizontalOverflow",
        "host",
        "hostCandidate",
        "hostname",
        "href",
        "hrefTranslate",
        "hreflang",
        "hspace",
        "html5TagCheckInerface",
        "htmlFor",
        "htmlText",
        "httpEquiv",
        "httpRequestStatusCode",
        "hwTimestamp",
        "hyphenate-character",
        "hyphenateCharacter",
        "hyphens",
        "hypot",
        "i18n",
        "ic",
        "iccId",
        "iceConnectionState",
        "iceGatheringState",
        "iceTransport",
        "icon",
        "iconURL",
        "id",
        "identifier",
        "identity",
        "ideographicBaseline",
        "idle",
        "idpLoginUrl",
        "ignoreBOM",
        "ignoreCase",
        "ignoreDepthValues",
        "image",
        "image-orientation",
        "image-rendering",
        "imageHeight",
        "imageOrientation",
        "imageRendering",
        "imageSizes",
        "imageSmoothingEnabled",
        "imageSmoothingQuality",
        "imageSrcset",
        "imageWidth",
        "images",
        "ime-mode",
        "imeMode",
        "implementation",
        "importExternalTexture",
        "importKey",
        "importNode",
        "importStylesheet",
        "imports",
        "impp",
        "imul",
        "in",
        "in1",
        "in2",
        "inBandMetadataTrackDispatchType",
        "inIncognitoContext",
        "inRange",
        "includes",
        "incognito",
        "incomingBidirectionalStreams",
        "incomingHighWaterMark",
        "incomingMaxAge",
        "incomingUnidirectionalStreams",
        "incremental",
        "indeterminate",
        "index",
        "indexNames",
        "indexOf",
        "indexedDB",
        "indicate",
        "indices",
        "inert",
        "inertiaDestinationX",
        "inertiaDestinationY",
        "info",
        "inherits",
        "init",
        "initAnimationEvent",
        "initBeforeLoadEvent",
        "initClipboardEvent",
        "initCloseEvent",
        "initCommandEvent",
        "initCompositionEvent",
        "initCustomEvent",
        "initData",
        "initDataType",
        "initDeviceMotionEvent",
        "initDeviceOrientationEvent",
        "initDragEvent",
        "initErrorEvent",
        "initEvent",
        "initFocusEvent",
        "initGestureEvent",
        "initHashChangeEvent",
        "initKeyEvent",
        "initKeyboardEvent",
        "initMSManipulationEvent",
        "initMessageEvent",
        "initMouseEvent",
        "initMouseScrollEvent",
        "initMouseWheelEvent",
        "initMutationEvent",
        "initNSMouseEvent",
        "initOverflowEvent",
        "initPageEvent",
        "initPageTransitionEvent",
        "initPointerEvent",
        "initPopStateEvent",
        "initProgressEvent",
        "initScrollAreaEvent",
        "initSimpleGestureEvent",
        "initStorageEvent",
        "initTextEvent",
        "initTimeEvent",
        "initTouchEvent",
        "initTransitionEvent",
        "initUIEvent",
        "initWebKitAnimationEvent",
        "initWebKitTransitionEvent",
        "initWebKitWheelEvent",
        "initWheelEvent",
        "initialTime",
        "initialValue",
        "initialize",
        "initiatorType",
        "inject",
        "ink",
        "inline-size",
        "inlineSize",
        "inlineVerticalFieldOfView",
        "inner",
        "innerHTML",
        "innerHeight",
        "innerText",
        "innerWidth",
        "input",
        "inputBuffer",
        "inputEncoding",
        "inputMethod",
        "inputMode",
        "inputSource",
        "inputSources",
        "inputType",
        "inputs",
        "insertAdjacentElement",
        "insertAdjacentHTML",
        "insertAdjacentText",
        "insertBefore",
        "insertCell",
        "insertDTMF",
        "insertData",
        "insertDebugMarker",
        "insertItemBefore",
        "insertNode",
        "insertRow",
        "insertRule",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "insetBlock",
        "insetBlockEnd",
        "insetBlockStart",
        "insetInline",
        "insetInlineEnd",
        "insetInlineStart",
        "install",
        "installing",
        "instanceRoot",
        "instantiate",
        "instantiateStreaming",
        "instruments",
        "int16",
        "int32",
        "int8",
        "integrity",
        "interactionId",
        "interactionMode",
        "intercept",
        "interfaceClass",
        "interfaceName",
        "interfaceNumber",
        "interfaceProtocol",
        "interfaceSubclass",
        "interfaces",
        "interimResults",
        "internalSubset",
        "interpretation",
        "intersection",
        "intersectionRatio",
        "intersectionRect",
        "intersectsNode",
        "interval",
        "invalidIteratorState",
        "invalidateFramebuffer",
        "invalidateSubFramebuffer",
        "inverse",
        "invertSelf",
        "invoker",
        "invokerType",
        "is",
        "is2D",
        "isActive",
        "isAllowedFileSchemeAccess",
        "isAllowedIncognitoAccess",
        "isAlternate",
        "isArray",
        "isAutoSelected",
        "isBingCurrentSearchDefault",
        "isBuffer",
        "isCandidateWindowVisible",
        "isChar",
        "isCollapsed",
        "isComposing",
        "isConcatSpreadable",
        "isConditionalMediationAvailable",
        "isConfigSupported",
        "isConnected",
        "isContentEditable",
        "isContentHandlerRegistered",
        "isContextLost",
        "isDefaultNamespace",
        "isDirectory",
        "isDisabled",
        "isDisjointFrom",
        "isEnabled",
        "isEqual",
        "isEqualNode",
        "isExtended",
        "isExtensible",
        "isExternalCTAP2SecurityKeySupported",
        "isFallbackAdapter",
        "isFile",
        "isFinite",
        "isFirstPersonObserver",
        "isFramebuffer",
        "isFrozen",
        "isGenerator",
        "isHTML",
        "isHistoryNavigation",
        "isId",
        "isIdentity",
        "isInjected",
        "isInputPending",
        "isInteger",
        "isInternal",
        "isIntersecting",
        "isLockFree",
        "isMap",
        "isMultiLine",
        "isNaN",
        "isOpen",
        "isPointInFill",
        "isPointInPath",
        "isPointInRange",
        "isPointInStroke",
        "isPrefAlternate",
        "isPresenting",
        "isPrimary",
        "isProgram",
        "isPropertyImplicit",
        "isProtocolHandlerRegistered",
        "isPrototypeOf",
        "isQuery",
        "isRawJSON",
        "isRenderbuffer",
        "isSafeInteger",
        "isSameEntry",
        "isSameNode",
        "isSampler",
        "isScript",
        "isScriptURL",
        "isSealed",
        "isSecureContext",
        "isSessionSupported",
        "isShader",
        "isSubsetOf",
        "isSupersetOf",
        "isSupported",
        "isSync",
        "isTextEdit",
        "isTexture",
        "isTransformFeedback",
        "isTrusted",
        "isTypeSupported",
        "isUserVerifyingPlatformAuthenticatorAvailable",
        "isVertexArray",
        "isView",
        "isVisible",
        "isWellFormed",
        "isochronousTransferIn",
        "isochronousTransferOut",
        "isolation",
        "italics",
        "item",
        "itemId",
        "itemProp",
        "itemRef",
        "itemScope",
        "itemType",
        "itemValue",
        "items",
        "iterateNext",
        "iterationComposite",
        "iterator",
        "javaEnabled",
        "jitterBufferTarget",
        "jobTitle",
        "join",
        "joinAdInterestGroup",
        "jointName",
        "json",
        "justify-content",
        "justify-items",
        "justify-self",
        "justifyContent",
        "justifyItems",
        "justifySelf",
        "k1",
        "k2",
        "k3",
        "k4",
        "kHz",
        "keepalive",
        "kernelMatrix",
        "kernelUnitLengthX",
        "kernelUnitLengthY",
        "kerning",
        "key",
        "keyCode",
        "keyFor",
        "keyIdentifier",
        "keyLightEnabled",
        "keyLocation",
        "keyPath",
        "keyStatuses",
        "keySystem",
        "keyText",
        "keyUsage",
        "keyboard",
        "keys",
        "keytype",
        "kind",
        "knee",
        "knownSources",
        "label",
        "labels",
        "lang",
        "language",
        "languages",
        "largeArcFlag",
        "lastChild",
        "lastElementChild",
        "lastError",
        "lastEventId",
        "lastIndex",
        "lastIndexOf",
        "lastInputTime",
        "lastMatch",
        "lastMessageSubject",
        "lastMessageType",
        "lastModified",
        "lastModifiedDate",
        "lastPage",
        "lastParen",
        "lastState",
        "lastStyleSheetSet",
        "latency",
        "latitude",
        "launchQueue",
        "layerName",
        "layerX",
        "layerY",
        "layout",
        "layoutFlow",
        "layoutGrid",
        "layoutGridChar",
        "layoutGridLine",
        "layoutGridMode",
        "layoutGridType",
        "lbound",
        "leaveAdInterestGroup",
        "left",
        "leftContext",
        "leftDegrees",
        "leftMargin",
        "leftProjectionMatrix",
        "leftViewMatrix",
        "length",
        "lengthAdjust",
        "lengthComputable",
        "letter-spacing",
        "letterSpacing",
        "level",
        "lh",
        "lighting-color",
        "lightingColor",
        "limitingConeAngle",
        "limits",
        "line",
        "line-break",
        "line-height",
        "lineAlign",
        "lineBreak",
        "lineCap",
        "lineDashOffset",
        "lineGapOverride",
        "lineHeight",
        "lineJoin",
        "lineNum",
        "lineNumber",
        "linePos",
        "lineTo",
        "lineWidth",
        "linearAcceleration",
        "linearRampToValueAtTime",
        "linearVelocity",
        "lineno",
        "lines",
        "link",
        "linkColor",
        "linkProgram",
        "links",
        "list",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "listStyle",
        "listStyleImage",
        "listStylePosition",
        "listStyleType",
        "listener",
        "listeners",
        "load",
        "loadEventEnd",
        "loadEventStart",
        "loadOp",
        "loadTime",
        "loadTimes",
        "loaded",
        "loading",
        "localDescription",
        "localName",
        "localService",
        "localStorage",
        "locale",
        "localeCompare",
        "location",
        "locationbar",
        "lock",
        "locked",
        "lockedFile",
        "locks",
        "lodMaxClamp",
        "lodMinClamp",
        "log",
        "log10",
        "log1p",
        "log2",
        "logicalXDPI",
        "logicalYDPI",
        "login",
        "loglevel",
        "longDesc",
        "longitude",
        "lookupNamespaceURI",
        "lookupPrefix",
        "loop",
        "loopEnd",
        "loopStart",
        "looping",
        "lost",
        "low",
        "lower",
        "lowerBound",
        "lowerOpen",
        "lowsrc",
        "lvb",
        "lvh",
        "lvi",
        "lvmax",
        "lvmin",
        "lvw",
        "m11",
        "m12",
        "m13",
        "m14",
        "m21",
        "m22",
        "m23",
        "m24",
        "m31",
        "m32",
        "m33",
        "m34",
        "m41",
        "m42",
        "m43",
        "m44",
        "magFilter",
        "makeXRCompatible",
        "managed",
        "management",
        "manifest",
        "manufacturer",
        "manufacturerName",
        "map",
        "mapAsync",
        "mapState",
        "mappedAtCreation",
        "mapping",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marginBlock",
        "marginBlockEnd",
        "marginBlockStart",
        "marginBottom",
        "marginHeight",
        "marginInline",
        "marginInlineEnd",
        "marginInlineStart",
        "marginLeft",
        "marginRight",
        "marginTop",
        "marginWidth",
        "mark",
        "marker",
        "marker-end",
        "marker-mid",
        "marker-offset",
        "marker-start",
        "markerEnd",
        "markerHeight",
        "markerMid",
        "markerOffset",
        "markerStart",
        "markerUnits",
        "markerWidth",
        "marks",
        "mask",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-position-x",
        "mask-position-y",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "maskClip",
        "maskComposite",
        "maskContentUnits",
        "maskImage",
        "maskMode",
        "maskOrigin",
        "maskPosition",
        "maskPositionX",
        "maskPositionY",
        "maskRepeat",
        "maskSize",
        "maskType",
        "maskUnits",
        "match",
        "matchAll",
        "matchMedia",
        "matchMedium",
        "matchPatterns",
        "matches",
        "math-depth",
        "math-style",
        "mathDepth",
        "mathStyle",
        "matrix",
        "matrixTransform",
        "max",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "maxActions",
        "maxAlternatives",
        "maxAnisotropy",
        "maxBindGroups",
        "maxBindGroupsPlusVertexBuffers",
        "maxBindingsPerBindGroup",
        "maxBlockSize",
        "maxBufferSize",
        "maxByteLength",
        "maxChannelCount",
        "maxChannels",
        "maxColorAttachmentBytesPerSample",
        "maxColorAttachments",
        "maxComputeInvocationsPerWorkgroup",
        "maxComputeWorkgroupSizeX",
        "maxComputeWorkgroupSizeY",
        "maxComputeWorkgroupSizeZ",
        "maxComputeWorkgroupStorageSize",
        "maxComputeWorkgroupsPerDimension",
        "maxConnectionsPerServer",
        "maxDatagramSize",
        "maxDecibels",
        "maxDistance",
        "maxDrawCount",
        "maxDynamicStorageBuffersPerPipelineLayout",
        "maxDynamicUniformBuffersPerPipelineLayout",
        "maxHeight",
        "maxInlineSize",
        "maxInterStageShaderComponents",
        "maxInterStageShaderVariables",
        "maxLayers",
        "maxLength",
        "maxMessageSize",
        "maxPacketLifeTime",
        "maxRetransmits",
        "maxSampledTexturesPerShaderStage",
        "maxSamplersPerShaderStage",
        "maxStorageBufferBindingSize",
        "maxStorageBuffersPerShaderStage",
        "maxStorageTexturesPerShaderStage",
        "maxTextureArrayLayers",
        "maxTextureDimension1D",
        "maxTextureDimension2D",
        "maxTextureDimension3D",
        "maxTouchPoints",
        "maxUniformBufferBindingSize",
        "maxUniformBuffersPerShaderStage",
        "maxValue",
        "maxVertexAttributes",
        "maxVertexBufferArrayStride",
        "maxVertexBuffers",
        "maxWidth",
        "maximumLatency",
        "measure",
        "measureText",
        "media",
        "mediaCapabilities",
        "mediaDevices",
        "mediaElement",
        "mediaGroup",
        "mediaKeys",
        "mediaSession",
        "mediaStream",
        "mediaText",
        "meetOrSlice",
        "memory",
        "menubar",
        "menus",
        "menusChild",
        "menusInternal",
        "mergeAttributes",
        "message",
        "messageClass",
        "messageHandlers",
        "messageType",
        "messages",
        "metaKey",
        "metadata",
        "method",
        "methodDetails",
        "methodName",
        "mid",
        "mimeType",
        "mimeTypes",
        "min",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "minBindingSize",
        "minBlockSize",
        "minDecibels",
        "minFilter",
        "minHeight",
        "minInlineSize",
        "minLength",
        "minStorageBufferOffsetAlignment",
        "minUniformBufferOffsetAlignment",
        "minValue",
        "minWidth",
        "minimumLatency",
        "mipLevel",
        "mipLevelCount",
        "mipmapFilter",
        "miterLimit",
        "mix-blend-mode",
        "mixBlendMode",
        "mm",
        "mobile",
        "mode",
        "model",
        "modify",
        "module",
        "mount",
        "move",
        "moveBy",
        "moveEnd",
        "moveFirst",
        "moveFocusDown",
        "moveFocusLeft",
        "moveFocusRight",
        "moveFocusUp",
        "moveInSuccession",
        "moveNext",
        "moveRow",
        "moveStart",
        "moveTo",
        "moveToBookmark",
        "moveToElementText",
        "moveToPoint",
        "movementX",
        "movementY",
        "mozAdd",
        "mozAnimationStartTime",
        "mozAnon",
        "mozApps",
        "mozAudioCaptured",
        "mozAudioChannelType",
        "mozAutoplayEnabled",
        "mozCancelAnimationFrame",
        "mozCancelFullScreen",
        "mozCancelRequestAnimationFrame",
        "mozCaptureStream",
        "mozCaptureStreamUntilEnded",
        "mozClearDataAt",
        "mozContact",
        "mozContacts",
        "mozCreateFileHandle",
        "mozCurrentTransform",
        "mozCurrentTransformInverse",
        "mozCursor",
        "mozDash",
        "mozDashOffset",
        "mozDecodedFrames",
        "mozExitPointerLock",
        "mozFillRule",
        "mozFragmentEnd",
        "mozFrameDelay",
        "mozFullScreen",
        "mozFullScreenElement",
        "mozFullScreenEnabled",
        "mozGetAll",
        "mozGetAllKeys",
        "mozGetAsFile",
        "mozGetDataAt",
        "mozGetMetadata",
        "mozGetUserMedia",
        "mozHasAudio",
        "mozHasItem",
        "mozHidden",
        "mozImageSmoothingEnabled",
        "mozIndexedDB",
        "mozInnerScreenX",
        "mozInnerScreenY",
        "mozInputSource",
        "mozIsTextField",
        "mozItem",
        "mozItemCount",
        "mozItems",
        "mozLength",
        "mozLockOrientation",
        "mozMatchesSelector",
        "mozMovementX",
        "mozMovementY",
        "mozOpaque",
        "mozOrientation",
        "mozPaintCount",
        "mozPaintedFrames",
        "mozParsedFrames",
        "mozPay",
        "mozPointerLockElement",
        "mozPresentedFrames",
        "mozPreservesPitch",
        "mozPressure",
        "mozPrintCallback",
        "mozRTCIceCandidate",
        "mozRTCPeerConnection",
        "mozRTCSessionDescription",
        "mozRemove",
        "mozRequestAnimationFrame",
        "mozRequestFullScreen",
        "mozRequestPointerLock",
        "mozSetDataAt",
        "mozSetImageElement",
        "mozSourceNode",
        "mozSrcObject",
        "mozSystem",
        "mozTCPSocket",
        "mozTextStyle",
        "mozTypesAt",
        "mozUnlockOrientation",
        "mozUserCancelled",
        "mozVisibilityState",
        "ms",
        "msAnimation",
        "msAnimationDelay",
        "msAnimationDirection",
        "msAnimationDuration",
        "msAnimationFillMode",
        "msAnimationIterationCount",
        "msAnimationName",
        "msAnimationPlayState",
        "msAnimationStartTime",
        "msAnimationTimingFunction",
        "msBackfaceVisibility",
        "msBlockProgression",
        "msCSSOMElementFloatMetrics",
        "msCaching",
        "msCachingEnabled",
        "msCancelRequestAnimationFrame",
        "msCapsLockWarningOff",
        "msClearImmediate",
        "msClose",
        "msContentZoomChaining",
        "msContentZoomFactor",
        "msContentZoomLimit",
        "msContentZoomLimitMax",
        "msContentZoomLimitMin",
        "msContentZoomSnap",
        "msContentZoomSnapPoints",
        "msContentZoomSnapType",
        "msContentZooming",
        "msConvertURL",
        "msCrypto",
        "msDoNotTrack",
        "msElementsFromPoint",
        "msElementsFromRect",
        "msExitFullscreen",
        "msExtendedCode",
        "msFillRule",
        "msFirstPaint",
        "msFlex",
        "msFlexAlign",
        "msFlexDirection",
        "msFlexFlow",
        "msFlexItemAlign",
        "msFlexLinePack",
        "msFlexNegative",
        "msFlexOrder",
        "msFlexPack",
        "msFlexPositive",
        "msFlexPreferredSize",
        "msFlexWrap",
        "msFlowFrom",
        "msFlowInto",
        "msFontFeatureSettings",
        "msFullscreenElement",
        "msFullscreenEnabled",
        "msGetInputContext",
        "msGetRegionContent",
        "msGetUntransformedBounds",
        "msGraphicsTrustStatus",
        "msGridColumn",
        "msGridColumnAlign",
        "msGridColumnSpan",
        "msGridColumns",
        "msGridRow",
        "msGridRowAlign",
        "msGridRowSpan",
        "msGridRows",
        "msHidden",
        "msHighContrastAdjust",
        "msHyphenateLimitChars",
        "msHyphenateLimitLines",
        "msHyphenateLimitZone",
        "msHyphens",
        "msImageSmoothingEnabled",
        "msImeAlign",
        "msIndexedDB",
        "msInterpolationMode",
        "msIsStaticHTML",
        "msKeySystem",
        "msKeys",
        "msLaunchUri",
        "msLockOrientation",
        "msManipulationViewsEnabled",
        "msMatchMedia",
        "msMatchesSelector",
        "msMaxTouchPoints",
        "msOrientation",
        "msOverflowStyle",
        "msPerspective",
        "msPerspectiveOrigin",
        "msPlayToDisabled",
        "msPlayToPreferredSourceUri",
        "msPlayToPrimary",
        "msPointerEnabled",
        "msRegionOverflow",
        "msReleasePointerCapture",
        "msRequestAnimationFrame",
        "msRequestFullscreen",
        "msSaveBlob",
        "msSaveOrOpenBlob",
        "msScrollChaining",
        "msScrollLimit",
        "msScrollLimitXMax",
        "msScrollLimitXMin",
        "msScrollLimitYMax",
        "msScrollLimitYMin",
        "msScrollRails",
        "msScrollSnapPointsX",
        "msScrollSnapPointsY",
        "msScrollSnapType",
        "msScrollSnapX",
        "msScrollSnapY",
        "msScrollTranslation",
        "msSetImmediate",
        "msSetMediaKeys",
        "msSetPointerCapture",
        "msTextCombineHorizontal",
        "msTextSizeAdjust",
        "msToBlob",
        "msTouchAction",
        "msTouchSelect",
        "msTraceAsyncCallbackCompleted",
        "msTraceAsyncCallbackStarting",
        "msTraceAsyncOperationCompleted",
        "msTraceAsyncOperationStarting",
        "msTransform",
        "msTransformOrigin",
        "msTransformStyle",
        "msTransition",
        "msTransitionDelay",
        "msTransitionDuration",
        "msTransitionProperty",
        "msTransitionTimingFunction",
        "msUnlockOrientation",
        "msUpdateAsyncCallbackRelation",
        "msUserSelect",
        "msVisibilityState",
        "msWrapFlow",
        "msWrapMargin",
        "msWrapThrough",
        "msWriteProfilerMark",
        "msZoom",
        "msZoomTo",
        "mt",
        "mul",
        "multiEntry",
        "multiSelectionObj",
        "multiline",
        "multiple",
        "multiply",
        "multiplySelf",
        "multisample",
        "multisampled",
        "mutableFile",
        "muted",
        "n",
        "nacl_arch",
        "name",
        "nameList",
        "nameProp",
        "namedItem",
        "namedRecordset",
        "names",
        "namespaceURI",
        "namespaces",
        "nativeApplication",
        "nativeMap",
        "nativeObjectCreate",
        "nativeSet",
        "nativeWeakMap",
        "naturalHeight",
        "naturalWidth",
        "navigate",
        "navigation",
        "navigationMode",
        "navigationPreload",
        "navigationStart",
        "navigationType",
        "navigator",
        "near",
        "nearestViewportElement",
        "negative",
        "negotiated",
        "netscape",
        "networkState",
        "networkStatus",
        "newScale",
        "newState",
        "newTranslate",
        "newURL",
        "newValue",
        "newValueSpecifiedUnits",
        "newVersion",
        "newhome",
        "next",
        "nextElementSibling",
        "nextHopProtocol",
        "nextNode",
        "nextPage",
        "nextSibling",
        "nickname",
        "noHref",
        "noModule",
        "noResize",
        "noShade",
        "noValidate",
        "noWrap",
        "node",
        "nodeName",
        "nodeType",
        "nodeValue",
        "nonce",
        "normDepthBufferFromNormView",
        "normalize",
        "normalizedPathSegList",
        "normandyAddonStudy",
        "notRestoredReasons",
        "notationName",
        "notations",
        "note",
        "noteGrainOn",
        "noteOff",
        "noteOn",
        "notifications",
        "notify",
        "now",
        "npnNegotiatedProtocol",
        "numOctaves",
        "number",
        "numberOfChannels",
        "numberOfFrames",
        "numberOfInputs",
        "numberOfItems",
        "numberOfOutputs",
        "numberValue",
        "oMatchesSelector",
        "object",
        "object-fit",
        "object-position",
        "objectFit",
        "objectPosition",
        "objectStore",
        "objectStoreNames",
        "objectType",
        "observe",
        "occlusionQuerySet",
        "of",
        "off",
        "offscreenBuffering",
        "offset",
        "offset-anchor",
        "offset-distance",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "offsetAnchor",
        "offsetDistance",
        "offsetHeight",
        "offsetLeft",
        "offsetNode",
        "offsetParent",
        "offsetPath",
        "offsetPosition",
        "offsetRotate",
        "offsetTop",
        "offsetWidth",
        "offsetX",
        "offsetY",
        "ok",
        "oldState",
        "oldURL",
        "oldValue",
        "oldVersion",
        "olderShadowRoot",
        "omnibox",
        "on",
        "onActivated",
        "onAdded",
        "onAttached",
        "onBoundsChanged",
        "onBrowserUpdateAvailable",
        "onClicked",
        "onCommitFiberRoot",
        "onCommitFiberUnmount",
        "onConnect",
        "onConnectExternal",
        "onConnectNative",
        "onCreated",
        "onDetached",
        "onDisabled",
        "onEnabled",
        "onFocusChanged",
        "onHighlighted",
        "onInstalled",
        "onLine",
        "onMessage",
        "onMessageExternal",
        "onMoved",
        "onPerformanceWarning",
        "onPostCommitFiberRoot",
        "onRemoved",
        "onReplaced",
        "onRestartRequired",
        "onStartup",
        "onSubmittedWorkDone",
        "onSuspend",
        "onSuspendCanceled",
        "onUninstalled",
        "onUpdateAvailable",
        "onUpdated",
        "onUserScriptConnect",
        "onUserScriptMessage",
        "onUserSettingsChanged",
        "onZoomChange",
        "onabort",
        "onabsolutedeviceorientation",
        "onactivate",
        "onactive",
        "onaddsourcebuffer",
        "onaddstream",
        "onaddtrack",
        "onafterprint",
        "onafterscriptexecute",
        "onafterupdate",
        "onanimationcancel",
        "onanimationend",
        "onanimationiteration",
        "onanimationstart",
        "onappinstalled",
        "onaudioend",
        "onaudioprocess",
        "onaudiostart",
        "onautocomplete",
        "onautocompleteerror",
        "onauxclick",
        "onbeforeactivate",
        "onbeforecopy",
        "onbeforecut",
        "onbeforedeactivate",
        "onbeforeeditfocus",
        "onbeforeinput",
        "onbeforeinstallprompt",
        "onbeforematch",
        "onbeforepaste",
        "onbeforeprint",
        "onbeforescriptexecute",
        "onbeforetoggle",
        "onbeforeunload",
        "onbeforeupdate",
        "onbeforexrselect",
        "onbegin",
        "onblocked",
        "onblur",
        "onbounce",
        "onboundary",
        "onbufferedamountlow",
        "oncached",
        "oncancel",
        "oncandidatewindowhide",
        "oncandidatewindowshow",
        "oncandidatewindowupdate",
        "oncanplay",
        "oncanplaythrough",
        "oncapturehandlechange",
        "once",
        "oncellchange",
        "onchange",
        "oncharacterboundsupdate",
        "oncharacteristicvaluechanged",
        "onchargingchange",
        "onchargingtimechange",
        "onchecking",
        "onclick",
        "onclose",
        "onclosing",
        "oncompassneedscalibration",
        "oncomplete",
        "oncompositionend",
        "oncompositionstart",
        "onconnect",
        "onconnecting",
        "onconnectionavailable",
        "onconnectionstatechange",
        "oncontentvisibilityautostatechange",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncontrollerchange",
        "oncontrolselect",
        "oncopy",
        "oncuechange",
        "oncurrententrychange",
        "oncurrentscreenchange",
        "oncut",
        "ondataavailable",
        "ondatachannel",
        "ondatasetchanged",
        "ondatasetcomplete",
        "ondblclick",
        "ondeactivate",
        "ondequeue",
        "ondevicechange",
        "ondevicelight",
        "ondevicemotion",
        "ondeviceorientation",
        "ondeviceorientationabsolute",
        "ondeviceproximity",
        "ondischargingtimechange",
        "ondisconnect",
        "ondisplay",
        "ondispose",
        "ondownloading",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragexit",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onencrypted",
        "onend",
        "onended",
        "onenter",
        "onenterpictureinpicture",
        "onerror",
        "onerrorupdate",
        "onexit",
        "onfencedtreeclick",
        "onfilterchange",
        "onfinish",
        "onfocus",
        "onfocusin",
        "onfocusout",
        "onformdata",
        "onfreeze",
        "onfullscreenchange",
        "onfullscreenerror",
        "ongamepadconnected",
        "ongamepaddisconnected",
        "ongatheringstatechange",
        "ongattserverdisconnected",
        "ongeometrychange",
        "ongesturechange",
        "ongestureend",
        "ongesturestart",
        "ongotpointercapture",
        "onhashchange",
        "onhelp",
        "onicecandidate",
        "onicecandidateerror",
        "oniceconnectionstatechange",
        "onicegatheringstatechange",
        "oninactive",
        "oninput",
        "oninputreport",
        "oninputsourceschange",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeystatuseschange",
        "onkeyup",
        "onlanguagechange",
        "onlayoutcomplete",
        "onleavepictureinpicture",
        "onlevelchange",
        "onload",
        "onloadT",
        "onloadeddata",
        "onloadedmetadata",
        "onloadend",
        "onloading",
        "onloadingdone",
        "onloadingerror",
        "onloadstart",
        "onlosecapture",
        "onlostpointercapture",
        "only",
        "onmanagedconfigurationchange",
        "onmark",
        "onmessage",
        "onmessageerror",
        "onmidimessage",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onmousewheel",
        "onmove",
        "onmoveend",
        "onmovestart",
        "onmozfullscreenchange",
        "onmozfullscreenerror",
        "onmozorientationchange",
        "onmozpointerlockchange",
        "onmozpointerlockerror",
        "onmscontentzoom",
        "onmsfullscreenchange",
        "onmsfullscreenerror",
        "onmsgesturechange",
        "onmsgesturedoubletap",
        "onmsgestureend",
        "onmsgesturehold",
        "onmsgesturestart",
        "onmsgesturetap",
        "onmsgotpointercapture",
        "onmsinertiastart",
        "onmslostpointercapture",
        "onmsmanipulationstatechanged",
        "onmsneedkey",
        "onmsorientationchange",
        "onmspointercancel",
        "onmspointerdown",
        "onmspointerenter",
        "onmspointerhover",
        "onmspointerleave",
        "onmspointermove",
        "onmspointerout",
        "onmspointerover",
        "onmspointerup",
        "onmssitemodejumplistitemremoved",
        "onmsthumbnailclick",
        "onmute",
        "onnavigate",
        "onnavigateerror",
        "onnavigatesuccess",
        "onnegotiationneeded",
        "onnomatch",
        "onnoupdate",
        "onobsolete",
        "onoffline",
        "ononline",
        "onopen",
        "onorientationchange",
        "onpagechange",
        "onpagehide",
        "onpagereveal",
        "onpageshow",
        "onpageswap",
        "onpaste",
        "onpause",
        "onpayerdetailchange",
        "onpaymentmethodchange",
        "onplay",
        "onplaying",
        "onpluginstreamstart",
        "onpointercancel",
        "onpointerdown",
        "onpointerenter",
        "onpointerleave",
        "onpointerlockchange",
        "onpointerlockerror",
        "onpointermove",
        "onpointerout",
        "onpointerover",
        "onpointerrawupdate",
        "onpointerup",
        "onpopstate",
        "onprerenderingchange",
        "onprioritychange",
        "onprocessorerror",
        "onprogress",
        "onpropertychange",
        "onratechange",
        "onreading",
        "onreadystatechange",
        "onreflectionchange",
        "onrejectionhandled",
        "onrelease",
        "onremove",
        "onremovesourcebuffer",
        "onremovestream",
        "onremovetrack",
        "onrepeat",
        "onreset",
        "onresize",
        "onresizeend",
        "onresizestart",
        "onresourcetimingbufferfull",
        "onresult",
        "onresume",
        "onrowenter",
        "onrowexit",
        "onrowsdelete",
        "onrowsinserted",
        "onscreenschange",
        "onscroll",
        "onscrollend",
        "onscrollsnapchange",
        "onscrollsnapchanging",
        "onsearch",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onselectedcandidatepairchange",
        "onselectend",
        "onselectionchange",
        "onselectstart",
        "onshippingaddresschange",
        "onshippingoptionchange",
        "onshow",
        "onsignalingstatechange",
        "onsinkchange",
        "onslotchange",
        "onsoundend",
        "onsoundstart",
        "onsourceclose",
        "onsourceclosed",
        "onsourceended",
        "onsourceopen",
        "onspeechend",
        "onspeechstart",
        "onsqueeze",
        "onsqueezeend",
        "onsqueezestart",
        "onstalled",
        "onstart",
        "onstatechange",
        "onstop",
        "onstorage",
        "onstoragecommit",
        "onsubmit",
        "onsuccess",
        "onsuspend",
        "onterminate",
        "ontextformatupdate",
        "ontextinput",
        "ontextupdate",
        "ontimeout",
        "ontimeupdate",
        "ontoggle",
        "ontonechange",
        "ontouchcancel",
        "ontouchend",
        "ontouchmove",
        "ontouchstart",
        "ontrack",
        "ontransitioncancel",
        "ontransitionend",
        "ontransitionrun",
        "ontransitionstart",
        "onuncapturederror",
        "onunhandledrejection",
        "onunload",
        "onunmute",
        "onupdate",
        "onupdateend",
        "onupdatefound",
        "onupdateready",
        "onupdatestart",
        "onupgradeneeded",
        "onuserproximity",
        "onversionchange",
        "onvisibilitychange",
        "onvoiceschanged",
        "onvolumechange",
        "onvrdisplayactivate",
        "onvrdisplayconnect",
        "onvrdisplaydeactivate",
        "onvrdisplaydisconnect",
        "onvrdisplaypresentchange",
        "onwaiting",
        "onwaitingforkey",
        "onwarning",
        "onwebkitanimationend",
        "onwebkitanimationiteration",
        "onwebkitanimationstart",
        "onwebkitcurrentplaybacktargetiswirelesschanged",
        "onwebkitfullscreenchange",
        "onwebkitfullscreenerror",
        "onwebkitkeyadded",
        "onwebkitkeyerror",
        "onwebkitkeymessage",
        "onwebkitneedkey",
        "onwebkitorientationchange",
        "onwebkitplaybacktargetavailabilitychanged",
        "onwebkitpointerlockchange",
        "onwebkitpointerlockerror",
        "onwebkitresourcetimingbufferfull",
        "onwebkittransitionend",
        "onwheel",
        "onzoom",
        "opacity",
        "open",
        "openCursor",
        "openDatabase",
        "openKeyCursor",
        "openOptionsPage",
        "openOrClosedShadowRoot",
        "openPopup",
        "opened",
        "opener",
        "opera",
        "operation",
        "operationType",
        "operator",
        "opr",
        "optimum",
        "options",
        "or",
        "order",
        "orderX",
        "orderY",
        "ordered",
        "org",
        "organization",
        "orient",
        "orientAngle",
        "orientType",
        "orientation",
        "orientationX",
        "orientationY",
        "orientationZ",
        "origin",
        "originAgentCluster",
        "originalPolicy",
        "originalTarget",
        "orphans",
        "os",
        "oscpu",
        "outerHTML",
        "outerHeight",
        "outerText",
        "outerWidth",
        "outgoingHighWaterMark",
        "outgoingMaxAge",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "outlineColor",
        "outlineOffset",
        "outlineStyle",
        "outlineWidth",
        "outputBuffer",
        "outputChannelCount",
        "outputLatency",
        "outputs",
        "overflow",
        "overflow-anchor",
        "overflow-block",
        "overflow-clip-margin",
        "overflow-inline",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "overflowAnchor",
        "overflowBlock",
        "overflowClipMargin",
        "overflowInline",
        "overflowWrap",
        "overflowX",
        "overflowY",
        "overlaysContent",
        "overrideColors",
        "overrideMimeType",
        "oversample",
        "overscroll-behavior",
        "overscroll-behavior-block",
        "overscroll-behavior-inline",
        "overscroll-behavior-x",
        "overscroll-behavior-y",
        "overscrollBehavior",
        "overscrollBehaviorBlock",
        "overscrollBehaviorInline",
        "overscrollBehaviorX",
        "overscrollBehaviorY",
        "ownKeys",
        "ownerDocument",
        "ownerElement",
        "ownerNode",
        "ownerRule",
        "ownerSVGElement",
        "owningElement",
        "p1",
        "p2",
        "p3",
        "p4",
        "packetSize",
        "packets",
        "pad",
        "padEnd",
        "padStart",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "paddingBlock",
        "paddingBlockEnd",
        "paddingBlockStart",
        "paddingBottom",
        "paddingInline",
        "paddingInlineEnd",
        "paddingInlineStart",
        "paddingLeft",
        "paddingRight",
        "paddingTop",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-orientation",
        "pageAction",
        "pageBreakAfter",
        "pageBreakBefore",
        "pageBreakInside",
        "pageCount",
        "pageLeft",
        "pageOrientation",
        "pageT",
        "pageTop",
        "pageX",
        "pageXOffset",
        "pageY",
        "pageYOffset",
        "pages",
        "paint-order",
        "paintOrder",
        "paintRequests",
        "paintType",
        "paintWorklet",
        "palette",
        "pan",
        "panningModel",
        "parameterData",
        "parameters",
        "parent",
        "parentElement",
        "parentNode",
        "parentRule",
        "parentStyleSheet",
        "parentTextEdit",
        "parentWindow",
        "parse",
        "parseAll",
        "parseCreationOptionsFromJSON",
        "parseFloat",
        "parseFromString",
        "parseHTMLUnsafe",
        "parseInt",
        "parseRequestOptionsFromJSON",
        "part",
        "participants",
        "passOp",
        "passive",
        "password",
        "pasteHTML",
        "path",
        "pathLength",
        "pathSegList",
        "pathSegType",
        "pathSegTypeAsLetter",
        "pathname",
        "pattern",
        "patternContentUnits",
        "patternMismatch",
        "patternTransform",
        "patternUnits",
        "pause",
        "pauseAnimations",
        "pauseDuration",
        "pauseOnExit",
        "pauseProfilers",
        "pauseTransformFeedback",
        "paused",
        "payerEmail",
        "payerName",
        "payerPhone",
        "paymentManager",
        "pc",
        "pdfViewerEnabled",
        "peerIdentity",
        "pending",
        "pendingLocalDescription",
        "pendingRemoteDescription",
        "percent",
        "performance",
        "periodicSync",
        "permission",
        "permissionState",
        "permissions",
        "persist",
        "persisted",
        "persistentDeviceId",
        "personalbar",
        "perspective",
        "perspective-origin",
        "perspectiveOrigin",
        "phone",
        "phoneticFamilyName",
        "phoneticGivenName",
        "photo",
        "pictureInPictureChild",
        "pictureInPictureElement",
        "pictureInPictureEnabled",
        "pictureInPictureWindow",
        "ping",
        "pipeThrough",
        "pipeTo",
        "pitch",
        "pixelBottom",
        "pixelDepth",
        "pixelHeight",
        "pixelLeft",
        "pixelRight",
        "pixelStorei",
        "pixelTop",
        "pixelUnitToMillimeterX",
        "pixelUnitToMillimeterY",
        "pixelWidth",
        "pkcs11",
        "place-content",
        "place-items",
        "place-self",
        "placeContent",
        "placeItems",
        "placeSelf",
        "placeholder",
        "platform",
        "platformVersion",
        "platforms",
        "play",
        "playEffect",
        "playState",
        "playbackRate",
        "playbackState",
        "playbackTime",
        "played",
        "playoutDelayHint",
        "playsInline",
        "plugins",
        "pluginspage",
        "pname",
        "pointer-events",
        "pointerBeforeReferenceNode",
        "pointerEnabled",
        "pointerEvents",
        "pointerId",
        "pointerLockElement",
        "pointerType",
        "points",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "polygonOffset",
        "pop",
        "popDebugGroup",
        "popErrorScope",
        "popover",
        "popoverTargetAction",
        "popoverTargetElement",
        "populateMatrix",
        "popupWindowFeatures",
        "popupWindowName",
        "popupWindowURI",
        "port",
        "port1",
        "port2",
        "ports",
        "posBottom",
        "posHeight",
        "posLeft",
        "posRight",
        "posTop",
        "posWidth",
        "pose",
        "position",
        "position-anchor",
        "position-area",
        "positionAlign",
        "positionAnchor",
        "positionArea",
        "positionX",
        "positionY",
        "positionZ",
        "postError",
        "postMessage",
        "postTask",
        "postalCode",
        "poster",
        "postscriptName",
        "pow",
        "powerEfficient",
        "powerOff",
        "powerPreference",
        "preMultiplySelf",
        "precision",
        "preferredReflectionFormat",
        "preferredStyleSheetSet",
        "preferredStylesheetSet",
        "prefix",
        "preload",
        "premultipliedAlpha",
        "prepend",
        "prerendering",
        "presentation",
        "presentationArea",
        "presentationStyle",
        "preserveAlpha",
        "preserveAspectRatio",
        "preserveAspectRatioString",
        "preservesPitch",
        "pressed",
        "pressure",
        "prevValue",
        "preventDefault",
        "preventExtensions",
        "preventSilentAccess",
        "previousElementSibling",
        "previousNode",
        "previousPage",
        "previousPriority",
        "previousRect",
        "previousScale",
        "previousSibling",
        "previousTranslate",
        "primaries",
        "primaryKey",
        "primaryLightDirection",
        "primaryLightIntensity",
        "primitive",
        "primitiveType",
        "primitiveUnits",
        "principals",
        "print",
        "print-color-adjust",
        "printColorAdjust",
        "printPreview",
        "priority",
        "privacy",
        "privateKey",
        "privateToken",
        "probablySupportsContext",
        "probeSpace",
        "process",
        "processIceMessage",
        "processingEnd",
        "processingStart",
        "processorOptions",
        "product",
        "productId",
        "productName",
        "productSub",
        "profile",
        "profileEnd",
        "profiles",
        "projectionMatrix",
        "promise",
        "prompt",
        "properties",
        "propertyIsEnumerable",
        "propertyName",
        "protectedAudience",
        "protocol",
        "protocolLong",
        "prototype",
        "provider",
        "proxy",
        "pseudoClass",
        "pseudoElement",
        "pt",
        "publicId",
        "publicKey",
        "published",
        "pulse",
        "push",
        "pushDebugGroup",
        "pushErrorScope",
        "pushManager",
        "pushNotification",
        "pushState",
        "put",
        "putImageData",
        "px",
        "quadraticCurveTo",
        "qualifier",
        "quaternion",
        "query",
        "queryCommandEnabled",
        "queryCommandIndeterm",
        "queryCommandState",
        "queryCommandSupported",
        "queryCommandText",
        "queryCommandValue",
        "queryFeatureSupport",
        "queryLocalFonts",
        "queryPermission",
        "querySelector",
        "querySelectorAll",
        "querySet",
        "queue",
        "queueMicrotask",
        "quote",
        "quotes",
        "r",
        "r1",
        "r2",
        "race",
        "rad",
        "radiogroup",
        "radius",
        "radiusX",
        "radiusY",
        "random",
        "randomUUID",
        "range",
        "rangeCount",
        "rangeEnd",
        "rangeMax",
        "rangeMin",
        "rangeOffset",
        "rangeOverflow",
        "rangeParent",
        "rangeStart",
        "rangeUnderflow",
        "rate",
        "ratio",
        "raw",
        "rawId",
        "rawJSON",
        "rawValueToMeters",
        "rcap",
        "rch",
        "read",
        "readAsArrayBuffer",
        "readAsBinaryString",
        "readAsBlob",
        "readAsDataURL",
        "readAsText",
        "readBuffer",
        "readEntries",
        "readOnly",
        "readPixels",
        "readReportRequested",
        "readText",
        "readValue",
        "readable",
        "ready",
        "readyState",
        "reason",
        "reasons",
        "reboot",
        "receiveFeatureReport",
        "receivedAlert",
        "receiver",
        "receivers",
        "recipient",
        "recommendedViewportScale",
        "reconnect",
        "recordNumber",
        "recordsAvailable",
        "recordset",
        "rect",
        "red",
        "redEyeReduction",
        "redirect",
        "redirectCount",
        "redirectEnd",
        "redirectStart",
        "redirected",
        "reduce",
        "reduceRight",
        "reduction",
        "refDistance",
        "refX",
        "refY",
        "referenceNode",
        "referenceSpace",
        "referrer",
        "referrerPolicy",
        "refresh",
        "region",
        "regionAnchorX",
        "regionAnchorY",
        "regionId",
        "regions",
        "register",
        "registerContentHandler",
        "registerElement",
        "registerInternalModuleStart",
        "registerInternalModuleStop",
        "registerProperty",
        "registerProtocolHandler",
        "reject",
        "rel",
        "relList",
        "relatedAddress",
        "relatedNode",
        "relatedPort",
        "relatedTarget",
        "relayProtocol",
        "release",
        "releaseCapture",
        "releaseEvents",
        "releaseInterface",
        "releaseLock",
        "releasePointerCapture",
        "releaseShaderCompiler",
        "released",
        "reliability",
        "reliable",
        "reliableWrite",
        "reload",
        "rem",
        "remainingSpace",
        "remote",
        "remoteDescription",
        "remove",
        "removeAllRanges",
        "removeAttribute",
        "removeAttributeNS",
        "removeAttributeNode",
        "removeBehavior",
        "removeChild",
        "removeCue",
        "removeEntry",
        "removeEventListener",
        "removeFilter",
        "removeImport",
        "removeItem",
        "removeListener",
        "removeNamedItem",
        "removeNamedItemNS",
        "removeNode",
        "removeParameter",
        "removeProperty",
        "removeRange",
        "removeRegion",
        "removeRule",
        "removeSiteSpecificTrackingException",
        "removeSourceBuffer",
        "removeStream",
        "removeTrack",
        "removeVariable",
        "removeWakeLockListener",
        "removeWebWideTrackingException",
        "removed",
        "removedNodes",
        "renderBlockingStatus",
        "renderHeight",
        "renderStart",
        "renderState",
        "renderTime",
        "renderWidth",
        "renderbufferStorage",
        "renderbufferStorageMultisample",
        "renderedBuffer",
        "rendererInterfaces",
        "renderers",
        "renderingMode",
        "renotify",
        "repeat",
        "repetitionCount",
        "replace",
        "replaceAdjacentText",
        "replaceAll",
        "replaceChild",
        "replaceChildren",
        "replaceData",
        "replaceId",
        "replaceItem",
        "replaceNode",
        "replaceState",
        "replaceSync",
        "replaceTrack",
        "replaceWholeText",
        "replaceWith",
        "reportError",
        "reportEvent",
        "reportId",
        "reportValidity",
        "request",
        "requestAdapter",
        "requestAdapterInfo",
        "requestAnimationFrame",
        "requestAutocomplete",
        "requestClose",
        "requestData",
        "requestDevice",
        "requestFrame",
        "requestFullscreen",
        "requestHitTestSource",
        "requestHitTestSourceForTransientInput",
        "requestId",
        "requestIdleCallback",
        "requestLightProbe",
        "requestMIDIAccess",
        "requestMediaKeySystemAccess",
        "requestPermission",
        "requestPictureInPicture",
        "requestPointerLock",
        "requestPort",
        "requestPresent",
        "requestPresenter",
        "requestReferenceSpace",
        "requestSession",
        "requestStart",
        "requestStorageAccess",
        "requestStorageAccessFor",
        "requestSubmit",
        "requestTime",
        "requestUpdateCheck",
        "requestVideoFrameCallback",
        "requestViewportScale",
        "requestWindow",
        "requestingWindow",
        "requireInteraction",
        "required",
        "requiredExtensions",
        "requiredFeatures",
        "requiredLimits",
        "reset",
        "resetLatency",
        "resetPose",
        "resetTransform",
        "resizable",
        "resize",
        "resizeBy",
        "resizeTo",
        "resolve",
        "resolveQuerySet",
        "resolveTarget",
        "resource",
        "respond",
        "respondWithNewView",
        "response",
        "responseBody",
        "responseEnd",
        "responseReady",
        "responseStart",
        "responseStatus",
        "responseText",
        "responseType",
        "responseURL",
        "responseXML",
        "restart",
        "restartAfterDelay",
        "restartIce",
        "restore",
        "result",
        "resultIndex",
        "resultType",
        "results",
        "resume",
        "resumeProfilers",
        "resumeTransformFeedback",
        "retry",
        "returnValue",
        "rev",
        "reverse",
        "reversed",
        "revocable",
        "revokeObjectURL",
        "rex",
        "rgbColor",
        "ric",
        "right",
        "rightContext",
        "rightDegrees",
        "rightMargin",
        "rightProjectionMatrix",
        "rightViewMatrix",
        "rlh",
        "role",
        "rolloffFactor",
        "root",
        "rootBounds",
        "rootElement",
        "rootMargin",
        "rotate",
        "rotateAxisAngle",
        "rotateAxisAngleSelf",
        "rotateFromVector",
        "rotateFromVectorSelf",
        "rotateSelf",
        "rotation",
        "rotationAngle",
        "rotationRate",
        "round",
        "roundRect",
        "row-gap",
        "rowGap",
        "rowIndex",
        "rowSpan",
        "rows",
        "rowsPerImage",
        "rtcpTransport",
        "rtt",
        "ruby-align",
        "ruby-position",
        "rubyAlign",
        "rubyOverhang",
        "rubyPosition",
        "rules",
        "run",
        "runAdAuction",
        "runtime",
        "runtimeStyle",
        "rx",
        "ry",
        "s",
        "safari",
        "sameDocument",
        "sample",
        "sampleCount",
        "sampleCoverage",
        "sampleInterval",
        "sampleRate",
        "sampleType",
        "sampler",
        "samplerParameterf",
        "samplerParameteri",
        "sandbox",
        "save",
        "saveAsPDF",
        "saveData",
        "scale",
        "scale3d",
        "scale3dSelf",
        "scaleNonUniform",
        "scaleNonUniformSelf",
        "scaleSelf",
        "scheduler",
        "scheduling",
        "scheme",
        "scissor",
        "scope",
        "scopeName",
        "scoped",
        "screen",
        "screenBrightness",
        "screenEnabled",
        "screenLeft",
        "screenPixelToMillimeterX",
        "screenPixelToMillimeterY",
        "screenState",
        "screenTop",
        "screenX",
        "screenY",
        "screens",
        "scriptURL",
        "scripting",
        "scripts",
        "scroll",
        "scroll-behavior",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollAmount",
        "scrollBehavior",
        "scrollBy",
        "scrollByLines",
        "scrollByPages",
        "scrollDelay",
        "scrollHeight",
        "scrollIntoView",
        "scrollIntoViewIfNeeded",
        "scrollLeft",
        "scrollLeftMax",
        "scrollMargin",
        "scrollMarginBlock",
        "scrollMarginBlockEnd",
        "scrollMarginBlockStart",
        "scrollMarginBottom",
        "scrollMarginInline",
        "scrollMarginInlineEnd",
        "scrollMarginInlineStart",
        "scrollMarginLeft",
        "scrollMarginRight",
        "scrollMarginTop",
        "scrollMaxX",
        "scrollMaxY",
        "scrollPadding",
        "scrollPaddingBlock",
        "scrollPaddingBlockEnd",
        "scrollPaddingBlockStart",
        "scrollPaddingBottom",
        "scrollPaddingInline",
        "scrollPaddingInlineEnd",
        "scrollPaddingInlineStart",
        "scrollPaddingLeft",
        "scrollPaddingRight",
        "scrollPaddingTop",
        "scrollRestoration",
        "scrollSnapAlign",
        "scrollSnapStop",
        "scrollSnapType",
        "scrollTo",
        "scrollTop",
        "scrollTopMax",
        "scrollWidth",
        "scrollX",
        "scrollY",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "scrollbar3dLightColor",
        "scrollbarArrowColor",
        "scrollbarBaseColor",
        "scrollbarColor",
        "scrollbarDarkShadowColor",
        "scrollbarFaceColor",
        "scrollbarGutter",
        "scrollbarHighlightColor",
        "scrollbarShadowColor",
        "scrollbarTrackColor",
        "scrollbarWidth",
        "scrollbars",
        "scrolling",
        "scrollingElement",
        "sctp",
        "sctpCauseCode",
        "sdp",
        "sdpLineNumber",
        "sdpMLineIndex",
        "sdpMid",
        "seal",
        "search",
        "searchBox",
        "searchBoxJavaBridge_",
        "searchParams",
        "sectionRowIndex",
        "secureConnectionStart",
        "security",
        "seed",
        "seek",
        "seekToNextFrame",
        "seekable",
        "seeking",
        "select",
        "selectAllChildren",
        "selectAlternateInterface",
        "selectAudioOutput",
        "selectConfiguration",
        "selectNode",
        "selectNodeContents",
        "selectNodes",
        "selectSingleNode",
        "selectSubString",
        "selectURL",
        "selected",
        "selectedIndex",
        "selectedOptions",
        "selectedStyleSheetSet",
        "selectedStylesheetSet",
        "selectedTrack",
        "selection",
        "selectionDirection",
        "selectionEnd",
        "selectionStart",
        "selector",
        "selectorText",
        "self",
        "send",
        "sendAsBinary",
        "sendBeacon",
        "sendFeatureReport",
        "sendMessage",
        "sendNativeMessage",
        "sendOrder",
        "sendReport",
        "sender",
        "sentAlert",
        "sentTimestamp",
        "separator",
        "serial",
        "serialNumber",
        "serializable",
        "serializeToString",
        "serverTiming",
        "service",
        "serviceWorker",
        "session",
        "sessionId",
        "sessionStorage",
        "sessions",
        "set",
        "setActionHandler",
        "setActive",
        "setAlpha",
        "setAppBadge",
        "setAttribute",
        "setAttributeNS",
        "setAttributeNode",
        "setAttributeNodeNS",
        "setAttributionReporting",
        "setBadgeBackgroundColor",
        "setBadgeText",
        "setBadgeTextColor",
        "setBaseAndExtent",
        "setBigInt64",
        "setBigUint64",
        "setBindGroup",
        "setBingCurrentSearchDefault",
        "setBlendConstant",
        "setCameraActive",
        "setCapture",
        "setCaptureHandleConfig",
        "setCodecPreferences",
        "setColor",
        "setCompositeOperation",
        "setConfiguration",
        "setConsumer",
        "setCurrentTime",
        "setCustomValidity",
        "setData",
        "setDate",
        "setDragImage",
        "setEnabled",
        "setEnd",
        "setEndAfter",
        "setEndBefore",
        "setEndPoint",
        "setExpires",
        "setFillColor",
        "setFilterRes",
        "setFloat16",
        "setFloat32",
        "setFloat64",
        "setFloatValue",
        "setFocusBehavior",
        "setFormValue",
        "setFromBase64",
        "setFromHex",
        "setFullYear",
        "setHTMLUnsafe",
        "setHeaderExtensionsToNegotiate",
        "setHeaderValue",
        "setHours",
        "setIcon",
        "setIdentityProvider",
        "setImmediate",
        "setIndexBuffer",
        "setInt16",
        "setInt32",
        "setInt8",
        "setInterval",
        "setItem",
        "setKeyframes",
        "setLineCap",
        "setLineDash",
        "setLineJoin",
        "setLineWidth",
        "setLiveSeekableRange",
        "setLocalDescription",
        "setMatrix",
        "setMatrixValue",
        "setMediaKeys",
        "setMicrophoneActive",
        "setMilliseconds",
        "setMinutes",
        "setMiterLimit",
        "setMonth",
        "setNamedItem",
        "setNamedItemNS",
        "setNonUserCodeExceptions",
        "setOrientToAngle",
        "setOrientToAuto",
        "setOrientation",
        "setOverrideHistoryNavigationMode",
        "setPaint",
        "setParameter",
        "setParameters",
        "setPeriodicWave",
        "setPipeline",
        "setPointerCapture",
        "setPopup",
        "setPosition",
        "setPositionState",
        "setPreference",
        "setPriority",
        "setPrivateToken",
        "setProperty",
        "setPrototypeOf",
        "setRGBColor",
        "setRGBColorICCColor",
        "setRadius",
        "setRangeText",
        "setRemoteDescription",
        "setReportEventDataForAutomaticBeacons",
        "setRequestHeader",
        "setResizable",
        "setResourceTimingBufferSize",
        "setRotate",
        "setScale",
        "setScissorRect",
        "setSeconds",
        "setSelectionRange",
        "setServerCertificate",
        "setShadow",
        "setSharedStorageContext",
        "setSignals",
        "setSinkId",
        "setSkewX",
        "setSkewY",
        "setStart",
        "setStartAfter",
        "setStartBefore",
        "setStatus",
        "setStdDeviation",
        "setStencilReference",
        "setStreams",
        "setStrictMode",
        "setStringValue",
        "setStrokeColor",
        "setSuggestResult",
        "setTargetAtTime",
        "setTargetValueAtTime",
        "setTime",
        "setTimeout",
        "setTitle",
        "setTransform",
        "setTranslate",
        "setUTCDate",
        "setUTCFullYear",
        "setUTCHours",
        "setUTCMilliseconds",
        "setUTCMinutes",
        "setUTCMonth",
        "setUTCSeconds",
        "setUint16",
        "setUint32",
        "setUint8",
        "setUninstallURL",
        "setUpdateUrlData",
        "setUri",
        "setValidity",
        "setValueAtTime",
        "setValueCurveAtTime",
        "setVariable",
        "setVelocity",
        "setVersion",
        "setVertexBuffer",
        "setViewport",
        "setYear",
        "setZoom",
        "setZoomSettings",
        "settingName",
        "settingValue",
        "sex",
        "shaderLocation",
        "shaderSource",
        "shadowBlur",
        "shadowColor",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowRoot",
        "shadowRootClonable",
        "shadowRootDelegatesFocus",
        "shadowRootMode",
        "shadowRootSerializable",
        "shape",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "shape-rendering",
        "shapeImageThreshold",
        "shapeMargin",
        "shapeOutside",
        "shapeRendering",
        "share",
        "sharedStorage",
        "sharedStorageWritable",
        "sheet",
        "shift",
        "shiftKey",
        "shiftLeft",
        "shippingAddress",
        "shippingOption",
        "shippingType",
        "show",
        "showDirectoryPicker",
        "showHelp",
        "showModal",
        "showModalDialog",
        "showModelessDialog",
        "showNotification",
        "showOpenFilePicker",
        "showPicker",
        "showPopover",
        "showSaveFilePicker",
        "sidebar",
        "sidebarAction",
        "sign",
        "signal",
        "signalingState",
        "signature",
        "silent",
        "sin",
        "singleNodeValue",
        "sinh",
        "sinkId",
        "sittingToStandingTransform",
        "size",
        "sizeAdjust",
        "sizeToContent",
        "sizeX",
        "sizeZ",
        "sizes",
        "skewX",
        "skewXSelf",
        "skewY",
        "skewYSelf",
        "skipTransition",
        "skipped",
        "slice",
        "slope",
        "slot",
        "slotAssignment",
        "small",
        "smil",
        "smooth",
        "smoothingTimeConstant",
        "snapTargetBlock",
        "snapTargetInline",
        "snapToLines",
        "snapshotItem",
        "snapshotLength",
        "some",
        "sort",
        "sortingCode",
        "source",
        "sourceBuffer",
        "sourceBuffers",
        "sourceCapabilities",
        "sourceCharPosition",
        "sourceFile",
        "sourceFunctionName",
        "sourceIndex",
        "sourceMap",
        "sourceURL",
        "sources",
        "spacing",
        "span",
        "speak",
        "speakAs",
        "speaking",
        "species",
        "specified",
        "specularConstant",
        "specularExponent",
        "speechSynthesis",
        "speed",
        "speedOfSound",
        "spellcheck",
        "sphericalHarmonicsCoefficients",
        "splice",
        "split",
        "splitText",
        "spreadMethod",
        "sqrt",
        "src",
        "srcElement",
        "srcFactor",
        "srcFilter",
        "srcObject",
        "srcUrn",
        "srcdoc",
        "srclang",
        "srcset",
        "stack",
        "stackTraceLimit",
        "stacktrace",
        "stageParameters",
        "standalone",
        "standby",
        "start",
        "startContainer",
        "startE",
        "startIce",
        "startLoadTime",
        "startMessages",
        "startNotifications",
        "startOffset",
        "startProfiling",
        "startRendering",
        "startShark",
        "startTime",
        "startViewTransition",
        "startsWith",
        "state",
        "states",
        "stats",
        "status",
        "statusCode",
        "statusMessage",
        "statusText",
        "statusbar",
        "stdDeviationX",
        "stdDeviationY",
        "stencilBack",
        "stencilClearValue",
        "stencilFront",
        "stencilFunc",
        "stencilFuncSeparate",
        "stencilLoadOp",
        "stencilMask",
        "stencilMaskSeparate",
        "stencilOp",
        "stencilOpSeparate",
        "stencilReadMask",
        "stencilReadOnly",
        "stencilStoreOp",
        "stencilWriteMask",
        "step",
        "stepDown",
        "stepMismatch",
        "stepMode",
        "stepUp",
        "sticky",
        "stitchTiles",
        "stop",
        "stop-color",
        "stop-opacity",
        "stopColor",
        "stopImmediatePropagation",
        "stopNotifications",
        "stopOpacity",
        "stopProfiling",
        "stopPropagation",
        "stopShark",
        "stopped",
        "storage",
        "storageArea",
        "storageBuckets",
        "storageName",
        "storageStatus",
        "storageTexture",
        "store",
        "storeOp",
        "storeSiteSpecificTrackingException",
        "storeWebWideTrackingException",
        "stpVersion",
        "stream",
        "streamErrorCode",
        "streams",
        "stretch",
        "strike",
        "string",
        "stringValue",
        "stringify",
        "stripIndexFormat",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "strokeDasharray",
        "strokeDashoffset",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeMiterlimit",
        "strokeOpacity",
        "strokeRect",
        "strokeStyle",
        "strokeText",
        "strokeWidth",
        "structuredClone",
        "style",
        "styleAndLayoutStart",
        "styleFloat",
        "styleMap",
        "styleMedia",
        "styleSheet",
        "styleSheetSets",
        "styleSheets",
        "sub",
        "subarray",
        "subject",
        "submit",
        "submitFrame",
        "submitter",
        "subscribe",
        "substr",
        "substring",
        "substringData",
        "subtle",
        "subtree",
        "suffix",
        "suffixes",
        "summary",
        "sup",
        "supported",
        "supportedContentEncodings",
        "supportedEntryTypes",
        "supportedValuesOf",
        "supports",
        "supportsFiber",
        "supportsSession",
        "supportsText",
        "surfaceScale",
        "surroundContents",
        "suspend",
        "suspendRedraw",
        "svb",
        "svh",
        "svi",
        "svmax",
        "svmin",
        "svw",
        "swapCache",
        "swapNode",
        "sweepFlag",
        "symbols",
        "symmetricDifference",
        "sync",
        "syntax",
        "sysexEnabled",
        "system",
        "systemCode",
        "systemId",
        "systemLanguage",
        "systemXDPI",
        "systemYDPI",
        "tBodies",
        "tFoot",
        "tHead",
        "tab",
        "tab-size",
        "tabId",
        "tabIds",
        "tabIndex",
        "tabSize",
        "table",
        "table-layout",
        "tableLayout",
        "tableValues",
        "tabs",
        "tag",
        "tagName",
        "tagUrn",
        "tags",
        "taintEnabled",
        "take",
        "takePhoto",
        "takeRecords",
        "tan",
        "tangentialPressure",
        "tanh",
        "target",
        "targetAddressSpace",
        "targetElement",
        "targetRayMode",
        "targetRaySpace",
        "targetTouches",
        "targetURL",
        "targetX",
        "targetY",
        "targets",
        "tcpType",
        "tee",
        "tel",
        "telemetry",
        "terminate",
        "test",
        "texImage2D",
        "texImage3D",
        "texParameterf",
        "texParameteri",
        "texStorage2D",
        "texStorage3D",
        "texSubImage2D",
        "texSubImage3D",
        "text",
        "text-align",
        "text-align-last",
        "text-anchor",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-skip-ink",
        "text-decoration-style",
        "text-decoration-thickness",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-offset",
        "text-underline-position",
        "text-wrap",
        "text-wrap-mode",
        "text-wrap-style",
        "textAlign",
        "textAlignLast",
        "textAnchor",
        "textAutospace",
        "textBaseline",
        "textCombineUpright",
        "textContent",
        "textDecoration",
        "textDecorationBlink",
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationLineThrough",
        "textDecorationNone",
        "textDecorationOverline",
        "textDecorationSkipInk",
        "textDecorationStyle",
        "textDecorationThickness",
        "textDecorationUnderline",
        "textEmphasis",
        "textEmphasisColor",
        "textEmphasisPosition",
        "textEmphasisStyle",
        "textIndent",
        "textJustify",
        "textJustifyTrim",
        "textKashida",
        "textKashidaSpace",
        "textLength",
        "textOrientation",
        "textOverflow",
        "textRendering",
        "textShadow",
        "textTracks",
        "textTransform",
        "textUnderlineOffset",
        "textUnderlinePosition",
        "textWrap",
        "textWrapMode",
        "textWrapStyle",
        "texture",
        "theme",
        "then",
        "threadId",
        "threshold",
        "thresholds",
        "throwIfAborted",
        "tiltX",
        "tiltY",
        "time",
        "timeEnd",
        "timeLog",
        "timeOrigin",
        "timeRemaining",
        "timeStamp",
        "timecode",
        "timeline",
        "timelineTime",
        "timeout",
        "timestamp",
        "timestampOffset",
        "timestampWrites",
        "timing",
        "title",
        "titlebarAreaRect",
        "tlsChannelId",
        "to",
        "toArray",
        "toBase64",
        "toBlob",
        "toDataURL",
        "toDateString",
        "toElement",
        "toExponential",
        "toFixed",
        "toFloat32Array",
        "toFloat64Array",
        "toGMTString",
        "toHex",
        "toISOString",
        "toJSON",
        "toLocaleDateString",
        "toLocaleFormat",
        "toLocaleLowerCase",
        "toLocaleString",
        "toLocaleTimeString",
        "toLocaleUpperCase",
        "toLowerCase",
        "toMatrix",
        "toMethod",
        "toPrecision",
        "toPrimitive",
        "toReversed",
        "toSdp",
        "toSorted",
        "toSource",
        "toSpliced",
        "toStaticHTML",
        "toString",
        "toStringTag",
        "toSum",
        "toTimeString",
        "toUTCString",
        "toUpperCase",
        "toWellFormed",
        "toggle",
        "toggleAttribute",
        "toggleLongPressEnabled",
        "togglePopover",
        "toggleReaderMode",
        "token",
        "tone",
        "toneBuffer",
        "tooLong",
        "tooShort",
        "toolbar",
        "top",
        "topMargin",
        "topSites",
        "topology",
        "total",
        "totalFrameDelay",
        "totalFrames",
        "totalFramesDuration",
        "totalVideoFrames",
        "touch-action",
        "touchAction",
        "touched",
        "touches",
        "trace",
        "track",
        "trackVisibility",
        "trackedAnchors",
        "tracks",
        "tran",
        "transaction",
        "transactions",
        "transceiver",
        "transfer",
        "transferControlToOffscreen",
        "transferFromImageBitmap",
        "transferImageBitmap",
        "transferIn",
        "transferOut",
        "transferSize",
        "transferToFixedLength",
        "transferToImageBitmap",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transformBox",
        "transformFeedbackVaryings",
        "transformOrigin",
        "transformPoint",
        "transformString",
        "transformStyle",
        "transformToDocument",
        "transformToFragment",
        "transition",
        "transition-behavior",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "transitionBehavior",
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction",
        "translate",
        "translateSelf",
        "translationX",
        "translationY",
        "transport",
        "traverseTo",
        "trim",
        "trimEnd",
        "trimLeft",
        "trimRight",
        "trimStart",
        "trueSpeed",
        "trunc",
        "truncate",
        "trustedTypes",
        "try",
        "turn",
        "twist",
        "type",
        "typeDetail",
        "typeMismatch",
        "typeMustMatch",
        "types",
        "u2f",
        "ubound",
        "uint16",
        "uint32",
        "uint8",
        "uint8Clamped",
        "unadjustedMovement",
        "unclippedDepth",
        "unconfigure",
        "undefined",
        "underlineStyle",
        "underlineThickness",
        "unescape",
        "uneval",
        "ungroup",
        "unicode",
        "unicode-bidi",
        "unicodeBidi",
        "unicodeRange",
        "unicodeSets",
        "uniform1f",
        "uniform1fv",
        "uniform1i",
        "uniform1iv",
        "uniform1ui",
        "uniform1uiv",
        "uniform2f",
        "uniform2fv",
        "uniform2i",
        "uniform2iv",
        "uniform2ui",
        "uniform2uiv",
        "uniform3f",
        "uniform3fv",
        "uniform3i",
        "uniform3iv",
        "uniform3ui",
        "uniform3uiv",
        "uniform4f",
        "uniform4fv",
        "uniform4i",
        "uniform4iv",
        "uniform4ui",
        "uniform4uiv",
        "uniformBlockBinding",
        "uniformMatrix2fv",
        "uniformMatrix2x3fv",
        "uniformMatrix2x4fv",
        "uniformMatrix3fv",
        "uniformMatrix3x2fv",
        "uniformMatrix3x4fv",
        "uniformMatrix4fv",
        "uniformMatrix4x2fv",
        "uniformMatrix4x3fv",
        "uninstallSelf",
        "union",
        "unique",
        "uniqueID",
        "uniqueNumber",
        "unit",
        "unitType",
        "units",
        "unloadEventEnd",
        "unloadEventStart",
        "unlock",
        "unmap",
        "unmount",
        "unobserve",
        "unpackColorSpace",
        "unpause",
        "unpauseAnimations",
        "unreadCount",
        "unregister",
        "unregisterContentHandler",
        "unregisterProtocolHandler",
        "unscopables",
        "unselectable",
        "unshift",
        "unsubscribe",
        "unsuspendRedraw",
        "unsuspendRedrawAll",
        "unwatch",
        "unwrapKey",
        "upDegrees",
        "upX",
        "upY",
        "upZ",
        "update",
        "updateAdInterestGroups",
        "updateCallbackDone",
        "updateCharacterBounds",
        "updateCommands",
        "updateControlBounds",
        "updateCurrentEntry",
        "updateIce",
        "updateInkTrailStartPoint",
        "updateInterval",
        "updatePlaybackRate",
        "updateRangeEnd",
        "updateRangeStart",
        "updateRenderState",
        "updateSelection",
        "updateSelectionBounds",
        "updateSettings",
        "updateText",
        "updateTiming",
        "updateViaCache",
        "updateWith",
        "updated",
        "updating",
        "upgrade",
        "upload",
        "uploadTotal",
        "uploaded",
        "upper",
        "upperBound",
        "upperOpen",
        "uri",
        "url",
        "urn",
        "urns",
        "usage",
        "usages",
        "usb",
        "usbVersionMajor",
        "usbVersionMinor",
        "usbVersionSubminor",
        "useCurrentView",
        "useMap",
        "useProgram",
        "usedSpace",
        "user-select",
        "userActivation",
        "userAgent",
        "userAgentData",
        "userChoice",
        "userHandle",
        "userHint",
        "userInitiated",
        "userLanguage",
        "userSelect",
        "userState",
        "userVisibleOnly",
        "username",
        "usernameFragment",
        "utterance",
        "uuid",
        "v8BreakIterator",
        "vAlign",
        "vLink",
        "valid",
        "validate",
        "validateProgram",
        "validationMessage",
        "validity",
        "value",
        "valueAsDate",
        "valueAsNumber",
        "valueAsString",
        "valueInSpecifiedUnits",
        "valueMissing",
        "valueOf",
        "valueText",
        "valueType",
        "values",
        "variable",
        "variant",
        "variationSettings",
        "vb",
        "vector-effect",
        "vectorEffect",
        "velocityAngular",
        "velocityExpansion",
        "velocityX",
        "velocityY",
        "vendor",
        "vendorId",
        "vendorSub",
        "verify",
        "version",
        "vertex",
        "vertexAttrib1f",
        "vertexAttrib1fv",
        "vertexAttrib2f",
        "vertexAttrib2fv",
        "vertexAttrib3f",
        "vertexAttrib3fv",
        "vertexAttrib4f",
        "vertexAttrib4fv",
        "vertexAttribDivisor",
        "vertexAttribDivisorANGLE",
        "vertexAttribI4i",
        "vertexAttribI4iv",
        "vertexAttribI4ui",
        "vertexAttribI4uiv",
        "vertexAttribIPointer",
        "vertexAttribPointer",
        "vertical",
        "vertical-align",
        "verticalAlign",
        "verticalOverflow",
        "vh",
        "vi",
        "vibrate",
        "vibrationActuator",
        "videoBitsPerSecond",
        "videoHeight",
        "videoTracks",
        "videoWidth",
        "view",
        "viewBox",
        "viewBoxString",
        "viewDimension",
        "viewFormats",
        "viewTarget",
        "viewTargetString",
        "viewTransition",
        "viewport",
        "viewportAnchorX",
        "viewportAnchorY",
        "viewportElement",
        "views",
        "violatedDirective",
        "virtualKeyboard",
        "virtualKeyboardPolicy",
        "visibility",
        "visibilityState",
        "visible",
        "visibleRect",
        "visualViewport",
        "vlinkColor",
        "vmax",
        "vmin",
        "voice",
        "voiceURI",
        "volume",
        "vrml",
        "vspace",
        "vw",
        "w",
        "wait",
        "waitAsync",
        "waitSync",
        "waiting",
        "wake",
        "wakeLock",
        "wand",
        "warmup",
        "warn",
        "wasAlternateProtocolAvailable",
        "wasClean",
        "wasDiscarded",
        "wasFetchedViaSpdy",
        "wasNpnNegotiated",
        "watch",
        "watchAvailability",
        "watchPosition",
        "webNavigation",
        "webRequest",
        "webdriver",
        "webkitAddKey",
        "webkitAlignContent",
        "webkitAlignItems",
        "webkitAlignSelf",
        "webkitAnimation",
        "webkitAnimationDelay",
        "webkitAnimationDirection",
        "webkitAnimationDuration",
        "webkitAnimationFillMode",
        "webkitAnimationIterationCount",
        "webkitAnimationName",
        "webkitAnimationPlayState",
        "webkitAnimationTimingFunction",
        "webkitAppearance",
        "webkitAudioContext",
        "webkitAudioDecodedByteCount",
        "webkitAudioPannerNode",
        "webkitBackfaceVisibility",
        "webkitBackground",
        "webkitBackgroundAttachment",
        "webkitBackgroundClip",
        "webkitBackgroundColor",
        "webkitBackgroundImage",
        "webkitBackgroundOrigin",
        "webkitBackgroundPosition",
        "webkitBackgroundPositionX",
        "webkitBackgroundPositionY",
        "webkitBackgroundRepeat",
        "webkitBackgroundSize",
        "webkitBackingStorePixelRatio",
        "webkitBorderBottomLeftRadius",
        "webkitBorderBottomRightRadius",
        "webkitBorderImage",
        "webkitBorderImageOutset",
        "webkitBorderImageRepeat",
        "webkitBorderImageSlice",
        "webkitBorderImageSource",
        "webkitBorderImageWidth",
        "webkitBorderRadius",
        "webkitBorderTopLeftRadius",
        "webkitBorderTopRightRadius",
        "webkitBoxAlign",
        "webkitBoxDirection",
        "webkitBoxFlex",
        "webkitBoxOrdinalGroup",
        "webkitBoxOrient",
        "webkitBoxPack",
        "webkitBoxShadow",
        "webkitBoxSizing",
        "webkitCancelAnimationFrame",
        "webkitCancelFullScreen",
        "webkitCancelKeyRequest",
        "webkitCancelRequestAnimationFrame",
        "webkitClearResourceTimings",
        "webkitClipPath",
        "webkitClosedCaptionsVisible",
        "webkitConvertPointFromNodeToPage",
        "webkitConvertPointFromPageToNode",
        "webkitCreateShadowRoot",
        "webkitCurrentFullScreenElement",
        "webkitCurrentPlaybackTargetIsWireless",
        "webkitDecodedFrameCount",
        "webkitDirectionInvertedFromDevice",
        "webkitDisplayingFullscreen",
        "webkitDroppedFrameCount",
        "webkitEnterFullScreen",
        "webkitEnterFullscreen",
        "webkitEntries",
        "webkitExitFullScreen",
        "webkitExitFullscreen",
        "webkitExitPointerLock",
        "webkitFilter",
        "webkitFlex",
        "webkitFlexBasis",
        "webkitFlexDirection",
        "webkitFlexFlow",
        "webkitFlexGrow",
        "webkitFlexShrink",
        "webkitFlexWrap",
        "webkitFontFeatureSettings",
        "webkitFullScreenKeyboardInputAllowed",
        "webkitFullscreenElement",
        "webkitFullscreenEnabled",
        "webkitGenerateKeyRequest",
        "webkitGetAsEntry",
        "webkitGetDatabaseNames",
        "webkitGetEntries",
        "webkitGetEntriesByName",
        "webkitGetEntriesByType",
        "webkitGetFlowByName",
        "webkitGetGamepads",
        "webkitGetImageDataHD",
        "webkitGetNamedFlows",
        "webkitGetRegionFlowRanges",
        "webkitGetUserMedia",
        "webkitHasClosedCaptions",
        "webkitHidden",
        "webkitIDBCursor",
        "webkitIDBDatabase",
        "webkitIDBDatabaseError",
        "webkitIDBDatabaseException",
        "webkitIDBFactory",
        "webkitIDBIndex",
        "webkitIDBKeyRange",
        "webkitIDBObjectStore",
        "webkitIDBRequest",
        "webkitIDBTransaction",
        "webkitImageSmoothingEnabled",
        "webkitIndexedDB",
        "webkitInitMessageEvent",
        "webkitIsFullScreen",
        "webkitJustifyContent",
        "webkitKeys",
        "webkitLineClamp",
        "webkitLineDashOffset",
        "webkitLockOrientation",
        "webkitMask",
        "webkitMaskClip",
        "webkitMaskComposite",
        "webkitMaskImage",
        "webkitMaskOrigin",
        "webkitMaskPosition",
        "webkitMaskPositionX",
        "webkitMaskPositionY",
        "webkitMaskRepeat",
        "webkitMaskSize",
        "webkitMatchesSelector",
        "webkitMediaStream",
        "webkitNotifications",
        "webkitOfflineAudioContext",
        "webkitOrder",
        "webkitOrientation",
        "webkitPeerConnection00",
        "webkitPersistentStorage",
        "webkitPerspective",
        "webkitPerspectiveOrigin",
        "webkitPointerLockElement",
        "webkitPostMessage",
        "webkitPreservesPitch",
        "webkitPutImageDataHD",
        "webkitRTCPeerConnection",
        "webkitRegionOverset",
        "webkitRelativePath",
        "webkitRequestAnimationFrame",
        "webkitRequestFileSystem",
        "webkitRequestFullScreen",
        "webkitRequestFullscreen",
        "webkitRequestPointerLock",
        "webkitResolveLocalFileSystemURL",
        "webkitSetMediaKeys",
        "webkitSetResourceTimingBufferSize",
        "webkitShadowRoot",
        "webkitShowPlaybackTargetPicker",
        "webkitSlice",
        "webkitSpeechGrammar",
        "webkitSpeechGrammarList",
        "webkitSpeechRecognition",
        "webkitSpeechRecognitionError",
        "webkitSpeechRecognitionEvent",
        "webkitStorageInfo",
        "webkitSupportsFullscreen",
        "webkitTemporaryStorage",
        "webkitTextFillColor",
        "webkitTextSecurity",
        "webkitTextSizeAdjust",
        "webkitTextStroke",
        "webkitTextStrokeColor",
        "webkitTextStrokeWidth",
        "webkitTransform",
        "webkitTransformOrigin",
        "webkitTransformStyle",
        "webkitTransition",
        "webkitTransitionDelay",
        "webkitTransitionDuration",
        "webkitTransitionProperty",
        "webkitTransitionTimingFunction",
        "webkitURL",
        "webkitUnlockOrientation",
        "webkitUserSelect",
        "webkitVideoDecodedByteCount",
        "webkitVisibilityState",
        "webkitWirelessVideoPlaybackDisabled",
        "webkitdirectory",
        "webkitdropzone",
        "webstore",
        "weight",
        "wgslLanguageFeatures",
        "whatToShow",
        "wheelDelta",
        "wheelDeltaX",
        "wheelDeltaY",
        "whenDefined",
        "which",
        "white-space",
        "white-space-collapse",
        "whiteSpace",
        "whiteSpaceCollapse",
        "wholeText",
        "widows",
        "width",
        "will-change",
        "willChange",
        "willValidate",
        "window",
        "windowAttribution",
        "windowControlsOverlay",
        "windowId",
        "windowIds",
        "windows",
        "with",
        "withCredentials",
        "withResolvers",
        "word-break",
        "word-spacing",
        "word-wrap",
        "wordBreak",
        "wordSpacing",
        "wordWrap",
        "workerStart",
        "worklet",
        "wow64",
        "wrap",
        "wrapKey",
        "writable",
        "writableAuxiliaries",
        "write",
        "writeBuffer",
        "writeMask",
        "writeText",
        "writeTexture",
        "writeTimestamp",
        "writeValue",
        "writeValueWithResponse",
        "writeValueWithoutResponse",
        "writeWithoutResponse",
        "writeln",
        "writing-mode",
        "writingMode",
        "writingSuggestions",
        "x",
        "x1",
        "x2",
        "xChannelSelector",
        "xmlEncoding",
        "xmlStandalone",
        "xmlVersion",
        "xmlbase",
        "xmllang",
        "xmlspace",
        "xor",
        "xr",
        "y",
        "y1",
        "y2",
        "yChannelSelector",
        "yandex",
        "yield",
        "z",
        "z-index",
        "zIndex",
        "zoom",
        "zoomAndPan",
        "zoomRectScreen"
      ];
      function find_builtins(reserved) {
        domprops.forEach(add);
        var new_globals = ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"];
        var objects = {};
        var global_ref = typeof global === "object" ? global : self;
        new_globals.forEach(function(new_global) {
          objects[new_global] = global_ref[new_global] || function() {
          };
        });
        [
          "null",
          "true",
          "false",
          "NaN",
          "Infinity",
          "-Infinity",
          "undefined"
        ].forEach(add);
        [
          Object,
          Array,
          Function,
          Number,
          String,
          Boolean,
          Error,
          Math,
          Date,
          RegExp,
          objects.Symbol,
          ArrayBuffer,
          DataView,
          decodeURI,
          decodeURIComponent,
          encodeURI,
          encodeURIComponent,
          eval,
          EvalError,
          Float32Array,
          Float64Array,
          Int8Array,
          Int16Array,
          Int32Array,
          isFinite,
          isNaN,
          JSON,
          objects.Map,
          parseFloat,
          parseInt,
          objects.Promise,
          objects.Proxy,
          RangeError,
          ReferenceError,
          objects.Reflect,
          objects.Set,
          SyntaxError,
          TypeError,
          Uint8Array,
          Uint8ClampedArray,
          Uint16Array,
          Uint32Array,
          URIError,
          objects.WeakMap,
          objects.WeakSet
        ].forEach(function(ctor) {
          Object.getOwnPropertyNames(ctor).map(add);
          if (ctor.prototype) {
            Object.getOwnPropertyNames(ctor.prototype).map(add);
          }
        });
        function add(name) {
          reserved.add(name);
        }
      }
      function reserve_quoted_keys(ast, reserved) {
        function add(name) {
          push_uniq(reserved, name);
        }
        ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ObjectKeyVal && node.quote) {
            add(node.key);
          } else if (node instanceof AST_ObjectProperty && node.quote) {
            add(node.key.name);
          } else if (node instanceof AST_Sub) {
            addStrings(node.property, add);
          }
        }));
      }
      function addStrings(node, add) {
        node.walk(new TreeWalker(function(node2) {
          if (node2 instanceof AST_Sequence) {
            addStrings(node2.tail_node(), add);
          } else if (node2 instanceof AST_String) {
            add(node2.value);
          } else if (node2 instanceof AST_Conditional) {
            addStrings(node2.consequent, add);
            addStrings(node2.alternative, add);
          }
          return true;
        }));
      }
      function mangle_private_properties(ast, options) {
        var cprivate = -1;
        var private_cache = /* @__PURE__ */ new Map();
        var nth_identifier = options.nth_identifier || base54;
        ast = ast.transform(new TreeTransformer(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_PrivateIn) {
            node.key.name = mangle_private(node.key.name);
          } else if (node instanceof AST_DotHash) {
            node.property = mangle_private(node.property);
          }
        }));
        return ast;
        function mangle_private(name) {
          let mangled = private_cache.get(name);
          if (!mangled) {
            mangled = nth_identifier.get(++cprivate);
            private_cache.set(name, mangled);
          }
          return mangled;
        }
      }
      function find_annotated_props(ast) {
        var annotated_props = /* @__PURE__ */ new Set();
        walk(ast, (node) => {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.key.name);
            }
          } else if (node instanceof AST_Dot) {
            if (has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.property);
            }
          } else if (node instanceof AST_Sub) {
            if (node.property instanceof AST_String && has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.property.value);
            }
          }
        });
        return annotated_props;
      }
      function mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {
        options = defaults(options, {
          builtins: false,
          cache: null,
          debug: false,
          keep_quoted: false,
          nth_identifier: base54,
          only_cache: false,
          regex: null,
          reserved: null,
          undeclared: false,
          only_annotated: false
        }, true);
        var nth_identifier = options.nth_identifier;
        var reserved_option = options.reserved;
        if (!Array.isArray(reserved_option))
          reserved_option = [reserved_option];
        var reserved = new Set(reserved_option);
        if (!options.builtins)
          find_builtins(reserved);
        var cname = -1;
        var cache;
        if (options.cache) {
          cache = options.cache.props;
        } else {
          cache = /* @__PURE__ */ new Map();
        }
        var only_annotated = options.only_annotated;
        var regex = options.regex && new RegExp(options.regex);
        var debug = options.debug !== false;
        var debug_name_suffix;
        if (debug) {
          debug_name_suffix = options.debug === true ? "" : options.debug;
        }
        var names_to_mangle = /* @__PURE__ */ new Set();
        var unmangleable = /* @__PURE__ */ new Set();
        cache.forEach((mangled_name) => unmangleable.add(mangled_name));
        var keep_quoted = !!options.keep_quoted;
        ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
              add(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (!keep_quoted || !node.quote) {
              add(node.key.name);
            }
          } else if (node instanceof AST_Dot) {
            var declared = !!options.undeclared;
            if (!declared) {
              var root = node;
              while (root.expression) {
                root = root.expression;
              }
              declared = !(root.thedef && root.thedef.undeclared);
            }
            if (declared && (!keep_quoted || !node.quote)) {
              add(node.property);
            }
          } else if (node instanceof AST_Sub) {
            if (!keep_quoted) {
              addStrings(node.property, add);
            }
          } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
            addStrings(node.args[1], add);
          } else if (node instanceof AST_Binary && node.operator === "in") {
            addStrings(node.left, add);
          } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
            add(node.value);
          }
        }));
        return ast.transform(new TreeTransformer(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
              node.key = mangle(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (!keep_quoted || !node.quote) {
              if (!node.computed_key()) {
                node.key.name = mangle(node.key.name);
              }
            }
          } else if (node instanceof AST_Dot) {
            if (!keep_quoted || !node.quote) {
              node.property = mangle(node.property);
            }
          } else if (!keep_quoted && node instanceof AST_Sub) {
            node.property = mangleStrings(node.property);
          } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
            node.args[1] = mangleStrings(node.args[1]);
          } else if (node instanceof AST_Binary && node.operator === "in") {
            node.left = mangleStrings(node.left);
          } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
            clear_annotation(node, _KEY);
            node.value = mangle(node.value);
          }
        }));
        function can_mangle(name) {
          if (unmangleable.has(name))
            return false;
          if (reserved.has(name))
            return false;
          if (options.only_cache) {
            return cache.has(name);
          }
          if (/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name))
            return false;
          return true;
        }
        function should_mangle(name) {
          if (only_annotated && !annotated_props.has(name))
            return false;
          if (regex && !regex.test(name)) {
            return annotated_props.has(name);
          }
          if (reserved.has(name))
            return false;
          return cache.has(name) || names_to_mangle.has(name);
        }
        function add(name) {
          if (can_mangle(name)) {
            names_to_mangle.add(name);
          }
          if (!should_mangle(name)) {
            unmangleable.add(name);
          }
        }
        function mangle(name) {
          if (!should_mangle(name)) {
            return name;
          }
          var mangled = cache.get(name);
          if (!mangled) {
            if (debug) {
              var debug_mangled = "_$" + name + "$" + debug_name_suffix + "_";
              if (can_mangle(debug_mangled)) {
                mangled = debug_mangled;
              }
            }
            if (!mangled) {
              do {
                mangled = nth_identifier.get(++cname);
              } while (!can_mangle(mangled));
            }
            cache.set(name, mangled);
          }
          return mangled;
        }
        function mangleStrings(node) {
          return node.transform(new TreeTransformer(function(node2) {
            if (node2 instanceof AST_Sequence) {
              var last = node2.expressions.length - 1;
              node2.expressions[last] = mangleStrings(node2.expressions[last]);
            } else if (node2 instanceof AST_String) {
              clear_annotation(node2, _KEY);
              node2.value = mangle(node2.value);
            } else if (node2 instanceof AST_Conditional) {
              node2.consequent = mangleStrings(node2.consequent);
              node2.alternative = mangleStrings(node2.alternative);
            }
            return node2;
          }));
        }
      }
      var to_ascii = typeof Buffer !== "undefined" ? (b64) => Buffer.from(b64, "base64").toString() : (b64) => decodeURIComponent(escape(atob(b64)));
      var to_base64 = typeof Buffer !== "undefined" ? (str) => Buffer.from(str).toString("base64") : (str) => btoa(unescape(encodeURIComponent(str)));
      function read_source_map(code) {
        var match = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(code);
        if (!match) {
          console.warn("inline source map not found");
          return null;
        }
        return to_ascii(match[2]);
      }
      function set_shorthand(name, options, keys) {
        if (options[name]) {
          keys.forEach(function(key) {
            if (options[key]) {
              if (typeof options[key] != "object")
                options[key] = {};
              if (!(name in options[key]))
                options[key][name] = options[name];
            }
          });
        }
      }
      function init_cache(cache) {
        if (!cache)
          return;
        if (!("props" in cache)) {
          cache.props = /* @__PURE__ */ new Map();
        } else if (!(cache.props instanceof Map)) {
          cache.props = map_from_object(cache.props);
        }
      }
      function cache_to_json(cache) {
        return {
          props: map_to_object(cache.props)
        };
      }
      function log_input(files, options, fs5, debug_folder) {
        if (!(fs5 && fs5.writeFileSync && fs5.mkdirSync)) {
          return;
        }
        try {
          fs5.mkdirSync(debug_folder);
        } catch (e) {
          if (e.code !== "EEXIST")
            throw e;
        }
        const log_path = `${debug_folder}/terser-debug-${Math.random() * 9999999 | 0}.log`;
        options = options || {};
        const options_str = JSON.stringify(options, (_key, thing) => {
          if (typeof thing === "function")
            return "[Function " + thing.toString() + "]";
          if (thing instanceof RegExp)
            return "[RegExp " + thing.toString() + "]";
          return thing;
        }, 4);
        const files_str = (file) => {
          if (typeof file === "object" && options.parse && options.parse.spidermonkey) {
            return JSON.stringify(file, null, 2);
          } else if (typeof file === "object") {
            return Object.keys(file).map((key) => key + ": " + files_str(file[key])).join("\n\n");
          } else if (typeof file === "string") {
            return "```\n" + file + "\n```";
          } else {
            return file;
          }
        };
        fs5.writeFileSync(log_path, "Options: \n" + options_str + "\n\nInput files:\n\n" + files_str(files) + "\n");
      }
      function* minify_sync_or_async(files, options, _fs_module) {
        if (_fs_module && typeof process === "object" && process.env && typeof process.env.TERSER_DEBUG_DIR === "string") {
          log_input(files, options, _fs_module, process.env.TERSER_DEBUG_DIR);
        }
        options = defaults(options, {
          compress: {},
          ecma: void 0,
          enclose: false,
          ie8: false,
          keep_classnames: void 0,
          keep_fnames: false,
          mangle: {},
          module: false,
          nameCache: null,
          output: null,
          format: null,
          parse: {},
          rename: void 0,
          safari10: false,
          sourceMap: false,
          spidermonkey: false,
          timings: false,
          toplevel: false,
          warnings: false,
          wrap: false
        }, true);
        var timings = options.timings && {
          start: Date.now()
        };
        if (options.keep_classnames === void 0) {
          options.keep_classnames = options.keep_fnames;
        }
        if (options.rename === void 0) {
          options.rename = options.compress && options.mangle;
        }
        if (options.output && options.format) {
          throw new Error("Please only specify either output or format option, preferrably format.");
        }
        options.format = options.format || options.output || {};
        set_shorthand("ecma", options, ["parse", "compress", "format"]);
        set_shorthand("ie8", options, ["compress", "mangle", "format"]);
        set_shorthand("keep_classnames", options, ["compress", "mangle"]);
        set_shorthand("keep_fnames", options, ["compress", "mangle"]);
        set_shorthand("module", options, ["parse", "compress", "mangle"]);
        set_shorthand("safari10", options, ["mangle", "format"]);
        set_shorthand("toplevel", options, ["compress", "mangle"]);
        set_shorthand("warnings", options, ["compress"]);
        var quoted_props;
        if (options.mangle) {
          options.mangle = defaults(options.mangle, {
            cache: options.nameCache && (options.nameCache.vars || {}),
            eval: false,
            ie8: false,
            keep_classnames: false,
            keep_fnames: false,
            module: false,
            nth_identifier: base54,
            properties: false,
            reserved: [],
            safari10: false,
            toplevel: false
          }, true);
          if (options.mangle.properties) {
            if (typeof options.mangle.properties != "object") {
              options.mangle.properties = {};
            }
            if (options.mangle.properties.keep_quoted) {
              quoted_props = options.mangle.properties.reserved;
              if (!Array.isArray(quoted_props))
                quoted_props = [];
              options.mangle.properties.reserved = quoted_props;
            }
            if (options.nameCache && !("cache" in options.mangle.properties)) {
              options.mangle.properties.cache = options.nameCache.props || {};
            }
          }
          init_cache(options.mangle.cache);
          init_cache(options.mangle.properties.cache);
        }
        if (options.sourceMap) {
          options.sourceMap = defaults(options.sourceMap, {
            asObject: false,
            content: null,
            filename: null,
            includeSources: false,
            root: null,
            url: null
          }, true);
        }
        if (timings)
          timings.parse = Date.now();
        var toplevel;
        if (files instanceof AST_Toplevel) {
          toplevel = files;
        } else {
          if (typeof files == "string" || options.parse.spidermonkey && !Array.isArray(files)) {
            files = [files];
          }
          options.parse = options.parse || {};
          options.parse.toplevel = null;
          if (options.parse.spidermonkey) {
            options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel2, name2) {
              if (!toplevel2)
                return files[name2];
              toplevel2.body = toplevel2.body.concat(files[name2].body);
              return toplevel2;
            }, null));
          } else {
            delete options.parse.spidermonkey;
            for (var name in files)
              if (HOP(files, name)) {
                options.parse.filename = name;
                options.parse.toplevel = parse2(files[name], options.parse);
                if (options.sourceMap && options.sourceMap.content == "inline") {
                  if (Object.keys(files).length > 1)
                    throw new Error("inline source map only works with singular input");
                  options.sourceMap.content = read_source_map(files[name]);
                }
              }
          }
          if (options.parse.toplevel === null) {
            throw new Error("no source file given");
          }
          toplevel = options.parse.toplevel;
        }
        if (quoted_props && options.mangle.properties.keep_quoted !== "strict") {
          reserve_quoted_keys(toplevel, quoted_props);
        }
        var annotated_props;
        if (options.mangle && options.mangle.properties) {
          annotated_props = find_annotated_props(toplevel);
        }
        if (options.wrap) {
          toplevel = toplevel.wrap_commonjs(options.wrap);
        }
        if (options.enclose) {
          toplevel = toplevel.wrap_enclose(options.enclose);
        }
        if (timings)
          timings.rename = Date.now();
        if (timings)
          timings.compress = Date.now();
        if (options.compress) {
          toplevel = new Compressor(options.compress, {
            mangle_options: options.mangle
          }).compress(toplevel);
        }
        if (timings)
          timings.scope = Date.now();
        if (options.mangle)
          toplevel.figure_out_scope(options.mangle);
        if (timings)
          timings.mangle = Date.now();
        if (options.mangle) {
          toplevel.compute_char_frequency(options.mangle);
          toplevel.mangle_names(options.mangle);
          toplevel = mangle_private_properties(toplevel, options.mangle);
        }
        if (timings)
          timings.properties = Date.now();
        if (options.mangle && options.mangle.properties) {
          toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);
        }
        if (timings)
          timings.format = Date.now();
        var result = {};
        if (options.format.ast) {
          result.ast = toplevel;
        }
        if (options.format.spidermonkey) {
          result.ast = toplevel.to_mozilla_ast();
        }
        let format_options;
        if (!HOP(options.format, "code") || options.format.code) {
          format_options = { ...options.format };
          if (!format_options.ast) {
            format_options._destroy_ast = true;
            walk(toplevel, (node) => {
              if (node instanceof AST_Scope) {
                node.variables = void 0;
                node.enclosed = void 0;
                node.parent_scope = void 0;
              }
              if (node.block_scope) {
                node.block_scope.variables = void 0;
                node.block_scope.enclosed = void 0;
                node.block_scope.parent_scope = void 0;
              }
            });
          }
          if (options.sourceMap) {
            if (options.sourceMap.includeSources && files instanceof AST_Toplevel) {
              throw new Error("original source content unavailable");
            }
            format_options.source_map = yield* SourceMap({
              file: options.sourceMap.filename,
              orig: options.sourceMap.content,
              root: options.sourceMap.root,
              files: options.sourceMap.includeSources ? files : null
            });
          }
          delete format_options.ast;
          delete format_options.code;
          delete format_options.spidermonkey;
          var stream = OutputStream(format_options);
          toplevel.print(stream);
          result.code = stream.get();
          if (options.sourceMap) {
            Object.defineProperty(result, "map", {
              configurable: true,
              enumerable: true,
              get() {
                const map = format_options.source_map.getEncoded();
                return result.map = options.sourceMap.asObject ? map : JSON.stringify(map);
              },
              set(value2) {
                Object.defineProperty(result, "map", {
                  value: value2,
                  writable: true
                });
              }
            });
            result.decoded_map = format_options.source_map.getDecoded();
            if (options.sourceMap.url == "inline") {
              var sourceMap2 = typeof result.map === "object" ? JSON.stringify(result.map) : result.map;
              result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(sourceMap2);
            } else if (options.sourceMap.url) {
              result.code += "\n//# sourceMappingURL=" + options.sourceMap.url;
            }
          }
        }
        if (options.nameCache && options.mangle) {
          if (options.mangle.cache)
            options.nameCache.vars = cache_to_json(options.mangle.cache);
          if (options.mangle.properties && options.mangle.properties.cache) {
            options.nameCache.props = cache_to_json(options.mangle.properties.cache);
          }
        }
        if (format_options && format_options.source_map) {
          format_options.source_map.destroy();
        }
        if (timings) {
          timings.end = Date.now();
          result.timings = {
            parse: 1e-3 * (timings.rename - timings.parse),
            rename: 1e-3 * (timings.compress - timings.rename),
            compress: 1e-3 * (timings.scope - timings.compress),
            scope: 1e-3 * (timings.mangle - timings.scope),
            mangle: 1e-3 * (timings.properties - timings.mangle),
            properties: 1e-3 * (timings.format - timings.properties),
            format: 1e-3 * (timings.end - timings.format),
            total: 1e-3 * (timings.end - timings.start)
          };
        }
        return result;
      }
      async function minify(files, options, _fs_module) {
        const gen = minify_sync_or_async(files, options, _fs_module);
        let yielded;
        let val;
        do {
          val = gen.next(await yielded);
          yielded = val.value;
        } while (!val.done);
        return val.value;
      }
      function minify_sync(files, options, _fs_module) {
        const gen = minify_sync_or_async(files, options, _fs_module);
        let yielded;
        let val;
        do {
          if (yielded && typeof yielded.then === "function") {
            throw new Error("minify_sync cannot be used with the legacy source-map module");
          }
          val = gen.next(yielded);
          yielded = val.value;
        } while (!val.done);
        return val.value;
      }
      async function run_cli({ program, packageJson, fs: fs5, path: path6 }) {
        const skip_keys = /* @__PURE__ */ new Set(["cname", "parent_scope", "scope", "uses_eval", "uses_with"]);
        var files = {};
        var options = {
          compress: false,
          mangle: false
        };
        const default_options = await _default_options();
        program.version(packageJson.name + " " + packageJson.version);
        program.parseArgv = program.parse;
        program.parse = void 0;
        if (process.argv.includes("ast"))
          program.helpInformation = describe_ast;
        else if (process.argv.includes("options"))
          program.helpInformation = function() {
            var text3 = [];
            for (var option in default_options) {
              text3.push("--" + (option === "sourceMap" ? "source-map" : option) + " options:");
              text3.push(format_object(default_options[option]));
              text3.push("");
            }
            return text3.join("\n");
          };
        program.option("-p, --parse <options>", "Specify parser options.", parse_js());
        program.option("-c, --compress [options]", "Enable compressor/specify compressor options.", parse_js());
        program.option("-m, --mangle [options]", "Mangle names/specify mangler options.", parse_js());
        program.option("--mangle-props [options]", "Mangle properties/specify mangler options.", parse_js());
        program.option("-f, --format [options]", "Format options.", parse_js());
        program.option("-b, --beautify [options]", "Alias for --format.", parse_js());
        program.option("-o, --output <file>", "Output file (default STDOUT).");
        program.option("--comments [filter]", "Preserve copyright comments in the output.");
        program.option("--config-file <file>", "Read minify() options from JSON file.");
        program.option("-d, --define <expr>[=value]", "Global definitions.", parse_js("define"));
        program.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017...");
        program.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values.");
        program.option("--ie8", "Support non-standard Internet Explorer 8.");
        program.option("--keep-classnames", "Do not mangle/drop class names.");
        program.option("--keep-fnames", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name.");
        program.option("--module", "Input is an ES6 module");
        program.option("--name-cache <file>", "File to hold mangled name mappings.");
        program.option("--rename", "Force symbol expansion.");
        program.option("--no-rename", "Disable symbol expansion.");
        program.option("--safari10", "Support non-standard Safari 10.");
        program.option("--source-map [options]", "Enable source map/specify source map options.", parse_js());
        program.option("--timings", "Display operations run time on STDERR.");
        program.option("--toplevel", "Compress and/or mangle variables in toplevel scope.");
        program.option("--wrap <name>", "Embed everything as a function with \u201Cexports\u201D corresponding to \u201Cname\u201D globally.");
        program.arguments("[files...]").parseArgv(process.argv);
        if (program.configFile) {
          options = JSON.parse(read_file(program.configFile));
        }
        if (!program.output && program.sourceMap && program.sourceMap.url != "inline") {
          fatal("ERROR: cannot write source map to STDOUT");
        }
        [
          "compress",
          "enclose",
          "ie8",
          "mangle",
          "module",
          "safari10",
          "sourceMap",
          "toplevel",
          "wrap"
        ].forEach(function(name) {
          if (name in program) {
            options[name] = program[name];
          }
        });
        if ("ecma" in program) {
          if (program.ecma != (program.ecma | 0))
            fatal("ERROR: ecma must be an integer");
          const ecma = program.ecma | 0;
          if (ecma > 5 && ecma < 2015)
            options.ecma = ecma + 2009;
          else
            options.ecma = ecma;
        }
        if (program.format || program.beautify) {
          const chosenOption = program.format || program.beautify;
          options.format = typeof chosenOption === "object" ? chosenOption : {};
        }
        if (program.comments) {
          if (typeof options.format != "object")
            options.format = {};
          options.format.comments = typeof program.comments == "string" ? program.comments == "false" ? false : program.comments : "some";
        }
        if (program.define) {
          if (typeof options.compress != "object")
            options.compress = {};
          if (typeof options.compress.global_defs != "object")
            options.compress.global_defs = {};
          for (var expr in program.define) {
            options.compress.global_defs[expr] = program.define[expr];
          }
        }
        if (program.keepClassnames) {
          options.keep_classnames = true;
        }
        if (program.keepFnames) {
          options.keep_fnames = true;
        }
        if (program.mangleProps) {
          if (program.mangleProps.domprops) {
            delete program.mangleProps.domprops;
          } else {
            if (typeof program.mangleProps != "object")
              program.mangleProps = {};
            if (!Array.isArray(program.mangleProps.reserved))
              program.mangleProps.reserved = [];
          }
          if (typeof options.mangle != "object")
            options.mangle = {};
          options.mangle.properties = program.mangleProps;
        }
        if (program.nameCache) {
          options.nameCache = JSON.parse(read_file(program.nameCache, "{}"));
        }
        if (program.output == "ast") {
          options.format = {
            ast: true,
            code: false
          };
        }
        if (program.parse) {
          if (!program.parse.acorn && !program.parse.spidermonkey) {
            options.parse = program.parse;
          } else if (program.sourceMap && program.sourceMap.content == "inline") {
            fatal("ERROR: inline source map only works with built-in parser");
          }
        }
        if (~program.rawArgs.indexOf("--rename")) {
          options.rename = true;
        } else if (!program.rename) {
          options.rename = false;
        }
        let convert_path = (name) => name;
        if (typeof program.sourceMap == "object" && "base" in program.sourceMap) {
          convert_path = function() {
            var base = program.sourceMap.base;
            delete options.sourceMap.base;
            return function(name) {
              return path6.relative(base, name);
            };
          }();
        }
        let filesList;
        if (options.files && options.files.length) {
          filesList = options.files;
          delete options.files;
        } else if (program.args.length) {
          filesList = program.args;
        }
        if (filesList) {
          simple_glob(filesList).forEach(function(name) {
            files[convert_path(name)] = read_file(name);
          });
        } else {
          await new Promise((resolve) => {
            var chunks = [];
            process.stdin.setEncoding("utf8");
            process.stdin.on("data", function(chunk) {
              chunks.push(chunk);
            }).on("end", function() {
              files = [chunks.join("")];
              resolve();
            });
            process.stdin.resume();
          });
        }
        await run_cli2();
        function convert_ast(fn) {
          return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
        }
        async function run_cli2() {
          var content = program.sourceMap && program.sourceMap.content;
          if (content && content !== "inline") {
            options.sourceMap.content = read_file(content, content);
          }
          if (program.timings)
            options.timings = true;
          try {
            if (program.parse) {
              if (program.parse.acorn) {
                files = convert_ast(function(toplevel, name) {
                  return require_acorn().parse(files[name], {
                    ecmaVersion: 2024,
                    locations: true,
                    program: toplevel,
                    sourceFile: name,
                    sourceType: options.module || program.parse.module ? "module" : "script"
                  });
                });
              } else if (program.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                  var obj = JSON.parse(files[name]);
                  if (!toplevel)
                    return obj;
                  toplevel.body = toplevel.body.concat(obj.body);
                  return toplevel;
                });
              }
            }
          } catch (ex) {
            fatal(ex);
          }
          let result;
          try {
            result = await minify(files, options, fs5);
          } catch (ex) {
            if (ex.name == "SyntaxError") {
              print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
              var col = ex.col;
              var lines = files[ex.filename].split(/\r?\n/);
              var line = lines[ex.line - 1];
              if (!line && !col) {
                line = lines[ex.line - 2];
                col = line.length;
              }
              if (line) {
                var limit = 70;
                if (col > limit) {
                  line = line.slice(col - limit);
                  col = limit;
                }
                print_error(line.slice(0, 80));
                print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
              }
            }
            if (ex.defs) {
              print_error("Supported options:");
              print_error(format_object(ex.defs));
            }
            fatal(ex);
            return;
          }
          if (program.output == "ast") {
            if (!options.compress && !options.mangle) {
              result.ast.figure_out_scope({});
            }
            console.log(JSON.stringify(result.ast, function(key, value2) {
              if (value2)
                switch (key) {
                  case "thedef":
                    return symdef(value2);
                  case "enclosed":
                    return value2.length ? value2.map(symdef) : void 0;
                  case "variables":
                  case "globals":
                    return value2.size ? collect_from_map(value2, symdef) : void 0;
                }
              if (skip_keys.has(key))
                return;
              if (value2 instanceof AST_Token)
                return;
              if (value2 instanceof Map)
                return;
              if (value2 instanceof AST_Node) {
                var result2 = {
                  _class: "AST_" + value2.TYPE
                };
                if (value2.block_scope) {
                  result2.variables = value2.block_scope.variables;
                  result2.enclosed = value2.block_scope.enclosed;
                }
                value2.CTOR.PROPS.forEach(function(prop) {
                  if (prop !== "block_scope") {
                    result2[prop] = value2[prop];
                  }
                });
                return result2;
              }
              return value2;
            }, 2));
          } else if (program.output == "spidermonkey") {
            try {
              const minified = await minify(result.code, {
                compress: false,
                mangle: false,
                format: {
                  ast: true,
                  code: false
                }
              }, fs5);
              console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));
            } catch (ex) {
              fatal(ex);
              return;
            }
          } else if (program.output) {
            fs5.mkdirSync(path6.dirname(program.output), { recursive: true });
            fs5.writeFileSync(program.output, result.code);
            if (options.sourceMap && options.sourceMap.url !== "inline" && result.map) {
              fs5.writeFileSync(program.output + ".map", result.map);
            }
          } else {
            console.log(result.code);
          }
          if (program.nameCache) {
            fs5.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));
          }
          if (result.timings)
            for (var phase in result.timings) {
              print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
            }
        }
        function fatal(message) {
          if (message instanceof Error)
            message = message.stack.replace(/^\S*?Error:/, "ERROR:");
          print_error(message);
          process.exit(1);
        }
        function simple_glob(glob) {
          if (Array.isArray(glob)) {
            return [].concat.apply([], glob.map(simple_glob));
          }
          if (glob && glob.match(/[*?]/)) {
            var dir = path6.dirname(glob);
            try {
              var entries = fs5.readdirSync(dir);
            } catch (ex) {
            }
            if (entries) {
              var pattern = "^" + path6.basename(glob).replace(/[.+^$[\]\\(){}]/g, "\\$&").replace(/\*/g, "[^/\\\\]*").replace(/\?/g, "[^/\\\\]") + "$";
              var mod = process.platform === "win32" ? "i" : "";
              var rx = new RegExp(pattern, mod);
              var results = entries.filter(function(name) {
                return rx.test(name);
              }).map(function(name) {
                return path6.join(dir, name);
              });
              if (results.length)
                return results;
            }
          }
          return [glob];
        }
        function read_file(path7, default_value) {
          try {
            return fs5.readFileSync(path7, "utf8");
          } catch (ex) {
            if ((ex.code == "ENOENT" || ex.code == "ENAMETOOLONG") && default_value != null)
              return default_value;
            fatal(ex);
          }
        }
        function parse_js(flag) {
          return function(value2, options2) {
            options2 = options2 || {};
            try {
              walk(parse2(value2, { expression: true }), (node) => {
                if (node instanceof AST_Assign) {
                  var name = node.left.print_to_string();
                  var value3 = node.right;
                  if (flag) {
                    options2[name] = value3;
                  } else if (value3 instanceof AST_Array) {
                    options2[name] = value3.elements.map(to_string);
                  } else if (value3 instanceof AST_RegExp) {
                    value3 = value3.value;
                    options2[name] = new RegExp(value3.source, value3.flags);
                  } else {
                    options2[name] = to_string(value3);
                  }
                  return true;
                }
                if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {
                  var name = node.print_to_string();
                  options2[name] = true;
                  return true;
                }
                if (!(node instanceof AST_Sequence))
                  throw node;
                function to_string(value4) {
                  return value4 instanceof AST_Constant ? value4.getValue() : value4.print_to_string({
                    quote_keys: true
                  });
                }
              });
            } catch (ex) {
              if (flag) {
                fatal("Error parsing arguments for '" + flag + "': " + value2);
              } else {
                options2[value2] = null;
              }
            }
            return options2;
          };
        }
        function symdef(def) {
          var ret = 1e6 + def.id + " " + def.name;
          if (def.mangled_name)
            ret += " " + def.mangled_name;
          return ret;
        }
        function collect_from_map(map, callback) {
          var result = [];
          map.forEach(function(def) {
            result.push(callback(def));
          });
          return result;
        }
        function format_object(obj) {
          var lines = [];
          var padding = "";
          Object.keys(obj).map(function(name) {
            if (padding.length < name.length)
              padding = Array(name.length + 1).join(" ");
            return [name, JSON.stringify(obj[name])];
          }).forEach(function(tokens) {
            lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
          });
          return lines.join("\n");
        }
        function print_error(msg) {
          process.stderr.write(msg);
          process.stderr.write("\n");
        }
        function describe_ast() {
          var out = OutputStream({ beautify: true });
          function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            const props = ctor.SELF_PROPS.filter((prop) => !/^\$/.test(prop));
            if (props.length > 0) {
              out.space();
              out.with_parens(function() {
                props.forEach(function(prop, i) {
                  if (i)
                    out.space();
                  out.print(prop);
                });
              });
            }
            if (ctor.documentation) {
              out.space();
              out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
              out.space();
              out.with_block(function() {
                ctor.SUBCLASSES.forEach(function(ctor2) {
                  out.indent();
                  doitem(ctor2);
                  out.newline();
                });
              });
            }
          }
          doitem(AST_Node);
          return out + "\n";
        }
      }
      async function _default_options() {
        const defs = {};
        Object.keys(infer_options({ 0: 0 })).forEach((component) => {
          const options = infer_options({
            [component]: { 0: 0 }
          });
          if (options)
            defs[component] = options;
        });
        return defs;
      }
      async function infer_options(options) {
        try {
          await minify("", options);
        } catch (error) {
          return error.defs;
        }
      }
      exports3._default_options = _default_options;
      exports3._run_cli = run_cli;
      exports3.minify = minify;
      exports3.minify_sync = minify_sync;
    });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/minifier.js
var require_minifier = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/minifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MinifierClient = void 0;
    var resources_1 = require_resources2();
    var terser_1 = require_bundle_min();
    var MinifierClient = class {
      constructor(minifyOutput = false) {
        this.minifiers = /* @__PURE__ */ new Map();
        this.minifyOutput = minifyOutput;
        this.setupMinifiers();
      }
      setupMinifiers() {
        this.minifiers.set("text/css", this.minifyCSS.bind(this));
        this.minifiers.set("text/javascript", this.minifyJS.bind(this));
        this.minifiers.set("application/javascript", this.minifyJS.bind(this));
        this.minifiers.set("application/json", this.minifyJSON.bind(this));
        this.minifiers.set("text/html", this.minifyHTML.bind(this));
        this.minifiers.set("image/svg+xml", this.minifySVG.bind(this));
        this.minifiers.set("application/xml", this.minifyXML.bind(this));
        this.minifiers.set("text/xml", this.minifyXML.bind(this));
      }
      async minify(resource) {
        const transformation = new MinifyTransformation(this);
        return resource.transform(transformation);
      }
      getMinifier(mediaType) {
        return this.minifiers.get(mediaType) || null;
      }
      async minifyCSS(content) {
        return content;
      }
      async minifyJS(content) {
        try {
          const result = await (0, terser_1.minify)(content, {
            compress: {
              drop_console: false,
              drop_debugger: true,
              passes: 2
            },
            mangle: {
              toplevel: false
            },
            format: {
              comments: false
            }
          });
          return result.code || content;
        } catch (error) {
          return content;
        }
      }
      async minifyJSON(content) {
        try {
          return JSON.stringify(JSON.parse(content));
        } catch {
          return content;
        }
      }
      async minifyHTML(content) {
        return content;
      }
      async minifySVG(content) {
        return content;
      }
      async minifyXML(content) {
        return content;
      }
    };
    exports2.MinifierClient = MinifierClient;
    var MinifyTransformation = class {
      constructor(minifierClient) {
        this.minifierClient = minifierClient;
      }
      key() {
        return resources_1.ResourceTransformationKey.newResourceTransformationKey("minify");
      }
      async transform(ctx) {
        ctx.addOutPathIdentifier(".min");
        const mediaType = ctx.source.inMediaType.type;
        const minifier = this.minifierClient.getMinifier(mediaType);
        if (!minifier) {
          ctx.source.from.pipe(ctx.target.to);
          return;
        }
        let content = "";
        ctx.source.from.on("data", (chunk) => {
          content += chunk.toString();
        });
        await new Promise((resolve, reject) => {
          ctx.source.from.on("end", async () => {
            try {
              const minified = await minifier(content);
              ctx.target.to.write(minified);
              ctx.target.to.end();
              resolve();
            } catch (error) {
              reject(error);
            }
          });
          ctx.source.from.on("error", reject);
        });
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/integrity.js
var require_integrity = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/integrity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntegrityClient = void 0;
    var crypto_1 = require("crypto");
    var resources_1 = require_resources2();
    var DEFAULT_HASH_ALGO = "sha256";
    var IntegrityClient = class {
      async fingerprint(resource, algo = DEFAULT_HASH_ALGO) {
        const transformation = new FingerprintTransformation(algo);
        return resource.transform(transformation);
      }
      generateIntegrity(content) {
        const hash = (0, crypto_1.createHash)("sha256").update(content, "utf8").digest("base64");
        return `sha256-${hash}`;
      }
      generateSHA384(content) {
        const hash = (0, crypto_1.createHash)("sha384").update(content, "utf8").digest("base64");
        return `sha384-${hash}`;
      }
      generateSHA512(content) {
        const hash = (0, crypto_1.createHash)("sha512").update(content, "utf8").digest("base64");
        return `sha512-${hash}`;
      }
      verifyIntegrity(content, integrity) {
        const [algorithm, expectedHash] = integrity.split("-", 2);
        let actualHash;
        switch (algorithm) {
          case "sha256":
            actualHash = (0, crypto_1.createHash)("sha256").update(content, "utf8").digest("base64");
            break;
          case "sha384":
            actualHash = (0, crypto_1.createHash)("sha384").update(content, "utf8").digest("base64");
            break;
          case "sha512":
            actualHash = (0, crypto_1.createHash)("sha512").update(content, "utf8").digest("base64");
            break;
          default:
            return false;
        }
        return actualHash === expectedHash;
      }
    };
    exports2.IntegrityClient = IntegrityClient;
    var FingerprintTransformation = class {
      constructor(algo) {
        this.algo = algo;
      }
      key() {
        return resources_1.ResourceTransformationKey.newResourceTransformationKey("fingerprint", this.algo);
      }
      async transform(ctx) {
        const hash = this.newHash(this.algo);
        let content = "";
        const chunks = [];
        ctx.source.from.on("data", (chunk) => {
          hash.update(chunk);
          chunks.push(chunk);
          content += chunk.toString();
        });
        await new Promise((resolve, reject) => {
          ctx.source.from.on("end", () => {
            try {
              const digest = hash.digest();
              const hexDigest = digest.toString("hex");
              ctx.data["Integrity"] = this.integrity(this.algo, digest);
              const shortHash = hexDigest.substring(0, 12);
              ctx.addOutPathIdentifier("." + shortHash);
              for (const chunk of chunks) {
                ctx.target.to.write(chunk);
              }
              ctx.target.to.end();
              resolve();
            } catch (error) {
              reject(error);
            }
          });
          ctx.source.from.on("error", reject);
        });
      }
      newHash(algo) {
        switch (algo) {
          case "md5":
            return (0, crypto_1.createHash)("md5");
          case "sha256":
            return (0, crypto_1.createHash)("sha256");
          case "sha384":
            return (0, crypto_1.createHash)("sha384");
          case "sha512":
            return (0, crypto_1.createHash)("sha512");
          default:
            throw new Error(`Unsupported hash algorithm: "${algo}", use either md5, sha256, sha384 or sha512`);
        }
      }
      integrity(algo, digest) {
        const encoded = digest.toString("base64");
        return `${algo}-${encoded}`;
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/template.js
var require_template5 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateClient = void 0;
    var resources_1 = require_resources2();
    var ExecuteAsTemplateTransform = class {
      constructor(templateExecutor, targetPath, data) {
        this.templateExecutor = templateExecutor;
        this._targetPath = targetPath;
        this.data = data;
      }
      key() {
        return resources_1.ResourceTransformationKey.newResourceTransformationKey("execute-as-template", this._targetPath);
      }
      async transform(ctx) {
        try {
          ctx.data.targetPath = this._targetPath;
          let templateContent = "";
          if (typeof ctx.source.from.read === "function") {
            let chunk;
            const chunks = [];
            while ((chunk = ctx.source.from.read()) !== null) {
              if (chunk) {
                chunks.push(chunk);
              }
            }
            if (chunks.length > 0) {
              templateContent = Buffer.concat(chunks).toString();
            } else {
              if (ctx.source.from._readableState && ctx.source.from._readableState.buffer) {
                const buffer = ctx.source.from._readableState.buffer;
                const bufferChunks = [];
                for (const entry of buffer) {
                  if (entry && entry.chunk) {
                    bufferChunks.push(entry.chunk);
                  }
                }
                if (bufferChunks.length > 0) {
                  templateContent = Buffer.concat(bufferChunks).toString();
                }
              }
            }
          }
          if (!templateContent) {
            return new Promise((resolve, reject) => {
              const contentChunks = [];
              ctx.source.from.on("data", (chunk) => {
                contentChunks.push(chunk);
              });
              ctx.source.from.on("end", async () => {
                try {
                  const content = Buffer.concat(contentChunks).toString();
                  await this.executeTemplate(content, ctx, resolve, reject);
                } catch (error) {
                  reject(new Error(`failed to parse Resource "${ctx.source.inPath}" as Template: ${error}`));
                }
              });
              ctx.source.from.on("error", (error) => {
                reject(error);
              });
              if (typeof ctx.source.from.resume === "function") {
                ctx.source.from.resume();
              }
            });
          } else {
            await this.executeTemplateSync(templateContent, ctx);
          }
        } catch (error) {
          throw new Error(`failed to parse Resource "${ctx.source.inPath}" as Template: ${error}`);
        }
      }
      async executeTemplateSync(templateContent, ctx) {
        const templateResult = await this.templateExecutor.executeTemplate(ctx.source.inPath, templateContent, this.data);
        ctx.target.to.write(templateResult);
        ctx.target.to.end();
      }
      async executeTemplate(templateContent, ctx, resolve, reject) {
        try {
          await this.executeTemplateSync(templateContent, ctx);
          resolve();
        } catch (error) {
          reject(error instanceof Error ? error : new Error(String(error)));
        }
      }
    };
    var TemplateClient = class {
      constructor(templateExecutor) {
        this.templateExecutor = templateExecutor;
      }
      async executeAsTemplate(resource, targetPath, data) {
        try {
          if (!resource) {
            throw new Error(`Resource is null or undefined`);
          }
          if (typeof resource.transform !== "function") {
            throw new Error(`Resource does not implement Transformer interface. Resource type: ${typeof resource}`);
          }
          const transformation = new ExecuteAsTemplateTransform(this.templateExecutor, targetPath.replace(/\\/g, "/").replace(/^\/+/, ""), data);
          const transformedResource = await resource.transform(transformation);
          return transformedResource;
        } catch (error) {
          throw error;
        }
      }
    };
    exports2.TemplateClient = TemplateClient;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/publisher.js
var require_publisher2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/publisher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Publisher = void 0;
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("resources", { component: "publisher" });
    var Publisher = class {
      constructor(pubFs, urlSvc) {
        this.pubFs = pubFs;
        this.urlSvc = urlSvc;
      }
      async openPublishFileForWriting(filename) {
        const cleanFilename = filename.replace(/^\/+/, "");
        try {
          const file = await this.pubFs.create(cleanFilename);
          return new FileWritable(file);
        } catch (error) {
          if (error.code === "ENOENT" || error.message.includes("ENOENT")) {
            const dir = path6.dirname(cleanFilename);
            await this.pubFs.mkdirAll(dir, 511);
            const file = await this.pubFs.create(cleanFilename);
            const originalClose = file.close.bind(file);
            file.close = async () => {
              try {
                await originalClose();
              } catch (error2) {
                log.errorf("\u274C [Publisher.File.close] Error closing publish file (retry) %s, $s", cleanFilename, error2);
                throw error2;
              }
            };
            return new FileWritable(file);
          }
          throw error;
        }
      }
      async openFilesForWriting(...filenames) {
        if (filenames.length === 0) {
          throw new Error("No filenames provided");
        }
        const filename = filenames[0];
        return await this.openFileForWriting(filename);
      }
      async openFileForWriting(filename) {
        const cleanFilename = path6.normalize(filename);
        try {
          return await this.pubFs.create(cleanFilename);
        } catch (error) {
          if (!this.isFileNotFoundError(error)) {
            throw error;
          }
          const dir = path6.dirname(cleanFilename);
          await this.pubFs.mkdirAll(dir, 511);
          return await this.pubFs.create(cleanFilename);
        }
      }
      isFileNotFoundError(error) {
        return error && (error.code === "ENOENT" || error.message?.includes("no such file or directory") || error.message?.includes("not found"));
      }
    };
    exports2.Publisher = Publisher;
    var stream_1 = require("stream");
    var FileWritable = class extends stream_1.Writable {
      constructor(file) {
        super();
        this.file = file;
      }
      _write(chunk, _encoding, callback) {
        this.file.write(chunk).then(() => callback()).catch(callback);
      }
      _final(callback) {
        this.file.sync?.().then(() => this.file.close()).then(() => callback()).catch(callback);
      }
    };
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/http.js
var require_http2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/http.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = void 0;
    var log_1 = require_log();
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var log = (0, log_1.getDomainLogger)("resources", { component: "http-client" });
    var HttpClient = class {
      constructor() {
        this.defaultTimeout = 3e4;
        this.defaultHeaders = {
          "User-Agent": "MDFriday-Resources/1.0.0"
        };
      }
      async fromRemote(uri, options) {
        return new Promise((resolve) => {
          try {
            const parsedUrl = new URL(uri);
            const isHttps = parsedUrl.protocol === "https:";
            const httpModule = isHttps ? https : http;
            const requestHeaders = {
              ...this.defaultHeaders,
              ...options?.headers
            };
            const requestOptions = {
              hostname: parsedUrl.hostname,
              port: parsedUrl.port || (isHttps ? 443 : 80),
              path: parsedUrl.pathname + parsedUrl.search,
              method: "GET",
              headers: requestHeaders,
              timeout: options?.timeout || this.defaultTimeout
            };
            const request = httpModule.request(requestOptions, (response) => {
              if (response.statusCode && response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
                log.infof("\u{1F504} [HttpClient.fromRemote] Redirecting from %s to %s", uri, response.headers.location);
                this.fromRemote(response.headers.location, options).then(resolve);
                return;
              }
              if (!response.statusCode || response.statusCode < 200 || response.statusCode >= 300) {
                log.errorf("\u274C [HttpClient.fromRemote] HTTP error %d when fetching %s: %s", response.statusCode || 0, uri, response.statusMessage || "Unknown error");
                resolve(null);
                return;
              }
              const chunks = [];
              response.on("data", (chunk) => {
                chunks.push(chunk);
              });
              response.on("end", () => {
                try {
                  const buffer = Buffer.concat(chunks);
                  const content = buffer.toString("utf8");
                  log.infof("\u2705 [HttpClient.fromRemote] Successfully fetched %d bytes from %s", content.length, uri);
                  resolve(content);
                } catch (error) {
                  log.errorf("\u274C [HttpClient.fromRemote] Error converting response to string from %s: %s", uri, error);
                  resolve(null);
                }
              });
              response.on("error", (error) => {
                log.errorf("\u274C [HttpClient.fromRemote] Response error when fetching %s: %s", uri, error.message);
                resolve(null);
              });
            });
            request.on("error", (error) => {
              log.errorf("\u274C [HttpClient.fromRemote] Request error when fetching %s: %s", uri, error.message);
              resolve(null);
            });
            request.on("timeout", () => {
              request.destroy();
              log.errorf("\u274C [HttpClient.fromRemote] Request timeout when fetching %s", uri);
              resolve(null);
            });
            request.end();
          } catch (error) {
            log.errorf("\u274C [HttpClient.fromRemote] Error fetching content from %s: %s", uri, error);
            resolve(null);
          }
        });
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/resources.js
var require_resources = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/entity/resources.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Resources = void 0;
    var resource_1 = require_resource();
    var resources_1 = require_resources2();
    var minifier_1 = require_minifier();
    var integrity_1 = require_integrity();
    var template_1 = require_template5();
    var publisher_1 = require_publisher2();
    var http_1 = require_http2();
    var type_1 = require_type7();
    var path6 = __importStar(require("path"));
    var crypto_1 = require("crypto");
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("resources", { component: "resources" });
    var Resources = class {
      constructor(workspace) {
        this.cache = /* @__PURE__ */ new Map();
        this.templateClient = null;
        this.workspace = workspace;
        this.fsSvc = workspace;
        this.urlSvc = workspace;
        this.templateSvc = workspace;
        this.publisher = new publisher_1.Publisher(workspace.publishFs(), workspace);
        this.minifierClient = new minifier_1.MinifierClient();
        this.integrityClient = new integrity_1.IntegrityClient();
        this.templateClient = new template_1.TemplateClient(this.templateSvc);
        this.httpClient = new http_1.HttpClient();
      }
      setTemplateSvc(templateSvc) {
        this.templateSvc = templateSvc;
        this.templateClient = new template_1.TemplateClient(templateSvc);
      }
      async getResource(pathname) {
        const cleanPath = path6.posix.normalize(pathname);
        const cacheKey = `${cleanPath}__get`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey) || null;
        }
        try {
          const assetsFs = this.workspace.assetsFs();
          const stats = await assetsFs.stat(cleanPath);
          if (!stats) {
            return null;
          }
          const opener = async () => {
            const file = await assetsFs.open(cleanPath);
            return await this.createReadSeekCloser(file);
          };
          const resource = await this.buildResource(cleanPath, opener);
          if (resource) {
            this.cache.set(cacheKey, resource);
          }
          return resource;
        } catch (error) {
          log.errorf("\u274C [Resources.getResource] Error getting resource %s, %s", cleanPath, error);
          return null;
        }
      }
      async getResourceWithOpener(pathname, opener) {
        const cleanPath = path6.posix.normalize(pathname);
        const cacheKey = `${cleanPath}__get_with_opener`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey) || null;
        }
        try {
          const resource = await this.buildResource(cleanPath, opener);
          if (resource) {
            this.cache.set(cacheKey, resource);
          }
          return resource;
        } catch (error) {
          log.errorf("\u274C [Resources.getResourceWithOpener] Error getting resource with opener %s, %s", cleanPath, error);
          return null;
        }
      }
      async executeAsTemplate(resource, targetPath, data) {
        if (!this.templateClient) {
          throw new Error("Template client not available. Please set template client first.");
        }
        const key = resource.key() + "-template-" + targetPath;
        const cacheKey = this.cacheKey(key);
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        try {
          const result = await this.templateClient.executeAsTemplate(resource, targetPath, data);
          if (result) {
            this.cache.set(cacheKey, result);
          } else {
            log.warnf("\u26A0\uFE0F [Resources.executeAsTemplate] Template execution returned null for resource %s", resource.key());
          }
          return result;
        } catch (error) {
          log.errorf("\u274C [Resources.executeAsTemplate] Error executing template %s, %s", resource.key(), error);
          throw error;
        }
      }
      async minify(resource) {
        if (!this.minifierClient) {
          throw new Error("Minifier client not available. Please set minifier client first.");
        }
        const key = resource.key() + "-minify";
        const cacheKey = this.cacheKey(key);
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        try {
          const result = await this.minifierClient.minify(resource);
          if (result) {
            this.cache.set(cacheKey, result);
          } else {
            log.warnf("\u26A0\uFE0F [Resources.minify] Minification returned null for resource %s", resource.key());
          }
          return result;
        } catch (error) {
          log.errorf("\u274C [Resources.minify] Error minifying resource %s, %s", resource.key(), error);
          throw error;
        }
      }
      async fingerprint(resource) {
        const key = resource.key() + "-fingerprint";
        const cacheKey = this.cacheKey(key);
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        try {
          const res = await this.integrityClient.fingerprint(resource);
          if (res) {
            this.cache.set(cacheKey, res);
          } else {
            log.warnf("\u26A0\uFE0F [Resources.fingerprint] Fingerprint operation returned null for resource %s", resource.key());
          }
          return res;
        } catch (error) {
          log.errorf("\u274C [Resources.fingerprint] Error fingerprinting resource %s, %s", resource.key(), error);
          throw error;
        }
      }
      async getRemote(uri) {
        const cacheKey = `${uri}__remote`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey) || null;
        }
        try {
          const content = await this.httpClient.fromRemote(uri);
          if (!content) {
            return null;
          }
          const opener = async () => {
            return this.newReadSeekerNoOpCloserFromString(content);
          };
          const resource = await this.buildResource(uri, opener);
          if (resource) {
            this.cache.set(cacheKey, resource);
          }
          return resource;
        } catch (error) {
          log.errorf("\u274C [Resources.fromRemote] Error getting remote resource %s, %s", uri, error);
          return null;
        }
      }
      cacheKey(key) {
        return (0, crypto_1.createHash)("sha256").update(key).digest("hex").substring(0, 16);
      }
      getMinifierClient() {
        return this.minifierClient;
      }
      getIntegrityClient() {
        return this.integrityClient;
      }
      setTemplateClient(client) {
        this.templateClient = client;
      }
      async buildResource(pathname, opener) {
        try {
          const ext = path6.extname(pathname);
          const mediaType = this.getMediaTypeFromExtension(ext);
          const resourcePaths = resources_1.ResourcePaths.newResourcePaths(pathname, this.workspace);
          const resource = new resource_1.ResourceImpl(opener, mediaType, resourcePaths, {}, this.publisher);
          return resource;
        } catch (error) {
          log.errorf("\u274C [Resources.buildResource] Error building resource for %s, %s", pathname, error);
          return null;
        }
      }
      getMediaTypeFromExtension(ext) {
        const mediaTypes = {
          ".js": { type: "text/javascript", mainType: "text", subType: "javascript" },
          ".css": { type: "text/css", mainType: "text", subType: "css" },
          ".html": { type: "text/html", mainType: "text", subType: "html" },
          ".json": { type: "application/json", mainType: "application", subType: "json" },
          ".svg": { type: "image/svg+xml", mainType: "image", subType: "svg+xml" },
          ".xml": { type: "application/xml", mainType: "application", subType: "xml" },
          ".txt": { type: "text/plain", mainType: "text", subType: "plain" }
        };
        const defaultMediaType = ext ? mediaTypes[ext] || mediaTypes[".txt"] : mediaTypes[".html"];
        const suffix = ext ? ext.substring(1) : "html";
        const fullSuffix = ext || ".html";
        return new type_1.MediaType({
          type: defaultMediaType.type,
          mainType: defaultMediaType.mainType,
          subType: defaultMediaType.subType,
          delimiter: ".",
          firstSuffix: { suffix, fullSuffix },
          mimeSuffix: "",
          suffixesCSV: suffix
        });
      }
      async createReadSeekCloser(file) {
        try {
          const chunks = [];
          let totalBytesRead = 0;
          try {
            while (true) {
              const buffer = new Uint8Array(8192);
              const result = await file.read(buffer);
              if (result.bytesRead === 0) {
                break;
              }
              totalBytesRead += result.bytesRead;
              chunks.push(buffer.slice(0, result.bytesRead));
            }
          } finally {
            await file.close();
          }
          let content = "";
          if (chunks.length > 0) {
            const allBytes = new Uint8Array(totalBytesRead);
            let offset = 0;
            for (const chunk of chunks) {
              allBytes.set(chunk, offset);
              offset += chunk.length;
            }
            content = new TextDecoder().decode(allBytes);
          }
          return this.newReadSeekerNoOpCloserFromString(content);
        } catch (error) {
          try {
            await file.close();
          } catch (closeError) {
            log.warnf("\u274C [Resources.createReadSeekCloser] Error closing file after read error %s, %s", file.path, closeError);
          }
          return this.newReadSeekerNoOpCloserFromString("");
        }
      }
      newReadSeekerNoOpCloserFromString(content) {
        const { Readable } = require("stream");
        const stream = new Readable({
          read() {
          }
        });
        stream.push(content);
        stream.push(null);
        return Object.assign(stream, {
          seek: async (offset, whence) => {
            return 0;
          },
          close: async () => {
            return Promise.resolve();
          }
        });
      }
    };
    exports2.Resources = Resources;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/resourcepaths.js
var require_resourcepaths = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/resourcepaths.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResourcePaths = void 0;
    var path6 = __importStar(require("path"));
    var ResourcePaths = class {
      constructor(dir = "", file = "", baseDirTarget = "", baseDirLink = "", targetBasePaths = [], baseUrl = "") {
        this.baseUrl = "";
        this.dir = dir;
        this.file = file;
        this.baseDirTarget = baseDirTarget;
        this.baseDirLink = baseDirLink;
        this.targetBasePaths = targetBasePaths;
        this.baseUrl = baseUrl;
      }
      static newResourcePaths(targetPath, svc) {
        const normalizedPath = targetPath.replace(/\\/g, "/");
        const parsedPath = path6.posix.parse(normalizedPath);
        let dir = parsedPath.dir;
        if (dir === "/") {
          dir = "";
        }
        return new ResourcePaths(dir, parsedPath.base, svc.baseUrl(), svc.baseUrl(), [], svc.baseUrl());
      }
      join(...parts) {
        let result = "";
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          if (!part)
            continue;
          if (result === "") {
            result = part;
          } else {
            const needsSlash = !result.endsWith("/") && !part.startsWith("/");
            const hasDoubleSlash = result.endsWith("/") && part.startsWith("/");
            if (hasDoubleSlash) {
              result += part.substring(1);
            } else if (needsSlash) {
              result += "/" + part;
            } else {
              result += part;
            }
          }
        }
        if (result.startsWith("/")) {
          result = result.substring(1);
        }
        if (result.endsWith("/") && result.length > 1) {
          result = result.substring(0, result.length - 1);
        }
        return result;
      }
      targetLink() {
        let link = this.join(this.baseDirLink, this.dir, this.file);
        if (link.startsWith("http://") || link.startsWith("https://")) {
          return link;
        }
        if (!link.startsWith("/")) {
          link = "/" + link;
        }
        return link;
      }
      targetPath() {
        return this.join(this.dir, this.file);
      }
      fromTargetPath(targetPath) {
        const normalizedPath = targetPath.replace(/\\/g, "/");
        const parsedPath = path6.posix.parse(normalizedPath);
        let dir = parsedPath.dir;
        if (dir === "/") {
          dir = "";
        }
        return new ResourcePaths(dir, parsedPath.base, this.baseUrl, this.baseUrl, this.targetBasePaths, this.baseUrl);
      }
      pathDir() {
        return this.dir;
      }
      pathBaseDirTarget() {
        return this.baseDirTarget;
      }
      pathBaseDirLink() {
        return this.baseDirLink;
      }
      pathTargetBasePaths() {
        return this.targetBasePaths;
      }
      pathFile() {
        return this.file;
      }
    };
    exports2.ResourcePaths = ResourcePaths;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/transformation.js
var require_transformation = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/transformation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResourceTransformationKey = void 0;
    exports2.contentReadSeekerCloser = contentReadSeekerCloser;
    var crypto_1 = require("crypto");
    var ResourceTransformationKey = class {
      constructor(name, elements = []) {
        this.name = name;
        this.elements = elements;
      }
      static newResourceTransformationKey(name, ...elements) {
        return new ResourceTransformationKey(name, elements);
      }
      value() {
        if (this.elements.length === 0) {
          return this.name;
        }
        const elementsStr = this.hashElements(...this.elements);
        return `${this.name}_${elementsStr}`;
      }
      hashElements(...elements) {
        const str = elements.map((e) => String(e)).join("|");
        return (0, crypto_1.createHash)("sha256").update(str).digest("hex").substring(0, 16);
      }
    };
    exports2.ResourceTransformationKey = ResourceTransformationKey;
    async function contentReadSeekerCloser(r) {
      try {
        return await r.readSeekCloser();
      } catch (error) {
        throw new Error(`Cannot transform content of Resource of type ${typeof r}: ${error}`);
      }
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/resourcemetadata.js
var require_resourcemetadata = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/valueobject/resourcemetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResourceMetadataImpl = void 0;
    var ResourceMetadataImpl = class {
      constructor(target, mediaType, metaData) {
        this.target = target;
        this.mediaType = mediaType;
        this.metaData = metaData;
      }
      marshal() {
        return JSON.stringify({
          Target: this.target,
          MediaType: this.mediaType,
          Data: this.metaData
        });
      }
      static unmarshal(data) {
        const parsed = JSON.parse(data);
        return new ResourceMetadataImpl(parsed.Target, parsed.MediaType, parsed.Data || {});
      }
    };
    exports2.ResourceMetadataImpl = ResourceMetadataImpl;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/factory/resource.js
var require_resource2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/factory/resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResources = createResources;
    var resources_1 = require_resources();
    function createResources(workspace) {
      return new resources_1.Resources(workspace);
    }
  }
});

// node_modules/@mdfriday/foundry/dist/internal/domain/resources/index.js
var require_resources2 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/domain/resources/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResources = exports2.ResourceMetadataImpl = exports2.ResourceTransformationKey = exports2.ResourcePaths = exports2.TemplateClient = exports2.IntegrityClient = exports2.MinifierClient = exports2.ResourceImpl = exports2.Resources = void 0;
    __exportStar(require_type10(), exports2);
    var resources_1 = require_resources();
    Object.defineProperty(exports2, "Resources", { enumerable: true, get: function() {
      return resources_1.Resources;
    } });
    var resource_1 = require_resource();
    Object.defineProperty(exports2, "ResourceImpl", { enumerable: true, get: function() {
      return resource_1.ResourceImpl;
    } });
    var minifier_1 = require_minifier();
    Object.defineProperty(exports2, "MinifierClient", { enumerable: true, get: function() {
      return minifier_1.MinifierClient;
    } });
    var integrity_1 = require_integrity();
    Object.defineProperty(exports2, "IntegrityClient", { enumerable: true, get: function() {
      return integrity_1.IntegrityClient;
    } });
    var template_1 = require_template5();
    Object.defineProperty(exports2, "TemplateClient", { enumerable: true, get: function() {
      return template_1.TemplateClient;
    } });
    var resourcepaths_1 = require_resourcepaths();
    Object.defineProperty(exports2, "ResourcePaths", { enumerable: true, get: function() {
      return resourcepaths_1.ResourcePaths;
    } });
    var transformation_1 = require_transformation();
    Object.defineProperty(exports2, "ResourceTransformationKey", { enumerable: true, get: function() {
      return transformation_1.ResourceTransformationKey;
    } });
    var resourcemetadata_1 = require_resourcemetadata();
    Object.defineProperty(exports2, "ResourceMetadataImpl", { enumerable: true, get: function() {
      return resourcemetadata_1.ResourceMetadataImpl;
    } });
    var resource_2 = require_resource2();
    Object.defineProperty(exports2, "createResources", { enumerable: true, get: function() {
      return resource_2.createResources;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/application/ssg.js
var require_ssg = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/application/ssg.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateStaticSite = generateStaticSite;
    exports2.processSSG = processSSG;
    exports2.generateStaticSiteWithProgress = generateStaticSiteWithProgress;
    exports2.processSSGWithProgress = processSSGWithProgress;
    exports2.serveSSG = serveSSG;
    var config_1 = require_config3();
    var module_1 = require_module6();
    var fs_1 = require_fs3();
    var content_1 = require_content3();
    var template_1 = require_template4();
    var site_1 = require_site2();
    var log_1 = require_log();
    var path_1 = __importDefault(require("path"));
    var resources_1 = require_resources2();
    var log = (0, log_1.getDomainLogger)("ssg", { component: "application" });
    var createDomainInstances = (site, content, fs5, config, modules, resources) => {
      return {
        site,
        content,
        fs: fs5,
        config,
        modules,
        resources
      };
    };
    async function loadConfiguration(projDir, modulesDir) {
      const osFs = (0, fs_1.newOsFs)();
      const configFilePath = path_1.default.join(projDir, "config.json");
      return await (0, config_1.loadConfigWithParams)(osFs, configFilePath, projDir, modulesDir);
    }
    async function createModule(config) {
      const info = {
        osFs: () => config.fs(),
        projDir: () => config.getDir().getWorkingDir(),
        moduleDir: () => config.getDir().getThemesDir(),
        moduleCacheDir: () => config.getDir().getThemesCacheDir(),
        importPaths: () => config.getModule().importPaths(),
        defaultLanguageKey: () => config.getLanguage().defaultLanguage(),
        otherLanguageKeys: () => config.getLanguage().otherLanguageKeys(),
        getRelDir: (name, langKey) => config.getLanguage().getRelDir(name, langKey)
      };
      return await (0, module_1.createModules)(info);
    }
    async function createFileSystem(config, module3) {
      const workspace = {
        path: config.getDir().getWorkingDir(),
        publish: config.getDir().getPublishDir(),
        osFs: config.fs()
      };
      return await (0, fs_1.createFs)(workspace, module3);
    }
    async function createContentEngine(filesystem, config, modules, markdown) {
      const services = {
        markdown: () => markdown,
        newFileMetaInfo: (filename) => {
          return filesystem.newFileMetaInfo(filename);
        },
        newFileMetaInfoWithContent: (content) => {
          return filesystem.newFileMetaInfoWithContent(content);
        },
        contentFs: () => {
          return filesystem.contentFs();
        },
        walkContent: (fs5, start, cb, conf) => {
          return filesystem.walkContent(fs5, start, cb, conf);
        },
        walkI18n: (start, cb, conf) => {
          return filesystem.walkI18n(start, cb, conf);
        },
        isLanguageValid: (lang) => {
          return config.getLanguage().isLanguageValid(lang);
        },
        getSourceLang: (source) => {
          return modules.getSourceLang(source);
        },
        getLanguageIndex: (lang) => {
          return config.getLanguage().getLanguageIndex(lang);
        },
        getLanguageByIndex: (idx) => {
          return config.getLanguage().getLanguageByIndex(idx);
        },
        defaultLanguage: () => {
          return config.getLanguage().defaultLanguage();
        },
        languageIndexes: () => {
          return config.getLanguage().languageIndexes();
        },
        views: () => {
          const viewNames = config.getTaxonomy().getViews();
          return viewNames.map((name) => {
            const singular = name.singular;
            const plural = name.plural;
            return {
              singular: () => singular || "",
              plural: () => plural || ""
            };
          });
        }
      };
      return (0, content_1.createContent)(services);
    }
    function createCustomizedFunctions(config, site, resources) {
      const baseUrlString = config.getProvider().getString("baseURL") || "http://localhost";
      return {
        relURL: (input) => {
          return site.getURL().relURL(input);
        },
        absURL: (input) => {
          return site.getURL().absURL(input, site.isMultipleLanguage(), site.languagePrefix());
        },
        urlize: (input) => {
          return site.getURL().urlize(input);
        },
        translate: (translationID) => {
          return site.translate(translationID);
        },
        relRefFrom: async (argsm, source) => {
          return [argsm.path || "", null];
        },
        title: () => config.getProvider().getString("title") || "My Site",
        baseURL: () => baseUrlString,
        params: () => config.getProvider().getParams("params"),
        menus: () => {
          return {};
        },
        isMultiLanguage: () => config.getLanguage().languageKeys().length > 1,
        version: () => "0.1.0",
        environment: () => "development",
        generator: () => "AuPro Static Site Generator",
        defaultLanguage: () => config.getLanguage().defaultLanguage(),
        languageKeys: () => config.getLanguage().languageKeys(),
        Get: async function(filename) {
          try {
            return await resources.getResource(filename);
          } catch (error) {
            log.warn(`Resource not found: ${filename}`, error);
            return Promise.resolve(null);
          }
        },
        GetRemote: async function(uri) {
          return await resources.getRemote(uri);
        },
        Minify: async function(resource) {
          return await resources.minify(resource);
        },
        Fingerprint: async function(resource) {
          return await resources.fingerprint(resource);
        },
        ExecuteAsTemplate: async function(targetPath, data, resource) {
          return await resources.executeAsTemplate(resource, targetPath, data);
        }
      };
    }
    function createResourcesEngine(config, fs5) {
      const workspace = {
        assetsFs: () => fs5.assetsFs(),
        publishFs: () => fs5.publishFs(),
        baseUrl: () => config.getProvider().getString("baseURL") || "http://localhost",
        executeTemplate: async (templateName, rawContent, data) => {
          throw new Error("Template execution not initialized. Please call resources.setTemplateSvc() first.");
        }
      };
      return (0, resources_1.createResources)(workspace);
    }
    async function createTemplateEngineFromFs(fs5, config, site, resources) {
      const services = createCustomizedFunctions(config, site, resources);
      const templateFs = {
        walk: fs5.walkLayouts.bind(fs5)
      };
      return await (0, template_1.createTemplateEngineWithServices)(templateFs, services);
    }
    async function createTemplateAdapter(templateEngine, site) {
      return {
        async lookupLayout(names) {
          const [tmpl, foundName, found, err] = await templateEngine.findFirst(names);
          if (err) {
            return { preparer: null, found: false };
          }
          if (!found || !tmpl || !foundName) {
            return { preparer: null, found: false };
          }
          const preparer = {
            name: () => foundName,
            execute: async (data) => {
              const [result, execErr] = await tmpl.Execute(data);
              if (execErr) {
                log.errorf("template exec error: %s", execErr);
                throw execErr;
              }
              return result;
            }
          };
          return { preparer, found: true };
        },
        async executeWithContext(preparer, data) {
          if (!preparer) {
            return "<html><body>Default template - no preparer</body></html>";
          }
          try {
            return await preparer.execute(data);
          } catch (error) {
            log.error(`\u274C Template execution error: ${error}`);
            return `<html><body>Template execution error: ${error}</body></html>`;
          }
        }
      };
    }
    async function createSiteForSSG(config, fs5, content) {
      const siteServices = {
        configParams: () => config.getProvider().getParams("params"),
        siteTitle: () => config.getProvider().getString("title") || "My Site",
        menus: () => {
          const result = {};
          return result;
        },
        isGoogleAnalyticsEnabled: () => config.getService().isGoogleAnalyticsEnabled(),
        googleAnalyticsID: () => config.getService().googleAnalyticsID(),
        isGoogleAnalyticsRespectDoNotTrack: () => config.getService().isGoogleAnalyticsRespectDoNotTrack(),
        isDisqusEnabled: () => config.getService().isDisqusEnabled(),
        disqusShortname: () => config.getService().disqusShortname(),
        isXRespectDoNotTrack: () => config.getService().isXRespectDoNotTrack(),
        isXDisableInlineCSS: () => config.getService().isXDisableInlineCSS(),
        globalPages: async (langIndex) => await content.globalPages(langIndex),
        globalRegularPages: () => content.globalRegularPages(),
        walkPages: async (langIndex, walker) => {
          await content.walkPages(langIndex, walker);
        },
        getPageSources: async (page) => {
          return content.getPageSources(page);
        },
        walkTaxonomies: async (langIndex, walker) => {
          await content.walkTaxonomies(langIndex, walker);
        },
        searchPage: async (pages, page) => {
          return [];
        },
        getPageFromPath: async (langIndex, path6) => {
          try {
            const page = content.getPageFromPath(langIndex, path6);
            if (!page) {
              log.error(`\u26A0\uFE0F  Application.getPageFromPath: content domain returned null for path: "${path6}"`);
            }
            return page;
          } catch (error) {
            log.error(`\u274C Application.getPageFromPath error delegating to content domain:`, error);
            return null;
          }
        },
        getPageFromPathSync: (langIndex, path6) => {
          try {
            const page = content.getPageFromPath(langIndex, path6);
            if (!page) {
              log.warn(`\u26A0\uFE0F  Application.getPageFromPathSync: content domain returned null for path: ${path6}`);
            }
            return page;
          } catch (error) {
            log.error(`\u274C Application.getPageFromPathSync error delegating to content domain:`, error);
            return null;
          }
        },
        getPageRef: async (context, ref, home) => {
          return null;
        },
        translate: (lang, translationID) => {
          return content.translate(lang, translationID);
        },
        defaultLanguage: () => config.getLanguage().defaultLanguage(),
        languageKeys: () => config.getLanguage().languageKeys(),
        getLanguageIndex: (lang) => config.getLanguage().getLanguageIndex(lang),
        getLanguageName: (lang) => config.getLanguage().getLanguageName(lang),
        changeFreq: () => "weekly",
        priority: () => 0.5,
        generateSitemap: async () => ({ urls: [] }),
        publishFs: () => {
          return fs5.publishFs();
        },
        staticFs() {
          return fs5.staticFs();
        },
        copyStaticFiles(from, to) {
          return fs5.copyStatic([from], to);
        },
        workingDir: () => config.getProvider().getString("workingDir") || process.cwd(),
        getResource: async (path6) => {
          return null;
        },
        getResourceWithOpener: async (path6, opener) => {
          return {
            name: () => path6,
            readSeekCloser: opener,
            targetPath: () => path6
          };
        },
        baseUrl: () => config.getProvider().getString("baseURL") || "http://localhost"
      };
      return (0, site_1.newSite)(siteServices);
    }
    async function generateStaticSite(projDir, modulesDir, markdown) {
      try {
        const config = await loadConfiguration(projDir, modulesDir);
        const modules = await createModule(config);
        const filesystem = await createFileSystem(config, modules);
        const content = await createContentEngine(filesystem, config, modules, markdown);
        const site = await createSiteForSSG(config, filesystem, content);
        const resources = createResourcesEngine(config, filesystem);
        const templateEngine = await createTemplateEngineFromFs(filesystem, config, site, resources);
        resources.setTemplateSvc({
          async executeTemplate(templateName, rawContent, data) {
            return await templateEngine.executeRaw(templateName, rawContent, data);
          }
        });
        content.setTemplateSvc({
          async execute(templateName, data) {
            return await templateEngine.executeShortcode(templateName, data);
          }
        });
        await content.collectPages();
        const templateAdapter = await createTemplateAdapter(templateEngine, site);
        await site.build(templateAdapter);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`\u274C Static site generation failed: ${message}`);
        throw new Error(`Failed to generate static site: ${message}`);
      }
    }
    async function processSSG(projDir, modulesDir, markdown) {
      try {
        const originalCwd = process.cwd();
        process.chdir(projDir);
        try {
          await generateStaticSite(projDir, modulesDir, markdown);
        } finally {
          process.chdir(originalCwd);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`\u274C SSG processing failed: ${message}`);
        throw new Error(`Failed to process SSG: ${message}`);
      }
    }
    async function generateStaticSiteWithProgress(projDir, modulesDir, markdown, onProgress) {
      try {
        onProgress?.({
          stage: "config",
          message: "Loading configuration...",
          percentage: 5
        });
        const config = await loadConfiguration(projDir, modulesDir);
        onProgress?.({
          stage: "modules",
          message: "Creating and downloading modules...",
          percentage: 10
        });
        const modules = await createModuleWithProgress(config, onProgress);
        onProgress?.({
          stage: "filesystem",
          message: "Creating filesystem...",
          percentage: 30
        });
        const filesystem = await createFileSystem(config, modules);
        onProgress?.({
          stage: "content",
          message: "Creating content engine...",
          percentage: 40
        });
        const content = await createContentEngine(filesystem, config, modules, markdown);
        onProgress?.({
          stage: "site",
          message: "Creating site...",
          percentage: 50
        });
        const site = await createSiteForSSG(config, filesystem, content);
        const resources = createResourcesEngine(config, filesystem);
        onProgress?.({
          stage: "template",
          message: "Creating template engine...",
          percentage: 60
        });
        const templateEngine = await createTemplateEngineFromFs(filesystem, config, site, resources);
        resources.setTemplateSvc({
          async executeTemplate(templateName, rawContent, data) {
            return await templateEngine.executeRaw(templateName, rawContent, data);
          }
        });
        content.setTemplateSvc({
          async execute(templateName, data) {
            return await templateEngine.executeShortcode(templateName, data);
          }
        });
        onProgress?.({
          stage: "pages",
          message: "Collecting pages...",
          percentage: 65
        });
        await content.collectPages();
        onProgress?.({
          stage: "build",
          message: "Building site...",
          percentage: 70
        });
        const templateAdapter = await createTemplateAdapter(templateEngine, site);
        await buildSiteWithProgress(site, templateAdapter, onProgress);
        onProgress?.({
          stage: "completion",
          message: "SSG generation completed",
          percentage: 100
        });
        return createDomainInstances(site, content, filesystem, config, modules, resources);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`\u274C Static site generation failed: ${message}`);
        throw new Error(`Failed to generate static site: ${message}`);
      }
    }
    async function createModuleWithProgress(config, onProgress) {
      const info = {
        osFs: () => config.fs(),
        projDir: () => config.getDir().getWorkingDir(),
        moduleDir: () => config.getDir().getThemesDir(),
        moduleCacheDir: () => config.getDir().getThemesCacheDir(),
        importPaths: () => config.getModule().importPaths(),
        defaultLanguageKey: () => config.getLanguage().defaultLanguage(),
        otherLanguageKeys: () => config.getLanguage().otherLanguageKeys(),
        getRelDir: (name, langKey) => config.getLanguage().getRelDir(name, langKey)
      };
      return await createModulesWithProgressTracking(info, onProgress);
    }
    async function createModulesWithProgressTracking(info, onProgress) {
      const moduleProgressCallback = onProgress ? (progress) => {
        onProgress({
          stage: "modules",
          message: `Downloading module: ${progress.modulePath}`,
          percentage: 10 + Math.floor(progress.downloadPercentage * 0.2),
          moduleDownload: {
            modulePath: progress.modulePath,
            downloadPercentage: progress.downloadPercentage
          }
        });
      } : void 0;
      return await (0, module_1.createModulesWithProgress)(info, moduleProgressCallback);
    }
    async function buildSiteWithProgress(site, template, onProgress) {
      const pageProgressCallback = onProgress ? (progress) => {
        const percentage = 70 + Math.floor(progress.currentPage / progress.totalPages * 29);
        onProgress({
          stage: "build",
          message: `Rendering pages (${progress.currentPage}/${progress.totalPages})...`,
          percentage,
          pageRender: progress
        });
      } : void 0;
      await site.buildWithProgress(template, pageProgressCallback);
    }
    async function processSSGWithProgress(projDir, modulesDir, markdown, onProgress) {
      try {
        const originalCwd = process.cwd();
        process.chdir(projDir);
        try {
          await generateStaticSiteWithProgress(projDir, modulesDir, markdown, onProgress);
        } finally {
          process.chdir(originalCwd);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`\u274C SSG processing failed: ${message}`);
        throw new Error(`Failed to process SSG: ${message}`);
      }
    }
    async function serveSSG(projDir, modulesDir, markdown, onProgress) {
      try {
        process.chdir(projDir);
        return await generateStaticSiteWithProgress(projDir, modulesDir, markdown, onProgress);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log.error(`\u274C SSG processing failed: ${message}`);
        throw new Error(`Failed to process SSG: ${message}`);
      }
    }
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdirpPromise = exports2.readdirp = exports2.ReaddirpStream = void 0;
    var promises_1 = require("fs/promises");
    var stream_1 = require("stream");
    var path_1 = require("path");
    function defaultOptions() {
      return {
        root: ".",
        fileFilter: (_path) => true,
        directoryFilter: (_path) => true,
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false,
        highWaterMark: 4096
      };
    }
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var DIR_TYPES = /* @__PURE__ */ new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
    var FILE_TYPES = /* @__PURE__ */ new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var wantBigintFsStats = process.platform === "win32";
    var emptyFn = (_path) => true;
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return emptyFn;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const fl = filter.trim();
        return (entry) => entry.basename === fl;
      }
      if (Array.isArray(filter)) {
        const trItems = filter.map((item) => item.trim());
        return (entry) => trItems.some((f) => entry.basename === f);
      }
      return emptyFn;
    };
    var ReaddirpStream = class extends stream_1.Readable {
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark
        });
        const opts = { ...defaultOptions(), ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? promises_1.lstat : promises_1.stat;
        if (wantBigintFsStats) {
          this._stat = (path6) => statMethod(path6, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = DIR_TYPES.has(type);
        this._wantsFile = FILE_TYPES.has(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = (0, path_1.resolve)(root);
        this._isDirent = !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const par = this.parent;
            const fil = par && par.files;
            if (fil && fil.length > 0) {
              const { path: path6, depth } = par;
              const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path6));
              const awaited = await Promise.all(slice);
              for (const entry of awaited) {
                if (!entry) {
                  batch--;
                  return;
                }
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path6, depth) {
        let files;
        try {
          files = await (0, promises_1.readdir)(path6, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path: path6 };
      }
      async _formatEntry(dirent, path6) {
        let entry;
        const basename2 = this._isDirent ? dirent.name : dirent;
        try {
          const fullPath = (0, path_1.resolve)((0, path_1.join)(path6, basename2));
          entry = { path: (0, path_1.relative)(this._root, fullPath), fullPath, basename: basename2 };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
          return;
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        if (!entry && this._statsProp in entry) {
          return "";
        }
        const stats = entry[this._statsProp];
        if (stats.isFile())
          return "file";
        if (stats.isDirectory())
          return "directory";
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await (0, promises_1.realpath)(full);
            const entryRealPathStats = await (0, promises_1.lstat)(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === path_1.sep) {
                const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
            return "";
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    exports2.ReaddirpStream = ReaddirpStream;
    var readdirp = (root, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    exports2.readdirp = readdirp;
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve, reject) => {
        const files = [];
        (0, exports2.readdirp)(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject(error));
      });
    };
    exports2.readdirpPromise = readdirpPromise;
    exports2.default = exports2.readdirp;
  }
});

// node_modules/chokidar/handler.js
var require_handler = __commonJS({
  "node_modules/chokidar/handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeFsHandler = exports2.EVENTS = exports2.isIBMi = exports2.isFreeBSD = exports2.isLinux = exports2.isMacos = exports2.isWindows = exports2.IDENTITY_FN = exports2.EMPTY_FN = exports2.STR_CLOSE = exports2.STR_END = exports2.STR_DATA = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var sysPath = require("path");
    var os_1 = require("os");
    exports2.STR_DATA = "data";
    exports2.STR_END = "end";
    exports2.STR_CLOSE = "close";
    var EMPTY_FN = () => {
    };
    exports2.EMPTY_FN = EMPTY_FN;
    var IDENTITY_FN = (val) => val;
    exports2.IDENTITY_FN = IDENTITY_FN;
    var pl = process.platform;
    exports2.isWindows = pl === "win32";
    exports2.isMacos = pl === "darwin";
    exports2.isLinux = pl === "linux";
    exports2.isFreeBSD = pl === "freebsd";
    exports2.isIBMi = (0, os_1.type)() === "OS400";
    exports2.EVENTS = {
      ALL: "all",
      READY: "ready",
      ADD: "add",
      CHANGE: "change",
      ADD_DIR: "addDir",
      UNLINK: "unlink",
      UNLINK_DIR: "unlinkDir",
      RAW: "raw",
      ERROR: "error"
    };
    var EV = exports2.EVENTS;
    var THROTTLE_MODE_WATCH = "watch";
    var statMethods = { lstat: promises_1.lstat, stat: promises_1.stat };
    var KEY_LISTENERS = "listeners";
    var KEY_ERR = "errHandlers";
    var KEY_RAW = "rawEmitters";
    var HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];
    var binaryExtensions = /* @__PURE__ */ new Set([
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "afdesign",
      "afphoto",
      "afpub",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ]);
    var isBinaryPath = (filePath) => binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set = cont[key];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path6, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path6);
        emitRaw(rawEvent, evPath, { watchedPath: path6 });
        if (evPath && path6 !== evPath) {
          fsWatchBroadcast(sysPath.resolve(path6, evPath), KEY_LISTENERS, sysPath.join(path6, evPath));
        }
      };
      try {
        return (0, fs_1.watch)(path6, {
          persistent: options.persistent
        }, handleEvent);
      } catch (error) {
        errHandler(error);
        return void 0;
      }
    }
    var fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[listenerType], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path6, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(path6, options, listener, errHandler, rawEmitter);
        if (!watcher)
          return;
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(path6, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
          return;
        watcher.on(EV.ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          if (cont)
            cont.watcherUnusable = true;
          if (exports2.isWindows && error.code === "EPERM") {
            try {
              const fd = await (0, promises_1.open)(path6, "r");
              await fd.close();
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path6, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        (0, fs_1.unwatchFile)(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: (0, fs_1.watchFile)(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV.CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path6, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          (0, fs_1.unwatchFile)(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      _watchWithNodeFs(path6, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path6);
        const basename2 = sysPath.basename(path6);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath.resolve(path6);
        const options = {
          persistent: opts.persistent
        };
        if (!listener)
          listener = exports2.EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          const enableBin = opts.interval !== opts.binaryInterval;
          options.interval = enableBin && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path6, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path6, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname3 = sysPath.dirname(file);
        const basename2 = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname3);
        let prevStats = stats;
        if (parent.has(basename2))
          return;
        const listener = async (path6, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await (0, promises_1.stat)(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV.CHANGE, file, newStats2);
              }
              if ((exports2.isMacos || exports2.isLinux || exports2.isFreeBSD) && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path6);
                prevStats = newStats2;
                const closer2 = this._watchWithNodeFs(file, listener);
                if (closer2)
                  this.fsw._addPathCloser(path6, closer2);
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname3, basename2);
            }
          } else if (parent.has(basename2)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV.CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV.ADD, file, 0))
            return;
          this.fsw._emit(EV.ADD, file, stats);
        }
        return closer;
      }
      async _handleSymlink(entry, directory, path6, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await (0, promises_1.realpath)(path6);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV.CHANGE, path6, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV.ADD, path6, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, "");
        throttler = this.fsw._throttle("readdir", directory, 1e3);
        if (!throttler)
          return;
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry)
        });
        if (!stream)
          return;
        stream.on(exports2.STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path6 = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path6, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path6 = sysPath.join(dir, sysPath.relative(dir, path6));
            this._addToNodeFs(path6, initialAdd, wh, depth + 1);
          }
        }).on(EV.ERROR, this._boundHandleError);
        return new Promise((resolve, reject) => {
          if (!stream)
            return reject();
          stream.once(exports2.STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve(void 0);
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item);
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          });
        });
      }
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          this.fsw._emit(EV.ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      async _addToNodeFs(path6, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path6) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path6);
        if (priorWh) {
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks;
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path6);
            const targetPath = follow ? await (0, promises_1.realpath)(path6) : path6;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await (0, promises_1.realpath)(path6) : path6;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV.ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path6, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path6), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          if (closer)
            this.fsw._addPathCloser(path6, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path6;
          }
        }
      }
    };
    exports2.NodeFsHandler = NodeFsHandler;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FSWatcher = exports2.WatchHelper = void 0;
    exports2.watch = watch;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var events_1 = require("events");
    var sysPath = require("path");
    var readdirp_1 = require_readdirp();
    var handler_js_1 = require_handler();
    var SLASH = "/";
    var SLASH_SLASH = "//";
    var ONE_DOT = ".";
    var TWO_DOTS = "..";
    var STRING_TYPE = "string";
    var BACK_SLASH_RE = /\\/g;
    var DOUBLE_SLASH_RE = /\/\//;
    var DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    var REPLACER_RE = /^\.[/\\]/;
    function arrify(item) {
      return Array.isArray(item) ? item : [item];
    }
    var isMatcherObject = (matcher) => typeof matcher === "object" && matcher !== null && !(matcher instanceof RegExp);
    function createPattern(matcher) {
      if (typeof matcher === "function")
        return matcher;
      if (typeof matcher === "string")
        return (string) => matcher === string;
      if (matcher instanceof RegExp)
        return (string) => matcher.test(string);
      if (typeof matcher === "object" && matcher !== null) {
        return (string) => {
          if (matcher.path === string)
            return true;
          if (matcher.recursive) {
            const relative = sysPath.relative(matcher.path, string);
            if (!relative) {
              return false;
            }
            return !relative.startsWith("..") && !sysPath.isAbsolute(relative);
          }
          return false;
        };
      }
      return () => false;
    }
    function normalizePath(path6) {
      if (typeof path6 !== "string")
        throw new Error("string expected");
      path6 = sysPath.normalize(path6);
      path6 = path6.replace(/\\/g, "/");
      let prepend = false;
      if (path6.startsWith("//"))
        prepend = true;
      const DOUBLE_SLASH_RE2 = /\/\//;
      while (path6.match(DOUBLE_SLASH_RE2))
        path6 = path6.replace(DOUBLE_SLASH_RE2, "/");
      if (prepend)
        path6 = "/" + path6;
      return path6;
    }
    function matchPatterns(patterns, testString, stats) {
      const path6 = normalizePath(testString);
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (pattern(path6, stats)) {
          return true;
        }
      }
      return false;
    }
    function anymatch(matchers, testString) {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const matchersArray = arrify(matchers);
      const patterns = matchersArray.map((matcher) => createPattern(matcher));
      if (testString == null) {
        return (testString2, stats) => {
          return matchPatterns(patterns, testString2, stats);
        };
      }
      return matchPatterns(patterns, testString);
    }
    var unifyPaths = (paths_) => {
      const paths = arrify(paths_).flat();
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path6) => toUnix(sysPath.normalize(toUnix(path6)));
    var normalizeIgnored = (cwd = "") => (path6) => {
      if (typeof path6 === "string") {
        return normalizePathToUnix(sysPath.isAbsolute(path6) ? path6 : sysPath.join(cwd, path6));
      } else {
        return path6;
      }
    };
    var getAbsolutePath = (path6, cwd) => {
      if (sysPath.isAbsolute(path6)) {
        return path6;
      }
      return sysPath.join(cwd, path6);
    };
    var EMPTY_SET = Object.freeze(/* @__PURE__ */ new Set());
    var DirEntry = class {
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await (0, promises_1.readdir)(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      getChildren() {
        const { items } = this;
        if (!items)
          return [];
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        this.path = "";
        this._removeWatcher = handler_js_1.EMPTY_FN;
        this.items = EMPTY_SET;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path6, follow, fsw) {
        this.fsw = fsw;
        const watchPath = path6;
        this.path = path6 = path6.replace(REPLACER_RE, "");
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.dirParts = [];
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      filterDir(entry) {
        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    exports2.WatchHelper = WatchHelper;
    var FSWatcher = class extends events_1.EventEmitter {
      constructor(_opts = {}) {
        super();
        this.closed = false;
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._watched = /* @__PURE__ */ new Map();
        this._pendingWrites = /* @__PURE__ */ new Map();
        this._pendingUnlinks = /* @__PURE__ */ new Map();
        this._readyCount = 0;
        this._readyEmitted = false;
        const awf = _opts.awaitWriteFinish;
        const DEF_AWF = { stabilityThreshold: 2e3, pollInterval: 100 };
        const opts = {
          persistent: true,
          ignoreInitial: false,
          ignorePermissionErrors: false,
          interval: 100,
          binaryInterval: 300,
          followSymlinks: true,
          usePolling: false,
          atomic: true,
          ..._opts,
          ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
          awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === "object" ? { ...DEF_AWF, ...awf } : false
        };
        if (handler_js_1.isIBMi)
          opts.usePolling = true;
        if (opts.atomic === void 0)
          opts.atomic = !opts.usePolling;
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0")
            opts.usePolling = false;
          else if (envLower === "true" || envLower === "1")
            opts.usePolling = true;
          else
            opts.usePolling = !!envLower;
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval)
          opts.interval = Number.parseInt(envInterval, 10);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = handler_js_1.EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(handler_js_1.EVENTS.READY));
          }
        };
        this._emitRaw = (...args) => this.emit(handler_js_1.EVENTS.RAW, ...args);
        this._boundRemove = this._remove.bind(this);
        this.options = opts;
        this._nodeFsHandler = new handler_js_1.NodeFsHandler(this);
        Object.freeze(opts);
      }
      _addIgnoredPath(matcher) {
        if (isMatcherObject(matcher)) {
          for (const ignored of this._ignoredPaths) {
            if (isMatcherObject(ignored) && ignored.path === matcher.path && ignored.recursive === matcher.recursive) {
              return;
            }
          }
        }
        this._ignoredPaths.add(matcher);
      }
      _removeIgnoredPath(matcher) {
        this._ignoredPaths.delete(matcher);
        if (typeof matcher === "string") {
          for (const ignored of this._ignoredPaths) {
            if (isMatcherObject(ignored) && ignored.path === matcher) {
              this._ignoredPaths.delete(ignored);
            }
          }
        }
      }
      add(paths_, _origAdd, _internal) {
        const { cwd } = this.options;
        this.closed = false;
        this._closePromise = void 0;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path6) => {
            const absPath = getAbsolutePath(path6, cwd);
            return absPath;
          });
        }
        paths.forEach((path6) => {
          this._removeIgnoredPath(path6);
        });
        this._userIgnored = void 0;
        if (!this._readyCount)
          this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(async (path6) => {
          const res = await this._nodeFsHandler._addToNodeFs(path6, !_internal, void 0, 0, _origAdd);
          if (res)
            this._emitReady();
          return res;
        })).then((results) => {
          if (this.closed)
            return;
          results.forEach((item) => {
            if (item)
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
        return this;
      }
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path6) => {
          if (!sysPath.isAbsolute(path6) && !this._closers.has(path6)) {
            if (cwd)
              path6 = sysPath.join(cwd, path6);
            path6 = sysPath.resolve(path6);
          }
          this._closePath(path6);
          this._addIgnoredPath(path6);
          if (this._watched.has(path6)) {
            this._addIgnoredPath({
              path: path6,
              recursive: true
            });
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      close() {
        if (this._closePromise) {
          return this._closePromise;
        }
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        this._closers.clear();
        this._watched.clear();
        this._streams.clear();
        this._symlinkPaths.clear();
        this._throttled.clear();
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          const index = key || ONE_DOT;
          watchList[index] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(event, ...args);
        if (event !== handler_js_1.EVENTS.ERROR)
          this.emit(handler_js_1.EVENTS.ALL, event, ...args);
      }
      async _emit(event, path6, stats) {
        if (this.closed)
          return;
        const opts = this.options;
        if (handler_js_1.isWindows)
          path6 = sysPath.normalize(path6);
        if (opts.cwd)
          path6 = sysPath.relative(opts.cwd, path6);
        const args = [path6];
        if (stats != null)
          args.push(stats);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path6))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === handler_js_1.EVENTS.UNLINK) {
            this._pendingUnlinks.set(path6, [event, ...args]);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path7) => {
                this.emit(...entry);
                this.emit(handler_js_1.EVENTS.ALL, ...entry);
                this._pendingUnlinks.delete(path7);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === handler_js_1.EVENTS.ADD && this._pendingUnlinks.has(path6)) {
            event = handler_js_1.EVENTS.CHANGE;
            this._pendingUnlinks.delete(path6);
          }
        }
        if (awf && (event === handler_js_1.EVENTS.ADD || event === handler_js_1.EVENTS.CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats2) => {
            if (err) {
              event = handler_js_1.EVENTS.ERROR;
              args[0] = err;
              this.emitWithAll(event, args);
            } else if (stats2) {
              if (args.length > 1) {
                args[1] = stats2;
              } else {
                args.push(stats2);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path6, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === handler_js_1.EVENTS.CHANGE) {
          const isThrottled = !this._throttle(handler_js_1.EVENTS.CHANGE, path6, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && stats === void 0 && (event === handler_js_1.EVENTS.ADD || event === handler_js_1.EVENTS.ADD_DIR || event === handler_js_1.EVENTS.CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path6) : path6;
          let stats2;
          try {
            stats2 = await (0, promises_1.stat)(fullPath);
          } catch (err) {
          }
          if (!stats2 || this.closed)
            return;
          args.push(stats2);
        }
        this.emitWithAll(event, args);
        return this;
      }
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(handler_js_1.EVENTS.ERROR, error);
        }
        return error || this.closed;
      }
      _throttle(actionType, path6, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        if (!action)
          throw new Error("invalid throttle");
        const actionPath = action.get(path6);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path6);
          const count = item ? item.count : 0;
          action.delete(path6);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path6, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      _awaitWriteFinish(path6, threshold, event, awfEmit) {
        const awf = this.options.awaitWriteFinish;
        if (typeof awf !== "object")
          return;
        const pollInterval = awf.pollInterval;
        let timeoutHandler;
        let fullPath = path6;
        if (this.options.cwd && !sysPath.isAbsolute(path6)) {
          fullPath = sysPath.join(this.options.cwd, path6);
        }
        const now = new Date();
        const writes = this._pendingWrites;
        function awaitWriteFinishFn(prevStat) {
          (0, fs_1.stat)(fullPath, (err, curStat) => {
            if (err || !writes.has(path6)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              writes.get(path6).lastChange = now2;
            }
            const pw = writes.get(path6);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              writes.delete(path6);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
            }
          });
        }
        if (!writes.has(path6)) {
          writes.set(path6, {
            lastChange: now,
            cancelWait: () => {
              writes.delete(path6);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
        }
      }
      _isIgnored(path6, stats) {
        if (this.options.atomic && DOT_RE.test(path6))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = (ign || []).map(normalizeIgnored(cwd));
          const ignoredPaths = [...this._ignoredPaths];
          const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];
          this._userIgnored = anymatch(list, void 0);
        }
        return this._userIgnored(path6, stats);
      }
      _isntIgnored(path6, stat) {
        return !this._isIgnored(path6, stat);
      }
      _getWatchHelpers(path6) {
        return new WatchHelper(path6, this.options.followSymlinks, this);
      }
      _getWatchedDir(directory) {
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        return Boolean(Number(stats.mode) & 256);
      }
      _remove(directory, item, isDirectory) {
        const path6 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path6);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path6) || this._watched.has(fullPath);
        if (!this._throttle("remove", path6, 100))
          return;
        if (!isDirectory && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path6);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path6, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path6;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path6);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === handler_js_1.EVENTS.ADD)
            return;
        }
        this._watched.delete(path6);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? handler_js_1.EVENTS.UNLINK_DIR : handler_js_1.EVENTS.UNLINK;
        if (wasTracked && !this._isIgnored(path6))
          this._emit(eventName, path6);
        this._closePath(path6);
      }
      _closePath(path6) {
        this._closeFile(path6);
        const dir = sysPath.dirname(path6);
        this._getWatchedDir(dir).remove(sysPath.basename(path6));
      }
      _closeFile(path6) {
        const closers = this._closers.get(path6);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path6);
      }
      _addPathCloser(path6, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path6);
        if (!list) {
          list = [];
          this._closers.set(path6, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options = { type: handler_js_1.EVENTS.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };
        let stream = (0, readdirp_1.readdirp)(root, options);
        this._streams.add(stream);
        stream.once(handler_js_1.STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(handler_js_1.STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports2.FSWatcher = FSWatcher;
    function watch(paths, options = {}) {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    }
    exports2.default = { watch, FSWatcher };
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/web/watcher/content-file-watcher.js
var require_content_file_watcher = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/web/watcher/content-file-watcher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentFileWatcher = void 0;
    var chokidar = __importStar(require_chokidar());
    var path6 = __importStar(require("path"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("web", { component: "content-file-watcher" });
    var ContentFileWatcher = class {
      constructor(config) {
        this.config = config;
        this.watcher = null;
        this.eventQueue = [];
        this.batchTimer = null;
        this.callbacks = [];
        this.batchDelay = config.batchDelay || 500;
      }
      async startWatching() {
        if (this.watcher) {
          await this.stopWatching();
        }
        this.watcher = chokidar.watch(this.config.contentDir, {
          ignored: [
            /(^|[\/\\])\../,
            /\.tmp$/,
            /\.swp$/,
            /~$/,
            /\.DS_Store$/,
            ...this.config.ignorePatterns || []
          ],
          persistent: true,
          ignoreInitial: true,
          followSymlinks: true,
          awaitWriteFinish: {
            stabilityThreshold: 100,
            pollInterval: 50
          }
        });
        this.watcher.on("add", (filePath) => this.queueEvent(filePath, "created")).on("change", (filePath) => this.queueEvent(filePath, "modified")).on("unlink", (filePath) => this.queueEvent(filePath, "deleted")).on("error", (error) => {
          log.error("File watcher error:", error);
        });
      }
      onFileChange(callback) {
        this.callbacks.push(callback);
      }
      queueEvent(filePath, eventType) {
        let fp = filePath;
        const { projContentDir, contentDir } = this.config;
        if (projContentDir !== contentDir && fp.startsWith(contentDir)) {
          fp = projContentDir + fp.slice(contentDir.length);
        }
        const normalizedPath = path6.normalize(fp);
        if (!this.isRelevantFile(normalizedPath)) {
          return;
        }
        const event = {
          filePath: normalizedPath,
          eventType,
          timestamp: Date.now(),
          isMarkdown: this.isMarkdownFile(normalizedPath),
          isImage: this.isImageFile(normalizedPath)
        };
        this.eventQueue.push(event);
        this.scheduleBatch();
      }
      isRelevantFile(filePath) {
        return this.isMarkdownFile(filePath) || this.isImageFile(filePath);
      }
      isMarkdownFile(filePath) {
        const ext = path6.extname(filePath).toLowerCase();
        return ext === ".md" || ext === ".markdown";
      }
      isImageFile(filePath) {
        const ext = path6.extname(filePath).toLowerCase();
        return [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp", ".bmp"].includes(ext);
      }
      scheduleBatch() {
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
        }
        this.batchTimer = setTimeout(async () => {
          if (this.eventQueue.length > 0) {
            const events = this.deduplicateEvents(this.eventQueue);
            this.eventQueue = [];
            for (const callback of this.callbacks) {
              try {
                await callback(events);
              } catch (error) {
                log.error("Error processing file change events:", error);
              }
            }
          }
        }, this.batchDelay);
      }
      deduplicateEvents(events) {
        const eventMap = /* @__PURE__ */ new Map();
        for (const event of events) {
          const existing = eventMap.get(event.filePath);
          if (!existing || event.timestamp > existing.timestamp) {
            eventMap.set(event.filePath, event);
          }
        }
        return Array.from(eventMap.values());
      }
      async stopWatching() {
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = null;
        }
        if (this.watcher) {
          await this.watcher.close();
          this.watcher = null;
        }
        this.eventQueue = [];
        this.callbacks = [];
      }
    };
    exports2.ContentFileWatcher = ContentFileWatcher;
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
    };
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/web/server/livereload-server.js
var require_livereload_server = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/web/server/livereload-server.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoundryLiveReloadServer = void 0;
    var http = __importStar(require("http"));
    var path6 = __importStar(require("path"));
    var fs5 = __importStar(require("fs/promises"));
    var ws_1 = require_browser();
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("web", { component: "livereload-server" });
    var FoundryLiveReloadServer = class {
      constructor(config) {
        this.httpServer = null;
        this.wsServer = null;
        this.clients = /* @__PURE__ */ new Set();
        this.running = false;
        this.config = {
          port: config.port || 8091,
          host: config.host || "localhost",
          livereloadPort: config.livereloadPort || 35729,
          enableLiveReload: config.enableLiveReload !== false,
          publicDir: config.publicDir
        };
      }
      async start() {
        if (this.running) {
          log.warn("LiveReloadServer already running");
          return;
        }
        try {
          await this.startHttpServer();
          if (this.config.enableLiveReload) {
            await this.startLiveReloadServer();
          }
          this.running = true;
        } catch (error) {
          log.error("Failed to start LiveReloadServer:", error);
          throw error;
        }
      }
      async stop() {
        if (!this.running) {
          return;
        }
        try {
          for (const client of this.clients) {
            client.close();
          }
          this.clients.clear();
          if (this.wsServer) {
            this.wsServer.close();
            this.wsServer = null;
          }
          if (this.httpServer) {
            await new Promise((resolve) => {
              this.httpServer.close(() => resolve());
            });
            this.httpServer = null;
          }
          this.running = false;
        } catch (error) {
          log.error("Error stopping LiveReloadServer:", error);
        }
      }
      notifyReload(changedFiles) {
        if (!this.config.enableLiveReload || this.clients.size === 0) {
          return;
        }
        const reloadEvent = {
          command: "reload",
          liveCSS: this.shouldLiveReloadCSS(changedFiles),
          liveImg: this.shouldLiveReloadImages(changedFiles)
        };
        if (changedFiles && changedFiles.length === 1) {
          const file = changedFiles[0];
          const ext = path6.extname(file).toLowerCase();
          if (ext === ".css") {
            reloadEvent.path = file;
            reloadEvent.liveCSS = true;
          } else if ([".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"].includes(ext)) {
            reloadEvent.path = file;
            reloadEvent.liveImg = true;
          }
        }
        const message = JSON.stringify(reloadEvent);
        for (const client of this.clients) {
          if (client.readyState === ws_1.WebSocket.OPEN) {
            client.send(message);
          }
        }
      }
      getUrl() {
        return `http://${this.config.host}:${this.config.port}`;
      }
      isServerRunning() {
        return this.running;
      }
      async startHttpServer() {
        this.httpServer = http.createServer(async (req, res) => {
          try {
            await this.handleHttpRequest(req, res);
          } catch (error) {
            log.error("HTTP request error:", error);
            res.statusCode = 500;
            res.end("Internal Server Error");
          }
        });
        await new Promise((resolve, reject) => {
          this.httpServer.listen(this.config.port, this.config.host, () => {
            resolve();
          });
          this.httpServer.on("error", (error) => {
            if (error.code === "EADDRINUSE") {
              this.config.port++;
              if (this.config.port < 8099) {
                this.httpServer.listen(this.config.port, this.config.host);
              } else {
                reject(new Error("No available ports"));
              }
            } else {
              reject(error);
            }
          });
        });
      }
      async startLiveReloadServer() {
        this.wsServer = new ws_1.WebSocketServer({
          port: this.config.livereloadPort,
          host: this.config.host
        });
        this.wsServer.on("connection", (ws) => {
          this.clients.add(ws);
          const helloMessage = {
            command: "hello",
            protocols: ["http://livereload.com/protocols/official-7"],
            serverName: "foundry-livereload"
          };
          ws.send(JSON.stringify(helloMessage));
          ws.on("close", () => {
            this.clients.delete(ws);
          });
          ws.on("message", (data) => {
            try {
              JSON.parse(data.toString());
            } catch (error) {
              log.error("Invalid LiveReload message:", data.toString());
            }
          });
        });
        this.wsServer.on("error", (error) => {
          log.error("LiveReload WebSocket server error:", error);
        });
      }
      async handleHttpRequest(req, res) {
        const url = req.url || "/";
        let filePath = this.resolveFilePath(url);
        try {
          const stats = await fs5.stat(filePath);
          if (stats.isDirectory()) {
            const indexPath = path6.join(filePath, "index.html");
            try {
              await fs5.stat(indexPath);
              filePath = indexPath;
            } catch {
              res.statusCode = 404;
              res.end("Not Found");
              return;
            }
          }
          let content = await fs5.readFile(filePath);
          const contentType = this.getContentType(filePath);
          res.setHeader("Content-Type", contentType);
          if (contentType.includes("text/html") && this.config.enableLiveReload) {
            const htmlContent = content.toString();
            const liveReloadScript = this.getLiveReloadScript();
            const modifiedHtml = htmlContent.replace(/<\/body>/i, `${liveReloadScript}
</body>`);
            content = Buffer.from(modifiedHtml, "utf8");
          }
          res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
          res.setHeader("Pragma", "no-cache");
          res.setHeader("Expires", "0");
          res.statusCode = 200;
          res.end(content);
        } catch (error) {
          if (error.code === "ENOENT") {
            res.statusCode = 404;
            res.end("Not Found");
          } else {
            throw error;
          }
        }
      }
      resolveFilePath(url) {
        const cleanUrl = url.split("?")[0].split("#")[0];
        let decodedUrl;
        try {
          decodedUrl = decodeURIComponent(cleanUrl);
        } catch (error) {
          log.warn("Failed to decode URL:", cleanUrl, error);
          decodedUrl = cleanUrl;
        }
        const normalizedPath = path6.normalize(decodedUrl).replace(/^(\.\.[\/\\])+/, "");
        const relativePath = normalizedPath.startsWith("/") ? normalizedPath.slice(1) : normalizedPath;
        const resolvedPath = path6.join(this.config.publicDir, relativePath);
        if (process.platform === "win32" && resolvedPath.length > 260) {
          log.warn("Path too long for Windows filesystem:", resolvedPath);
        }
        if (process.platform === "win32") {
          const invalidChars = /[<>:"|?*\x00-\x1f]/;
          if (invalidChars.test(relativePath)) {
            log.warn("Path contains invalid characters for Windows:", relativePath);
          }
        }
        return resolvedPath;
      }
      getContentType(filePath) {
        const ext = path6.extname(filePath).toLowerCase();
        const mimeTypes = {
          ".html": "text/html; charset=utf-8",
          ".css": "text/css; charset=utf-8",
          ".js": "application/javascript; charset=utf-8",
          ".json": "application/json; charset=utf-8",
          ".png": "image/png",
          ".jpg": "image/jpeg",
          ".jpeg": "image/jpeg",
          ".gif": "image/gif",
          ".svg": "image/svg+xml",
          ".webp": "image/webp",
          ".ico": "image/x-icon",
          ".woff": "font/woff",
          ".woff2": "font/woff2",
          ".ttf": "font/ttf",
          ".eot": "application/vnd.ms-fontobject",
          ".xml": "application/xml; charset=utf-8",
          ".txt": "text/plain; charset=utf-8"
        };
        return mimeTypes[ext] || "application/octet-stream";
      }
      getLiveReloadScript() {
        return `
<script>
(function() {
  'use strict';
  
  var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  var address = protocol + '//${this.config.host}:${this.config.livereloadPort}/livereload';
  var socket = new WebSocket(address);
  
  socket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    
    if (data.command === 'reload') {
      if (data.liveCSS) {
        // \u70ED\u66F4\u65B0 CSS
        reloadCSS();
      } else if (data.liveImg) {
        // \u70ED\u66F4\u65B0\u56FE\u7247
        reloadImages();
      } else {
        // \u5B8C\u6574\u9875\u9762\u5237\u65B0
        window.location.reload();
      }
    }
  };
  
  socket.onopen = function() {
    console.log('LiveReload connected');
  };
  
  socket.onclose = function() {
    console.log('LiveReload disconnected');
    // \u5C1D\u8BD5\u91CD\u8FDE
    setTimeout(function() {
      window.location.reload();
    }, 1000);
  };
  
  function reloadCSS() {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.href;
      if (href) {
        var url = new URL(href);
        url.searchParams.set('_t', Date.now().toString());
        link.href = url.toString();
      }
    }
    console.log('CSS reloaded');
  }
  
  function reloadImages() {
    var images = document.querySelectorAll('img');
    for (var i = 0; i < images.length; i++) {
      var img = images[i];
      var src = img.src;
      if (src) {
        var url = new URL(src);
        url.searchParams.set('_t', Date.now().toString());
        img.src = url.toString();
      }
    }
    console.log('Images reloaded');
  }
})();
<\/script>`;
      }
      shouldLiveReloadCSS(changedFiles) {
        if (!changedFiles)
          return false;
        return changedFiles.some((file) => path6.extname(file).toLowerCase() === ".css");
      }
      shouldLiveReloadImages(changedFiles) {
        if (!changedFiles)
          return false;
        const imageExts = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"];
        return changedFiles.some((file) => imageExts.includes(path6.extname(file).toLowerCase()));
      }
    };
    exports2.FoundryLiveReloadServer = FoundryLiveReloadServer;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/web/server/electron-livereload-server.js
var require_electron_livereload_server = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/web/server/electron-livereload-server.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElectronLiveReloadServer = void 0;
    var http = __importStar(require("http"));
    var path6 = __importStar(require("path"));
    var fs5 = __importStar(require("fs/promises"));
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("web", { component: "electron-livereload-server" });
    var ElectronLiveReloadServer = class {
      constructor(config) {
        this.httpServer = null;
        this.running = false;
        this.config = {
          port: config.port || 8091,
          host: config.host || "localhost",
          livereloadPort: config.livereloadPort || 35729,
          enableLiveReload: config.enableLiveReload !== false,
          publicDir: config.publicDir
        };
        this.stateFilePath = path6.join(this.config.publicDir, ".foundry-livereload-state.json");
      }
      async start() {
        if (this.running) {
          log.warn("ElectronLiveReloadServer already running");
          return;
        }
        try {
          await this.startHttpServer();
          if (this.config.enableLiveReload) {
            await this.initStateFile();
          }
          this.running = true;
          log.info(`ElectronLiveReloadServer started at ${this.getUrl()}`);
        } catch (error) {
          log.error("Failed to start ElectronLiveReloadServer:", error);
          throw error;
        }
      }
      async stop() {
        if (!this.running) {
          return;
        }
        try {
          if (this.httpServer) {
            await new Promise((resolve) => {
              this.httpServer.close(() => resolve());
            });
            this.httpServer = null;
          }
          try {
            await fs5.unlink(this.stateFilePath);
          } catch (error) {
          }
          this.running = false;
          log.info("ElectronLiveReloadServer stopped");
        } catch (error) {
          log.error("Error stopping ElectronLiveReloadServer:", error);
        }
      }
      notifyReload(changedFiles) {
        if (!this.config.enableLiveReload) {
          return;
        }
        const state = {
          timestamp: Date.now(),
          command: "reload",
          liveCSS: this.shouldLiveReloadCSS(changedFiles),
          liveImg: this.shouldLiveReloadImages(changedFiles),
          ...changedFiles && { changedFiles }
        };
        if (changedFiles && changedFiles.length === 1) {
          const file = changedFiles[0];
          const ext = path6.extname(file).toLowerCase();
          if (ext === ".css" || [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"].includes(ext)) {
            state.path = file;
          }
        }
        this.writeStateFile(state).catch((error) => {
          log.error("Failed to write state file:", error);
        });
      }
      getUrl() {
        return `http://${this.config.host}:${this.config.port}`;
      }
      isServerRunning() {
        return this.running;
      }
      async initStateFile() {
        const initialState = {
          timestamp: Date.now(),
          command: "hello"
        };
        await this.writeStateFile(initialState);
      }
      async writeStateFile(state) {
        try {
          await fs5.writeFile(this.stateFilePath, JSON.stringify(state), "utf8");
        } catch (error) {
          log.error("Failed to write LiveReload state file:", error);
        }
      }
      async startHttpServer() {
        this.httpServer = http.createServer(async (req, res) => {
          try {
            await this.handleHttpRequest(req, res);
          } catch (error) {
            log.error("HTTP request error:", error);
            res.statusCode = 500;
            res.end("Internal Server Error");
          }
        });
        await new Promise((resolve, reject) => {
          this.httpServer.listen(this.config.port, this.config.host, () => {
            resolve();
          });
          this.httpServer.on("error", (error) => {
            if (error.code === "EADDRINUSE") {
              this.config.port++;
              if (this.config.port < 8099) {
                this.httpServer.listen(this.config.port, this.config.host);
              } else {
                reject(new Error("No available ports"));
              }
            } else {
              reject(error);
            }
          });
        });
      }
      async handleHttpRequest(req, res) {
        const url = req.url || "/";
        if (url.startsWith("/.foundry-livereload-state.json")) {
          try {
            const content = await fs5.readFile(this.stateFilePath, "utf8");
            res.setHeader("Content-Type", "application/json; charset=utf-8");
            res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
            res.setHeader("Pragma", "no-cache");
            res.setHeader("Expires", "0");
            res.statusCode = 200;
            res.end(content);
            return;
          } catch (error) {
            if (error.code === "ENOENT") {
              res.statusCode = 404;
              res.end("State file not found");
            } else {
              res.statusCode = 500;
              res.end("Internal Server Error");
            }
            return;
          }
        }
        let filePath = this.resolveFilePath(url);
        try {
          const stats = await fs5.stat(filePath);
          if (stats.isDirectory()) {
            const indexPath = path6.join(filePath, "index.html");
            try {
              await fs5.stat(indexPath);
              filePath = indexPath;
            } catch {
              res.statusCode = 404;
              res.end("Not Found");
              return;
            }
          }
          let content = await fs5.readFile(filePath);
          const contentType = this.getContentType(filePath);
          res.setHeader("Content-Type", contentType);
          if (contentType.includes("text/html") && this.config.enableLiveReload) {
            const htmlContent = content.toString();
            const liveReloadScript = this.getLiveReloadScript();
            const modifiedHtml = htmlContent.replace(/<\/body>/i, `${liveReloadScript}
</body>`);
            content = Buffer.from(modifiedHtml, "utf8");
          }
          res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
          res.setHeader("Pragma", "no-cache");
          res.setHeader("Expires", "0");
          res.statusCode = 200;
          res.end(content);
        } catch (error) {
          if (error.code === "ENOENT") {
            res.statusCode = 404;
            res.end("Not Found");
          } else {
            throw error;
          }
        }
      }
      resolveFilePath(url) {
        const cleanUrl = url.split("?")[0].split("#")[0];
        let decodedUrl;
        try {
          decodedUrl = decodeURIComponent(cleanUrl);
        } catch (error) {
          log.warn("Failed to decode URL:", cleanUrl, error);
          decodedUrl = cleanUrl;
        }
        const normalizedPath = path6.normalize(decodedUrl).replace(/^(\.\.[\/\\])+/, "");
        const relativePath = normalizedPath.startsWith("/") ? normalizedPath.slice(1) : normalizedPath;
        const resolvedPath = path6.join(this.config.publicDir, relativePath);
        return resolvedPath;
      }
      getContentType(filePath) {
        const ext = path6.extname(filePath).toLowerCase();
        const mimeTypes = {
          ".html": "text/html; charset=utf-8",
          ".css": "text/css; charset=utf-8",
          ".js": "application/javascript; charset=utf-8",
          ".json": "application/json; charset=utf-8",
          ".png": "image/png",
          ".jpg": "image/jpeg",
          ".jpeg": "image/jpeg",
          ".gif": "image/gif",
          ".svg": "image/svg+xml",
          ".webp": "image/webp",
          ".ico": "image/x-icon",
          ".woff": "font/woff",
          ".woff2": "font/woff2",
          ".ttf": "font/ttf",
          ".eot": "application/vnd.ms-fontobject",
          ".xml": "application/xml; charset=utf-8",
          ".txt": "text/plain; charset=utf-8"
        };
        return mimeTypes[ext] || "application/octet-stream";
      }
      getLiveReloadScript() {
        return `
<script>
(function() {
  'use strict';
  
  var stateFilePath = '/.foundry-livereload-state.json';
  var storageKey = 'foundry-livereload-last-timestamp';
  var lastTimestamp = 0;
  var pollInterval = 500; // 500ms \u8F6E\u8BE2\u95F4\u9694
  
  // \u4ECE localStorage \u6062\u590D\u4E0A\u6B21\u7684\u65F6\u95F4\u6233\uFF0C\u907F\u514D\u9875\u9762\u5237\u65B0\u540E\u91CD\u590D\u89E6\u53D1
  try {
    var stored = localStorage.getItem(storageKey);
    if (stored) {
      lastTimestamp = parseInt(stored, 10) || 0;
    }
  } catch (error) {
    // localStorage \u53EF\u80FD\u4E0D\u53EF\u7528\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u503C
    console.warn('LiveReload: localStorage not available, may cause duplicate reloads');
  }
  
  function checkForReload() {
    fetch(stateFilePath + '?_t=' + Date.now(), { cache: 'no-cache' })
      .then(function(response) {
        if (!response.ok) {
          throw new Error('Failed to fetch state file');
        }
        return response.json();
      })
      .then(function(state) {
        if (state.timestamp > lastTimestamp) {
          // \u66F4\u65B0\u65F6\u95F4\u6233\u5E76\u4FDD\u5B58\u5230 localStorage
          lastTimestamp = state.timestamp;
          try {
            localStorage.setItem(storageKey, lastTimestamp.toString());
          } catch (error) {
            // localStorage \u5199\u5165\u5931\u8D25\uFF0C\u5FFD\u7565
          }
          
          if (state.command === 'reload') {
            if (state.liveCSS) {
              // \u70ED\u66F4\u65B0 CSS
              reloadCSS();
            } else if (state.liveImg) {
              // \u70ED\u66F4\u65B0\u56FE\u7247
              reloadImages();
            } else {
              // \u5B8C\u6574\u9875\u9762\u5237\u65B0
              window.location.reload();
            }
          }
        }
      })
      .catch(function(error) {
        // \u9759\u9ED8\u5904\u7406\u9519\u8BEF\uFF0C\u907F\u514D\u63A7\u5236\u53F0\u566A\u97F3
      });
  }
  
  function reloadCSS() {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.href;
      if (href) {
        var url = new URL(href);
        url.searchParams.set('_t', Date.now().toString());
        link.href = url.toString();
      }
    }
    console.log('CSS reloaded');
  }
  
  function reloadImages() {
    var images = document.querySelectorAll('img');
    for (var i = 0; i < images.length; i++) {
      var img = images[i];
      var src = img.src;
      if (src) {
        var url = new URL(src);
        url.searchParams.set('_t', Date.now().toString());
        img.src = url.toString();
      }
    }
    console.log('Images reloaded');
  }
  
  // \u5F00\u59CB\u8F6E\u8BE2
  setInterval(checkForReload, pollInterval);
  
  // \u521D\u59CB\u68C0\u67E5
  checkForReload();
})();
<\/script>`;
      }
      shouldLiveReloadCSS(changedFiles) {
        if (!changedFiles)
          return false;
        return changedFiles.some((file) => path6.extname(file).toLowerCase() === ".css");
      }
      shouldLiveReloadImages(changedFiles) {
        if (!changedFiles)
          return false;
        const imageExts = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"];
        return changedFiles.some((file) => imageExts.includes(path6.extname(file).toLowerCase()));
      }
    };
    exports2.ElectronLiveReloadServer = ElectronLiveReloadServer;
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/web/server/types.js
var require_types4 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/web/server/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@mdfriday/foundry/dist/pkg/web/server/index.js
var require_server = __commonJS({
  "node_modules/@mdfriday/foundry/dist/pkg/web/server/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElectronLiveReloadServer = exports2.FoundryLiveReloadServer = void 0;
    exports2.isElectronEnvironment = isElectronEnvironment;
    exports2.createLiveReloadServer = createLiveReloadServer;
    var livereload_server_1 = require_livereload_server();
    var electron_livereload_server_1 = require_electron_livereload_server();
    function isElectronEnvironment() {
      if (typeof globalThis !== "undefined" && globalThis.window && globalThis.window.process && globalThis.window.process.type) {
        return true;
      }
      try {
        require("electron");
        return true;
      } catch {
      }
      if (process.env.ELECTRON_RUN_AS_NODE || process.env.ELECTRON_NO_ATTACH_CONSOLE) {
        return true;
      }
      if (process.versions && process.versions.electron) {
        return true;
      }
      return false;
    }
    function createLiveReloadServer(config) {
      if (isElectronEnvironment()) {
        return new electron_livereload_server_1.ElectronLiveReloadServer(config);
      } else {
        return new livereload_server_1.FoundryLiveReloadServer(config);
      }
    }
    __exportStar(require_types4(), exports2);
    var livereload_server_2 = require_livereload_server();
    Object.defineProperty(exports2, "FoundryLiveReloadServer", { enumerable: true, get: function() {
      return livereload_server_2.FoundryLiveReloadServer;
    } });
    var electron_livereload_server_2 = require_electron_livereload_server();
    Object.defineProperty(exports2, "ElectronLiveReloadServer", { enumerable: true, get: function() {
      return electron_livereload_server_2.ElectronLiveReloadServer;
    } });
  }
});

// node_modules/@mdfriday/foundry/dist/internal/application/incremental-build-coordinator.js
var require_incremental_build_coordinator = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/application/incremental-build-coordinator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IncrementalBuildCoordinator = void 0;
    var ssg_1 = require_ssg();
    var log_1 = require_log();
    var content_file_watcher_1 = require_content_file_watcher();
    var server_1 = require_server();
    var log = (0, log_1.getDomainLogger)("build", { component: "incremental-coordinator" });
    var IncrementalBuildCoordinator = class {
      constructor(config) {
        this.config = config;
        this.buildInProgress = false;
        this.initialized = false;
        if (config.enableWatching) {
          const watcherConfig = {
            contentDir: config.contentDir,
            projContentDir: config.projContentDir || config.contentDir,
            batchDelay: config.batchDelay || 500
          };
          this.fileWatcher = new content_file_watcher_1.ContentFileWatcher(watcherConfig);
          this.fileWatcher.onFileChange((events) => this.handleFileChanges(events));
        }
        if (config.liveReload?.enabled !== false) {
          const liveReloadConfig = {
            port: config.liveReload?.port || 8091,
            host: config.liveReload?.host || "localhost",
            livereloadPort: config.liveReload?.livereloadPort || 35729,
            publicDir: config.publicDir,
            enableLiveReload: true
          };
          this.liveReloadServer = (0, server_1.createLiveReloadServer)(liveReloadConfig);
        }
      }
      async initialize() {
        if (this.initialized) {
          log.warn("IncrementalBuildCoordinator already initialized");
          return;
        }
        await this.performFullBuildAndCacheDomains();
        this.initialized = true;
      }
      async performFullBuildAndCacheDomains() {
        try {
          this.domainInstances = await (0, ssg_1.serveSSG)(this.config.projDir, this.config.modulesDir, this.config.markdown, this.config.progressCallback);
        } catch (error) {
          log.error("Failed to perform full build and cache domains:", error);
          throw error;
        }
      }
      async startWatching() {
        if (!this.initialized) {
          throw new Error("Must call initialize() before startWatching()");
        }
        if (this.config.enableWatching && this.fileWatcher) {
          await this.fileWatcher.startWatching();
        }
        if (this.liveReloadServer) {
          await this.liveReloadServer.start();
        }
      }
      async stopWatching() {
        if (this.fileWatcher) {
          await this.fileWatcher.stopWatching();
        }
        if (this.liveReloadServer) {
          await this.liveReloadServer.stop();
        }
      }
      async handleFileChanges(events) {
        if (this.buildInProgress) {
          setTimeout(() => this.handleFileChanges(events), 1e3);
          return;
        }
        try {
          this.buildInProgress = true;
          if (this.needFullRebuild(events)) {
            await this.performFullRebuild(events);
            return;
          }
          await this.performIncrementalBuild(events);
        } finally {
          this.buildInProgress = false;
        }
      }
      needFullRebuild(events) {
        return events.some((event) => event.eventType === "deleted" || event.eventType === "created");
      }
      async performIncrementalBuild(events) {
        if (!this.domainInstances) {
          log.error("Domain instances not available, falling back to full rebuild");
          await this.performFullRebuild(events);
          return;
        }
        try {
          const fileMetaInfos = await this.domainInstances.fs.getFileMetaInfos(this.getEventsFilePaths(events));
          await this.domainInstances.content.handleChangeFiles(fileMetaInfos);
          await this.domainInstances.site.render();
          if (this.liveReloadServer) {
            const changedPaths = events.map((e) => e.filePath);
            this.liveReloadServer.notifyReload(changedPaths);
          }
        } catch (error) {
          log.error("Incremental build failed, falling back to full rebuild:", error);
          await this.performFullRebuild(events);
        }
      }
      getEventsFilePaths(events) {
        return events.map((event) => event.filePath);
      }
      async performFullRebuild(events) {
        await (0, ssg_1.processSSGWithProgress)(this.config.projDir, this.config.modulesDir, this.config.markdown, (progress) => {
          log.info(`Rebuild progress: ${progress.stage} - ${progress.percentage}%`);
        });
        if (this.liveReloadServer) {
          const changedPaths = events.map((e) => e.filePath);
          this.liveReloadServer.notifyReload(changedPaths);
        }
      }
      isInitialized() {
        return this.initialized;
      }
      isBuildInProgress() {
        return this.buildInProgress;
      }
      getConfig() {
        return { ...this.config };
      }
      getServerUrl() {
        if (this.liveReloadServer) {
          return this.liveReloadServer.getUrl();
        }
        return "";
      }
      getLiveReloadStatus() {
        if (!this.liveReloadServer) {
          return { running: false };
        }
        const isRunning = this.liveReloadServer.isServerRunning();
        return {
          running: isRunning,
          ...isRunning && { url: this.liveReloadServer.getUrl() }
        };
      }
    };
    exports2.IncrementalBuildCoordinator = IncrementalBuildCoordinator;
  }
});

// node_modules/@mdfriday/foundry/dist/internal/application/incremental-ssg.js
var require_incremental_ssg = __commonJS({
  "node_modules/@mdfriday/foundry/dist/internal/application/incremental-ssg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IncrementalBuildCoordinator = void 0;
    exports2.startIncrementalBuild = startIncrementalBuild2;
    var incremental_build_coordinator_1 = require_incremental_build_coordinator();
    Object.defineProperty(exports2, "IncrementalBuildCoordinator", { enumerable: true, get: function() {
      return incremental_build_coordinator_1.IncrementalBuildCoordinator;
    } });
    var log_1 = require_log();
    var log = (0, log_1.getDomainLogger)("build", { component: "incremental-ssg" });
    async function startIncrementalBuild2(config) {
      const coordinator = new incremental_build_coordinator_1.IncrementalBuildCoordinator(config);
      await coordinator.initialize();
      if (config.enableWatching) {
        await coordinator.startWatching();
      }
      return coordinator;
    }
  }
});

// node_modules/@mdfriday/foundry/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoIDGenerator = exports2.IncrementalBuildCoordinator = exports2.startIncrementalBuild = exports2.processSSGWithProgress = exports2.processSSG = void 0;
    var ssg_1 = require_ssg();
    Object.defineProperty(exports2, "processSSG", { enumerable: true, get: function() {
      return ssg_1.processSSG;
    } });
    Object.defineProperty(exports2, "processSSGWithProgress", { enumerable: true, get: function() {
      return ssg_1.processSSGWithProgress;
    } });
    var incremental_ssg_1 = require_incremental_ssg();
    Object.defineProperty(exports2, "startIncrementalBuild", { enumerable: true, get: function() {
      return incremental_ssg_1.startIncrementalBuild;
    } });
    Object.defineProperty(exports2, "IncrementalBuildCoordinator", { enumerable: true, get: function() {
      return incremental_ssg_1.IncrementalBuildCoordinator;
    } });
    var markdown_1 = require_markdown3();
    Object.defineProperty(exports2, "AutoIDGenerator", { enumerable: true, get: function() {
      return markdown_1.AutoIDGenerator;
    } });
  }
});

// node_modules/basic-ftp/dist/parseControlResponse.js
var require_parseControlResponse = __commonJS({
  "node_modules/basic-ftp/dist/parseControlResponse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.positiveIntermediate = exports2.positiveCompletion = exports2.isMultiline = exports2.isSingleLine = exports2.parseControlResponse = void 0;
    var LF = "\n";
    function parseControlResponse(text3) {
      const lines = text3.split(/\r?\n/).filter(isNotBlank);
      const messages = [];
      let startAt = 0;
      let tokenRegex;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!tokenRegex) {
          if (isMultiline(line)) {
            const token = line.substr(0, 3);
            tokenRegex = new RegExp(`^${token}(?:$| )`);
            startAt = i;
          } else if (isSingleLine(line)) {
            messages.push(line);
          }
        } else if (tokenRegex.test(line)) {
          tokenRegex = void 0;
          messages.push(lines.slice(startAt, i + 1).join(LF));
        }
      }
      const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : "";
      return { messages, rest };
    }
    exports2.parseControlResponse = parseControlResponse;
    function isSingleLine(line) {
      return /^\d\d\d(?:$| )/.test(line);
    }
    exports2.isSingleLine = isSingleLine;
    function isMultiline(line) {
      return /^\d\d\d-/.test(line);
    }
    exports2.isMultiline = isMultiline;
    function positiveCompletion(code) {
      return code >= 200 && code < 300;
    }
    exports2.positiveCompletion = positiveCompletion;
    function positiveIntermediate(code) {
      return code >= 300 && code < 400;
    }
    exports2.positiveIntermediate = positiveIntermediate;
    function isNotBlank(str) {
      return str.trim() !== "";
    }
  }
});

// node_modules/basic-ftp/dist/FtpContext.js
var require_FtpContext = __commonJS({
  "node_modules/basic-ftp/dist/FtpContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FTPContext = exports2.FTPError = void 0;
    var net_1 = require("net");
    var parseControlResponse_1 = require_parseControlResponse();
    var FTPError = class extends Error {
      constructor(res) {
        super(res.message);
        this.name = this.constructor.name;
        this.code = res.code;
      }
    };
    exports2.FTPError = FTPError;
    function doNothing() {
    }
    var FTPContext = class {
      constructor(timeout = 0, encoding = "utf8") {
        this.timeout = timeout;
        this.verbose = false;
        this.ipFamily = void 0;
        this.tlsOptions = {};
        this._partialResponse = "";
        this._encoding = encoding;
        this._socket = this.socket = this._newSocket();
        this._dataSocket = void 0;
      }
      close() {
        const message = this._task ? "User closed client during task" : "User closed client";
        const err = new Error(message);
        this.closeWithError(err);
      }
      closeWithError(err) {
        if (this._closingError) {
          return;
        }
        this._closingError = err;
        this._closeControlSocket();
        this._closeSocket(this._dataSocket);
        this._passToHandler(err);
        this._stopTrackingTask();
      }
      get closed() {
        return this.socket.remoteAddress === void 0 || this._closingError !== void 0;
      }
      reset() {
        this.socket = this._newSocket();
      }
      get socket() {
        return this._socket;
      }
      set socket(socket) {
        this.dataSocket = void 0;
        this.tlsOptions = {};
        this._partialResponse = "";
        if (this._socket) {
          const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
          if (newSocketUpgradesExisting) {
            this._removeSocketListeners(this.socket);
          } else {
            this._closeControlSocket();
          }
        }
        if (socket) {
          this._closingError = void 0;
          socket.setTimeout(0);
          socket.setEncoding(this._encoding);
          socket.setKeepAlive(true);
          socket.on("data", (data) => this._onControlSocketData(data));
          socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
          socket.on("close", (hadError) => {
            if (!hadError)
              this.closeWithError(new Error("Server closed connection unexpectedly."));
          });
          this._setupDefaultErrorHandlers(socket, "control socket");
        }
        this._socket = socket;
      }
      get dataSocket() {
        return this._dataSocket;
      }
      set dataSocket(socket) {
        this._closeSocket(this._dataSocket);
        if (socket) {
          socket.setTimeout(0);
          this._setupDefaultErrorHandlers(socket, "data socket");
        }
        this._dataSocket = socket;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        this._encoding = encoding;
        if (this.socket) {
          this.socket.setEncoding(encoding);
        }
      }
      send(command) {
        const containsPassword = command.startsWith("PASS");
        const message = containsPassword ? "> PASS ###" : `> ${command}`;
        this.log(message);
        this._socket.write(command + "\r\n", this.encoding);
      }
      request(command) {
        return this.handle(command, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else {
            task.resolve(res);
          }
        });
      }
      handle(command, responseHandler) {
        if (this._task) {
          const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
          err.stack += `
Running task launched at: ${this._task.stack}`;
          this.closeWithError(err);
        }
        return new Promise((resolveTask, rejectTask) => {
          this._task = {
            stack: new Error().stack || "Unknown call stack",
            responseHandler,
            resolver: {
              resolve: (arg) => {
                this._stopTrackingTask();
                resolveTask(arg);
              },
              reject: (err) => {
                this._stopTrackingTask();
                rejectTask(err);
              }
            }
          };
          if (this._closingError) {
            const err = new Error(`Client is closed because ${this._closingError.message}`);
            err.stack += `
Closing reason: ${this._closingError.stack}`;
            err.code = this._closingError.code !== void 0 ? this._closingError.code : "0";
            this._passToHandler(err);
            return;
          }
          this.socket.setTimeout(this.timeout);
          if (command) {
            this.send(command);
          }
        });
      }
      log(message) {
        if (this.verbose) {
          console.log(message);
        }
      }
      get hasTLS() {
        return "encrypted" in this._socket;
      }
      _stopTrackingTask() {
        this.socket.setTimeout(0);
        this._task = void 0;
      }
      _onControlSocketData(chunk) {
        this.log(`< ${chunk}`);
        const completeResponse = this._partialResponse + chunk;
        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);
        this._partialResponse = parsed.rest;
        for (const message of parsed.messages) {
          const code = parseInt(message.substr(0, 3), 10);
          const response = { code, message };
          const err = code >= 400 ? new FTPError(response) : void 0;
          this._passToHandler(err ? err : response);
        }
      }
      _passToHandler(response) {
        if (this._task) {
          this._task.responseHandler(response, this._task.resolver);
        }
      }
      _setupDefaultErrorHandlers(socket, identifier) {
        socket.once("error", (error) => {
          error.message += ` (${identifier})`;
          this.closeWithError(error);
        });
        socket.once("close", (hadError) => {
          if (hadError) {
            this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
          }
        });
        socket.once("timeout", () => {
          socket.destroy();
          this.closeWithError(new Error(`Timeout (${identifier})`));
        });
      }
      _closeControlSocket() {
        this._removeSocketListeners(this._socket);
        this._socket.on("error", doNothing);
        this.send("QUIT");
        this._closeSocket(this._socket);
      }
      _closeSocket(socket) {
        if (socket) {
          this._removeSocketListeners(socket);
          socket.on("error", doNothing);
          socket.destroy();
        }
      }
      _removeSocketListeners(socket) {
        socket.removeAllListeners();
        socket.removeAllListeners("timeout");
        socket.removeAllListeners("data");
        socket.removeAllListeners("end");
        socket.removeAllListeners("error");
        socket.removeAllListeners("close");
        socket.removeAllListeners("connect");
      }
      _newSocket() {
        return new net_1.Socket();
      }
    };
    exports2.FTPContext = FTPContext;
  }
});

// node_modules/basic-ftp/dist/FileInfo.js
var require_FileInfo = __commonJS({
  "node_modules/basic-ftp/dist/FileInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileInfo = exports2.FileType = void 0;
    var FileType;
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 3] = "SymbolicLink";
    })(FileType || (exports2.FileType = FileType = {}));
    var FileInfo = class {
      constructor(name) {
        this.name = name;
        this.type = FileType.Unknown;
        this.size = 0;
        this.rawModifiedAt = "";
        this.modifiedAt = void 0;
        this.permissions = void 0;
        this.hardLinkCount = void 0;
        this.link = void 0;
        this.group = void 0;
        this.user = void 0;
        this.uniqueID = void 0;
        this.name = name;
      }
      get isDirectory() {
        return this.type === FileType.Directory;
      }
      get isSymbolicLink() {
        return this.type === FileType.SymbolicLink;
      }
      get isFile() {
        return this.type === FileType.File;
      }
      get date() {
        return this.rawModifiedAt;
      }
      set date(rawModifiedAt) {
        this.rawModifiedAt = rawModifiedAt;
      }
    };
    exports2.FileInfo = FileInfo;
    FileInfo.UnixPermission = {
      Read: 4,
      Write: 2,
      Execute: 1
    };
  }
});

// node_modules/basic-ftp/dist/parseListDOS.js
var require_parseListDOS = __commonJS({
  "node_modules/basic-ftp/dist/parseListDOS.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    var RE_LINE = new RegExp("(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)");
    function testLine(line) {
      return /^\d{2}/.test(line) && RE_LINE.test(line);
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const groups = line.match(RE_LINE);
      if (groups === null) {
        return void 0;
      }
      const name = groups[5];
      if (name === "." || name === "..") {
        return void 0;
      }
      const file = new FileInfo_1.FileInfo(name);
      const fileType = groups[3];
      if (fileType === "<DIR>") {
        file.type = FileInfo_1.FileType.Directory;
        file.size = 0;
      } else {
        file.type = FileInfo_1.FileType.File;
        file.size = parseInt(groups[4], 10);
      }
      file.rawModifiedAt = groups[1] + " " + groups[2];
      return file;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      return files;
    }
    exports2.transformList = transformList;
  }
});

// node_modules/basic-ftp/dist/parseListUnix.js
var require_parseListUnix = __commonJS({
  "node_modules/basic-ftp/dist/parseListUnix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    var JA_MONTH = "\u6708";
    var JA_DAY = "\u65E5";
    var JA_YEAR = "\u5E74";
    var RE_LINE = new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + "))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))\\s(.*)");
    function testLine(line) {
      return RE_LINE.test(line);
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const groups = line.match(RE_LINE);
      if (groups === null) {
        return void 0;
      }
      const name = groups[21];
      if (name === "." || name === "..") {
        return void 0;
      }
      const file = new FileInfo_1.FileInfo(name);
      file.size = parseInt(groups[18], 10);
      file.user = groups[16];
      file.group = groups[17];
      file.hardLinkCount = parseInt(groups[15], 10);
      file.rawModifiedAt = groups[19] + " " + groups[20];
      file.permissions = {
        user: parseMode(groups[4], groups[5], groups[6]),
        group: parseMode(groups[8], groups[9], groups[10]),
        world: parseMode(groups[12], groups[13], groups[14])
      };
      switch (groups[1].charAt(0)) {
        case "d":
          file.type = FileInfo_1.FileType.Directory;
          break;
        case "e":
          file.type = FileInfo_1.FileType.SymbolicLink;
          break;
        case "l":
          file.type = FileInfo_1.FileType.SymbolicLink;
          break;
        case "b":
        case "c":
          file.type = FileInfo_1.FileType.File;
          break;
        case "f":
        case "-":
          file.type = FileInfo_1.FileType.File;
          break;
        default:
          file.type = FileInfo_1.FileType.Unknown;
      }
      if (file.isSymbolicLink) {
        const end = name.indexOf(" -> ");
        if (end !== -1) {
          file.name = name.substring(0, end);
          file.link = name.substring(end + 4);
        }
      }
      return file;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      return files;
    }
    exports2.transformList = transformList;
    function parseMode(r, w, x) {
      let value2 = 0;
      if (r !== "-") {
        value2 += FileInfo_1.FileInfo.UnixPermission.Read;
      }
      if (w !== "-") {
        value2 += FileInfo_1.FileInfo.UnixPermission.Write;
      }
      const execToken = x.charAt(0);
      if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
        value2 += FileInfo_1.FileInfo.UnixPermission.Execute;
      }
      return value2;
    }
  }
});

// node_modules/basic-ftp/dist/parseListMLSD.js
var require_parseListMLSD = __commonJS({
  "node_modules/basic-ftp/dist/parseListMLSD.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseMLSxDate = exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    function parseSize(value2, info) {
      info.size = parseInt(value2, 10);
    }
    var factHandlersByName = {
      "size": parseSize,
      "sizd": parseSize,
      "unique": (value2, info) => {
        info.uniqueID = value2;
      },
      "modify": (value2, info) => {
        info.modifiedAt = parseMLSxDate(value2);
        info.rawModifiedAt = info.modifiedAt.toISOString();
      },
      "type": (value2, info) => {
        if (value2.startsWith("OS.unix=slink")) {
          info.type = FileInfo_1.FileType.SymbolicLink;
          info.link = value2.substr(value2.indexOf(":") + 1);
          return 1;
        }
        switch (value2) {
          case "file":
            info.type = FileInfo_1.FileType.File;
            break;
          case "dir":
            info.type = FileInfo_1.FileType.Directory;
            break;
          case "OS.unix=symlink":
            info.type = FileInfo_1.FileType.SymbolicLink;
            break;
          case "cdir":
          case "pdir":
            return 2;
          default:
            info.type = FileInfo_1.FileType.Unknown;
        }
        return 1;
      },
      "unix.mode": (value2, info) => {
        const digits = value2.substr(-3);
        info.permissions = {
          user: parseInt(digits[0], 10),
          group: parseInt(digits[1], 10),
          world: parseInt(digits[2], 10)
        };
      },
      "unix.ownername": (value2, info) => {
        info.user = value2;
      },
      "unix.owner": (value2, info) => {
        if (info.user === void 0)
          info.user = value2;
      },
      get "unix.uid"() {
        return this["unix.owner"];
      },
      "unix.groupname": (value2, info) => {
        info.group = value2;
      },
      "unix.group": (value2, info) => {
        if (info.group === void 0)
          info.group = value2;
      },
      get "unix.gid"() {
        return this["unix.group"];
      }
    };
    function splitStringOnce(str, delimiter) {
      const pos2 = str.indexOf(delimiter);
      const a = str.substr(0, pos2);
      const b = str.substr(pos2 + delimiter.length);
      return [a, b];
    }
    function testLine(line) {
      return /^\S+=\S+;/.test(line) || line.startsWith(" ");
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const [packedFacts, name] = splitStringOnce(line, " ");
      if (name === "" || name === "." || name === "..") {
        return void 0;
      }
      const info = new FileInfo_1.FileInfo(name);
      const facts = packedFacts.split(";");
      for (const fact of facts) {
        const [factName, factValue] = splitStringOnce(fact, "=");
        if (!factValue) {
          continue;
        }
        const factHandler = factHandlersByName[factName.toLowerCase()];
        if (!factHandler) {
          continue;
        }
        const result = factHandler(factValue, info);
        if (result === 2) {
          return void 0;
        }
      }
      return info;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      const nonLinksByID = /* @__PURE__ */ new Map();
      for (const file of files) {
        if (!file.isSymbolicLink && file.uniqueID !== void 0) {
          nonLinksByID.set(file.uniqueID, file);
        }
      }
      const resolvedFiles = [];
      for (const file of files) {
        if (file.isSymbolicLink && file.uniqueID !== void 0 && file.link === void 0) {
          const target = nonLinksByID.get(file.uniqueID);
          if (target !== void 0) {
            file.link = target.name;
          }
        }
        const isPartOfDirectory = !file.name.includes("/");
        if (isPartOfDirectory) {
          resolvedFiles.push(file);
        }
      }
      return resolvedFiles;
    }
    exports2.transformList = transformList;
    function parseMLSxDate(fact) {
      return new Date(Date.UTC(+fact.slice(0, 4), +fact.slice(4, 6) - 1, +fact.slice(6, 8), +fact.slice(8, 10), +fact.slice(10, 12), +fact.slice(12, 14), +fact.slice(15, 18)));
    }
    exports2.parseMLSxDate = parseMLSxDate;
  }
});

// node_modules/basic-ftp/dist/parseList.js
var require_parseList = __commonJS({
  "node_modules/basic-ftp/dist/parseList.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseList = void 0;
    var dosParser = __importStar(require_parseListDOS());
    var unixParser = __importStar(require_parseListUnix());
    var mlsdParser = __importStar(require_parseListMLSD());
    var availableParsers = [
      dosParser,
      unixParser,
      mlsdParser
    ];
    function firstCompatibleParser(line, parsers) {
      return parsers.find((parser) => parser.testLine(line) === true);
    }
    function isNotBlank(str) {
      return str.trim() !== "";
    }
    function isNotMeta(str) {
      return !str.startsWith("total");
    }
    var REGEX_NEWLINE = /\r?\n/;
    function parseList(rawList) {
      const lines = rawList.split(REGEX_NEWLINE).filter(isNotBlank).filter(isNotMeta);
      if (lines.length === 0) {
        return [];
      }
      const testLine = lines[lines.length - 1];
      const parser = firstCompatibleParser(testLine, availableParsers);
      if (!parser) {
        throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
      }
      const files = lines.map(parser.parseLine).filter((info) => info !== void 0);
      return parser.transformList(files);
    }
    exports2.parseList = parseList;
  }
});

// node_modules/basic-ftp/dist/ProgressTracker.js
var require_ProgressTracker = __commonJS({
  "node_modules/basic-ftp/dist/ProgressTracker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressTracker = void 0;
    var ProgressTracker = class {
      constructor() {
        this.bytesOverall = 0;
        this.intervalMs = 500;
        this.onStop = noop2;
        this.onHandle = noop2;
      }
      reportTo(onHandle = noop2) {
        this.onHandle = onHandle;
      }
      start(socket, name, type) {
        let lastBytes = 0;
        this.onStop = poll(this.intervalMs, () => {
          const bytes = socket.bytesRead + socket.bytesWritten;
          this.bytesOverall += bytes - lastBytes;
          lastBytes = bytes;
          this.onHandle({
            name,
            type,
            bytes,
            bytesOverall: this.bytesOverall
          });
        });
      }
      stop() {
        this.onStop(false);
      }
      updateAndStop() {
        this.onStop(true);
      }
    };
    exports2.ProgressTracker = ProgressTracker;
    function poll(intervalMs, updateFunc) {
      const id = setInterval(updateFunc, intervalMs);
      const stopFunc = (stopWithUpdate) => {
        clearInterval(id);
        if (stopWithUpdate) {
          updateFunc();
        }
        updateFunc = noop2;
      };
      updateFunc();
      return stopFunc;
    }
    function noop2() {
    }
  }
});

// node_modules/basic-ftp/dist/StringWriter.js
var require_StringWriter = __commonJS({
  "node_modules/basic-ftp/dist/StringWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringWriter = void 0;
    var stream_1 = require("stream");
    var StringWriter = class extends stream_1.Writable {
      constructor() {
        super(...arguments);
        this.buf = Buffer.alloc(0);
      }
      _write(chunk, _, callback) {
        if (chunk instanceof Buffer) {
          this.buf = Buffer.concat([this.buf, chunk]);
          callback(null);
        } else {
          callback(new Error("StringWriter expects chunks of type 'Buffer'."));
        }
      }
      getText(encoding) {
        return this.buf.toString(encoding);
      }
    };
    exports2.StringWriter = StringWriter;
  }
});

// node_modules/basic-ftp/dist/netUtils.js
var require_netUtils = __commonJS({
  "node_modules/basic-ftp/dist/netUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipIsPrivateV4Address = exports2.upgradeSocket = exports2.describeAddress = exports2.describeTLS = void 0;
    var tls_1 = require("tls");
    function describeTLS(socket) {
      if (socket instanceof tls_1.TLSSocket) {
        const protocol = socket.getProtocol();
        return protocol ? protocol : "Server socket or disconnected client socket";
      }
      return "No encryption";
    }
    exports2.describeTLS = describeTLS;
    function describeAddress(socket) {
      if (socket.remoteFamily === "IPv6") {
        return `[${socket.remoteAddress}]:${socket.remotePort}`;
      }
      return `${socket.remoteAddress}:${socket.remotePort}`;
    }
    exports2.describeAddress = describeAddress;
    function upgradeSocket(socket, options) {
      return new Promise((resolve, reject) => {
        const tlsOptions = Object.assign({}, options, {
          socket
        });
        const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {
          const expectCertificate = tlsOptions.rejectUnauthorized !== false;
          if (expectCertificate && !tlsSocket.authorized) {
            reject(tlsSocket.authorizationError);
          } else {
            tlsSocket.removeAllListeners("error");
            resolve(tlsSocket);
          }
        }).once("error", (error) => {
          reject(error);
        });
      });
    }
    exports2.upgradeSocket = upgradeSocket;
    function ipIsPrivateV4Address(ip = "") {
      if (ip.startsWith("::ffff:")) {
        ip = ip.substr(7);
      }
      const octets = ip.split(".").map((o) => parseInt(o, 10));
      return octets[0] === 10 || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 || octets[0] === 192 && octets[1] === 168 || ip === "127.0.0.1";
    }
    exports2.ipIsPrivateV4Address = ipIsPrivateV4Address;
  }
});

// node_modules/basic-ftp/dist/transfer.js
var require_transfer = __commonJS({
  "node_modules/basic-ftp/dist/transfer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.downloadTo = exports2.uploadFrom = exports2.connectForPassiveTransfer = exports2.parsePasvResponse = exports2.enterPassiveModeIPv4 = exports2.parseEpsvResponse = exports2.enterPassiveModeIPv6 = void 0;
    var netUtils_1 = require_netUtils();
    var stream_1 = require("stream");
    var tls_1 = require("tls");
    var parseControlResponse_1 = require_parseControlResponse();
    async function enterPassiveModeIPv6(ftp2) {
      const res = await ftp2.request("EPSV");
      const port = parseEpsvResponse(res.message);
      if (!port) {
        throw new Error("Can't parse EPSV response: " + res.message);
      }
      const controlHost = ftp2.socket.remoteAddress;
      if (controlHost === void 0) {
        throw new Error("Control socket is disconnected, can't get remote address.");
      }
      await connectForPassiveTransfer(controlHost, port, ftp2);
      return res;
    }
    exports2.enterPassiveModeIPv6 = enterPassiveModeIPv6;
    function parseEpsvResponse(message) {
      const groups = message.match(/[|!]{3}(.+)[|!]/);
      if (groups === null || groups[1] === void 0) {
        throw new Error(`Can't parse response to 'EPSV': ${message}`);
      }
      const port = parseInt(groups[1], 10);
      if (Number.isNaN(port)) {
        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);
      }
      return port;
    }
    exports2.parseEpsvResponse = parseEpsvResponse;
    async function enterPassiveModeIPv4(ftp2) {
      const res = await ftp2.request("PASV");
      const target = parsePasvResponse(res.message);
      if (!target) {
        throw new Error("Can't parse PASV response: " + res.message);
      }
      const controlHost = ftp2.socket.remoteAddress;
      if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {
        target.host = controlHost;
      }
      await connectForPassiveTransfer(target.host, target.port, ftp2);
      return res;
    }
    exports2.enterPassiveModeIPv4 = enterPassiveModeIPv4;
    function parsePasvResponse(message) {
      const groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
      if (groups === null || groups.length !== 4) {
        throw new Error(`Can't parse response to 'PASV': ${message}`);
      }
      return {
        host: groups[1].replace(/,/g, "."),
        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
      };
    }
    exports2.parsePasvResponse = parsePasvResponse;
    function connectForPassiveTransfer(host, port, ftp2) {
      return new Promise((resolve, reject) => {
        let socket = ftp2._newSocket();
        const handleConnErr = function(err) {
          err.message = "Can't open data connection in passive mode: " + err.message;
          reject(err);
        };
        const handleTimeout = function() {
          socket.destroy();
          reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));
        };
        socket.setTimeout(ftp2.timeout);
        socket.on("error", handleConnErr);
        socket.on("timeout", handleTimeout);
        socket.connect({ port, host, family: ftp2.ipFamily }, () => {
          if (ftp2.socket instanceof tls_1.TLSSocket) {
            socket = (0, tls_1.connect)(Object.assign({}, ftp2.tlsOptions, {
              socket,
              session: ftp2.socket.getSession()
            }));
          }
          socket.removeListener("error", handleConnErr);
          socket.removeListener("timeout", handleTimeout);
          ftp2.dataSocket = socket;
          resolve();
        });
      });
    }
    exports2.connectForPassiveTransfer = connectForPassiveTransfer;
    var TransferResolver = class {
      constructor(ftp2, progress) {
        this.ftp = ftp2;
        this.progress = progress;
        this.response = void 0;
        this.dataTransferDone = false;
      }
      onDataStart(name, type) {
        if (this.ftp.dataSocket === void 0) {
          throw new Error("Data transfer should start but there is no data connection.");
        }
        this.ftp.socket.setTimeout(0);
        this.ftp.dataSocket.setTimeout(this.ftp.timeout);
        this.progress.start(this.ftp.dataSocket, name, type);
      }
      onDataDone(task) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        if (this.ftp.dataSocket) {
          this.ftp.dataSocket.setTimeout(0);
        }
        this.dataTransferDone = true;
        this.tryResolve(task);
      }
      onControlDone(task, response) {
        this.response = response;
        this.tryResolve(task);
      }
      onError(task, err) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        this.ftp.dataSocket = void 0;
        task.reject(err);
      }
      onUnexpectedRequest(response) {
        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);
        this.ftp.closeWithError(err);
      }
      tryResolve(task) {
        const canResolve = this.dataTransferDone && this.response !== void 0;
        if (canResolve) {
          this.ftp.dataSocket = void 0;
          task.resolve(this.response);
        }
      }
    };
    function uploadFrom(source, config) {
      const resolver = new TransferResolver(config.ftp, config.tracker);
      const fullCommand = `${config.command} ${config.remotePath}`;
      return config.ftp.handle(fullCommand, (res, task) => {
        if (res instanceof Error) {
          resolver.onError(task, res);
        } else if (res.code === 150 || res.code === 125) {
          const dataSocket = config.ftp.dataSocket;
          if (!dataSocket) {
            resolver.onError(task, new Error("Upload should begin but no data connection is available."));
            return;
          }
          const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== void 0 : true;
          onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
            config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
            resolver.onDataStart(config.remotePath, config.type);
            (0, stream_1.pipeline)(source, dataSocket, (err) => {
              if (err) {
                resolver.onError(task, err);
              } else {
                resolver.onDataDone(task);
              }
            });
          });
        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
          resolver.onControlDone(task, res);
        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
          resolver.onUnexpectedRequest(res);
        }
      });
    }
    exports2.uploadFrom = uploadFrom;
    function downloadTo(destination, config) {
      if (!config.ftp.dataSocket) {
        throw new Error("Download will be initiated but no data connection is available.");
      }
      const resolver = new TransferResolver(config.ftp, config.tracker);
      return config.ftp.handle(config.command, (res, task) => {
        if (res instanceof Error) {
          resolver.onError(task, res);
        } else if (res.code === 150 || res.code === 125) {
          const dataSocket = config.ftp.dataSocket;
          if (!dataSocket) {
            resolver.onError(task, new Error("Download should begin but no data connection is available."));
            return;
          }
          config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
          resolver.onDataStart(config.remotePath, config.type);
          (0, stream_1.pipeline)(dataSocket, destination, (err) => {
            if (err) {
              resolver.onError(task, err);
            } else {
              resolver.onDataDone(task);
            }
          });
        } else if (res.code === 350) {
          config.ftp.send("RETR " + config.remotePath);
        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
          resolver.onControlDone(task, res);
        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
          resolver.onUnexpectedRequest(res);
        }
      });
    }
    exports2.downloadTo = downloadTo;
    function onConditionOrEvent(condition, emitter, eventName, action) {
      if (condition === true) {
        action();
      } else {
        emitter.once(eventName, () => action());
      }
    }
  }
});

// node_modules/basic-ftp/dist/Client.js
var require_Client = __commonJS({
  "node_modules/basic-ftp/dist/Client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var tls_1 = require("tls");
    var util_1 = require("util");
    var FtpContext_1 = require_FtpContext();
    var parseList_1 = require_parseList();
    var ProgressTracker_1 = require_ProgressTracker();
    var StringWriter_1 = require_StringWriter();
    var parseListMLSD_1 = require_parseListMLSD();
    var netUtils_1 = require_netUtils();
    var transfer_1 = require_transfer();
    var parseControlResponse_1 = require_parseControlResponse();
    var fsReadDir = (0, util_1.promisify)(fs_1.readdir);
    var fsMkDir = (0, util_1.promisify)(fs_1.mkdir);
    var fsStat = (0, util_1.promisify)(fs_1.stat);
    var fsOpen = (0, util_1.promisify)(fs_1.open);
    var fsClose = (0, util_1.promisify)(fs_1.close);
    var fsUnlink = (0, util_1.promisify)(fs_1.unlink);
    var LIST_COMMANDS_DEFAULT = () => ["LIST -a", "LIST"];
    var LIST_COMMANDS_MLSD = () => ["MLSD", "LIST -a", "LIST"];
    var Client2 = class {
      constructor(timeout = 3e4) {
        this.availableListCommands = LIST_COMMANDS_DEFAULT();
        this.ftp = new FtpContext_1.FTPContext(timeout);
        this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);
        this.parseList = parseList_1.parseList;
        this._progressTracker = new ProgressTracker_1.ProgressTracker();
      }
      close() {
        this.ftp.close();
        this._progressTracker.stop();
      }
      get closed() {
        return this.ftp.closed;
      }
      connect(host = "localhost", port = 21) {
        this.ftp.reset();
        this.ftp.socket.connect({
          host,
          port,
          family: this.ftp.ipFamily
        }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
        return this._handleConnectResponse();
      }
      connectImplicitTLS(host = "localhost", port = 21, tlsOptions = {}) {
        this.ftp.reset();
        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
        this.ftp.tlsOptions = tlsOptions;
        return this._handleConnectResponse();
      }
      _handleConnectResponse() {
        return this.ftp.handle(void 0, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
            task.resolve(res);
          } else {
            task.reject(new FtpContext_1.FTPError(res));
          }
        });
      }
      send(command, ignoreErrorCodesDEPRECATED = false) {
        if (ignoreErrorCodesDEPRECATED) {
          this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).");
          return this.sendIgnoringError(command);
        }
        return this.ftp.request(command);
      }
      sendIgnoringError(command) {
        return this.ftp.handle(command, (res, task) => {
          if (res instanceof FtpContext_1.FTPError) {
            task.resolve({ code: res.code, message: res.message });
          } else if (res instanceof Error) {
            task.reject(res);
          } else {
            task.resolve(res);
          }
        });
      }
      async useTLS(options = {}, command = "AUTH TLS") {
        const ret = await this.send(command);
        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);
        this.ftp.tlsOptions = options;
        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
        return ret;
      }
      login(user = "anonymous", password = "guest") {
        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
        return this.ftp.handle("USER " + user, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
            task.resolve(res);
          } else if (res.code === 331) {
            this.ftp.send("PASS " + password);
          } else {
            task.reject(new FtpContext_1.FTPError(res));
          }
        });
      }
      async useDefaultSettings() {
        const features = await this.features();
        const supportsMLSD = features.has("MLST");
        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();
        await this.send("TYPE I");
        await this.sendIgnoringError("STRU F");
        await this.sendIgnoringError("OPTS UTF8 ON");
        if (supportsMLSD) {
          await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;");
        }
        if (this.ftp.hasTLS) {
          await this.sendIgnoringError("PBSZ 0");
          await this.sendIgnoringError("PROT P");
        }
      }
      async access(options = {}) {
        var _a, _b;
        const useExplicitTLS = options.secure === true;
        const useImplicitTLS = options.secure === "implicit";
        let welcome;
        if (useImplicitTLS) {
          welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);
        } else {
          welcome = await this.connect(options.host, options.port);
        }
        if (useExplicitTLS) {
          const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};
          secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;
          await this.useTLS(secureOptions);
        }
        await this.sendIgnoringError("OPTS UTF8 ON");
        await this.login(options.user, options.password);
        await this.useDefaultSettings();
        return welcome;
      }
      async pwd() {
        const res = await this.send("PWD");
        const parsed = res.message.match(/"(.+)"/);
        if (parsed === null || parsed[1] === void 0) {
          throw new Error(`Can't parse response to command 'PWD': ${res.message}`);
        }
        return parsed[1];
      }
      async features() {
        const res = await this.sendIgnoringError("FEAT");
        const features = /* @__PURE__ */ new Map();
        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {
          res.message.split("\n").slice(1, -1).forEach((line) => {
            const entry = line.trim().split(" ");
            features.set(entry[0], entry[1] || "");
          });
        }
        return features;
      }
      async cd(path6) {
        const validPath = await this.protectWhitespace(path6);
        return this.send("CWD " + validPath);
      }
      async cdup() {
        return this.send("CDUP");
      }
      async lastMod(path6) {
        const validPath = await this.protectWhitespace(path6);
        const res = await this.send(`MDTM ${validPath}`);
        const date = res.message.slice(4);
        return (0, parseListMLSD_1.parseMLSxDate)(date);
      }
      async size(path6) {
        const validPath = await this.protectWhitespace(path6);
        const command = `SIZE ${validPath}`;
        const res = await this.send(command);
        const size = parseInt(res.message.slice(4), 10);
        if (Number.isNaN(size)) {
          throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);
        }
        return size;
      }
      async rename(srcPath, destPath) {
        const validSrc = await this.protectWhitespace(srcPath);
        const validDest = await this.protectWhitespace(destPath);
        await this.send("RNFR " + validSrc);
        return this.send("RNTO " + validDest);
      }
      async remove(path6, ignoreErrorCodes = false) {
        const validPath = await this.protectWhitespace(path6);
        if (ignoreErrorCodes) {
          return this.sendIgnoringError(`DELE ${validPath}`);
        }
        return this.send(`DELE ${validPath}`);
      }
      trackProgress(handler) {
        this._progressTracker.bytesOverall = 0;
        this._progressTracker.reportTo(handler);
      }
      async uploadFrom(source, toRemotePath, options = {}) {
        return this._uploadWithCommand(source, toRemotePath, "STOR", options);
      }
      async appendFrom(source, toRemotePath, options = {}) {
        return this._uploadWithCommand(source, toRemotePath, "APPE", options);
      }
      async _uploadWithCommand(source, remotePath, command, options) {
        if (typeof source === "string") {
          return this._uploadLocalFile(source, remotePath, command, options);
        }
        return this._uploadFromStream(source, remotePath, command);
      }
      async _uploadLocalFile(localPath, remotePath, command, options) {
        const fd = await fsOpen(localPath, "r");
        const source = (0, fs_1.createReadStream)("", {
          fd,
          start: options.localStart,
          end: options.localEndInclusive,
          autoClose: false
        });
        try {
          return await this._uploadFromStream(source, remotePath, command);
        } finally {
          await ignoreError(() => fsClose(fd));
        }
      }
      async _uploadFromStream(source, remotePath, command) {
        const onError = (err) => this.ftp.closeWithError(err);
        source.once("error", onError);
        try {
          const validPath = await this.protectWhitespace(remotePath);
          await this.prepareTransfer(this.ftp);
          return await (0, transfer_1.uploadFrom)(source, {
            ftp: this.ftp,
            tracker: this._progressTracker,
            command,
            remotePath: validPath,
            type: "upload"
          });
        } finally {
          source.removeListener("error", onError);
        }
      }
      async downloadTo(destination, fromRemotePath, startAt = 0) {
        if (typeof destination === "string") {
          return this._downloadToFile(destination, fromRemotePath, startAt);
        }
        return this._downloadToStream(destination, fromRemotePath, startAt);
      }
      async _downloadToFile(localPath, remotePath, startAt) {
        const appendingToLocalFile = startAt > 0;
        const fileSystemFlags = appendingToLocalFile ? "r+" : "w";
        const fd = await fsOpen(localPath, fileSystemFlags);
        const destination = (0, fs_1.createWriteStream)("", {
          fd,
          start: startAt,
          autoClose: false
        });
        try {
          return await this._downloadToStream(destination, remotePath, startAt);
        } catch (err) {
          const localFileStats = await ignoreError(() => fsStat(localPath));
          const hasDownloadedData = localFileStats && localFileStats.size > 0;
          const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;
          if (shouldRemoveLocalFile) {
            await ignoreError(() => fsUnlink(localPath));
          }
          throw err;
        } finally {
          await ignoreError(() => fsClose(fd));
        }
      }
      async _downloadToStream(destination, remotePath, startAt) {
        const onError = (err) => this.ftp.closeWithError(err);
        destination.once("error", onError);
        try {
          const validPath = await this.protectWhitespace(remotePath);
          await this.prepareTransfer(this.ftp);
          return await (0, transfer_1.downloadTo)(destination, {
            ftp: this.ftp,
            tracker: this._progressTracker,
            command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,
            remotePath: validPath,
            type: "download"
          });
        } finally {
          destination.removeListener("error", onError);
          destination.end();
        }
      }
      async list(path6 = "") {
        const validPath = await this.protectWhitespace(path6);
        let lastError;
        for (const candidate of this.availableListCommands) {
          const command = validPath === "" ? candidate : `${candidate} ${validPath}`;
          await this.prepareTransfer(this.ftp);
          try {
            const parsedList = await this._requestListWithCommand(command);
            this.availableListCommands = [candidate];
            return parsedList;
          } catch (err) {
            const shouldTryNext = err instanceof FtpContext_1.FTPError;
            if (!shouldTryNext) {
              throw err;
            }
            lastError = err;
          }
        }
        throw lastError;
      }
      async _requestListWithCommand(command) {
        const buffer = new StringWriter_1.StringWriter();
        await (0, transfer_1.downloadTo)(buffer, {
          ftp: this.ftp,
          tracker: this._progressTracker,
          command,
          remotePath: "",
          type: "list"
        });
        const text3 = buffer.getText(this.ftp.encoding);
        this.ftp.log(text3);
        return this.parseList(text3);
      }
      async removeDir(remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          await this.cd(remoteDirPath);
          const absoluteDirPath = await this.pwd();
          await this.clearWorkingDir();
          const dirIsRoot = absoluteDirPath === "/";
          if (!dirIsRoot) {
            await this.cdup();
            await this.removeEmptyDir(absoluteDirPath);
          }
        });
      }
      async clearWorkingDir() {
        for (const file of await this.list()) {
          if (file.isDirectory) {
            await this.cd(file.name);
            await this.clearWorkingDir();
            await this.cdup();
            await this.removeEmptyDir(file.name);
          } else {
            await this.remove(file.name);
          }
        }
      }
      async uploadFromDir(localDirPath, remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          if (remoteDirPath) {
            await this.ensureDir(remoteDirPath);
          }
          return await this._uploadToWorkingDir(localDirPath);
        });
      }
      async _uploadToWorkingDir(localDirPath) {
        const files = await fsReadDir(localDirPath);
        for (const file of files) {
          const fullPath = (0, path_1.join)(localDirPath, file);
          const stats = await fsStat(fullPath);
          if (stats.isFile()) {
            await this.uploadFrom(fullPath, file);
          } else if (stats.isDirectory()) {
            await this._openDir(file);
            await this._uploadToWorkingDir(fullPath);
            await this.cdup();
          }
        }
      }
      async downloadToDir(localDirPath, remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          if (remoteDirPath) {
            await this.cd(remoteDirPath);
          }
          return await this._downloadFromWorkingDir(localDirPath);
        });
      }
      async _downloadFromWorkingDir(localDirPath) {
        await ensureLocalDirectory(localDirPath);
        for (const file of await this.list()) {
          const localPath = (0, path_1.join)(localDirPath, file.name);
          if (file.isDirectory) {
            await this.cd(file.name);
            await this._downloadFromWorkingDir(localPath);
            await this.cdup();
          } else if (file.isFile) {
            await this.downloadTo(localPath, file.name);
          }
        }
      }
      async ensureDir(remoteDirPath) {
        if (remoteDirPath.startsWith("/")) {
          await this.cd("/");
        }
        const names = remoteDirPath.split("/").filter((name) => name !== "");
        for (const name of names) {
          await this._openDir(name);
        }
      }
      async _openDir(dirName) {
        await this.sendIgnoringError("MKD " + dirName);
        await this.cd(dirName);
      }
      async removeEmptyDir(path6) {
        const validPath = await this.protectWhitespace(path6);
        return this.send(`RMD ${validPath}`);
      }
      async protectWhitespace(path6) {
        if (!path6.startsWith(" ")) {
          return path6;
        }
        const pwd = await this.pwd();
        const absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
        return absolutePathPrefix + path6;
      }
      async _exitAtCurrentDirectory(func) {
        const userDir = await this.pwd();
        try {
          return await func();
        } finally {
          if (!this.closed) {
            await ignoreError(() => this.cd(userDir));
          }
        }
      }
      _enterFirstCompatibleMode(strategies) {
        return async (ftp2) => {
          ftp2.log("Trying to find optimal transfer strategy...");
          let lastError = void 0;
          for (const strategy of strategies) {
            try {
              const res = await strategy(ftp2);
              ftp2.log("Optimal transfer strategy found.");
              this.prepareTransfer = strategy;
              return res;
            } catch (err) {
              lastError = err;
            }
          }
          throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);
        };
      }
      async upload(source, toRemotePath, options = {}) {
        this.ftp.log("Warning: upload() has been deprecated, use uploadFrom().");
        return this.uploadFrom(source, toRemotePath, options);
      }
      async append(source, toRemotePath, options = {}) {
        this.ftp.log("Warning: append() has been deprecated, use appendFrom().");
        return this.appendFrom(source, toRemotePath, options);
      }
      async download(destination, fromRemotePath, startAt = 0) {
        this.ftp.log("Warning: download() has been deprecated, use downloadTo().");
        return this.downloadTo(destination, fromRemotePath, startAt);
      }
      async uploadDir(localDirPath, remoteDirPath) {
        this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir().");
        return this.uploadFromDir(localDirPath, remoteDirPath);
      }
      async downloadDir(localDirPath) {
        this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir().");
        return this.downloadToDir(localDirPath);
      }
    };
    exports2.Client = Client2;
    async function ensureLocalDirectory(path6) {
      try {
        await fsStat(path6);
      } catch (err) {
        await fsMkDir(path6, { recursive: true });
      }
    }
    async function ignoreError(func) {
      try {
        return await func();
      } catch (err) {
        return void 0;
      }
    }
  }
});

// node_modules/basic-ftp/dist/StringEncoding.js
var require_StringEncoding = __commonJS({
  "node_modules/basic-ftp/dist/StringEncoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/basic-ftp/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/basic-ftp/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enterPassiveModeIPv6 = exports2.enterPassiveModeIPv4 = void 0;
    __exportStar(require_Client(), exports2);
    __exportStar(require_FtpContext(), exports2);
    __exportStar(require_FileInfo(), exports2);
    __exportStar(require_parseList(), exports2);
    __exportStar(require_StringEncoding(), exports2);
    var transfer_1 = require_transfer();
    Object.defineProperty(exports2, "enterPassiveModeIPv4", { enumerable: true, get: function() {
      return transfer_1.enterPassiveModeIPv4;
    } });
    Object.defineProperty(exports2, "enterPassiveModeIPv6", { enumerable: true, get: function() {
      return transfer_1.enterPassiveModeIPv6;
    } });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  API_URL_DEV: () => API_URL_DEV,
  API_URL_PRO: () => API_URL_PRO,
  FRIDAY_ICON: () => FRIDAY_ICON,
  GetBaseUrl: () => GetBaseUrl,
  default: () => FridayPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/server.ts
var import_obsidian5 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text2(data) {
  return document.createTextNode(data);
}
function space() {
  return text2(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value2) {
  if (value2 == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2)
    node.setAttribute(attribute, value2);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = data;
}
function set_input_value(input, value2) {
  input.value = value2 == null ? "" : value2;
}
function set_style(node, key, value2, important) {
  if (value2 == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value2, important ? "important" : "");
  }
}
function select_option(select, value2, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value2) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance5, create_fragment5, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value2);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment5 ? create_fragment5($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/svelte/Server.svelte
var import_obsidian4 = require("obsidian");

// src/svelte/Info.svelte
function add_css(target) {
  append_styles(target, "svelte-1m52mn7", ".mdf-info.svelte-1m52mn7{font-size:0.9em;text-align:center}");
}
function create_fragment(ctx) {
  let div;
  let t0_value = ctx[0]("info.service_description") + "";
  let t0;
  let t1;
  let br0;
  let t2;
  let br1;
  let t3;
  let a;
  return {
    c() {
      div = element("div");
      t0 = text2(t0_value);
      t1 = space();
      br0 = element("br");
      t2 = space();
      br1 = element("br");
      t3 = space();
      a = element("a");
      a.innerHTML = `<img src="https://gohugo.net/mdfriday.svg" alt="MDFriday" width="20" height="20"/>`;
      attr(a, "href", "https://mdfriday.com");
      attr(a, "target", "_blank");
      attr(div, "class", "mdf-info svelte-1m52mn7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, br0);
      append(div, t2);
      append(div, br1);
      append(div, t3);
      append(div, a);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[0]("info.service_description") + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let t;
  var _a;
  let { plugin } = $$props;
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(0, t = ($$invalidate(2, _a = plugin === null || plugin === void 0 ? void 0 : plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key) => key));
    }
  };
  return [t, plugin, _a];
}
var Info = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 1 }, add_css);
  }
};
var Info_default = Info;

// src/svelte/Site.svelte
var import_obsidian3 = require("obsidian");

// src/svelte/ProgressBar.svelte
function add_css2(target) {
  append_styles(target, "svelte-9d941e", ".progress-container.svelte-9d941e{width:100%;background-color:#e0e0e0;border-radius:8px;height:10px;margin-top:10px;overflow:hidden;position:relative}.progress-bar.svelte-9d941e{height:10px;background-color:rgb(124 58 237);transition:width 0.4s ease;position:absolute;top:0;left:0}");
}
function create_fragment2(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "progress-bar svelte-9d941e");
      set_style(div0, "width", ctx[0] + "%");
      attr(div1, "class", "progress-container svelte-9d941e");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_style(div0, "width", ctx2[0] + "%");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { progress = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
  };
  return [progress];
}
var ProgressBar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { progress: 0 }, add_css2);
  }
};
var ProgressBar_default = ProgressBar;

// src/svelte/Site.svelte
var path2 = __toESM(require("path"));
var fs2 = __toESM(require("fs"));
var import_foundry2 = __toESM(require_dist3());
var import_jszip = __toESM(require_jszip_min());

// src/markdown/base-renderer.ts
var import_obsidian = require("obsidian");
var import_foundry = __toESM(require_dist3());

// src/markdown/obsidian-parser-result.ts
var ObsidianHeader = class {
  constructor(_text, _level, _id, _position) {
    this._text = _text;
    this._level = _level;
    this._id = _id;
    this._position = _position;
  }
  name() {
    return this._text;
  }
  level() {
    return this._level;
  }
  links() {
    return [];
  }
  paragraphs() {
    return [];
  }
  listParagraphs() {
    return [];
  }
  text() {
    return this._text;
  }
  id() {
    return this._id || this.generateId();
  }
  generateId() {
    return this._text.toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
  }
};
var ObsidianTocFragments = class {
  constructor(items) {
    this.items = items;
  }
  toHTML() {
    if (this.items.length === 0) {
      return "";
    }
    return `<nav class="table-of-contents">
${this.renderItems(this.items)}
</nav>`;
  }
  toMarkdown() {
    if (this.items.length === 0) {
      return "";
    }
    return this.renderMarkdownItems(this.items, 0);
  }
  isEmpty() {
    return this.items.length === 0;
  }
  getItems() {
    return [...this.items];
  }
  renderItems(items, level = 0) {
    if (items.length === 0)
      return "";
    const indent = "  ".repeat(level);
    let html = `${indent}<ul>
`;
    for (const item of items) {
      html += `${indent}  <li>
`;
      html += `${indent}    <a href="#${item.anchor}">${this.escapeHtml(item.text)}</a>
`;
      if (item.children.length > 0) {
        html += this.renderItems(item.children, level + 2);
      }
      html += `${indent}  </li>
`;
    }
    html += `${indent}</ul>
`;
    return html;
  }
  renderMarkdownItems(items, level) {
    let markdown = "";
    for (const item of items) {
      const indent = "  ".repeat(level);
      markdown += `${indent}- [${item.text}](#${item.anchor})
`;
      if (item.children.length > 0) {
        markdown += this.renderMarkdownItems(item.children, level + 1);
      }
    }
    return markdown;
  }
  escapeHtml(text3) {
    return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
};
var ObsidianParsingResult = class {
  constructor(plugin, file, source) {
    this.plugin = plugin;
    this.file = file;
    this.source = source;
    this._headers = [];
    this.buildFromMetadata();
  }
  headers() {
    return [...this._headers];
  }
  tableOfContents() {
    return this._toc;
  }
  buildFromMetadata() {
    const metadata = this.plugin.app.metadataCache.getFileCache(this.file);
    if (metadata?.headings) {
      this._headers = this.buildHeaders(metadata.headings);
      this._toc = this.buildTableOfContents(metadata.headings);
    } else {
      this.parseFromSource();
    }
  }
  buildHeaders(headings) {
    return headings.map((heading) => {
      return new ObsidianHeader(heading.heading, heading.level, void 0, heading.position?.start ? {
        line: heading.position.start.line,
        ch: heading.position.start.col
      } : void 0);
    });
  }
  buildTableOfContents(headings) {
    const tocItems = this.buildTocItems(headings);
    return new ObsidianTocFragments(tocItems);
  }
  buildTocItems(headings) {
    const items = [];
    const stack = [];
    for (const heading of headings) {
      const tocItem = {
        text: heading.heading,
        level: heading.level,
        anchor: this.generateAnchor(heading.heading),
        children: []
      };
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      if (stack.length === 0) {
        items.push(tocItem);
      } else {
        stack[stack.length - 1].item.children.push(tocItem);
      }
      stack.push({ item: tocItem, level: heading.level });
    }
    return items;
  }
  generateAnchor(text3) {
    return text3.toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
  }
  parseFromSource() {
    const lines = this.source.split("\n");
    const headings = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = line.match(/^(#{1,6})\s+(.+)$/);
      if (match) {
        const level = match[1].length;
        const text3 = match[2].trim();
        headings.push({
          text: text3,
          level,
          position: {
            start: { line: i, ch: 0 },
            end: { line: i, ch: line.length }
          }
        });
      }
    }
    this._headers = headings.map((heading) => new ObsidianHeader(heading.text, heading.level, void 0, heading.position?.start));
    const tocItems = this.buildTocItemsFromHeaders(headings);
    this._toc = new ObsidianTocFragments(tocItems);
  }
  buildTocItemsFromHeaders(headings) {
    const items = [];
    const stack = [];
    for (const heading of headings) {
      const tocItem = {
        text: heading.text,
        level: heading.level,
        anchor: heading.id || this.generateAnchor(heading.text),
        children: []
      };
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      if (stack.length === 0) {
        items.push(tocItem);
      } else {
        stack[stack.length - 1].item.children.push(tocItem);
      }
      stack.push({ item: tocItem, level: heading.level });
    }
    return items;
  }
  getFile() {
    return this.file;
  }
  getSource() {
    return this.source;
  }
  getMetadata() {
    return this.plugin.app.metadataCache.getFileCache(this.file);
  }
  getFlatHeaders() {
    return this._headers.map((header) => {
      const obsHeader = header;
      return {
        text: obsHeader.text(),
        level: header.level(),
        id: obsHeader.id()
      };
    });
  }
  getHeadersByLevel(level) {
    return this._headers.filter((header) => header.level() === level);
  }
  getHeadersInRange(minLevel, maxLevel) {
    return this._headers.filter((header) => {
      const headerLevel = header.level();
      return headerLevel >= minLevel && headerLevel <= maxLevel;
    });
  }
};

// src/markdown/resource-processor.ts
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var ObsidianResourceProcessor = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  configureImageOutput(obImagesDir, sitePath, selectedFolderName) {
    this.obImagesDir = obImagesDir;
    this.sitePath = sitePath;
    this.selectedFolderName = selectedFolderName;
  }
  async processRelativeResources(html, basePath, options = {}) {
    const {
      processInternalLinks = true,
      processRelativePaths = true
    } = options;
    let processedHtml = html;
    if (processInternalLinks) {
      processedHtml = await this.processObsidianLinks(processedHtml, basePath);
    }
    if (processRelativePaths) {
      processedHtml = await this.processRelativePaths(processedHtml, basePath);
    }
    processedHtml = await this.processAppUrls(processedHtml);
    processedHtml = await this.processInternalLinks(processedHtml);
    return processedHtml;
  }
  async processAppUrls(html) {
    if (!this.obImagesDir || !this.sitePath) {
      return html;
    }
    const appUrlPattern = /<img([^>]*?)src=["'](app:\/\/[^"']+)["']([^>]*?)>/g;
    const matches = Array.from(html.matchAll(appUrlPattern));
    let processedHtml = html;
    for (const match of matches) {
      try {
        const [fullMatch, before, appUrl, after] = match;
        const urlParts = appUrl.match(/^app:\/\/[^\/]+(.+?)(?:\?.*)?$/);
        if (!urlParts || !urlParts[1]) {
          continue;
        }
        const imagePath = this.normalizeAppUrlPath(urlParts[1]);
        const imageName = path.basename(imagePath);
        try {
          await fs.promises.access(imagePath);
        } catch (error) {
          console.warn(`Image file not found: ${imagePath}`, error);
          continue;
        }
        const targetPath = path.join(this.obImagesDir, imageName);
        try {
          await fs.promises.copyFile(imagePath, targetPath);
        } catch (copyError) {
          console.error(`Failed to copy image: ${imagePath}`, copyError);
          continue;
        }
        const newSrc = path.posix.join(this.sitePath, "ob-images", imageName);
        const newImgTag = `<img${before}src="${newSrc}"${after}>`;
        processedHtml = processedHtml.replace(fullMatch, newImgTag);
      } catch (error) {
        console.error(`Error processing app:// URL:`, error);
      }
    }
    return processedHtml;
  }
  async processInternalLinks(html) {
    if (!this.sitePath || !this.selectedFolderName) {
      return html;
    }
    let processedHtml = html;
    const aTagPattern = /<a[^>]*data-href=["'](app:\/\/[^"']+)["'][^>]*>.*?<\/a>/g;
    const replacements = [];
    let match;
    while ((match = aTagPattern.exec(html)) !== null) {
      try {
        const fullATag = match[0];
        const dataHref = match[1];
        const urlParts = dataHref.match(/^app:\/\/[^\/]+(.+?)(?:\?.*)?$/);
        if (!urlParts || !urlParts[1]) {
          continue;
        }
        const fullPath = this.normalizeAppUrlPath(urlParts[1]);
        const folderPattern = path.sep + this.selectedFolderName + path.sep;
        const folderIndex = fullPath.indexOf(folderPattern);
        if (folderIndex === -1) {
          continue;
        }
        const relativePath = fullPath.substring(folderIndex + this.selectedFolderName.length + 2);
        const htmlPath = relativePath.replace(/\.md$/, ".html");
        const newHref = path.posix.join(this.sitePath, htmlPath);
        const openTagMatch = fullATag.match(/^<a[^>]*>/);
        if (!openTagMatch) {
          continue;
        }
        const openTag = openTagMatch[0];
        const hrefMatch = openTag.match(/(?<!data-)href=["']([^"']+)["']/);
        if (hrefMatch) {
          const currentHref = hrefMatch[1];
          const newOpenTag = openTag.replace(/(?<!data-)href=["'][^"']*["']/, `href="${newHref}"`);
          const newFullATag = fullATag.replace(openTag, newOpenTag);
          replacements.push({
            original: fullATag,
            replacement: newFullATag
          });
        }
      } catch (error) {
        console.error("Error processing internal link:", error);
      }
    }
    for (const replacement of replacements) {
      processedHtml = processedHtml.replace(replacement.original, replacement.replacement);
    }
    return processedHtml;
  }
  async processObsidianLinks(html, basePath) {
    html = html.replace(/!\[\[([^\]]+)\]\]/g, (match, filename) => {
      const linkedFile = this.findLinkedFile(filename, basePath);
      if (linkedFile) {
        const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
        return `<img src="${resourcePath}" alt="${filename}">`;
      }
      return match;
    });
    html = html.replace(/(?<!!)\[\[([^\]]+)\]\]/g, (match, filename) => {
      const linkedFile = this.findLinkedFile(filename, basePath);
      if (linkedFile) {
        const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
        return `<a href="${resourcePath}">${filename}</a>`;
      }
      return match;
    });
    return html;
  }
  async processRelativePaths(html, basePath) {
    html = html.replace(/<img([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<img${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<a([^>]*?)href=["']([^"']+)["']([^>]*?)>/g, (match, before, href, after) => {
      if (!this.isAbsoluteOrDataUrl(href)) {
        const linkedFile = this.findLinkedFile(href, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<a${before}href="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    return html;
  }
  findLinkedFile(filename, basePath) {
    if (basePath) {
      const linkedFile = this.plugin.app.metadataCache.getFirstLinkpathDest(filename, basePath);
      if (linkedFile) {
        return linkedFile;
      }
    }
    const files = this.plugin.app.vault.getFiles();
    let foundFile = files.find((file) => file.name === filename);
    if (foundFile) {
      return foundFile;
    }
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, "");
    foundFile = files.find((file) => {
      const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
      return fileNameWithoutExt === nameWithoutExt;
    });
    if (foundFile) {
      return foundFile;
    }
    foundFile = files.find((file) => file.path.includes(filename));
    if (foundFile) {
      return foundFile;
    }
    return null;
  }
  normalizeAppUrlPath(rawPath) {
    let normalizedPath = decodeURIComponent(rawPath);
    if (process.platform === "win32") {
      if (/^\/[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.substring(1);
      } else if (/^\\[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.substring(1);
      } else if (/^[\/\\]+[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.replace(/^[\/\\]+/, "");
      }
    }
    normalizedPath = path.normalize(normalizedPath);
    return normalizedPath;
  }
  isAbsoluteOrDataUrl(url) {
    return url.startsWith("http") || url.startsWith("https") || url.startsWith("data:") || url.startsWith("app://") || url.startsWith("file://") || url.startsWith("//");
  }
  async processAllResources(html, baseFile) {
    const basePath = baseFile?.path;
    let processedHtml = await this.processRelativeResources(html, basePath, {
      processInternalLinks: true,
      processRelativePaths: true
    });
    processedHtml = await this.processMediaElements(processedHtml, basePath);
    return processedHtml;
  }
  async processMediaElements(html, basePath) {
    html = html.replace(/<audio([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<audio${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<video([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<video${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<source([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<source${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    return html;
  }
  getResourcePath(file) {
    return this.plugin.app.vault.adapter.getResourcePath(file.path);
  }
  isMediaFile(file) {
    const mediaExtensions = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "svg",
      "webp",
      "bmp",
      "ico",
      "mp3",
      "wav",
      "ogg",
      "flac",
      "m4a",
      "aac",
      "mp4",
      "webm",
      "ogv",
      "mov",
      "avi",
      "mkv"
    ];
    const extension = file.extension.toLowerCase();
    return mediaExtensions.includes(extension);
  }
  getAllMediaFiles() {
    return this.plugin.app.vault.getFiles().filter((file) => this.isMediaFile(file));
  }
};

// src/markdown/dom-utils.ts
function analyzeRenderingComplexity(source) {
  const detectedPatterns = [];
  let complexity = "simple" /* SIMPLE */;
  let suggestedTimeout = 50;
  const simplePatterns = [
    { pattern: /^[^$\[\]`%<]*$/, name: "\u7EAF\u6587\u672C", timeout: 0 }
  ];
  const basicPatterns = [
    { pattern: /\*\*.*?\*\*/, name: "\u7C97\u4F53", timeout: 50 },
    { pattern: /\*.*?\*/, name: "\u659C\u4F53", timeout: 50 },
    { pattern: /`.*?`/, name: "\u884C\u5185\u4EE3\u7801", timeout: 50 },
    { pattern: /^#+\s/, name: "\u6807\u9898", timeout: 50 },
    { pattern: /^\s*[-*+]\s/, name: "\u5217\u8868", timeout: 100 }
  ];
  const complexPatterns = [
    { pattern: /```[\s\S]*?```/, name: "\u4EE3\u7801\u5757", timeout: 200 },
    { pattern: /!\[.*?\]\(.*?\)/, name: "\u56FE\u7247\u94FE\u63A5", timeout: 300 },
    { pattern: /\[.*?\]\(.*?\)/, name: "\u94FE\u63A5", timeout: 150 },
    { pattern: /\|.*\|/, name: "\u8868\u683C", timeout: 200 },
    { pattern: /\[\[.*?\]\]/, name: "\u5185\u90E8\u94FE\u63A5", timeout: 300 }
  ];
  const heavyPatterns = [
    { pattern: /\$\$[\s\S]*?\$\$/, name: "\u6570\u5B66\u516C\u5F0F\u5757", timeout: 800 },
    { pattern: /\$[^$\n]+\$/, name: "\u884C\u5185\u6570\u5B66\u516C\u5F0F", timeout: 400 },
    { pattern: /```mermaid[\s\S]*?```/, name: "Mermaid\u56FE\u8868", timeout: 1e3 },
    { pattern: /```dataview[\s\S]*?```/, name: "Dataview\u67E5\u8BE2", timeout: 1200 },
    { pattern: /```chart[\s\S]*?```/, name: "\u56FE\u8868\u63D2\u4EF6", timeout: 800 },
    { pattern: /%%.+%%/, name: "\u63D2\u4EF6\u6CE8\u91CA", timeout: 300 },
    { pattern: /<canvas/, name: "Canvas\u5143\u7D20", timeout: 600 },
    { pattern: /class=".*plugin.*"/, name: "\u63D2\u4EF6\u7C7B\u540D", timeout: 500 },
    { pattern: /data-.*plugin/, name: "\u63D2\u4EF6\u6570\u636E\u5C5E\u6027", timeout: 500 }
  ];
  for (const { pattern, name, timeout } of heavyPatterns) {
    if (pattern.test(source)) {
      detectedPatterns.push(name);
      complexity = "heavy" /* HEAVY */;
      suggestedTimeout = Math.max(suggestedTimeout, timeout);
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of complexPatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        complexity = "complex" /* COMPLEX */;
        suggestedTimeout = Math.max(suggestedTimeout, timeout);
      }
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of basicPatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        complexity = "basic" /* BASIC */;
        suggestedTimeout = Math.max(suggestedTimeout, timeout);
      }
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of simplePatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        suggestedTimeout = timeout;
        break;
      }
    }
  }
  return { complexity, suggestedTimeout, patterns: detectedPatterns };
}
function hasAsyncElements(container) {
  const asyncSelectors = [
    ".math",
    ".mermaid",
    ".dataview",
    ".chart",
    "canvas",
    "[data-plugin]",
    ".cm-editor",
    ".obsidian-search-match-highlight",
    ".internal-link"
  ];
  return asyncSelectors.some((selector) => container.querySelector(selector) !== null);
}
function waitForDomStable(container, timeout = 300, source) {
  return new Promise((resolve) => {
    let timer = null;
    let changeCount = 0;
    const startTime = Date.now();
    if (source) {
      const analysis = analyzeRenderingComplexity(source);
      if (analysis.complexity === "simple" /* SIMPLE */) {
        resolve();
        return;
      }
      if (analysis.complexity === "basic" /* BASIC */) {
        timeout = Math.min(timeout, 100);
      } else {
        timeout = Math.min(analysis.suggestedTimeout, timeout);
      }
    }
    if (!hasAsyncElements(container)) {
      resolve();
      return;
    }
    let maxWaitTime = 2e3;
    if (source) {
      const analysis = analyzeRenderingComplexity(source);
      switch (analysis.complexity) {
        case "basic" /* BASIC */:
          maxWaitTime = 500;
          break;
        case "complex" /* COMPLEX */:
          maxWaitTime = 1500;
          break;
        case "heavy" /* HEAVY */:
          maxWaitTime = 3e3;
          break;
      }
    }
    const observer = new MutationObserver((mutations) => {
      changeCount++;
      const hasSignificantChange = mutations.some((mutation) => mutation.type === "childList" || mutation.type === "characterData" && mutation.target.textContent?.trim() || mutation.type === "attributes" && ["class", "style", "data-plugin", "data-rendered"].includes(mutation.attributeName || ""));
      if (!hasSignificantChange) {
        return;
      }
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(() => {
        observer.disconnect();
        resolve();
      }, timeout);
    });
    observer.observe(container, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true,
      attributeFilter: ["class", "style", "data-plugin", "data-rendered"]
    });
    const maxTimer = setTimeout(() => {
      observer.disconnect();
      if (timer)
        clearTimeout(timer);
      resolve();
    }, maxWaitTime);
    timer = setTimeout(() => {
      observer.disconnect();
      clearTimeout(maxTimer);
      resolve();
    }, timeout);
  });
}
function createRenderContainer(theme, width = "1000px") {
  const container = document.createElement("div");
  container.addClass("markdown-preview-view", "markdown-rendered");
  const bodyClasses = document.body.className;
  if (bodyClasses.includes("theme-light") || bodyClasses.includes("theme-dark")) {
    container.className += " " + bodyClasses;
  }
  if (theme) {
    container.addClass(theme);
  }
  container.style.position = "absolute";
  container.style.top = "-9999px";
  container.style.left = "-9999px";
  container.style.width = width;
  container.style.visibility = "hidden";
  document.body.appendChild(container);
  return container;
}
function cleanupContainer(container) {
  try {
    if (container && container.parentNode) {
      container.parentNode.removeChild(container);
    }
  } catch (error) {
    console.warn("\u6E05\u7406\u5BB9\u5668\u65F6\u51FA\u9519:", error);
  }
}
function getCurrentTheme() {
  return document.body.classList.contains("theme-dark") ? "theme-dark" : "theme-light";
}
function waitForResourcesLoaded(container, timeout = 3e3) {
  return new Promise((resolve) => {
    const images = container.querySelectorAll("img");
    const videos = container.querySelectorAll("video");
    const iframes = container.querySelectorAll("iframe");
    const allElements = [...Array.from(images), ...Array.from(videos), ...Array.from(iframes)];
    if (allElements.length === 0) {
      resolve();
      return;
    }
    let loadedCount = 0;
    const totalCount = allElements.length;
    const checkComplete = () => {
      loadedCount++;
      if (loadedCount >= totalCount) {
        resolve();
      }
    };
    const timeoutId = setTimeout(() => {
      resolve();
    }, timeout);
    allElements.forEach((element2) => {
      if (element2 instanceof HTMLImageElement) {
        if (element2.complete) {
          checkComplete();
        } else {
          element2.addEventListener("load", () => {
            checkComplete();
          });
          element2.addEventListener("error", () => {
            checkComplete();
          });
        }
      } else if (element2 instanceof HTMLVideoElement) {
        if (element2.readyState >= 2) {
          checkComplete();
        } else {
          element2.addEventListener("loadeddata", () => {
            checkComplete();
          });
          element2.addEventListener("error", () => {
            checkComplete();
          });
        }
      } else if (element2 instanceof HTMLIFrameElement) {
        element2.addEventListener("load", () => {
          checkComplete();
        });
        element2.addEventListener("error", () => {
          checkComplete();
        });
      }
    });
    if (loadedCount >= totalCount) {
      clearTimeout(timeoutId);
    }
  });
}

// src/markdown/base-renderer.ts
var BaseRenderer = class {
  constructor(plugin, options = {}) {
    this.plugin = plugin;
    this.options = {
      autoHeadingID: true,
      containerWidth: "800px",
      waitForStable: false,
      timeout: 100,
      baseFile: void 0,
      ...options
    };
    this.resourceProcessor = new ObsidianResourceProcessor(plugin);
  }
  async parse(source) {
    try {
      const virtualFile = this.createVirtualFile(source);
      return new ObsidianParsingResult(this.plugin, virtualFile, source);
    } catch (error) {
      console.error("BaseRenderer\u89E3\u6790\u5931\u8D25:", error);
      throw new Error(`\u89E3\u6790\u5931\u8D25: ${error.message}`);
    }
  }
  async renderWithObsidian(source, includeTheme, customContainerWidth, waitForResources) {
    const virtualFile = this.createVirtualFile(source);
    const theme = includeTheme ? getCurrentTheme() : void 0;
    const containerWidth = customContainerWidth || this.options.containerWidth;
    const container = createRenderContainer(theme, containerWidth);
    try {
      await import_obsidian.MarkdownRenderer.render(this.plugin.app, source, container, virtualFile.path, this.plugin);
      if (this.options.waitForStable) {
        await waitForDomStable(container, this.options.timeout, source);
      }
      if (waitForResources) {
        await waitForResourcesLoaded(container, 3e3);
      }
      return container.innerHTML;
    } finally {
      cleanupContainer(container);
    }
  }
  ensureHeadingIDs(html) {
    if (!this.options.autoHeadingID) {
      return html;
    }
    const idGenerator = new import_foundry.AutoIDGenerator();
    return html.replace(/<h([1-6])(?![^>]*\sid=)([^>]*)>([^<]+)<\/h[1-6]>/g, (match, level, attrs, text3) => {
      const id = idGenerator.generateID(text3.trim());
      return `<h${level}${attrs} id="${id}">${text3}</h${level}>`;
    });
  }
  async processResources(html, baseFile) {
    return await this.resourceProcessor.processAllResources(html, this.options.baseFile || baseFile);
  }
  createVirtualFile(source, customName) {
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const fileName = customName || `virtual_${timestamp}_${randomId}.md`;
    const baseName = fileName.replace(/\.md$/, "");
    return {
      path: fileName,
      name: fileName,
      basename: baseName,
      extension: "md",
      parent: null,
      vault: this.plugin.app.vault,
      stat: {
        ctime: timestamp,
        mtime: timestamp,
        size: source.length
      }
    };
  }
  getOptions() {
    return { ...this.options };
  }
  setBaseFile(file) {
    this.options.baseFile = file;
  }
  getResourceProcessor() {
    return this.resourceProcessor;
  }
  updateOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
};

// src/markdown/style-renderer.ts
var StyleRenderer = class extends BaseRenderer {
  constructor(plugin, options = {}) {
    const defaultOptions = {
      autoHeadingID: true,
      containerWidth: "800px",
      waitForStable: false,
      timeout: 100,
      ...options
    };
    super(plugin, defaultOptions);
  }
  async render(source) {
    try {
      let html = await this.renderWithObsidian(source, false);
      html = this.ensureHeadingIDs(html);
      html = await this.processResources(html);
      return html;
    } catch (error) {
      console.error("StyleRenderer\u6E32\u67D3\u5931\u8D25:", error);
      throw new Error(`\u6E32\u67D3\u5931\u8D25: ${error.message}`);
    }
  }
  getOptions() {
    return super.getOptions();
  }
};

// src/markdown/css-collector.ts
var ObsidianCSSCollector = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.options = {};
  }
  async getObsidianAppCSS() {
    if (!this.options.includeAppCSS) {
      return "";
    }
    try {
      const appCssUrl = "app://obsidian.md/app.css";
      try {
        const response = await fetch(appCssUrl);
        if (response.ok) {
          return await response.text();
        }
      } catch (e) {
        console.error("fetch app.css \u5931\u8D25\uFF0C\u5C1D\u8BD5\u5176\u4ED6\u65B9\u6CD5:", e.message);
      }
      return "";
    } catch (error) {
      console.error("\u83B7\u53D6 app.css \u65F6\u51FA\u9519:", error);
      return "";
    }
  }
  async getAllLoadedCSS() {
    let additionalCSS = "";
    let skippedSheets = [];
    const appCSS = await this.getObsidianAppCSS();
    for (const sheet of Array.from(document.styleSheets)) {
      try {
        const rules = sheet.cssRules || sheet.rules;
        if (!rules)
          continue;
        if (sheet.href && sheet.href.includes("app.css")) {
          continue;
        }
        for (const rule of Array.from(rules)) {
          additionalCSS += rule.cssText + "\n";
        }
      } catch (e) {
        if (sheet.href) {
          skippedSheets.push(sheet.href);
          console.warn("\u65E0\u6CD5\u8BFB\u53D6\u6837\u5F0F\u8868:", sheet.href, e);
        }
      }
    }
    const baseStyles = "";
    return {
      appCSS,
      additionalCSS,
      baseStyles,
      skippedSheets
    };
  }
  getObsidianBaseStyles() {
    return "";
  }
  async collectAllCSS(options = {}) {
    const {
      includeAppCSS = true,
      includeBaseStyles = true
    } = options;
    this.options = options;
    const result = await this.getAllLoadedCSS();
    let fullCSS = "";
    if (includeBaseStyles) {
      fullCSS += "/* Obsidian Base Styles (fallback styles with defaults) */\n";
      fullCSS += this.getObsidianBaseStyles() + "\n\n";
    }
    if (includeAppCSS && result.appCSS) {
      fullCSS += "/* Obsidian Core Styles (app.css) */\n";
      fullCSS += result.appCSS + "\n\n";
    }
    if (result.additionalCSS) {
      fullCSS += "/* Obsidian Plugin and Theme Styles */\n";
      fullCSS += result.additionalCSS + "\n\n";
    }
    return fullCSS;
  }
};

// src/markdown/obsidian-renderer.ts
var _OBStyleRenderer = class extends BaseRenderer {
  constructor(plugin, options = {}) {
    const defaultOptions = {
      autoHeadingID: true,
      includeCSS: true,
      waitForPlugins: true,
      waitForStable: true,
      timeout: 500,
      containerWidth: "1000px",
      includeTheme: true,
      ...options
    };
    super(plugin, defaultOptions);
    this.context = {
      plugin,
      options: defaultOptions
    };
    this.cssCollector = new ObsidianCSSCollector(plugin);
  }
  async render(source) {
    try {
      const tempFile = this.createVirtualFile(source);
      let html = await this.renderWithObsidian(source, this.context.options.includeTheme, this.context.options.containerWidth, this.context.options.waitForPlugins);
      html = this.ensureHeadingIDs(html);
      html = await this.processResources(html, tempFile);
      if (this.context.options.includeCSS) {
        html = await this.wrapWithCSS(html, tempFile.basename || "Document");
      }
      return html;
    } catch (error) {
      console.error("\u6E32\u67D3 Markdown \u65F6\u51FA\u9519:", error);
      throw new Error(`\u6E32\u67D3\u5931\u8D25: ${error.message}`);
    }
  }
  async wrapWithCSS(html, title) {
    const css = await this.cssCollector.collectAllCSS({
      includeAppCSS: false,
      includeBaseStyles: true
    });
    const currentTheme = getCurrentTheme();
    return `<style>
${css}

</style>

<div class="obsidian-content-wrapper ${currentTheme}">
  <div class="markdown-preview-view markdown-rendered">
    ${html}
  </div>
</div>`;
  }
  escapeHtml(text3) {
    return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  setBaseFile(file) {
    super.setBaseFile(file);
    this.context.options.baseFile = file;
    this.context.file = file;
  }
  getOptions() {
    return { ...this.context.options };
  }
  updateOptions(options) {
    super.updateOptions(options);
    this.context.options = {
      ...this.context.options,
      ...options
    };
  }
  getCSSCollector() {
    return this.cssCollector;
  }
  getResourceProcessor() {
    return super.getResourceProcessor();
  }
  async renderHTML(source) {
    const originalIncludeCSS = this.context.options.includeCSS;
    try {
      this.context.options.includeCSS = false;
      return await this.render(source);
    } finally {
      this.context.options.includeCSS = originalIncludeCSS;
    }
  }
};
var OBStyleRenderer = _OBStyleRenderer;
OBStyleRenderer.ObsidianRenderer = _OBStyleRenderer;

// src/markdown/index.ts
function createStyleRenderer(plugin, options = {}) {
  const defaultOptions = {
    autoHeadingID: true,
    containerWidth: "800px",
    waitForStable: false,
    timeout: 100,
    ...options
  };
  return new StyleRenderer(plugin, defaultOptions);
}

// src/theme/themeApiService.ts
var import_obsidian2 = require("obsidian");
var THEMES_JSON_URL = "https://gohugo.net/themes.json";
var themesCache = null;
var allTagsCache = null;
var cacheTimestamp = null;
var CACHE_EXPIRY_MS = 2 * 60 * 60 * 1e3;
function mapRawThemeToThemeItem(rawTheme) {
  return {
    id: String(rawTheme.id),
    name: rawTheme.name,
    author: rawTheme.author,
    version: rawTheme.version,
    screenshot: rawTheme.screenshot,
    download_url: rawTheme.download_url,
    demo_url: rawTheme.demo_url,
    demo_notes_url: rawTheme.demo_notes_url,
    tags: Array.isArray(rawTheme.tags) ? rawTheme.tags : [],
    title: rawTheme.name || `Theme ${rawTheme.id}`,
    description: `${rawTheme.name} theme by ${rawTheme.author || "Unknown"}`,
    thumbnail: rawTheme.screenshot,
    demo: rawTheme.demo_url,
    asset: rawTheme.screenshot
  };
}
async function fetchAllThemes() {
  try {
    const timestamp = Date.now();
    const urlWithTimestamp = `${THEMES_JSON_URL}?_t=${timestamp}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url: urlWithTimestamp,
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.status !== 200) {
      throw new Error(`Failed to fetch themes: ${response.status}`);
    }
    const rawThemes = response.json;
    if (!Array.isArray(rawThemes)) {
      throw new Error("Invalid themes data format");
    }
    return rawThemes.map(mapRawThemeToThemeItem).filter((theme) => theme.name !== "Base");
  } catch (error) {
    console.error("Error fetching themes:", error);
    throw error;
  }
}
function extractAllTags(themes) {
  const allTags = themes.flatMap((theme) => theme.tags);
  const uniqueTags = [...new Set(allTags)];
  return uniqueTags.sort((a, b) => a.localeCompare(b));
}
function filterThemes(themes, searchTerm = "", selectedTags = []) {
  let filteredThemes = themes;
  if (searchTerm.trim()) {
    const term = searchTerm.trim().toLowerCase();
    filteredThemes = filteredThemes.filter((theme) => theme.name.toLowerCase().includes(term) || theme.author.toLowerCase().includes(term) || theme.tags.some((tag) => tag.toLowerCase().includes(term)));
  }
  if (selectedTags.length > 0) {
    filteredThemes = filteredThemes.filter((theme) => selectedTags.every((selectedTag) => theme.tags.some((tag) => tag === selectedTag)));
  }
  return filteredThemes;
}
var themeApiService = {
  async initializeThemes() {
    const now = Date.now();
    const isCacheExpired = cacheTimestamp === null || now - cacheTimestamp > CACHE_EXPIRY_MS;
    if (themesCache === null || isCacheExpired) {
      themesCache = await fetchAllThemes();
      allTagsCache = extractAllTags(themesCache);
      cacheTimestamp = now;
    }
  },
  async getAllThemes() {
    await this.initializeThemes();
    return themesCache || [];
  },
  async fetchThemes(page = 1, limit = 20, selectedTags = [], searchTerm = "") {
    return this.searchThemes(page, limit, searchTerm, selectedTags);
  },
  async searchThemes(page = 1, limit = 20, searchTerm = "", selectedTags = []) {
    try {
      await this.initializeThemes();
      const allThemes = themesCache || [];
      const filteredThemes = filterThemes(allThemes, searchTerm, selectedTags);
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginatedThemes = filteredThemes.slice(startIndex, endIndex);
      const hasMore = endIndex < filteredThemes.length;
      return { themes: paginatedThemes, hasMore };
    } catch (error) {
      console.error("Error searching themes:", error);
      return { themes: [], hasMore: false };
    }
  },
  async fetchAllTags() {
    try {
      await this.initializeThemes();
      return allTagsCache || [];
    } catch (error) {
      console.error("Error fetching theme tags:", error);
      return [];
    }
  },
  createThemeMetadata(theme) {
    return {
      id: parseInt(theme.id, 10),
      name: theme.title,
      template: "",
      uuid: theme.id,
      tags: theme.tags
    };
  },
  async getThemeById(themeId) {
    try {
      await this.initializeThemes();
      const themes = themesCache || [];
      return themes.find((theme) => theme.id === themeId) || null;
    } catch (error) {
      console.error("Error getting theme by ID:", error);
      return null;
    }
  },
  async fetchThemeByName(name) {
    try {
      await this.initializeThemes();
      const allThemes = themesCache || [];
      const theme = allThemes.find((t) => t.name.toLowerCase() === name.toLowerCase());
      return theme || null;
    } catch (error) {
      console.error(`Error fetching theme by name '${name}':`, error);
      return null;
    }
  },
  clearCache() {
    themesCache = null;
    allTagsCache = null;
    cacheTimestamp = null;
  }
};

// src/svelte/Site.svelte
function add_css3(target) {
  append_styles(target, "svelte-hnzno1", `.site-builder.svelte-hnzno1.svelte-hnzno1{padding:20px;max-width:100%}.section.svelte-hnzno1.svelte-hnzno1{margin-bottom:20px}.section-label.svelte-hnzno1.svelte-hnzno1{display:block;margin-bottom:8px;font-weight:500;color:var(--text-normal);font-size:14px}.form-input.svelte-hnzno1.svelte-hnzno1{width:100%;padding:10px 12px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:14px;line-height:1.4;box-sizing:border-box;min-height:38px}.form-select.svelte-hnzno1.svelte-hnzno1{width:100%;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:14px;line-height:1.4;box-sizing:border-box;min-height:38px;appearance:none;background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right 12px center;background-size:16px;padding-right:40px}.theme-selector.svelte-hnzno1.svelte-hnzno1{width:100%}.current-theme.svelte-hnzno1.svelte-hnzno1{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);min-height:38px;box-sizing:border-box}.theme-name.svelte-hnzno1.svelte-hnzno1{color:var(--text-normal);font-size:14px}.change-theme-btn.svelte-hnzno1.svelte-hnzno1{padding:6px 12px;border:1px solid var(--interactive-accent);border-radius:3px;background:transparent;color:var(--interactive-accent);font-size:12px;cursor:pointer;transition:all 0.2s;white-space:nowrap}.change-theme-btn.svelte-hnzno1.svelte-hnzno1:hover{background:var(--interactive-accent);color:var(--text-on-accent)}.section-title.svelte-hnzno1.svelte-hnzno1{margin:0 0 10px 0;font-size:16px;font-weight:600;color:var(--text-normal)}.preview-section.svelte-hnzno1.svelte-hnzno1,.publish-section.svelte-hnzno1.svelte-hnzno1{padding:15px;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-secondary)}.action-button.svelte-hnzno1.svelte-hnzno1{padding:10px 20px;border:none;border-radius:4px;background:var(--interactive-accent);color:var(--text-on-accent);font-size:14px;font-weight:500;cursor:pointer;transition:background-color 0.2s;min-height:38px}.action-button.svelte-hnzno1.svelte-hnzno1:hover:not(:disabled){background:var(--interactive-accent-hover)}.action-button.svelte-hnzno1.svelte-hnzno1:disabled{background:var(--background-modifier-border);color:var(--text-muted);cursor:not-allowed}.preview-button.svelte-hnzno1.svelte-hnzno1{margin-bottom:10px}.publish-button.svelte-hnzno1.svelte-hnzno1{margin-left:10px}.preview-link.svelte-hnzno1.svelte-hnzno1,.publish-success.svelte-hnzno1.svelte-hnzno1{margin-top:15px;padding:10px;background:var(--background-primary);border-radius:4px;border:1px solid var(--background-modifier-border)}.preview-url.svelte-hnzno1.svelte-hnzno1,.publish-url.svelte-hnzno1.svelte-hnzno1{display:block;color:var(--interactive-accent);text-decoration:none;word-break:break-all;margin-top:5px}.preview-url.svelte-hnzno1.svelte-hnzno1:hover,.publish-url.svelte-hnzno1.svelte-hnzno1:hover{text-decoration:underline}.progress-container.svelte-hnzno1.svelte-hnzno1{margin:10px 0}.progress-container.svelte-hnzno1 p.svelte-hnzno1{margin:0 0 10px 0;color:var(--text-muted);font-size:14px}.publish-options.svelte-hnzno1.svelte-hnzno1{display:flex;align-items:flex-start;gap:10px;flex-wrap:wrap}.publish-select-wrapper.svelte-hnzno1.svelte-hnzno1{flex:1;min-width:150px}.success-message.svelte-hnzno1.svelte-hnzno1{margin:0 0 5px 0;color:var(--text-success);font-weight:500}.ftp-success-info.svelte-hnzno1.svelte-hnzno1{margin:5px 0 0 0;color:var(--text-muted);font-size:14px}.preview-actions.svelte-hnzno1.svelte-hnzno1{margin-top:10px;display:flex;gap:10px}.export-button.svelte-hnzno1.svelte-hnzno1{background:var(--interactive-normal);color:var(--text-normal);border:1px solid var(--background-modifier-border)}.export-button.svelte-hnzno1.svelte-hnzno1:hover:not(:disabled){background:var(--interactive-hover)}.export-button.svelte-hnzno1.svelte-hnzno1:disabled{opacity:0.6}.advanced-settings.svelte-hnzno1.svelte-hnzno1{border:1px solid var(--background-modifier-border);border-radius:4px;overflow:hidden}.advanced-toggle.svelte-hnzno1.svelte-hnzno1{width:100%;padding:12px 16px;border:none;background:transparent;color:var(--text-normal);font-size:14px;font-weight:500;cursor:pointer;display:flex;align-items:center;gap:8px;transition:background-color 0.2s;box-shadow:none}.advanced-toggle.svelte-hnzno1.svelte-hnzno1:hover{background:var(--background-modifier-hover)}.toggle-icon.svelte-hnzno1.svelte-hnzno1{transition:transform 0.2s;font-size:12px;color:var(--text-muted)}.toggle-icon.expanded.svelte-hnzno1.svelte-hnzno1{transform:rotate(90deg)}.advanced-content.svelte-hnzno1.svelte-hnzno1{background:var(--background-secondary);padding:16px;border-top:1px solid var(--background-modifier-border)}.advanced-field.svelte-hnzno1.svelte-hnzno1{margin-bottom:16px}.advanced-field.svelte-hnzno1.svelte-hnzno1:last-child{margin-bottom:0}.field-hint.svelte-hnzno1.svelte-hnzno1{font-size:12px;color:var(--text-muted);margin-top:4px;line-height:1.4}.multilang-table.svelte-hnzno1.svelte-hnzno1{border:1px solid var(--background-modifier-border);border-radius:4px;overflow:hidden;background:var(--background-primary)}.multilang-header.svelte-hnzno1.svelte-hnzno1{display:grid;grid-template-columns:1fr 2fr;background:var(--background-secondary);border-bottom:1px solid var(--background-modifier-border)}.multilang-header-cell.svelte-hnzno1.svelte-hnzno1{padding:10px 12px;font-weight:500;font-size:14px;color:var(--text-normal);border-right:1px solid var(--background-modifier-border);display:flex;align-items:center;justify-content:space-between;overflow:hidden;min-width:0}.add-language-btn.svelte-hnzno1.svelte-hnzno1{padding:4px 8px;border:1px solid var(--interactive-accent);border-radius:3px;background:transparent;color:var(--interactive-accent);font-size:11px;cursor:pointer;transition:all 0.2s;white-space:nowrap;margin-left:8px}.add-language-btn.svelte-hnzno1.svelte-hnzno1:hover{background:var(--interactive-accent);color:var(--text-on-accent)}.multilang-header-cell.svelte-hnzno1.svelte-hnzno1:last-child{border-right:none}.multilang-row.svelte-hnzno1.svelte-hnzno1{display:grid;grid-template-columns:1fr 2fr;border-bottom:1px solid var(--background-modifier-border);transition:background-color 0.2s}.multilang-row.svelte-hnzno1.svelte-hnzno1:last-child{border-bottom:none}.multilang-row.svelte-hnzno1.svelte-hnzno1:hover{background:var(--background-modifier-hover)}.multilang-cell.svelte-hnzno1.svelte-hnzno1{padding:10px 12px;display:flex;align-items:center;border-right:1px solid var(--background-modifier-border);min-height:38px;box-sizing:border-box;overflow:hidden;min-width:0}.multilang-cell.svelte-hnzno1.svelte-hnzno1:last-child{border-right:none}.content-path-cell.svelte-hnzno1.svelte-hnzno1{gap:8px}.content-path.svelte-hnzno1.svelte-hnzno1{color:var(--text-normal);font-size:14px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;min-width:0}.default-badge.svelte-hnzno1.svelte-hnzno1{background:var(--interactive-accent);color:var(--text-on-accent);padding:2px 6px;border-radius:3px;font-size:11px;font-weight:500;white-space:nowrap}.language-cell.svelte-hnzno1.svelte-hnzno1{display:flex;align-items:center;gap:8px}.language-select.svelte-hnzno1.svelte-hnzno1{flex:1;max-width:180px;padding:4px 8px;border:1px solid var(--background-modifier-border);border-radius:3px;background:var(--background-primary);color:var(--text-normal);font-size:13px;appearance:none;background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right 6px center;background-size:12px;padding-right:24px}.remove-btn.svelte-hnzno1.svelte-hnzno1{width:20px;height:20px;border:none;border-radius:50%;background:transparent;color:var(--text-muted);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s;opacity:0;margin-left:4px}.multilang-row.svelte-hnzno1:hover .remove-btn.svelte-hnzno1{opacity:1}.remove-btn.svelte-hnzno1.svelte-hnzno1:hover{background:var(--background-modifier-error);color:var(--text-on-accent);transform:scale(1.1)}.remove-icon.svelte-hnzno1.svelte-hnzno1{line-height:1;font-weight:bold}.multilang-empty.svelte-hnzno1.svelte-hnzno1{padding:20px;text-align:center;color:var(--text-muted);font-style:italic}.empty-message.svelte-hnzno1.svelte-hnzno1{font-size:14px}`);
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[76] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[79] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[82] = list[i];
  return child_ctx;
}
function create_if_block_10(ctx) {
  let button;
  let t_1_value = ctx[4]("ui.clear") + "";
  let t_1;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "add-language-btn svelte-hnzno1");
      attr(button, "title", button_title_value = ctx[4]("ui.clear_all_content"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[23]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t_1_value !== (t_1_value = ctx2[4]("ui.clear") + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 16 && button_title_value !== (button_title_value = ctx2[4]("ui.clear_all_content"))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  let t_1_value = ctx[4]("ui.default") + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text2(t_1_value);
      attr(span, "class", "default-badge svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t_1_value !== (t_1_value = ctx2[4]("ui.default") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let t0_value = ctx[82].name + "";
  let t0;
  let t1;
  let t2_value = ctx[82].englishName + "";
  let t2;
  let t3;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text2(t0_value);
      t1 = text2(" (");
      t2 = text2(t2_value);
      t3 = text2(")");
      option.__value = option_value_value = ctx[82].code;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
      append(option, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_8(ctx) {
  let button;
  let span;
  let button_title_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[42](ctx[79]);
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "\xD7";
      attr(span, "class", "remove-icon svelte-hnzno1");
      attr(button, "class", "remove-btn svelte-hnzno1");
      attr(button, "title", button_title_value = ctx[4]("ui.remove_language"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 16 && button_title_value !== (button_title_value = ctx[4]("ui.remove_language"))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let div2;
  let div0;
  let span;
  let t0_value = (ctx[79].folder ? ctx[79].folder.name : ctx[79].file ? ctx[79].file.name : ctx[4]("ui.no_content_selected")) + "";
  let t0;
  let t1;
  let t2;
  let div1;
  let select;
  let select_value_value;
  let t3;
  let mounted;
  let dispose;
  let if_block0 = ctx[79].weight === 1 && create_if_block_9(ctx);
  let each_value_2 = ctx[20];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function change_handler(...args) {
    return ctx[41](ctx[79], ...args);
  }
  let if_block1 = ctx[3].length > 1 && create_if_block_8(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div1 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "class", "content-path svelte-hnzno1");
      attr(div0, "class", "multilang-cell content-path-cell svelte-hnzno1");
      attr(select, "class", "language-select svelte-hnzno1");
      attr(div1, "class", "multilang-cell language-cell svelte-hnzno1");
      attr(div2, "class", "multilang-row svelte-hnzno1");
      toggle_class(div2, "removable", ctx[3].length > 1);
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(span, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[79].languageCode);
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = listen(select, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 24 && t0_value !== (t0_value = (ctx[79].folder ? ctx[79].folder.name : ctx[79].file ? ctx[79].file.name : ctx[4]("ui.no_content_selected")) + ""))
        set_data(t0, t0_value);
      if (ctx[79].weight === 1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_9(ctx);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 1048576) {
        each_value_2 = ctx[20];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & 1048584 && select_value_value !== (select_value_value = ctx[79].languageCode)) {
        select_option(select, ctx[79].languageCode);
      }
      if (ctx[3].length > 1) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_8(ctx);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 8) {
        toggle_class(div2, "removable", ctx[3].length > 1);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let span;
  let t_1_value = ctx[4]("ui.no_content_selected_hint") + "";
  let t_1;
  return {
    c() {
      div = element("div");
      span = element("span");
      t_1 = text2(t_1_value);
      attr(span, "class", "empty-message svelte-hnzno1");
      attr(div, "class", "multilang-empty svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t_1_value !== (t_1_value = ctx2[4]("ui.no_content_selected_hint") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6(ctx) {
  let div6;
  let div1;
  let label0;
  let t0_value = ctx[4]("ui.site_path") + "";
  let t0;
  let t1;
  let input0;
  let input0_placeholder_value;
  let input0_title_value;
  let t2;
  let div0;
  let t3_value = ctx[4]("ui.site_path_hint") + "";
  let t3;
  let t4;
  let div3;
  let label1;
  let t5_value = ctx[4]("ui.google_analytics_id") + "";
  let t5;
  let t6;
  let input1;
  let input1_placeholder_value;
  let input1_title_value;
  let t7;
  let div2;
  let t8_value = ctx[4]("ui.google_analytics_hint") + "";
  let t8;
  let t9;
  let div5;
  let label2;
  let t10_value = ctx[4]("ui.disqus_shortname") + "";
  let t10;
  let t11;
  let input2;
  let input2_placeholder_value;
  let input2_title_value;
  let t12;
  let div4;
  let t13_value = ctx[4]("ui.disqus_hint") + "";
  let t13;
  let mounted;
  let dispose;
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      label0 = element("label");
      t0 = text2(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      div0 = element("div");
      t3 = text2(t3_value);
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      t5 = text2(t5_value);
      t6 = space();
      input1 = element("input");
      t7 = space();
      div2 = element("div");
      t8 = text2(t8_value);
      t9 = space();
      div5 = element("div");
      label2 = element("label");
      t10 = text2(t10_value);
      t11 = space();
      input2 = element("input");
      t12 = space();
      div4 = element("div");
      t13 = text2(t13_value);
      attr(label0, "class", "section-label svelte-hnzno1");
      attr(label0, "for", "site-path");
      attr(input0, "type", "text");
      attr(input0, "class", "form-input svelte-hnzno1");
      attr(input0, "placeholder", input0_placeholder_value = ctx[4]("ui.site_path_placeholder"));
      attr(input0, "title", input0_title_value = ctx[4]("ui.site_path_hint"));
      attr(div0, "class", "field-hint svelte-hnzno1");
      attr(div1, "class", "advanced-field svelte-hnzno1");
      attr(label1, "class", "section-label svelte-hnzno1");
      attr(label1, "for", "google-analytics");
      attr(input1, "type", "text");
      attr(input1, "class", "form-input svelte-hnzno1");
      attr(input1, "placeholder", input1_placeholder_value = ctx[4]("ui.google_analytics_placeholder"));
      attr(input1, "title", input1_title_value = ctx[4]("ui.google_analytics_hint"));
      attr(div2, "class", "field-hint svelte-hnzno1");
      attr(div3, "class", "advanced-field svelte-hnzno1");
      attr(label2, "class", "section-label svelte-hnzno1");
      attr(label2, "for", "disqus-shortname");
      attr(input2, "type", "text");
      attr(input2, "class", "form-input svelte-hnzno1");
      attr(input2, "placeholder", input2_placeholder_value = ctx[4]("ui.disqus_placeholder"));
      attr(input2, "title", input2_title_value = ctx[4]("ui.disqus_hint"));
      attr(div4, "class", "field-hint svelte-hnzno1");
      attr(div5, "class", "advanced-field svelte-hnzno1");
      attr(div6, "class", "advanced-content svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, label0);
      append(label0, t0);
      append(div1, t1);
      append(div1, input0);
      set_input_value(input0, ctx[1]);
      append(div1, t2);
      append(div1, div0);
      append(div0, t3);
      append(div6, t4);
      append(div6, div3);
      append(div3, label1);
      append(label1, t5);
      append(div3, t6);
      append(div3, input1);
      set_input_value(input1, ctx[6]);
      append(div3, t7);
      append(div3, div2);
      append(div2, t8);
      append(div6, t9);
      append(div6, div5);
      append(div5, label2);
      append(label2, t10);
      append(div5, t11);
      append(div5, input2);
      set_input_value(input2, ctx[7]);
      append(div5, t12);
      append(div5, div4);
      append(div4, t13);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[44]),
          listen(input0, "blur", ctx[26]),
          listen(input1, "input", ctx[45]),
          listen(input2, "input", ctx[46])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t0_value !== (t0_value = ctx2[4]("ui.site_path") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 16 && input0_placeholder_value !== (input0_placeholder_value = ctx2[4]("ui.site_path_placeholder"))) {
        attr(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty[0] & 16 && input0_title_value !== (input0_title_value = ctx2[4]("ui.site_path_hint"))) {
        attr(input0, "title", input0_title_value);
      }
      if (dirty[0] & 2 && input0.value !== ctx2[1]) {
        set_input_value(input0, ctx2[1]);
      }
      if (dirty[0] & 16 && t3_value !== (t3_value = ctx2[4]("ui.site_path_hint") + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 16 && t5_value !== (t5_value = ctx2[4]("ui.google_analytics_id") + ""))
        set_data(t5, t5_value);
      if (dirty[0] & 16 && input1_placeholder_value !== (input1_placeholder_value = ctx2[4]("ui.google_analytics_placeholder"))) {
        attr(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty[0] & 16 && input1_title_value !== (input1_title_value = ctx2[4]("ui.google_analytics_hint"))) {
        attr(input1, "title", input1_title_value);
      }
      if (dirty[0] & 64 && input1.value !== ctx2[6]) {
        set_input_value(input1, ctx2[6]);
      }
      if (dirty[0] & 16 && t8_value !== (t8_value = ctx2[4]("ui.google_analytics_hint") + ""))
        set_data(t8, t8_value);
      if (dirty[0] & 16 && t10_value !== (t10_value = ctx2[4]("ui.disqus_shortname") + ""))
        set_data(t10, t10_value);
      if (dirty[0] & 16 && input2_placeholder_value !== (input2_placeholder_value = ctx2[4]("ui.disqus_placeholder"))) {
        attr(input2, "placeholder", input2_placeholder_value);
      }
      if (dirty[0] & 16 && input2_title_value !== (input2_title_value = ctx2[4]("ui.disqus_hint"))) {
        attr(input2, "title", input2_title_value);
      }
      if (dirty[0] & 128 && input2.value !== ctx2[7]) {
        set_input_value(input2, ctx2[7]);
      }
      if (dirty[0] & 16 && t13_value !== (t13_value = ctx2[4]("ui.disqus_hint") + ""))
        set_data(t13, t13_value);
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1(ctx) {
  let button;
  let t_1_value = (ctx[11] ? ctx[4]("ui.regenerate_preview") : ctx[4]("ui.generate_preview")) + "";
  let t_1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "action-button preview-button svelte-hnzno1");
      button.disabled = button_disabled_value = ctx[3].length === 0;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[27]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2064 && t_1_value !== (t_1_value = (ctx2[11] ? ctx2[4]("ui.regenerate_preview") : ctx2[4]("ui.generate_preview")) + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 1048584 && button_disabled_value !== (button_disabled_value = ctx2[3].length === 0)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let p;
  let t0_value = ctx[4]("ui.preview_building") + "";
  let t0;
  let t1;
  let progressbar;
  let current;
  progressbar = new ProgressBar_default({
    props: { progress: ctx[9] }
  });
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      create_component(progressbar.$$.fragment);
      attr(p, "class", "svelte-hnzno1");
      attr(div, "class", "progress-container svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      mount_component(progressbar, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 16) && t0_value !== (t0_value = ctx2[4]("ui.preview_building") + ""))
        set_data(t0, t0_value);
      const progressbar_changes = {};
      if (dirty[0] & 512)
        progressbar_changes.progress = ctx2[9];
      progressbar.$set(progressbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(progressbar);
    }
  };
}
function create_if_block_4(ctx) {
  let div1;
  let p;
  let t0_value = ctx[4]("ui.preview_link") + "";
  let t0;
  let t1;
  let a;
  let t2;
  let t3;
  let div0;
  let button;
  let t4_value = (ctx[16] ? ctx[4]("ui.exporting") : ctx[4]("ui.export_site")) + "";
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      a = element("a");
      t2 = text2(ctx[10]);
      t3 = space();
      div0 = element("div");
      button = element("button");
      t4 = text2(t4_value);
      attr(a, "href", ctx[10]);
      attr(a, "target", "_blank");
      attr(a, "class", "preview-url svelte-hnzno1");
      attr(button, "class", "action-button export-button svelte-hnzno1");
      button.disabled = ctx[16];
      attr(div0, "class", "preview-actions svelte-hnzno1");
      attr(div1, "class", "preview-link svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p);
      append(p, t0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, button);
      append(button, t4);
      if (!mounted) {
        dispose = listen(button, "click", ctx[29]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t0_value !== (t0_value = ctx2[4]("ui.preview_link") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024)
        set_data(t2, ctx2[10]);
      if (dirty[0] & 1024) {
        attr(a, "href", ctx2[10]);
      }
      if (dirty[0] & 65552 && t4_value !== (t4_value = (ctx2[16] ? ctx2[4]("ui.exporting") : ctx2[4]("ui.export_site")) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & 65536) {
        button.disabled = ctx2[16];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let option;
  let t_1_value = ctx[76].label + "";
  let t_1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t_1 = text2(t_1_value);
      option.__value = option_value_value = ctx[76].value;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262144 && t_1_value !== (t_1_value = ctx2[76].label + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 262144 && option_value_value !== (option_value_value = ctx2[76].value)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block(ctx) {
  let button;
  let t_1_value = ctx[4]("ui.publish") + "";
  let t_1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "action-button publish-button svelte-hnzno1");
      button.disabled = button_disabled_value = !ctx[11];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[28]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t_1_value !== (t_1_value = ctx2[4]("ui.publish") + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 2048 && button_disabled_value !== (button_disabled_value = !ctx2[11])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let p;
  let t0_value = ctx[4]("ui.publish_building") + "";
  let t0;
  let t1;
  let progressbar;
  let current;
  progressbar = new ProgressBar_default({
    props: { progress: ctx[13] }
  });
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      create_component(progressbar.$$.fragment);
      attr(p, "class", "svelte-hnzno1");
      attr(div, "class", "progress-container svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      mount_component(progressbar, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 16) && t0_value !== (t0_value = ctx2[4]("ui.publish_building") + ""))
        set_data(t0, t0_value);
      const progressbar_changes = {};
      if (dirty[0] & 8192)
        progressbar_changes.progress = ctx2[13];
      progressbar.$set(progressbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(progressbar);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let p;
  let t0_value = ctx[4]("ui.published_successfully") + "";
  let t0;
  let t1;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_1;
    if (ctx2[2] === "ftp")
      return create_if_block_2;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1, -1]);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(p, "class", "success-message svelte-hnzno1");
      attr(div, "class", "publish-success svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t0_value !== (t0_value = ctx2[4]("ui.published_successfully") + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_2(ctx) {
  let p;
  let t_1_value = ctx[4]("messages.ftp_upload_success") + "";
  let t_1;
  return {
    c() {
      p = element("p");
      t_1 = text2(t_1_value);
      attr(p, "class", "ftp-success-info svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t_1_value !== (t_1_value = ctx2[4]("messages.ftp_upload_success") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_1(ctx) {
  let a;
  let t_1;
  return {
    c() {
      a = element("a");
      t_1 = text2(ctx[15]);
      attr(a, "href", ctx[15]);
      attr(a, "target", "_blank");
      attr(a, "class", "publish-url svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data(t_1, ctx2[15]);
      if (dirty[0] & 32768) {
        attr(a, "href", ctx2[15]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment3(ctx) {
  let div18;
  let div5;
  let div0;
  let t0_value = ctx[4]("ui.multilingual_content") + "";
  let t0;
  let t1;
  let div4;
  let div3;
  let div1;
  let t2_value = ctx[4]("ui.content_path") + "";
  let t2;
  let t3;
  let div2;
  let span0;
  let t4_value = ctx[4]("ui.language") + "";
  let t4;
  let t5;
  let t6;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t7;
  let t8;
  let div6;
  let label0;
  let t9_value = ctx[4]("ui.site_name") + "";
  let t9;
  let t10;
  let input;
  let input_placeholder_value;
  let t11;
  let div8;
  let div7;
  let button0;
  let span1;
  let t13;
  let t14_value = ctx[4]("ui.advanced_settings") + "";
  let t14;
  let t15;
  let t16;
  let div11;
  let label1;
  let t17_value = ctx[4]("ui.theme") + "";
  let t17;
  let t18;
  let div10;
  let div9;
  let span2;
  let t19;
  let t20;
  let button1;
  let t21_value = ctx[4]("ui.change_theme") + "";
  let t21;
  let t22;
  let div13;
  let h30;
  let t23_value = ctx[4]("ui.preview") + "";
  let t23;
  let t24;
  let div12;
  let current_block_type_index;
  let if_block3;
  let t25;
  let t26;
  let div17;
  let h31;
  let t27_value = ctx[4]("ui.publish") + "";
  let t27;
  let t28;
  let div16;
  let div15;
  let div14;
  let select;
  let t29;
  let current_block_type_index_1;
  let if_block5;
  let t30;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3].length > 0 && create_if_block_10(ctx);
  let each_value_1 = ctx[3];
  const get_key = (ctx2) => ctx2[79].id;
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
  }
  let if_block1 = ctx[3].length === 0 && create_if_block_7(ctx);
  let if_block2 = ctx[5] && create_if_block_6(ctx);
  const if_block_creators = [create_if_block_5, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block4 = ctx[11] && ctx[10] && create_if_block_4(ctx);
  let each_value = ctx[18];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const if_block_creators_1 = [create_if_block_3, create_else_block];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[12])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx, [-1, -1, -1]);
  if_block5 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let if_block6 = ctx[14] && create_if_block(ctx);
  return {
    c() {
      div18 = element("div");
      div5 = element("div");
      div0 = element("div");
      t0 = text2(t0_value);
      t1 = space();
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      t2 = text2(t2_value);
      t3 = space();
      div2 = element("div");
      span0 = element("span");
      t4 = text2(t4_value);
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      div6 = element("div");
      label0 = element("label");
      t9 = text2(t9_value);
      t10 = space();
      input = element("input");
      t11 = space();
      div8 = element("div");
      div7 = element("div");
      button0 = element("button");
      span1 = element("span");
      span1.textContent = "\u25B6";
      t13 = space();
      t14 = text2(t14_value);
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      div11 = element("div");
      label1 = element("label");
      t17 = text2(t17_value);
      t18 = space();
      div10 = element("div");
      div9 = element("div");
      span2 = element("span");
      t19 = text2(ctx[17]);
      t20 = space();
      button1 = element("button");
      t21 = text2(t21_value);
      t22 = space();
      div13 = element("div");
      h30 = element("h3");
      t23 = text2(t23_value);
      t24 = space();
      div12 = element("div");
      if_block3.c();
      t25 = space();
      if (if_block4)
        if_block4.c();
      t26 = space();
      div17 = element("div");
      h31 = element("h3");
      t27 = text2(t27_value);
      t28 = space();
      div16 = element("div");
      div15 = element("div");
      div14 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t29 = space();
      if_block5.c();
      t30 = space();
      if (if_block6)
        if_block6.c();
      attr(div0, "class", "section-label svelte-hnzno1");
      attr(div1, "class", "multilang-header-cell svelte-hnzno1");
      attr(div2, "class", "multilang-header-cell svelte-hnzno1");
      attr(div3, "class", "multilang-header svelte-hnzno1");
      attr(div4, "class", "multilang-table svelte-hnzno1");
      attr(div5, "class", "section svelte-hnzno1");
      attr(label0, "class", "section-label svelte-hnzno1");
      attr(label0, "for", "site-name");
      attr(input, "type", "text");
      attr(input, "class", "form-input svelte-hnzno1");
      attr(input, "placeholder", input_placeholder_value = ctx[4]("ui.site_name_placeholder"));
      attr(div6, "class", "section svelte-hnzno1");
      attr(span1, "class", "toggle-icon svelte-hnzno1");
      toggle_class(span1, "expanded", ctx[5]);
      attr(button0, "class", "advanced-toggle svelte-hnzno1");
      attr(button0, "aria-expanded", ctx[5]);
      attr(div7, "class", "advanced-settings svelte-hnzno1");
      attr(div8, "class", "section svelte-hnzno1");
      attr(label1, "class", "section-label svelte-hnzno1");
      attr(label1, "for", "themes");
      attr(span2, "class", "theme-name svelte-hnzno1");
      attr(button1, "class", "change-theme-btn svelte-hnzno1");
      attr(div9, "class", "current-theme svelte-hnzno1");
      attr(div10, "class", "theme-selector svelte-hnzno1");
      attr(div11, "class", "section svelte-hnzno1");
      attr(h30, "class", "section-title svelte-hnzno1");
      attr(div12, "class", "preview-section svelte-hnzno1");
      attr(div13, "class", "section svelte-hnzno1");
      attr(h31, "class", "section-title svelte-hnzno1");
      attr(select, "class", "form-select svelte-hnzno1");
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[47].call(select));
      attr(div14, "class", "publish-select-wrapper svelte-hnzno1");
      attr(div15, "class", "publish-options svelte-hnzno1");
      attr(div16, "class", "publish-section svelte-hnzno1");
      attr(div17, "class", "section svelte-hnzno1");
      attr(div18, "class", "site-builder svelte-hnzno1");
    },
    m(target, anchor) {
      insert(target, div18, anchor);
      append(div18, div5);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div4);
      append(div4, div3);
      append(div3, div1);
      append(div1, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, span0);
      append(span0, t4);
      append(div2, t5);
      if (if_block0)
        if_block0.m(div2, null);
      append(div4, t6);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div4, null);
        }
      }
      append(div4, t7);
      if (if_block1)
        if_block1.m(div4, null);
      append(div18, t8);
      append(div18, div6);
      append(div6, label0);
      append(label0, t9);
      append(div6, t10);
      append(div6, input);
      set_input_value(input, ctx[0]);
      append(div18, t11);
      append(div18, div8);
      append(div8, div7);
      append(div7, button0);
      append(button0, span1);
      append(button0, t13);
      append(button0, t14);
      append(div7, t15);
      if (if_block2)
        if_block2.m(div7, null);
      append(div18, t16);
      append(div18, div11);
      append(div11, label1);
      append(label1, t17);
      append(div11, t18);
      append(div11, div10);
      append(div10, div9);
      append(div9, span2);
      append(span2, t19);
      append(div9, t20);
      append(div9, button1);
      append(button1, t21);
      append(div18, t22);
      append(div18, div13);
      append(div13, h30);
      append(h30, t23);
      append(div13, t24);
      append(div13, div12);
      if_blocks[current_block_type_index].m(div12, null);
      append(div12, t25);
      if (if_block4)
        if_block4.m(div12, null);
      append(div18, t26);
      append(div18, div17);
      append(div17, h31);
      append(h31, t27);
      append(div17, t28);
      append(div17, div16);
      append(div16, div15);
      append(div15, div14);
      append(div14, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[2], true);
      append(div15, t29);
      if_blocks_1[current_block_type_index_1].m(div15, null);
      append(div16, t30);
      if (if_block6)
        if_block6.m(div16, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[43]),
          listen(button0, "click", ctx[25]),
          listen(button1, "click", ctx[24]),
          listen(select, "change", ctx[47])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 16) && t0_value !== (t0_value = ctx2[4]("ui.multilingual_content") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty[0] & 16) && t2_value !== (t2_value = ctx2[4]("ui.content_path") + ""))
        set_data(t2, t2_value);
      if ((!current || dirty[0] & 16) && t4_value !== (t4_value = ctx2[4]("ui.language") + ""))
        set_data(t4, t4_value);
      if (ctx2[3].length > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 7340056) {
        each_value_1 = ctx2[3];
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, div4, destroy_block, create_each_block_1, t7, get_each_context_1);
      }
      if (ctx2[3].length === 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty[0] & 16) && t9_value !== (t9_value = ctx2[4]("ui.site_name") + ""))
        set_data(t9, t9_value);
      if (!current || dirty[0] & 16 && input_placeholder_value !== (input_placeholder_value = ctx2[4]("ui.site_name_placeholder"))) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(span1, "expanded", ctx2[5]);
      }
      if ((!current || dirty[0] & 16) && t14_value !== (t14_value = ctx2[4]("ui.advanced_settings") + ""))
        set_data(t14, t14_value);
      if (!current || dirty[0] & 32) {
        attr(button0, "aria-expanded", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_6(ctx2);
          if_block2.c();
          if_block2.m(div7, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if ((!current || dirty[0] & 16) && t17_value !== (t17_value = ctx2[4]("ui.theme") + ""))
        set_data(t17, t17_value);
      if (!current || dirty[0] & 131072)
        set_data(t19, ctx2[17]);
      if ((!current || dirty[0] & 16) && t21_value !== (t21_value = ctx2[4]("ui.change_theme") + ""))
        set_data(t21, t21_value);
      if ((!current || dirty[0] & 16) && t23_value !== (t23_value = ctx2[4]("ui.preview") + ""))
        set_data(t23, t23_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(div12, t25);
      }
      if (ctx2[11] && ctx2[10]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_4(ctx2);
          if_block4.c();
          if_block4.m(div12, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if ((!current || dirty[0] & 16) && t27_value !== (t27_value = ctx2[4]("ui.publish") + ""))
        set_data(t27, t27_value);
      if (dirty[0] & 262144) {
        each_value = ctx2[18];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 262148) {
        select_option(select, ctx2[2]);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block5 = if_blocks_1[current_block_type_index_1];
        if (!if_block5) {
          if_block5 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block5.c();
        } else {
          if_block5.p(ctx2, dirty);
        }
        transition_in(if_block5, 1);
        if_block5.m(div15, null);
      }
      if (ctx2[14]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block(ctx2);
          if_block6.c();
          if_block6.m(div16, null);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block3);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(if_block3);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div18);
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if_blocks[current_block_type_index].d();
      if (if_block4)
        if_block4.d();
      destroy_each(each_blocks, detaching);
      if_blocks_1[current_block_type_index_1].d();
      if (if_block6)
        if_block6.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
var BOOK_THEME_URL = "https://gohugo.net/book-ob.zip?version=1.1";
var BOOK_THEME_ID = "3";
var BOOK_THEME_NAME = "Obsidian Book";
var NOTE_THEME_URL = "https://gohugo.net/note.zip?version=1.2";
var NOTE_THEME_ID = "2";
var NOTE_THEME_NAME = "Note";
var serverHost = "localhost";
var serverPort = 8090;
function normalizeSitePath(path6) {
  if (!path6.startsWith("/")) {
    path6 = "/" + path6;
  }
  if (path6.length > 1 && path6.endsWith("/")) {
    path6 = path6.slice(0, -1);
  }
  return path6;
}
function generateRandomId() {
  return Math.random().toString(36).substring(2, 8);
}
function instance3($$self, $$props, $$invalidate) {
  let site;
  let languageContents;
  let t;
  let currentContents;
  let isForSingleFile;
  let defaultContentLanguage;
  let publishOptions;
  let displayThemeName;
  let $languageContents, $$unsubscribe_languageContents = noop, $$subscribe_languageContents = () => ($$unsubscribe_languageContents(), $$unsubscribe_languageContents = subscribe(languageContents, ($$value) => $$invalidate(40, $languageContents = $$value)), languageContents);
  $$self.$$.on_destroy.push(() => $$unsubscribe_languageContents());
  var _a, _b, _c, _d, _e;
  let { app } = $$props;
  let { plugin } = $$props;
  const isWindows = process.platform === "win32";
  let basePath = plugin.pluginDir;
  let absSelectedFolderPath = "";
  let absProjContentPath = "";
  let contentPath = "";
  let siteName = "";
  let sitePath = "/";
  let selectedThemeDownloadUrl = BOOK_THEME_URL;
  let selectedThemeName = BOOK_THEME_NAME;
  let selectedThemeId = BOOK_THEME_ID;
  let showAdvancedSettings = false;
  let googleAnalyticsId = "";
  let disqusShortname = "";
  let themesDir = "";
  let isBuilding = false;
  let buildProgress = 0;
  let previewUrl = "";
  let previewId = "";
  let hasPreview = false;
  let absPreviewDir = "";
  let isPublishing = false;
  let publishProgress = 0;
  let publishSuccess = false;
  let publishUrl = "";
  let selectedPublishOption = plugin.settings.publishMethod || "netlify";
  let isExporting = false;
  let httpServer;
  let serverRunning = false;
  onMount(async () => {
    console.log("Site component mounting...");
    themesDir = path2.join(plugin.pluginDir, "themes");
    await createThemesDirectory();
    const adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    console.log("Site component mounted successfully");
  });
  onDestroy(() => {
    if (serverRunning) {
      httpServer.stopWatching();
      serverRunning = false;
    }
  });
  const SUPPORTED_LANGUAGES = [
    {
      code: "en",
      name: "English",
      direction: "ltr",
      englishName: "English"
    },
    {
      code: "zh",
      name: "\u4E2D\u6587",
      direction: "ltr",
      englishName: "Chinese"
    },
    {
      code: "es",
      name: "Espa\xF1ol",
      direction: "ltr",
      englishName: "Spanish"
    },
    {
      code: "fr",
      name: "Fran\xE7ais",
      direction: "ltr",
      englishName: "French"
    },
    {
      code: "de",
      name: "Deutsch",
      direction: "ltr",
      englishName: "German"
    },
    {
      code: "ja",
      name: "\u65E5\u672C\u8A9E",
      direction: "ltr",
      englishName: "Japanese"
    },
    {
      code: "ko",
      name: "\uD55C\uAD6D\uC5B4",
      direction: "ltr",
      englishName: "Korean"
    }
  ];
  function updateLanguageCode(contentId, newLanguageCode) {
    site.updateLanguageCode(contentId, newLanguageCode);
  }
  function removeLanguageContent(contentId) {
    site.removeLanguageContent(contentId);
  }
  function clearAllContent() {
    site.clearAllContent();
  }
  function getLanguageName(code) {
    const lang = SUPPORTED_LANGUAGES.find((l) => l.code === code);
    return lang ? lang.name : code;
  }
  function showAddLanguageDialog() {
    new import_obsidian3.Notice(t("messages.add_language_instruction"), 5e3);
  }
  function openThemeModal() {
    plugin.showThemeSelectionModal(selectedThemeId, (themeUrl, themeName, themeId) => {
      $$invalidate(37, selectedThemeDownloadUrl = themeUrl);
      $$invalidate(38, selectedThemeName = themeName || (isForSingleFile ? "Note" : "Book"));
      selectedThemeId = themeId || selectedThemeId;
    }, isForSingleFile);
  }
  function toggleAdvancedSettings() {
    $$invalidate(5, showAdvancedSettings = !showAdvancedSettings);
  }
  function handleSitePathChange() {
    $$invalidate(1, sitePath = normalizeSitePath(sitePath));
  }
  async function createRendererBasedOnTheme() {
    var _a2, _b2, _c2, _d2, _e2, _f, _g;
    try {
      const themeInfo = await themeApiService.getThemeById(selectedThemeId);
      const obImagesDir = path2.join(absPreviewDir, "public", "ob-images");
      const hasOBTag = ((_a2 = themeInfo === null || themeInfo === void 0 ? void 0 : themeInfo.tags) === null || _a2 === void 0 ? void 0 : _a2.some((tag) => tag.toLowerCase() === "obsidian")) || false;
      if (hasOBTag) {
        const renderer = new OBStyleRenderer(plugin, {
          includeCSS: true,
          waitForPlugins: true,
          timeout: 200,
          containerWidth: "1000px",
          includeTheme: true
        });
        renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_c2 = (_b2 = currentContents[0]) === null || _b2 === void 0 ? void 0 : _b2.folder) === null || _c2 === void 0 ? void 0 : _c2.name);
        return renderer;
      } else {
        const renderer = createStyleRenderer(plugin, {
          autoHeadingID: true,
          waitForStable: false
        });
        if (renderer.getResourceProcessor) {
          renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_e2 = (_d2 = currentContents[0]) === null || _d2 === void 0 ? void 0 : _d2.folder) === null || _e2 === void 0 ? void 0 : _e2.name);
        }
        return renderer;
      }
    } catch (error) {
      console.warn("Failed to get theme info, falling back to lightweight renderer:", error);
      const obImagesDir = path2.join(absPreviewDir, "public", "ob-images");
      const renderer = createStyleRenderer(plugin, {
        autoHeadingID: true,
        waitForStable: false
      });
      if (renderer.getResourceProcessor) {
        renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_g = (_f = currentContents[0]) === null || _f === void 0 ? void 0 : _f.folder) === null || _g === void 0 ? void 0 : _g.name);
      }
      return renderer;
    }
  }
  async function createSitePathStructure(previewDir) {
    if (sitePath === "/") {
      return path2.join(previewDir, "public");
    }
    const pathParts = sitePath.split("/").filter((part) => part !== "");
    if (pathParts.length === 0) {
      return path2.join(previewDir, "public");
    }
    let currentDir = previewDir;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentDir = path2.join(currentDir, pathParts[i]);
      if (!await app.vault.adapter.exists(currentDir)) {
        await app.vault.adapter.mkdir(currentDir);
      }
    }
    const finalDirName = pathParts[pathParts.length - 1];
    const finalDirPath = path2.join(currentDir, finalDirName);
    const publicDir = path2.join(previewDir, "public");
    if (await app.vault.adapter.exists(finalDirPath)) {
      await app.vault.adapter.rmdir(finalDirPath, true);
    }
    const adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      const absFinalDirPath = path2.join(adapter.getBasePath(), finalDirPath);
      const absPublicDir = path2.join(adapter.getBasePath(), publicDir);
      try {
        if (isWindows) {
          await fs2.promises.symlink(absPublicDir, absFinalDirPath, "junction");
        } else {
          await fs2.promises.symlink(absPublicDir, absFinalDirPath, "dir");
        }
      } catch (error) {
        console.error("Failed to create symlink for site path:", error);
        await fs2.promises.cp(absPublicDir, absFinalDirPath, { recursive: true });
      }
    }
    return previewDir;
  }
  async function startPreview() {
    if (currentContents.length === 0) {
      new import_obsidian3.Notice(t("messages.no_folder_or_file_selected"), 3e3);
      return;
    }
    $$invalidate(8, isBuilding = true);
    $$invalidate(9, buildProgress = 0);
    $$invalidate(11, hasPreview = false);
    try {
      if (serverRunning) {
        await httpServer.stopWatching();
        serverRunning = false;
      }
      previewId = generateRandomId();
      const previewDir = path2.join(plugin.pluginDir, "preview", previewId);
      await createPreviewDirectory(previewDir);
      $$invalidate(9, buildProgress = 5);
      if (sitePath.startsWith("/preview")) {
        $$invalidate(1, sitePath = `/preview/${previewId}`);
      }
      await createConfigFile(previewDir);
      $$invalidate(9, buildProgress = 10);
      await linkMultiLanguageContents(previewDir);
      $$invalidate(9, buildProgress = 15);
      absPreviewDir = path2.join(basePath, previewDir);
      const absThemesDir = path2.join(basePath, themesDir);
      const serverRootDir = await createSitePathStructure(previewDir);
      const obImagesDir = path2.join(absPreviewDir, "public", "ob-images");
      const styleRenderer = await createRendererBasedOnTheme();
      httpServer = await (0, import_foundry2.startIncrementalBuild)({
        projDir: absPreviewDir,
        modulesDir: absThemesDir,
        contentDir: absSelectedFolderPath,
        projContentDir: absProjContentPath,
        publicDir: path2.join(basePath, serverRootDir),
        enableWatching: true,
        batchDelay: 500,
        progressCallback: (progress) => {
          $$invalidate(9, buildProgress = 15 + progress.percentage / 100 * 85);
        },
        markdown: styleRenderer,
        liveReload: {
          enabled: true,
          port: serverPort,
          host: serverHost,
          livereloadPort: 35729
        }
      });
      serverRunning = true;
      $$invalidate(9, buildProgress = 100);
      if (sitePath === "/") {
        if (isForSingleFile) {
          $$invalidate(10, previewUrl = `${httpServer.getServerUrl()}/`);
        } else {
          $$invalidate(10, previewUrl = httpServer.getServerUrl());
        }
      } else {
        $$invalidate(10, previewUrl = `${httpServer.getServerUrl()}${sitePath}/`);
      }
      $$invalidate(11, hasPreview = true);
      window.open(previewUrl, "_blank");
      new import_obsidian3.Notice(t("messages.preview_generated_successfully"), 3e3);
      plugin.hugoverse.sendCounter("preview").catch((error) => {
        console.warn("Counter request failed (non-critical):", error);
      });
    } catch (error) {
      console.error("Preview generation failed:", error);
      new import_obsidian3.Notice(t("messages.preview_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(8, isBuilding = false);
    }
  }
  async function startPublish() {
    if (!hasPreview) {
      new import_obsidian3.Notice(t("messages.please_generate_preview_first"), 3e3);
      return;
    }
    if (!previewId || !absPreviewDir) {
      new import_obsidian3.Notice(t("messages.preview_data_missing"), 3e3);
      return;
    }
    if (selectedPublishOption === "netlify") {
      if (!plugin.settings.netlifyAccessToken || !plugin.settings.netlifyProjectId) {
        new import_obsidian3.Notice(t("messages.netlify_settings_missing"), 5e3);
        return;
      }
    } else if (selectedPublishOption === "ftp") {
      if (!plugin.settings.ftpServer || !plugin.settings.ftpUsername || !plugin.settings.ftpPassword) {
        new import_obsidian3.Notice(t("messages.ftp_settings_missing"), 5e3);
        return;
      }
    }
    $$invalidate(12, isPublishing = true);
    $$invalidate(13, publishProgress = 0);
    $$invalidate(14, publishSuccess = false);
    try {
      $$invalidate(13, publishProgress = 5);
      const publicDir = path2.join(absPreviewDir, "public");
      if (selectedPublishOption === "netlify") {
        await publishToNetlify(publicDir);
      } else if (selectedPublishOption === "ftp") {
        await publishToFTP(publicDir);
      } else {
        const zipContent = await createZipFromDirectory(publicDir);
        $$invalidate(13, publishProgress = 50);
        const previewApiId = await plugin.hugoverse.createMDFPreview(previewId, zipContent);
        if (!previewApiId) {
          throw new Error("Failed to create MDFriday preview");
        }
        $$invalidate(13, publishProgress = 80);
        const deployPath = await plugin.hugoverse.deployMDFridayPreview(previewApiId);
        if (!deployPath) {
          throw new Error("Failed to deploy MDFriday preview");
        }
        $$invalidate(13, publishProgress = 100);
        const baseUrl = GetBaseUrl();
        $$invalidate(15, publishUrl = `${baseUrl}${deployPath}`);
        $$invalidate(14, publishSuccess = true);
        new import_obsidian3.Notice(t("messages.site_published_successfully"), 3e3);
        plugin.hugoverse.sendCounter("mdf-preview").catch((error) => {
          console.warn("Counter request failed (non-critical):", error);
        });
      }
    } catch (error) {
      console.error("Publishing failed:", error);
      new import_obsidian3.Notice(t("messages.publishing_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(12, isPublishing = false);
    }
  }
  async function publishToNetlify(publicDir) {
    try {
      $$invalidate(15, publishUrl = await plugin.netlify.deployToNetlify(publicDir, (progress) => {
        $$invalidate(13, publishProgress = Math.round(progress));
      }));
      $$invalidate(14, publishSuccess = true);
      new import_obsidian3.Notice(t("messages.netlify_deploy_success"), 3e3);
      plugin.hugoverse.sendCounter("netlify").catch((error) => {
        console.warn("Counter request failed (non-critical):", error);
      });
    } catch (error) {
      console.error("Netlify deployment failed:", error);
      throw new Error(t("messages.netlify_deploy_failed", { error: error.message }));
    }
  }
  async function publishToFTP(publicDir) {
    try {
      plugin.initializeFTP();
      if (!plugin.ftp) {
        throw new Error("FTP uploader not initialized - please check FTP settings");
      }
      console.log("Starting FTP upload from:", publicDir);
      plugin.ftp.setProgressCallback((progress) => {
        $$invalidate(13, publishProgress = Math.round(progress.percentage));
      });
      const result = await plugin.ftp.uploadDirectory(publicDir);
      if (result.success) {
        $$invalidate(14, publishSuccess = true);
        $$invalidate(15, publishUrl = "");
        if (!result.usedSecure) {
          new import_obsidian3.Notice(t("messages.ftp_fallback_to_plain"), 4e3);
        }
        new import_obsidian3.Notice(t("messages.ftp_upload_success"), 3e3);
        plugin.hugoverse.sendCounter("ftp").catch((error) => {
          console.warn("Counter request failed (non-critical):", error);
        });
      } else {
        throw new Error(result.error || "Unknown FTP error");
      }
    } catch (error) {
      console.error("FTP upload failed:", error);
      throw new Error(t("messages.ftp_upload_failed", { error: error.message }));
    }
  }
  async function createPreviewDirectory(previewDir) {
    const previewRoot = path2.join(plugin.pluginDir, "preview");
    if (!await app.vault.adapter.exists(previewRoot)) {
      await app.vault.adapter.mkdir(previewRoot);
    }
    if (!await app.vault.adapter.exists(previewDir)) {
      await app.vault.adapter.mkdir(previewDir);
    }
    const contentDir = path2.join(previewDir, "content");
    if (!await app.vault.adapter.exists(contentDir)) {
      await app.vault.adapter.mkdir(contentDir);
    }
    const publicDir = path2.join(previewDir, "public");
    if (!await app.vault.adapter.exists(publicDir)) {
      await app.vault.adapter.mkdir(publicDir);
    }
    const obImagesDir = path2.join(publicDir, "ob-images");
    if (!await app.vault.adapter.exists(obImagesDir)) {
      await app.vault.adapter.mkdir(obImagesDir);
    }
  }
  async function createThemesDirectory() {
    if (!await app.vault.adapter.exists(themesDir)) {
      await app.vault.adapter.mkdir(themesDir);
    }
  }
  async function createConfigFile(previewDir) {
    const config = {
      baseURL: sitePath,
      title: siteName,
      contentDir: "content",
      publishDir: "public",
      defaultContentLanguage,
      taxonomies: { tag: "tags", category: "categories" },
      module: {
        imports: [{ path: selectedThemeDownloadUrl }]
      },
      params: { branding: false }
    };
    const services = {};
    if (googleAnalyticsId && googleAnalyticsId.trim()) {
      services.googleAnalytics = { id: googleAnalyticsId.trim() };
    }
    if (disqusShortname && disqusShortname.trim()) {
      services.disqus = { shortname: disqusShortname.trim() };
    }
    if (Object.keys(services).length > 0) {
      config.services = services;
    }
    if (currentContents.length > 1) {
      const languages = {};
      currentContents.forEach((content, index) => {
        const contentDir = index === 0 ? "content" : `content.${content.languageCode}`;
        languages[content.languageCode] = { contentDir, weight: content.weight };
      });
      config.languages = languages;
    }
    const configPath = path2.join(previewDir, "config.json");
    await app.vault.adapter.write(configPath, JSON.stringify(config, null, 2));
  }
  async function exportSite() {
    if (!hasPreview || !absPreviewDir) {
      new import_obsidian3.Notice(t("messages.please_generate_preview_first"), 3e3);
      return;
    }
    $$invalidate(16, isExporting = true);
    try {
      const publicDir = path2.join(absPreviewDir, "public");
      const zipContent = await createZipFromDirectory(publicDir);
      const { dialog } = require("@electron/remote") || require("electron").remote;
      const { canceled, filePath } = await dialog.showSaveDialog({
        title: t("ui.export_site_dialog_title"),
        defaultPath: "mdfriday-site.zip",
        filters: [
          { name: "ZIP Files", extensions: ["zip"] },
          { name: "All Files", extensions: ["*"] }
        ]
      });
      if (!canceled && filePath) {
        await fs2.promises.writeFile(filePath, zipContent);
        new import_obsidian3.Notice(t("messages.site_exported_successfully", { path: filePath }), 3e3);
      }
    } catch (error) {
      console.error("Export failed:", error);
      new import_obsidian3.Notice(t("messages.export_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(16, isExporting = false);
    }
  }
  async function linkMultiLanguageContents(previewDir) {
    for (let i = 0; i < currentContents.length; i++) {
      const content = currentContents[i];
      const contentDir = i === 0 ? "content" : `content.${content.languageCode}`;
      const targetPath = path2.join(previewDir, contentDir);
      if (content.folder) {
        await linkFolderContents(content.folder, targetPath);
      } else if (content.file) {
        await linkSingleFileContent(content.file, targetPath);
      }
    }
  }
  async function linkFolderContents(folder, targetPath) {
    const adapter = app.vault.adapter;
    let sourcePath;
    let absTargetPath;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      sourcePath = path2.join(adapter.getBasePath(), folder.path);
      absTargetPath = path2.join(adapter.getBasePath(), targetPath);
      absSelectedFolderPath = sourcePath;
      absProjContentPath = absTargetPath;
    } else {
      console.warn("Not using FileSystemAdapter, falling back to copying files");
      await copyFolderContents(folder, targetPath);
      return;
    }
    try {
      if (await app.vault.adapter.exists(targetPath)) {
        await app.vault.adapter.rmdir(targetPath, true);
      }
      if (isWindows) {
        await fs2.promises.symlink(sourcePath, absTargetPath, "junction");
        return;
      }
      await fs2.promises.symlink(sourcePath, absTargetPath, "dir");
    } catch (error) {
      console.error("Failed to create symbolic link, falling back to copying:", error);
      await copyFolderContents(folder, targetPath);
    }
  }
  async function copyFolderContents(folder, targetPath) {
    const copyRecursive = async (sourceFolder, destPath) => {
      for (const child of sourceFolder.children) {
        if (child instanceof import_obsidian3.TFolder) {
          const childDestPath = path2.join(destPath, child.name);
          if (!await app.vault.adapter.exists(childDestPath)) {
            await app.vault.adapter.mkdir(childDestPath);
          }
          await copyRecursive(child, childDestPath);
        } else if (child instanceof import_obsidian3.TFile) {
          const childDestPath = path2.join(destPath, child.name);
          try {
            const content = await app.vault.read(child);
            await app.vault.adapter.write(childDestPath, content);
          } catch (error) {
            console.warn(`Failed to copy file ${child.path}:`, error);
          }
        }
      }
    };
    await copyRecursive(folder, targetPath);
  }
  async function linkSingleFileContent(file, targetPath) {
    const adapter = app.vault.adapter;
    let sourcePath;
    let absTargetPath;
    let absContentDir;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      sourcePath = path2.join(adapter.getBasePath(), file.path);
      absContentDir = path2.join(adapter.getBasePath(), targetPath);
      absTargetPath = path2.join(absContentDir, "index.md");
      absSelectedFolderPath = path2.dirname(sourcePath);
      absProjContentPath = absContentDir;
    } else {
      console.warn("Not using FileSystemAdapter, falling back to copying file");
      await copySingleFileContent(file, targetPath);
      return;
    }
    try {
      if (!await app.vault.adapter.exists(targetPath)) {
        await app.vault.adapter.mkdir(targetPath);
      }
      if (await app.vault.adapter.exists(path2.join(targetPath, "index.md"))) {
        await app.vault.adapter.remove(path2.join(targetPath, "index.md"));
      }
      if (isWindows) {
        await fs2.promises.symlink(sourcePath, absTargetPath, "file");
      } else {
        await fs2.promises.symlink(sourcePath, absTargetPath);
      }
    } catch (error) {
      console.error("Failed to create symbolic link for file, falling back to copying:", error);
      await copySingleFileContent(file, targetPath);
    }
  }
  async function copySingleFileContent(file, targetPath) {
    if (!await app.vault.adapter.exists(targetPath)) {
      await app.vault.adapter.mkdir(targetPath);
    }
    const indexPath = path2.join(targetPath, "index.md");
    try {
      const fileContent = await app.vault.read(file);
      await app.vault.adapter.write(indexPath, fileContent);
    } catch (error) {
      console.error("Failed to copy file content:", error);
      throw error;
    }
  }
  async function createZipFromDirectory(sourceDir) {
    const zip = new import_jszip.default();
    const addDirectoryToZip = async (dirPath, zipFolder) => {
      const items = await fs2.promises.readdir(dirPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path2.join(dirPath, item.name);
        if (item.isDirectory()) {
          const subFolder = zipFolder.folder(item.name);
          if (subFolder) {
            await addDirectoryToZip(itemPath, subFolder);
          }
        } else if (item.isFile()) {
          const fileContent = await fs2.promises.readFile(itemPath);
          zipFolder.file(item.name, fileContent);
        }
      }
    };
    await addDirectoryToZip(sourceDir, zip);
    return await zip.generateAsync({ type: "uint8array" });
  }
  const change_handler = (content, e) => updateLanguageCode(content.id, e.currentTarget.value);
  const click_handler = (content) => removeLanguageContent(content.id);
  function input_input_handler() {
    siteName = this.value;
    $$invalidate(0, siteName), $$invalidate(3, currentContents), $$invalidate(35, _d), $$invalidate(36, _e), $$invalidate(40, $languageContents);
  }
  function input0_input_handler() {
    sitePath = this.value;
    $$invalidate(1, sitePath);
  }
  function input1_input_handler() {
    googleAnalyticsId = this.value;
    $$invalidate(6, googleAnalyticsId);
  }
  function input2_input_handler() {
    disqusShortname = this.value;
    $$invalidate(7, disqusShortname);
  }
  function select_change_handler() {
    selectedPublishOption = select_value(this);
    $$invalidate(2, selectedPublishOption), $$invalidate(1, sitePath), $$invalidate(31, plugin);
    $$invalidate(18, publishOptions), $$invalidate(4, t), $$invalidate(1, sitePath), $$invalidate(31, plugin), $$invalidate(32, _a);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(30, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(31, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 1) {
      $:
        $$invalidate(39, site = plugin.site);
    }
    if ($$self.$$.dirty[1] & 256) {
      $:
        $$subscribe_languageContents($$invalidate(19, languageContents = site ? site.languageContents : null));
    }
    if ($$self.$$.dirty[1] & 3) {
      $:
        $$invalidate(4, t = ($$invalidate(32, _a = plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key) => key));
    }
    if ($$self.$$.dirty[1] & 512) {
      $:
        $$invalidate(3, currentContents = $languageContents || []);
    }
    if ($$self.$$.dirty[1] & 256) {
      $:
        isForSingleFile = site ? site.isForSingleFile() : false;
    }
    if ($$self.$$.dirty[1] & 256) {
      $:
        defaultContentLanguage = site ? site.getDefaultContentLanguage() : "en";
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 64) {
      $: {
        if (currentContents.length > 0) {
          const firstContent = currentContents[0];
          if (firstContent.file && !selectedThemeDownloadUrl.includes("note")) {
            $$invalidate(37, selectedThemeDownloadUrl = NOTE_THEME_URL);
            $$invalidate(38, selectedThemeName = NOTE_THEME_NAME);
            selectedThemeId = NOTE_THEME_ID;
          } else if (firstContent.folder && !selectedThemeDownloadUrl.includes("book")) {
            $$invalidate(37, selectedThemeDownloadUrl = BOOK_THEME_URL);
            $$invalidate(38, selectedThemeName = BOOK_THEME_NAME);
            selectedThemeId = BOOK_THEME_ID;
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 18) {
      $:
        $$invalidate(18, publishOptions = [
          {
            value: "netlify",
            label: t("ui.publish_option_netlify")
          },
          {
            value: "ftp",
            label: t("ui.publish_option_ftp")
          },
          ...sitePath.startsWith("/preview/") ? [
            {
              value: "mdf-preview",
              label: t("ui.publish_option_mdfriday")
            }
          ] : []
        ]);
    }
    if ($$self.$$.dirty[0] & 6 | $$self.$$.dirty[1] & 1) {
      $:
        if (!sitePath.startsWith("/preview/") && selectedPublishOption === "mdf-preview") {
          $$invalidate(2, selectedPublishOption = plugin.settings.publishMethod || "netlify");
        }
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[1] & 12) {
      $:
        contentPath = currentContents.length > 0 ? ($$invalidate(33, _b = currentContents[0].folder) === null || _b === void 0 ? void 0 : _b.name) || ($$invalidate(34, _c = currentContents[0].file) === null || _c === void 0 ? void 0 : _c.name) || "" : "";
    }
    if ($$self.$$.dirty[0] & 9 | $$self.$$.dirty[1] & 48) {
      $: {
        if (currentContents.length > 0 && !siteName) {
          const firstContent = currentContents[0];
          $$invalidate(0, siteName = ($$invalidate(35, _d = firstContent.folder) === null || _d === void 0 ? void 0 : _d.name) || ($$invalidate(36, _e = firstContent.file) === null || _e === void 0 ? void 0 : _e.basename) || "");
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      $:
        if (currentContents.length === 0) {
          $$invalidate(11, hasPreview = false);
          $$invalidate(10, previewUrl = "");
          previewId = "";
          $$invalidate(0, siteName = "");
        }
    }
    if ($$self.$$.dirty[1] & 128) {
      $:
        $$invalidate(17, displayThemeName = selectedThemeName || BOOK_THEME_NAME);
    }
  };
  return [
    siteName,
    sitePath,
    selectedPublishOption,
    currentContents,
    t,
    showAdvancedSettings,
    googleAnalyticsId,
    disqusShortname,
    isBuilding,
    buildProgress,
    previewUrl,
    hasPreview,
    isPublishing,
    publishProgress,
    publishSuccess,
    publishUrl,
    isExporting,
    displayThemeName,
    publishOptions,
    languageContents,
    SUPPORTED_LANGUAGES,
    updateLanguageCode,
    removeLanguageContent,
    clearAllContent,
    openThemeModal,
    toggleAdvancedSettings,
    handleSitePathChange,
    startPreview,
    startPublish,
    exportSite,
    app,
    plugin,
    _a,
    _b,
    _c,
    _d,
    _e,
    selectedThemeDownloadUrl,
    selectedThemeName,
    site,
    $languageContents,
    change_handler,
    click_handler,
    input_input_handler,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    select_change_handler
  ];
}
var Site = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { app: 30, plugin: 31 }, add_css3, [-1, -1, -1]);
  }
};
var Site_default = Site;

// src/svelte/Server.svelte
function add_css4(target) {
  append_styles(target, "svelte-1lauw5u", ".friday-plugin-main.svelte-1lauw5u{padding:initial;width:initial;height:initial;position:initial;overflow-y:initial;overflow-wrap:initial}.centered-line.svelte-1lauw5u{width:80%;margin:20px auto;border:none;border-top:1px solid rgb(64 64 64);height:1px;background-color:transparent}.friday-tab-content.svelte-1lauw5u{padding:10px 0}");
}
function create_else_block2(ctx) {
  let section;
  let div1;
  let div0;
  let site;
  let t0;
  let hr;
  let t1;
  let info;
  let current;
  site = new Site_default({
    props: {
      app: ctx[0],
      plugin: ctx[1]
    }
  });
  info = new Info_default({ props: { plugin: ctx[1] } });
  return {
    c() {
      section = element("section");
      div1 = element("div");
      div0 = element("div");
      create_component(site.$$.fragment);
      t0 = space();
      hr = element("hr");
      t1 = space();
      create_component(info.$$.fragment);
      attr(hr, "class", "centered-line svelte-1lauw5u");
      attr(div0, "role", "tabpanel");
      attr(div0, "id", "panel-site");
      attr(div0, "aria-labelledby", "tab-site");
      attr(div0, "tabindex", "0");
      attr(div1, "class", "friday-tab-content svelte-1lauw5u");
      attr(section, "id", "friday-plugin-main");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div1);
      append(div1, div0);
      mount_component(site, div0, null);
      append(div0, t0);
      append(div0, hr);
      append(div0, t1);
      mount_component(info, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const site_changes = {};
      if (dirty & 1)
        site_changes.app = ctx2[0];
      if (dirty & 2)
        site_changes.plugin = ctx2[1];
      site.$set(site_changes);
      const info_changes = {};
      if (dirty & 2)
        info_changes.plugin = ctx2[1];
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(site.$$.fragment, local);
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(site.$$.fragment, local);
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(site);
      destroy_component(info);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let p;
  let t0_value = ctx[3]("ui.desktop_only_message") + "";
  let t0;
  let t1;
  let br;
  let t2;
  let t3_value = ctx[3]("ui.mobile_coming_soon") + "";
  let t3;
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      br = element("br");
      t2 = space();
      t3 = text2(t3_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(p, t1);
      append(p, br);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t0_value !== (t0_value = ctx2[3]("ui.desktop_only_message") + ""))
        set_data(t0, t0_value);
      if (dirty & 8 && t3_value !== (t3_value = ctx2[3]("ui.mobile_coming_soon") + ""))
        set_data(t3, t3_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "friday-plugin-main svelte-1lauw5u");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let t;
  var _a;
  let { app } = $$props;
  let { plugin } = $$props;
  let isClientSupported = false;
  onMount(async () => {
    $$invalidate(2, isClientSupported = import_obsidian4.Platform.isDesktop);
    if (!isClientSupported) {
      new import_obsidian4.Notice(t("messages.desktop_only_notice"), 5e3);
      return;
    }
  });
  onDestroy(() => {
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 18) {
      $:
        $$invalidate(3, t = ($$invalidate(4, _a = plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key) => key));
    }
  };
  return [app, plugin, isClientSupported, t, _a];
}
var Server = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { app: 0, plugin: 1 }, add_css4);
  }
};
var Server_default = Server;

// src/server.ts
var FRIDAY_SERVER_VIEW_TYPE = "Friday_Service";
var ServerView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this._app = null;
    this.plugin = plugin;
  }
  async onClose() {
    if (this._app) {
      this._app.$destroy();
      this._app = null;
    }
  }
  async onOpen() {
    this._app = new Server_default({
      target: this.contentEl,
      props: {
        app: this.app,
        plugin: this.plugin
      }
    });
  }
  getDisplayText() {
    return "Friday Service";
  }
  getViewType() {
    return FRIDAY_SERVER_VIEW_TYPE;
  }
  getIcon() {
    return FRIDAY_ICON;
  }
};

// src/user.ts
var import_obsidian6 = require("obsidian");
var User = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.apiUrl = this.plugin.apiUrl;
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    this.token = this.plugin.settings.userToken;
  }
  getName() {
    return this.name;
  }
  async getToken() {
    return this.token;
  }
  async logout() {
    this.token = "";
    this.plugin.settings.userToken = "";
    await this.plugin.saveSettings();
  }
  async login() {
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    if (!this.name || !this.password) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_email_password"), 5e3);
      return;
    }
    try {
      const loginUrl = `${this.apiUrl}/api/login`;
      const response = await (0, import_obsidian6.requestUrl)({
        url: loginUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `email=${encodeURIComponent(this.name)}&password=${encodeURIComponent(this.password)}`
      });
      if (response.status !== 201) {
        throw new Error(`Login failed: ${response.text}`);
      }
      this.token = response.json.data[0];
      this.plugin.settings.userToken = this.token;
      await this.plugin.saveSettings();
    } catch (error) {
      console.error("Failed to login:", error);
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.login_failed"), 5e3);
    }
  }
  async register() {
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    if (!this.name || !this.password) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_email_password"), 5e3);
      return;
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(this.name)) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_valid_email"), 5e3);
      return;
    }
    try {
      const registerUrl = `${this.apiUrl}/api/user`;
      const response = await (0, import_obsidian6.requestUrl)({
        url: registerUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `email=${encodeURIComponent(this.name)}&password=${encodeURIComponent(this.password)}`
      });
      if (response.status !== 201) {
        throw new Error(`Registration failed: ${response.text}`);
      }
      this.token = response.json.data[0];
      this.plugin.settings.userToken = this.token;
      await this.plugin.saveSettings();
    } catch (error) {
      console.error("Failed to register user:", error);
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.register_failed"), 5e3);
    }
  }
};

// src/theme/modal.ts
var import_obsidian7 = require("obsidian");
var ThemeSelectionModal = class extends import_obsidian7.Modal {
  constructor(app, selectedTheme, onSelect, plugin, isForSingleFile = false) {
    super(app);
    this.themes = [];
    this.allThemes = [];
    this.allTags = [];
    this.selectedTags = [];
    this.searchTerm = "";
    this.loading = false;
    this.loadingTags = false;
    this.loadingError = null;
    this.loadingState = "idle";
    this.searchTimeout = null;
    this.isForSingleFile = false;
    this.selectedTheme = selectedTheme;
    this.onSelect = onSelect;
    this.plugin = plugin;
    this.isForSingleFile = isForSingleFile;
    this.setTitle(plugin.i18n.t("theme.choose_theme"));
  }
  t(key, params) {
    return this.plugin.i18n.t(key, params);
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("friday-theme-modal");
    contentEl.empty();
    this.loadingState = "initial";
    this.renderModal();
    try {
      await this.loadTags();
      await this.loadThemes();
      this.renderModal();
    } catch (error) {
      console.error("Failed to load initial data:", error);
      this.loadingState = "error";
      this.loadingError = error instanceof Error ? error.message : "Unknown error";
      this.renderModal();
    }
  }
  async loadTags() {
    this.loadingTags = true;
    this.loadingState = "tags";
    try {
      this.allThemes = await themeApiService.getAllThemes();
      if (this.isForSingleFile) {
        this.allThemes = this.allThemes.filter((theme) => theme.tags.some((tag) => tag.toLowerCase() === "page"));
      }
      this.allTags = this.extractTagsFromThemes(this.allThemes);
    } catch (error) {
      console.error("Failed to load tags:", error);
      throw error;
    } finally {
      this.loadingTags = false;
    }
  }
  extractTagsFromThemes(themes) {
    const allTags = themes.flatMap((theme) => theme.tags);
    const uniqueTags = [...new Set(allTags)];
    return uniqueTags.sort((a, b) => a.localeCompare(b));
  }
  async loadThemes() {
    this.loading = true;
    this.loadingState = this.searchTerm || this.selectedTags.length > 0 ? "search" : "themes";
    this.loadingError = null;
    try {
      let filteredThemes = [...this.allThemes];
      if (this.searchTerm.trim()) {
        const term = this.searchTerm.trim().toLowerCase();
        filteredThemes = filteredThemes.filter((theme) => theme.name.toLowerCase().includes(term) || theme.author.toLowerCase().includes(term) || theme.tags.some((tag) => tag.toLowerCase().includes(term)));
      }
      if (this.selectedTags.length > 0) {
        filteredThemes = filteredThemes.filter((theme) => this.selectedTags.every((selectedTag) => theme.tags.some((tag) => tag === selectedTag)));
      }
      this.themes = filteredThemes.slice(0, 20);
      this.loadingState = "idle";
    } catch (error) {
      console.error("Failed to load themes:", error);
      this.themes = [];
      this.loadingState = "error";
      this.loadingError = error instanceof Error ? error.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  renderModal() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.loadingState === "initial" || this.loadingState === "tags") {
      const themesSection2 = contentEl.createDiv("themes-section");
      this.renderLoadingState(themesSection2);
      return;
    }
    const searchSection = contentEl.createDiv("search-section");
    const searchWrapper = searchSection.createDiv("search-input-wrapper");
    const searchInput = searchWrapper.createEl("input", {
      type: "text",
      placeholder: this.t("theme.search_themes"),
      cls: "search-input"
    });
    searchWrapper.createDiv("search-icon").setText("\u{1F50D}");
    searchInput.addEventListener("input", async (e) => {
      this.searchTerm = e.target.value;
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(async () => {
        await this.loadThemes();
        this.renderThemes();
      }, 300);
    });
    const tagsSection = searchSection.createDiv("tags-section");
    const tagsHeader = tagsSection.createDiv("tags-header");
    tagsHeader.createEl("span", { text: this.t("theme.filter_by_tags"), cls: "tags-label" });
    if (this.selectedTags.length > 0) {
      const clearBtn = tagsHeader.createEl("button", { text: this.t("theme.clear_filters"), cls: "clear-filters-btn" });
      clearBtn.addEventListener("click", async () => {
        this.selectedTags = [];
        this.searchTerm = "";
        searchInput.value = "";
        await this.loadThemes();
        this.renderModal();
      });
    }
    const tagsGrid = tagsSection.createDiv("tags-grid");
    this.allTags.forEach((tag) => {
      const tagBtn = tagsGrid.createEl("button", {
        text: tag,
        cls: `tag-btn ${this.selectedTags.includes(tag) ? "selected" : ""}`
      });
      tagBtn.addEventListener("click", async () => {
        if (this.selectedTags.includes(tag)) {
          this.selectedTags = this.selectedTags.filter((t) => t !== tag);
        } else {
          this.selectedTags.push(tag);
        }
        await this.loadThemes();
        this.renderModal();
      });
    });
    const themesSection = contentEl.createDiv("themes-section");
    this.renderThemes(themesSection);
  }
  renderThemes(container) {
    const themesSection = container || this.contentEl.querySelector(".themes-section");
    if (!themesSection)
      return;
    themesSection.empty();
    if (this.loadingState === "error") {
      this.renderErrorState(themesSection);
      return;
    }
    if (this.loading || this.loadingState !== "idle") {
      this.renderLoadingState(themesSection);
      return;
    }
    if (this.themes.length === 0) {
      const noResults = themesSection.createDiv("no-results");
      noResults.createEl("p", { text: this.t("theme.no_themes_found") });
      return;
    }
    const themesGrid = themesSection.createDiv("themes-grid");
    this.themes.forEach((theme) => {
      const themeCard = themesGrid.createDiv(`theme-card ${theme.id === this.selectedTheme ? "selected" : ""}`);
      if (theme.thumbnail) {
        themeCard.style.backgroundImage = `url("${theme.thumbnail}")`;
      } else {
        const gradients = [
          "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
          "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
          "linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)",
          "linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)",
          "linear-gradient(135deg, #fa709a 0%, #fee140 100%)",
          "linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)",
          "linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)",
          "linear-gradient(135deg, #ff8a80 0%, #ea80fc 100%)"
        ];
        const hash = theme.name.split("").reduce((a, b) => {
          a = (a << 5) - a + b.charCodeAt(0);
          return a & a;
        }, 0);
        const gradientIndex = Math.abs(hash) % gradients.length;
        themeCard.style.background = gradients[gradientIndex];
      }
      const overlay = themeCard.createDiv("theme-overlay");
      overlay.createEl("h3", { text: theme.name, cls: "theme-title" });
      if (theme.author || theme.version) {
        const authorInfo = overlay.createDiv("theme-author-info");
        if (theme.author) {
          authorInfo.createEl("span", { text: this.t("theme.by_author", { author: theme.author }), cls: "theme-author" });
        }
        if (theme.version) {
          if (theme.author) {
            authorInfo.createEl("span", { text: " \u2022 ", cls: "separator" });
          }
          authorInfo.createEl("span", { text: `v${theme.version}`, cls: "theme-version" });
        }
      }
      overlay.createEl("p", { text: theme.description || "", cls: "theme-description" });
      if (theme.tags && theme.tags.length > 0) {
        const tags = overlay.createDiv("theme-tags");
        theme.tags.forEach((tag) => {
          tags.createEl("span", { text: tag, cls: "tag" });
        });
      }
      const actions = overlay.createDiv("theme-actions");
      if (theme.demo) {
        const demoLink = actions.createEl("a", { text: this.t("theme.view_demo"), cls: "demo-link" });
        demoLink.href = theme.demo;
        demoLink.target = "_blank";
        demoLink.addEventListener("click", (e) => {
          e.stopPropagation();
        });
      }
      const useBtn = actions.createEl("button", {
        text: theme.id === this.selectedTheme ? this.t("theme.current") : this.t("theme.use_it"),
        cls: `use-theme-btn ${theme.id === this.selectedTheme ? "current" : ""}`
      });
      useBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.onSelect(theme.download_url, theme.name, theme.id);
        this.close();
      });
      themeCard.addEventListener("click", () => {
        this.onSelect(theme.download_url, theme.name, theme.id);
        this.close();
      });
    });
  }
  renderLoadingState(container) {
    if (this.loadingState === "initial" || this.loadingState === "tags") {
      const loadingContainer = container.createDiv("loading-container");
      let loadingText = this.t("theme.loading_initial");
      if (this.loadingState === "tags") {
        loadingText = this.t("theme.loading_tags");
      }
      loadingContainer.createDiv("loading-spinner");
      loadingContainer.createDiv("loading-text").setText(loadingText);
      return;
    }
    if (this.loading) {
      let loadingText = this.t("theme.loading_themes");
      if (this.loadingState === "search") {
        loadingText = this.t("theme.loading_search");
      }
      container.createDiv("loading-message").setText(loadingText);
    }
  }
  renderErrorState(container) {
    const errorContainer = container.createDiv("error-container");
    errorContainer.createDiv("error-icon").setText("\u26A0\uFE0F");
    const errorMessage = this.loadingError || this.t("theme.loading_error");
    errorContainer.createDiv("error-message").setText(errorMessage);
    const retryButton = errorContainer.createEl("button", {
      text: this.t("theme.retry"),
      cls: "retry-button"
    });
    retryButton.addEventListener("click", async () => {
      try {
        await this.loadThemes();
      } catch (error) {
        console.error("Retry failed:", error);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
      this.searchTimeout = null;
    }
  }
};

// src/hugoverse.ts
var import_obsidian8 = require("obsidian");
var path3 = __toESM(require("path"));
var NEW_ID = "-1";
var COUNTER_REQUEST_ID_KEY = "friday_counter_request_id";
var Hugoverse = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.apiUrl = this.plugin.apiUrl;
    this.user = this.plugin.user;
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian8.FileSystemAdapter) {
      this.basePath = adapter.getBasePath();
    }
  }
  generateDownloadUrl(filename) {
    return `${this.apiUrl}/api/uploads/themes/${filename}`;
  }
  generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  getOrCreateRequestId() {
    let requestId = localStorage.getItem(COUNTER_REQUEST_ID_KEY);
    if (!requestId) {
      requestId = this.generateUUID();
      localStorage.setItem(COUNTER_REQUEST_ID_KEY, requestId);
    }
    return requestId;
  }
  projectDirPath(filepath) {
    return path3.dirname(filepath);
  }
  async deployMDFridayPreview(id) {
    try {
      const createPostUrl = `${this.apiUrl}/api/mdf/preview/deploy?type=MDFPreview&id=${id}`;
      let body = new FormData();
      body.append("type", "MDFPreview");
      body.append("id", id);
      body.append("host_name", "MDFriday Preview");
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: createPostUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        throw new Error(`Post creation failed: ${response.text}`);
      }
      return response.json.data[0];
    } catch (error) {
      console.error("Failed to create post:", error.toString());
      new import_obsidian8.Notice(this.plugin.i18n.t("messages.failed_to_create_post"), 5e3);
    }
  }
  async createMDFPreview(name, content) {
    try {
      const createResourceUrl = `${this.apiUrl}/api/mdf/preview?type=MDFPreview`;
      let body = new FormData();
      body.append("type", "MDFPreview");
      body.append("id", NEW_ID);
      body.append("name", name);
      body.append("size", content.byteLength.toString());
      const mimeType = "application/zip";
      const blob = new Blob([content], { type: mimeType });
      body.append(`asset`, blob, `${name}.zip`);
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: createResourceUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        throw new Error(`Resource creation failed: ${response.text}`);
      }
      return response.json.data[0].id;
    } catch (error) {
      console.error("Failed to create resource:", error.toString());
      new import_obsidian8.Notice(this.plugin.i18n.t("messages.failed_to_create_resource"), 5e3);
    }
  }
  async formDataToArrayBuffer(formData, boundary) {
    let bodyParts = [];
    const formDataEntries = [];
    formData.forEach((value2, key) => {
      formDataEntries.push({ value: value2, key });
    });
    for (const { value: value2, key } of formDataEntries) {
      bodyParts.push(`--${boundary}\r
`);
      if (typeof value2 === "string") {
        bodyParts.push(`Content-Disposition: form-data; name="${key}"\r
\r
${value2}\r
`);
      } else if (value2 instanceof Blob) {
        bodyParts.push(`Content-Disposition: form-data; name="${key}"; filename="${value2.name}"\r
`);
        bodyParts.push(`Content-Type: ${value2.type || "application/octet-stream"}\r
\r
`);
        const arrayBuffer = await value2.arrayBuffer();
        bodyParts.push(new Uint8Array(arrayBuffer));
        bodyParts.push(`\r
`);
      }
    }
    bodyParts.push(`--${boundary}--\r
`);
    const encoder = new TextEncoder();
    const encodedParts = bodyParts.map((part) => typeof part === "string" ? encoder.encode(part) : part);
    const totalLength = encodedParts.reduce((acc, curr) => acc + curr.length, 0);
    const combinedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of encodedParts) {
      combinedArray.set(part, offset);
      offset += part.length;
    }
    return combinedArray.buffer;
  }
  async sendCounter(kind = "preview") {
    try {
      const requestId = this.getOrCreateRequestId();
      const counterUrl = `${this.apiUrl}/api/counter?type=Counter`;
      let body = new FormData();
      body.append("id", NEW_ID);
      body.append("kind", kind);
      body.append("request_id", requestId);
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: counterUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        console.warn(`Counter request failed: ${response.text}`);
        return false;
      }
      return true;
    } catch (error) {
      console.warn("Failed to send counter:", error.toString());
      return false;
    }
  }
};

// src/netlify.ts
var import_obsidian9 = require("obsidian");
var path4 = __toESM(require("path"));
var fs3 = __toESM(require("fs"));
var import_jszip2 = __toESM(require_jszip_min());
var NetlifyAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian9.FileSystemAdapter) {
      this.basePath = adapter.getBasePath();
    }
  }
  async deployToNetlify(publicDir, progressCallback) {
    const { netlifyAccessToken, netlifyProjectId } = this.plugin.settings;
    if (!netlifyAccessToken || !netlifyProjectId) {
      throw new Error("Netlify access token and project ID are required");
    }
    try {
      progressCallback?.(5);
      const zipContent = await this.createZipFromDirectory(publicDir);
      progressCallback?.(30);
      const deployId = await this.uploadToNetlify(zipContent, netlifyAccessToken, netlifyProjectId, (uploadProgress) => {
        progressCallback?.(30 + uploadProgress * 0.6);
      });
      progressCallback?.(90);
      try {
        await this.waitForDeployment(deployId, netlifyAccessToken);
      } catch (error) {
        console.warn("Failed to confirm deployment status via API, but deployment may still be successful:", error.message);
      }
      progressCallback?.(100);
      return await this.getSiteUrl(netlifyProjectId, netlifyAccessToken);
    } catch (error) {
      console.error("Netlify deployment failed:", error);
      if (error.message.includes("401") || error.message.includes("Unauthorized")) {
        throw new Error("Invalid Netlify access token. Please check your settings.");
      } else if (error.message.includes("404") || error.message.includes("Not Found")) {
        throw new Error("Netlify site not found. Please check your project ID.");
      } else if (error.message.includes("network") || error.message.includes("CORS")) {
        throw new Error("Network error. Please check your internet connection.");
      }
      throw error;
    }
  }
  async createZipFromDirectory(sourceDir) {
    const zip = new import_jszip2.default();
    const addDirectoryToZip = async (dirPath, zipFolder) => {
      const items = await fs3.promises.readdir(dirPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path4.join(dirPath, item.name);
        if (item.isDirectory()) {
          const subFolder = zipFolder.folder(item.name);
          if (subFolder) {
            await addDirectoryToZip(itemPath, subFolder);
          }
        } else if (item.isFile()) {
          const fileContent = await fs3.promises.readFile(itemPath);
          zipFolder.file(item.name, fileContent);
        }
      }
    };
    await addDirectoryToZip(sourceDir, zip);
    return await zip.generateAsync({ type: "uint8array" });
  }
  async uploadToNetlify(zipContent, accessToken, siteId, progressCallback) {
    try {
      const progressInterval = this.simulateUploadProgress(zipContent.length, progressCallback);
      const response = await (0, import_obsidian9.requestUrl)({
        url: `https://api.netlify.com/api/v1/sites/${siteId}/deploys`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/zip"
        },
        body: zipContent.buffer
      });
      clearInterval(progressInterval);
      progressCallback?.(100);
      if (response.status === 200) {
        return response.json.id;
      } else {
        throw new Error(`Upload failed with status: ${response.status} - ${response.text}`);
      }
    } catch (error) {
      console.error("Netlify upload error:", error);
      throw new Error(`Upload failed: ${error.message}`);
    }
  }
  simulateUploadProgress(fileSize, progressCallback) {
    let progress = 0;
    const totalTime = Math.min(Math.max(fileSize / 1024 / 1024 * 2e3, 3e3), 3e4);
    const interval = 500;
    const increment = interval / totalTime * 100;
    return setInterval(() => {
      progress = Math.min(progress + increment, 95);
      progressCallback?.(progress);
    }, interval);
  }
  async waitForDeployment(deployId, accessToken, maxAttempts = 30) {
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const checkUrl = `https://api.netlify.com/api/v1/deploys/${deployId}`;
        const response = await (0, import_obsidian9.requestUrl)({
          url: checkUrl,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        });
        if (response.status === 200) {
          const deploy = response.json;
          if (deploy.state === "ready") {
            return;
          } else if (deploy.state === "error") {
            throw new Error(`Deployment failed: ${deploy.error_message || "Unknown error"}`);
          }
        } else {
          console.warn(`Unexpected status code: ${response.status}, response: ${response.text}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      } catch (error) {
        console.error(`Error checking deployment status (attempt ${i + 1}):`, error);
        if (i === maxAttempts - 1) {
          throw error;
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      }
    }
    throw new Error("Deployment timed out");
  }
  async getSiteUrl(siteId, accessToken) {
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: `https://api.netlify.com/api/v1/sites/${siteId}`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      if (response.status === 200) {
        const site = response.json;
        return site.ssl_url || site.url;
      }
      throw new Error(`Failed to get site URL: ${response.status}`);
    } catch (error) {
      console.error("Failed to get site URL:", error);
      throw error;
    }
  }
};

// src/i18n/utils.ts
var AVAILABLE_LANGUAGES = [
  {
    code: "en",
    name: "English",
    nativeName: "English"
  },
  {
    code: "zh-cn",
    name: "Chinese (Simplified)",
    nativeName: "\u7B80\u4F53\u4E2D\u6587"
  }
];
var DEFAULT_LANGUAGE = "en";
function detectLanguage(app) {
  try {
    let obsidianLang = app.vault?.config?.lang;
    if (!obsidianLang) {
      obsidianLang = app.vault?.config?.language;
    }
    if (!obsidianLang && typeof window !== "undefined" && window.moment) {
      obsidianLang = window.moment.locale();
    }
    if (!obsidianLang && document.documentElement.lang) {
      obsidianLang = document.documentElement.lang;
    }
    if (obsidianLang) {
      const normalized = normalizeLanguageCode(obsidianLang);
      if (normalized && isValidLanguageCode(normalized)) {
        return normalized;
      }
    }
  } catch (error) {
    console.warn("Failed to get Obsidian language setting:", error);
  }
  try {
    const browserLang = navigator.language || navigator.languages?.[0];
    if (browserLang) {
      const normalized = normalizeLanguageCode(browserLang);
      if (normalized && isValidLanguageCode(normalized)) {
        return normalized;
      }
    }
  } catch (error) {
    console.warn("Failed to get browser language:", error);
  }
  return DEFAULT_LANGUAGE;
}
function normalizeLanguageCode(langCode) {
  if (!langCode)
    return null;
  const normalized = langCode.toLowerCase().replace(/[_]/g, "-");
  const mappings = {
    "zh": "zh-cn",
    "zh-cn": "zh-cn",
    "zh-hans": "zh-cn",
    "zh-hans-cn": "zh-cn",
    "zh-chs": "zh-cn",
    "zh-simplified": "zh-cn",
    "chinese": "zh-cn",
    "chinese-simplified": "zh-cn",
    "zh-hant": "zh-tw",
    "zh-tw": "zh-tw",
    "zh-cht": "zh-tw",
    "zh-traditional": "zh-tw",
    "chinese-traditional": "zh-tw",
    "en": "en",
    "en-us": "en",
    "en-gb": "en",
    "en-au": "en",
    "en-ca": "en",
    "english": "en"
  };
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  for (const [key, value2] of Object.entries(mappings)) {
    if (normalized.startsWith(key + "-") || normalized.startsWith(key + "_")) {
      return value2;
    }
  }
  return null;
}
function isValidLanguageCode(code) {
  return AVAILABLE_LANGUAGES.some((lang) => lang.code === code);
}
function interpolateTemplate(template, params) {
  if (!params)
    return template;
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return params[key] !== void 0 ? String(params[key]) : match;
  });
}
function getNestedValue(obj, path6) {
  return path6.split(".").reduce((current, key) => {
    return current && current[key] !== void 0 ? current[key] : void 0;
  }, obj);
}

// src/i18n/locales/en.ts
var en = {
  settings: {
    welcome_back: "Welcome Back!",
    welcome: "Welcome!",
    logged_in_as: "Logged in as: {{username}}",
    please_enter_credentials: "Please enter your credentials.",
    email: "Email",
    email_desc: "Enter your email address",
    email_placeholder: "your@email.com",
    password: "Password",
    password_desc: "Enter your password",
    password_placeholder: "password",
    register: "Register",
    login: "Login",
    logout: "Logout",
    publish_settings: "Publish Settings",
    publish_method: "Publish Method",
    publish_method_desc: "Choose how you want to publish your site",
    publish_method_netlify: "Netlify",
    publish_method_ftp: "FTP",
    netlify_settings: "Netlify Settings",
    netlify_access_token: "Personal Access Token",
    netlify_access_token_desc: "Your Netlify personal access token for API authentication",
    netlify_access_token_placeholder: "Enter your Netlify access token",
    netlify_project_id: "Project ID",
    netlify_project_id_desc: "The ID of your Netlify project/site",
    netlify_project_id_placeholder: "Enter your project ID",
    ftp_settings: "FTP Settings",
    ftp_server: "Server Address",
    ftp_server_desc: "FTP server domain or IP address",
    ftp_server_placeholder: "e.g. ftp.example.com",
    ftp_username: "Username",
    ftp_username_desc: "FTP login username",
    ftp_username_placeholder: "Enter username",
    ftp_password: "Password",
    ftp_password_desc: "FTP login password",
    ftp_password_placeholder: "Enter password",
    ftp_remote_dir: "Remote Directory",
    ftp_remote_dir_desc: "Target directory path for upload",
    ftp_remote_dir_placeholder: "e.g. /www/site",
    ftp_ignore_cert: "Ignore Certificate Verification",
    ftp_ignore_cert_desc: "Enable for self-signed certificates, recommended",
    ftp_test_connection: "Test FTP Connection",
    ftp_test_connection_desc: "Test if current FTP settings are correct",
    ftp_test_connection_testing: "Testing...",
    ftp_test_connection_success: "Connection Successful",
    ftp_test_connection_failed: "Connection Failed",
    mdfriday_account: "MDFriday Account (Optional)",
    mdfriday_account_desc: "Sign in to access advanced features like theme marketplace and cloud publishing."
  },
  ui: {
    desktop_only_title: "Desktop Only",
    desktop_only_message: "We're sorry, only desktop is supported at this time.",
    mobile_coming_soon: "Mobile and Tablet is coming soon.\nThank you for your patience and understanding!",
    multilingual_content: "Multilingual Content",
    content_path: "Content Path",
    language: "Language",
    clear: "Clear",
    clear_all_content: "Clear all content",
    default: "Default",
    no_content_selected: "No content selected",
    no_content_selected_hint: 'Right-click on a folder or file and select "Publish to Web" to get started',
    remove_language: "Remove language",
    site_name: "Site Name",
    site_name_placeholder: "Enter site name",
    advanced_settings: "Advanced Settings",
    site_path: "Site Path",
    site_path_placeholder: "/",
    site_path_hint: 'Specify the base path for your site. Use "/" for root deployment.',
    google_analytics_id: "Google Analytics ID",
    google_analytics_placeholder: "G-XXXXXXXXXX",
    google_analytics_hint: "Your Google Analytics measurement ID (optional)",
    disqus_shortname: "Disqus Shortname",
    disqus_placeholder: "your-site-shortname",
    disqus_hint: "Your Disqus shortname for comments (optional)",
    theme: "Theme",
    change_theme: "Change Theme",
    preview: "Preview",
    preview_building: "Building preview...",
    preview_success: "Preview ready!",
    preview_failed: "Preview build failed",
    generate_preview: "Generate Preview",
    regenerate_preview: "Regenerate Preview",
    preview_link: "Preview link:",
    export_site: "Export Site",
    exporting: "Exporting...",
    export_site_dialog_title: "Save Site Archive",
    publish: "Publish",
    publish_option_mdfriday: "MDFriday Preview",
    publish_option_netlify: "Netlify",
    publish_option_ftp: "FTP Upload",
    publish_building: "Publishing...",
    publish_success: "Published successfully!",
    publish_failed: "Publish failed",
    published_successfully: "\u2705 Published successfully!",
    server_start: "Start Server",
    server_stop: "Stop Server",
    server_running: "Server Running",
    server_stopped: "Server Stopped"
  },
  menu: {
    publish_to_web: "Publish to Web"
  },
  commands: {},
  theme: {
    choose_theme: "Choose a Theme",
    search_themes: "Search themes...",
    filter_by_tags: "Filter by tags:",
    clear_filters: "Clear filters",
    loading_themes: "Loading themes...",
    loading_tags: "Loading tags...",
    loading_initial: "Initializing theme library...",
    loading_search: "Searching themes...",
    loading_error: "Loading failed, please retry",
    no_themes_found: "No themes found",
    view_demo: "View Demo",
    use_it: "Use It",
    current: "Current",
    by_author: "by {{author}}",
    retry: "Retry"
  },
  messages: {
    desktop_only_notice: "Only desktop is supported at this time.",
    preview_url_copied: "Preview URL copied to clipboard",
    publish_url_copied: "Publish URL copied to clipboard",
    build_started: "Build started",
    build_completed: "Build completed successfully",
    build_failed: "Build failed",
    publish_started: "Publishing started",
    publish_completed: "Published successfully",
    publish_failed: "Publishing failed",
    no_folder_selected: "No folder selected",
    no_folder_or_file_selected: "No folder or file selected",
    must_select_folder_type: 'Content type mismatch: You previously selected a folder, but now selected a file. To publish files, click the "Clear" button in the top-right to remove previous selections, then select files only.',
    must_select_file_type: 'Content type mismatch: You previously selected a file, but now selected a folder. To publish folders, click the "Clear" button in the top-right to remove previous selections, then select folders only.',
    all_content_cleared: "All content cleared successfully",
    language_added_successfully: "Language content added successfully",
    please_use_publish_first: 'Please use "Publish to Web" on a folder or file first to get started',
    add_language_instruction: 'Right-click on a folder or file and select "Publish to Web" to add more languages',
    preview_generated_successfully: "Preview generated successfully!",
    preview_failed: "Preview failed: {{error}}",
    please_generate_preview_first: "Please generate preview first",
    preview_data_missing: "Preview data is missing",
    site_published_successfully: "Site published successfully!",
    publishing_failed: "Publishing failed: {{error}}",
    site_exported_successfully: "Site exported successfully to: {{path}}",
    export_failed: "Export failed: {{error}}",
    netlify_settings_missing: "Please configure Netlify settings first",
    netlify_deploy_failed: "Netlify deployment failed: {{error}}",
    netlify_deploy_success: "Site deployed to Netlify successfully!",
    ftp_settings_missing: "Please configure FTP settings first",
    ftp_upload_failed: "FTP upload failed: {{error}}",
    ftp_upload_success: "Site uploaded to FTP server successfully!",
    ftp_fallback_to_plain: "Server does not support encryption, switched to plain FTP",
    enter_email_password: "Please enter your email and password",
    enter_valid_email: "Please enter a valid email address",
    login_failed: "Failed to login",
    register_failed: "Failed to register user",
    failed_to_create_post: "Failed to create post.",
    failed_to_create_resource: "Failed to create resource."
  },
  info: {
    service_description: "You own it \u2014 your notes, your themes, your cloud.\nMDFriday lets you build and publish with full control.",
    learn_more: "Learn more"
  },
  common: {
    loading: "Loading...",
    success: "Success",
    error: "Error",
    cancel: "Cancel",
    confirm: "Confirm",
    save: "Save",
    close: "Close",
    copy: "Copy",
    copied: "Copied!"
  }
};

// src/i18n/locales/zh-cn.ts
var zhCn = {
  settings: {
    welcome_back: "\u6B22\u8FCE\u56DE\u6765\uFF01",
    welcome: "\u6B22\u8FCE\uFF01",
    logged_in_as: "\u5DF2\u767B\u5F55\u7528\u6237\uFF1A{{username}}",
    please_enter_credentials: "\u8BF7\u8F93\u5165\u60A8\u7684\u767B\u5F55\u4FE1\u606F\u3002",
    email: "\u90AE\u7BB1",
    email_desc: "\u8BF7\u8F93\u5165\u60A8\u7684\u90AE\u7BB1\u5730\u5740",
    email_placeholder: "your@email.com",
    password: "\u5BC6\u7801",
    password_desc: "\u8BF7\u8F93\u5165\u60A8\u7684\u5BC6\u7801",
    password_placeholder: "\u5BC6\u7801",
    register: "\u6CE8\u518C",
    login: "\u767B\u5F55",
    logout: "\u9000\u51FA\u767B\u5F55",
    publish_settings: "\u53D1\u5E03\u8BBE\u7F6E",
    publish_method: "\u53D1\u5E03\u65B9\u5F0F",
    publish_method_desc: "\u9009\u62E9\u60A8\u60F3\u8981\u53D1\u5E03\u7F51\u7AD9\u7684\u65B9\u5F0F",
    publish_method_netlify: "Netlify",
    publish_method_ftp: "FTP",
    netlify_settings: "Netlify \u8BBE\u7F6E",
    netlify_access_token: "\u4E2A\u4EBA\u8BBF\u95EE\u4EE4\u724C",
    netlify_access_token_desc: "\u60A8\u7684 Netlify \u4E2A\u4EBA\u8BBF\u95EE\u4EE4\u724C\uFF0C\u7528\u4E8E API \u8BA4\u8BC1",
    netlify_access_token_placeholder: "\u8BF7\u8F93\u5165\u60A8\u7684 Netlify \u8BBF\u95EE\u4EE4\u724C",
    netlify_project_id: "\u9879\u76EE ID",
    netlify_project_id_desc: "\u60A8\u7684 Netlify \u9879\u76EE/\u7AD9\u70B9\u7684 ID",
    netlify_project_id_placeholder: "\u8BF7\u8F93\u5165\u60A8\u7684\u9879\u76EE ID",
    ftp_settings: "FTP \u8BBE\u7F6E",
    ftp_server: "\u670D\u52A1\u5668\u5730\u5740",
    ftp_server_desc: "FTP \u670D\u52A1\u5668\u57DF\u540D\u6216 IP \u5730\u5740",
    ftp_server_placeholder: "\u4F8B\u5982\uFF1Aftp.example.com",
    ftp_username: "\u7528\u6237\u540D",
    ftp_username_desc: "FTP \u767B\u5F55\u7528\u6237\u540D",
    ftp_username_placeholder: "\u8BF7\u8F93\u5165\u7528\u6237\u540D",
    ftp_password: "\u5BC6\u7801",
    ftp_password_desc: "FTP \u767B\u5F55\u5BC6\u7801",
    ftp_password_placeholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
    ftp_remote_dir: "\u8FDC\u7A0B\u76EE\u5F55",
    ftp_remote_dir_desc: "\u4E0A\u4F20\u7684\u76EE\u6807\u76EE\u5F55\u8DEF\u5F84",
    ftp_remote_dir_placeholder: "\u4F8B\u5982\uFF1A/www/site",
    ftp_ignore_cert: "\u5FFD\u7565\u8BC1\u4E66\u9A8C\u8BC1",
    ftp_ignore_cert_desc: "\u9002\u914D\u81EA\u7B7E\u540D\u8BC1\u4E66\uFF0C\u5EFA\u8BAE\u5F00\u542F",
    ftp_test_connection: "\u6D4B\u8BD5 FTP \u8FDE\u63A5",
    ftp_test_connection_desc: "\u6D4B\u8BD5\u5F53\u524D FTP \u8BBE\u7F6E\u662F\u5426\u6B63\u786E",
    ftp_test_connection_testing: "\u6D4B\u8BD5\u4E2D...",
    ftp_test_connection_success: "\u8FDE\u63A5\u6210\u529F",
    ftp_test_connection_failed: "\u8FDE\u63A5\u5931\u8D25",
    mdfriday_account: "MDFriday \u8D26\u6237\uFF08\u53EF\u9009\uFF09",
    mdfriday_account_desc: "\u767B\u5F55\u4EE5\u4F7F\u7528\u9AD8\u7EA7\u529F\u80FD\uFF0C\u5982\u4E3B\u9898\u5E02\u573A\u548C\u4E91\u7AEF\u53D1\u5E03\u3002"
  },
  ui: {
    desktop_only_title: "\u4EC5\u652F\u6301\u684C\u9762\u7248",
    desktop_only_message: "\u62B1\u6B49\uFF0C\u76EE\u524D\u4EC5\u652F\u6301\u684C\u9762\u7248\u672C\u3002",
    mobile_coming_soon: "\u79FB\u52A8\u7AEF\u548C\u5E73\u677F\u7AEF\u5373\u5C06\u63A8\u51FA\u3002\n\u611F\u8C22\u60A8\u7684\u8010\u5FC3\u7B49\u5F85\u548C\u7406\u89E3\uFF01",
    multilingual_content: "\u591A\u8BED\u8A00\u5185\u5BB9",
    content_path: "\u5185\u5BB9\u8DEF\u5F84",
    language: "\u8BED\u8A00",
    clear: "\u6E05\u7A7A",
    clear_all_content: "\u6E05\u7A7A\u6240\u6709\u5185\u5BB9",
    default: "\u9ED8\u8BA4",
    no_content_selected: "\u672A\u9009\u62E9\u5185\u5BB9",
    no_content_selected_hint: '\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u5E76\u9009\u62E9"\u53D1\u5E03\u5230\u7F51\u7AD9"\u5F00\u59CB',
    remove_language: "\u79FB\u9664\u8BED\u8A00",
    site_name: "\u7AD9\u70B9\u540D\u79F0",
    site_name_placeholder: "\u8BF7\u8F93\u5165\u7AD9\u70B9\u540D\u79F0",
    advanced_settings: "\u9AD8\u7EA7\u8BBE\u7F6E",
    site_path: "\u7AD9\u70B9\u8DEF\u5F84",
    site_path_placeholder: "/",
    site_path_hint: '\u6307\u5B9A\u7AD9\u70B9\u7684\u57FA\u7840\u8DEF\u5F84\u3002\u4F7F\u7528 "/" \u8868\u793A\u6839\u8DEF\u5F84\u90E8\u7F72\u3002',
    google_analytics_id: "Google Analytics ID",
    google_analytics_placeholder: "G-XXXXXXXXXX",
    google_analytics_hint: "\u60A8\u7684 Google Analytics \u6D4B\u91CF ID\uFF08\u53EF\u9009\uFF09",
    disqus_shortname: "Disqus \u77ED\u540D\u79F0",
    disqus_placeholder: "your-site-shortname",
    disqus_hint: "\u60A8\u7684 Disqus \u77ED\u540D\u79F0\uFF0C\u7528\u4E8E\u8BC4\u8BBA\u529F\u80FD\uFF08\u53EF\u9009\uFF09",
    theme: "\u4E3B\u9898",
    change_theme: "\u66F4\u6362\u4E3B\u9898",
    preview: "\u9884\u89C8",
    preview_building: "\u6B63\u5728\u6784\u5EFA\u9884\u89C8...",
    preview_success: "\u9884\u89C8\u5DF2\u5C31\u7EEA\uFF01",
    preview_failed: "\u9884\u89C8\u6784\u5EFA\u5931\u8D25",
    generate_preview: "\u751F\u6210\u9884\u89C8",
    regenerate_preview: "\u91CD\u65B0\u751F\u6210\u9884\u89C8",
    preview_link: "\u9884\u89C8\u94FE\u63A5\uFF1A",
    export_site: "\u5BFC\u51FA\u7AD9\u70B9",
    exporting: "\u5BFC\u51FA\u4E2D...",
    export_site_dialog_title: "\u4FDD\u5B58\u7AD9\u70B9\u538B\u7F29\u5305",
    publish: "\u53D1\u5E03",
    publish_option_mdfriday: "MDFriday \u9884\u89C8",
    publish_option_netlify: "Netlify",
    publish_option_ftp: "FTP \u4E0A\u4F20",
    publish_building: "\u6B63\u5728\u53D1\u5E03...",
    publish_success: "\u53D1\u5E03\u6210\u529F\uFF01",
    publish_failed: "\u53D1\u5E03\u5931\u8D25",
    published_successfully: "\u2705 \u53D1\u5E03\u6210\u529F\uFF01",
    server_start: "\u542F\u52A8\u670D\u52A1\u5668",
    server_stop: "\u505C\u6B62\u670D\u52A1\u5668",
    server_running: "\u670D\u52A1\u5668\u8FD0\u884C\u4E2D",
    server_stopped: "\u670D\u52A1\u5668\u5DF2\u505C\u6B62"
  },
  menu: {
    publish_to_web: "\u53D1\u5E03\u5230\u7F51\u7EDC"
  },
  commands: {},
  theme: {
    choose_theme: "\u9009\u62E9\u4E3B\u9898",
    search_themes: "\u641C\u7D22\u4E3B\u9898...",
    filter_by_tags: "\u6309\u6807\u7B7E\u7B5B\u9009\uFF1A",
    clear_filters: "\u6E05\u9664\u7B5B\u9009",
    loading_themes: "\u6B63\u5728\u52A0\u8F7D\u4E3B\u9898...",
    loading_tags: "\u6B63\u5728\u52A0\u8F7D\u6807\u7B7E...",
    loading_initial: "\u6B63\u5728\u521D\u59CB\u5316\u4E3B\u9898\u5E93...",
    loading_search: "\u6B63\u5728\u641C\u7D22\u4E3B\u9898...",
    loading_error: "\u52A0\u8F7D\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
    no_themes_found: "\u672A\u627E\u5230\u4E3B\u9898",
    view_demo: "\u67E5\u770B\u6F14\u793A",
    use_it: "\u4F7F\u7528",
    current: "\u5F53\u524D",
    by_author: "\u4F5C\u8005\uFF1A{{author}}",
    retry: "\u91CD\u8BD5"
  },
  messages: {
    desktop_only_notice: "\u76EE\u524D\u4EC5\u652F\u6301\u684C\u9762\u7248\u672C\u3002",
    preview_url_copied: "\u9884\u89C8\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    publish_url_copied: "\u53D1\u5E03\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    build_started: "\u5F00\u59CB\u6784\u5EFA",
    build_completed: "\u6784\u5EFA\u6210\u529F\u5B8C\u6210",
    build_failed: "\u6784\u5EFA\u5931\u8D25",
    publish_started: "\u5F00\u59CB\u53D1\u5E03",
    publish_completed: "\u53D1\u5E03\u6210\u529F",
    publish_failed: "\u53D1\u5E03\u5931\u8D25",
    no_folder_selected: "\u672A\u9009\u62E9\u6587\u4EF6\u5939",
    no_folder_or_file_selected: "\u672A\u9009\u62E9\u6587\u4EF6\u5939\u6216\u6587\u4EF6",
    must_select_folder_type: '\u5185\u5BB9\u7C7B\u578B\u4E0D\u5339\u914D\uFF1A\u60A8\u4E4B\u524D\u9009\u62E9\u4E86\u6587\u4EF6\u5939\uFF0C\u73B0\u5728\u9009\u62E9\u4E86\u6587\u4EF6\u3002\u8981\u53D1\u5E03\u6587\u4EF6\uFF0C\u8BF7\u70B9\u51FB\u53F3\u4E0A\u89D2\u7684"\u6E05\u7A7A"\u6309\u94AE\u79FB\u9664\u4E4B\u524D\u7684\u9009\u62E9\uFF0C\u7136\u540E\u53EA\u9009\u62E9\u6587\u4EF6\u3002',
    must_select_file_type: '\u5185\u5BB9\u7C7B\u578B\u4E0D\u5339\u914D\uFF1A\u60A8\u4E4B\u524D\u9009\u62E9\u4E86\u6587\u4EF6\uFF0C\u73B0\u5728\u9009\u62E9\u4E86\u6587\u4EF6\u5939\u3002\u8981\u53D1\u5E03\u6587\u4EF6\u5939\uFF0C\u8BF7\u70B9\u51FB\u53F3\u4E0A\u89D2\u7684"\u6E05\u7A7A"\u6309\u94AE\u79FB\u9664\u4E4B\u524D\u7684\u9009\u62E9\uFF0C\u7136\u540E\u53EA\u9009\u62E9\u6587\u4EF6\u5939\u3002',
    all_content_cleared: "\u6240\u6709\u5185\u5BB9\u5DF2\u6210\u529F\u6E05\u7A7A",
    language_added_successfully: "\u8BED\u8A00\u5185\u5BB9\u6DFB\u52A0\u6210\u529F",
    please_use_publish_first: '\u8BF7\u5148\u5728\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u4E0A\u4F7F\u7528"\u53D1\u5E03\u5230\u7F51\u7AD9"\u529F\u80FD',
    add_language_instruction: '\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u5E76\u9009\u62E9"\u53D1\u5E03\u5230\u7F51\u7AD9"\u4EE5\u6DFB\u52A0\u66F4\u591A\u8BED\u8A00',
    preview_generated_successfully: "\u9884\u89C8\u751F\u6210\u6210\u529F\uFF01",
    preview_failed: "\u9884\u89C8\u5931\u8D25\uFF1A{{error}}",
    please_generate_preview_first: "\u8BF7\u5148\u751F\u6210\u9884\u89C8",
    preview_data_missing: "\u9884\u89C8\u6570\u636E\u7F3A\u5931",
    site_published_successfully: "\u7AD9\u70B9\u53D1\u5E03\u6210\u529F\uFF01",
    publishing_failed: "\u53D1\u5E03\u5931\u8D25\uFF1A{{error}}",
    site_exported_successfully: "\u7AD9\u70B9\u5BFC\u51FA\u6210\u529F\u81F3\uFF1A{{path}}",
    export_failed: "\u5BFC\u51FA\u5931\u8D25\uFF1A{{error}}",
    netlify_settings_missing: "\u8BF7\u5148\u914D\u7F6E Netlify \u8BBE\u7F6E",
    netlify_deploy_failed: "Netlify \u90E8\u7F72\u5931\u8D25\uFF1A{{error}}",
    netlify_deploy_success: "\u7AD9\u70B9\u5DF2\u6210\u529F\u90E8\u7F72\u5230 Netlify\uFF01",
    ftp_settings_missing: "\u8BF7\u5148\u914D\u7F6E FTP \u8BBE\u7F6E",
    ftp_upload_failed: "FTP \u4E0A\u4F20\u5931\u8D25\uFF1A{{error}}",
    ftp_upload_success: "\u7AD9\u70B9\u5DF2\u6210\u529F\u4E0A\u4F20\u5230 FTP \u670D\u52A1\u5668\uFF01",
    ftp_fallback_to_plain: "\u670D\u52A1\u5668\u4E0D\u652F\u6301\u52A0\u5BC6\uFF0C\u5DF2\u5207\u6362\u5230\u666E\u901A FTP",
    enter_email_password: "\u8BF7\u8F93\u5165\u60A8\u7684\u90AE\u7BB1\u548C\u5BC6\u7801",
    enter_valid_email: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u90AE\u7BB1\u5730\u5740",
    login_failed: "\u767B\u5F55\u5931\u8D25",
    register_failed: "\u6CE8\u518C\u7528\u6237\u5931\u8D25",
    failed_to_create_post: "\u521B\u5EFA\u6587\u7AE0\u5931\u8D25\u3002",
    failed_to_create_resource: "\u521B\u5EFA\u8D44\u6E90\u5931\u8D25\u3002"
  },
  info: {
    service_description: "\u4F60\u7684\u6570\u636E\uFF0C\u4F60\u638C\u63A7 \u2014\u2014 \u4F60\u7684\u7B14\u8BB0\u3001\u4F60\u7684\u4E3B\u9898\u3001\u4F60\u7684\u4E91\u7AEF\u3002\nMDFriday \u8BA9\u4F60\u81EA\u7531\u6784\u5EFA\u4E0E\u53D1\u5E03\uFF0C\u5B8C\u5168\u638C\u63E1\u5168\u6D41\u7A0B\u3002",
    learn_more: "\u4E86\u89E3\u66F4\u591A"
  },
  common: {
    loading: "\u52A0\u8F7D\u4E2D...",
    success: "\u6210\u529F",
    error: "\u9519\u8BEF",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    save: "\u4FDD\u5B58",
    close: "\u5173\u95ED",
    copy: "\u590D\u5236",
    copied: "\u5DF2\u590D\u5236\uFF01"
  }
};

// src/i18n/service.ts
var I18nService = class {
  constructor(plugin) {
    this.currentLanguage = DEFAULT_LANGUAGE;
    this.translations = {
      "en": en,
      "zh-cn": zhCn
    };
    this.ready = false;
    this.t = (key, params) => {
      if (!this.ready) {
        console.warn("I18n service not ready, returning key:", key);
        return key;
      }
      const currentTranslations = this.translations[this.currentLanguage];
      if (!currentTranslations) {
        console.warn(`No translations found for language '${this.currentLanguage}'`);
        return key;
      }
      const translation = getNestedValue(currentTranslations, key);
      if (translation === void 0) {
        if (this.currentLanguage !== "en") {
          const fallbackTranslation = getNestedValue(this.translations["en"], key);
          if (fallbackTranslation !== void 0) {
            console.warn(`Missing translation for key '${key}' in '${this.currentLanguage}', using English fallback`);
            return interpolateTemplate(fallbackTranslation, params);
          }
        }
        console.warn(`Missing translation for key '${key}' in '${this.currentLanguage}'`);
        return key;
      }
      if (typeof translation !== "string") {
        console.warn(`Translation for key '${key}' is not a string:`, translation);
        return key;
      }
      return interpolateTemplate(translation, params);
    };
    this.plugin = plugin;
    this.app = plugin.app;
  }
  async init() {
    try {
      const detectedLanguage = detectLanguage(this.app);
      this.setLanguageInternal(detectedLanguage);
      this.ready = true;
    } catch (error) {
      console.error("Failed to initialize i18n service:", error);
      this.currentLanguage = DEFAULT_LANGUAGE;
      this.ready = true;
    }
  }
  getCurrentLanguage() {
    return this.currentLanguage;
  }
  setLanguageInternal(language) {
    if (!this.translations[language]) {
      console.warn(`Language '${language}' not supported, falling back to '${DEFAULT_LANGUAGE}'`);
      language = DEFAULT_LANGUAGE;
    }
    this.currentLanguage = language;
    this.plugin.app.workspace.trigger("friday:language-changed", language);
  }
  async setLanguage(language) {
    this.setLanguageInternal(language);
  }
  getAvailableLanguages() {
    return [...AVAILABLE_LANGUAGES];
  }
  isReady() {
    return this.ready;
  }
  getTranslationForLanguage(key, language, params) {
    const translations = this.translations[language];
    if (!translations) {
      return key;
    }
    const translation = getNestedValue(translations, key);
    if (translation === void 0 || typeof translation !== "string") {
      return key;
    }
    return interpolateTemplate(translation, params);
  }
  async reload() {
    this.ready = false;
    await this.init();
  }
  getLanguageDisplayName(code) {
    const targetCode = code || this.currentLanguage;
    const info = AVAILABLE_LANGUAGES.find((lang) => lang.code === targetCode);
    return info ? info.nativeName === info.name ? info.name : `${info.name} (${info.nativeName})` : targetCode;
  }
  hasTranslation(key, language) {
    const targetLanguage = language || this.currentLanguage;
    const translations = this.translations[targetLanguage];
    if (!translations)
      return false;
    const translation = getNestedValue(translations, key);
    return translation !== void 0 && typeof translation === "string";
  }
};

// src/ftp.ts
var ftp = __toESM(require_dist4());
var path5 = __toESM(require("path"));
var fs4 = __toESM(require("fs"));
var FTPUploader = class {
  constructor(config) {
    this.totalSize = 0;
    this.transferredSize = 0;
    this.client = new ftp.Client();
    this.config = config;
  }
  setProgressCallback(callback) {
    this.onProgress = callback;
  }
  async calculateDirectorySize(dirPath) {
    let totalSize = 0;
    const calculateRecursive = async (currentPath) => {
      const items = await fs4.promises.readdir(currentPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path5.join(currentPath, item.name);
        if (item.isDirectory()) {
          await calculateRecursive(itemPath);
        } else if (item.isFile()) {
          const stats = await fs4.promises.stat(itemPath);
          totalSize += stats.size;
        }
      }
    };
    await calculateRecursive(dirPath);
    return totalSize;
  }
  async connectWithFallback() {
    const accessConfig = {
      host: this.config.server,
      user: this.config.username,
      password: this.config.password,
      secure: true,
      secureOptions: {
        rejectUnauthorized: !this.config.ignoreCert
      }
    };
    this.client.ftp.verbose = true;
    try {
      await this.client.access(accessConfig);
      return { usedSecure: true };
    } catch (err) {
      const errorMessage = String(err);
      if (/TLS|AUTH|SSL|SECURE|certificate|handshake/i.test(errorMessage) || /530/i.test(errorMessage) && /login/i.test(errorMessage)) {
        this.client.close();
        this.client = new ftp.Client();
        this.client.ftp.verbose = true;
        const plainConfig = {
          host: this.config.server,
          user: this.config.username,
          password: this.config.password,
          secure: false
        };
        await this.client.access(plainConfig);
        return { usedSecure: false };
      } else {
        console.error("FTP connection failed with non-recoverable error:", errorMessage);
        throw err;
      }
    }
  }
  async uploadDirectory(localDir) {
    try {
      this.totalSize = await this.calculateDirectorySize(localDir);
      this.transferredSize = 0;
      const connectionResult = await this.connectWithFallback();
      this.client.trackProgress((info) => {
        this.transferredSize += info.bytes;
        const percentage = this.totalSize > 0 ? Math.round(this.transferredSize / this.totalSize * 100) : 0;
        if (this.onProgress) {
          this.onProgress({
            fileName: info.name || "Unknown",
            bytesTransferred: this.transferredSize,
            totalBytes: this.totalSize,
            percentage
          });
        }
      });
      if (this.config.remoteDir && this.config.remoteDir !== "/") {
        try {
          await this.client.cd(this.config.remoteDir);
        } catch (err) {
          await this.client.ensureDir(this.config.remoteDir);
          await this.client.cd(this.config.remoteDir);
        }
      }
      await this.client.uploadFromDir(localDir);
      return {
        success: true,
        usedSecure: connectionResult.usedSecure
      };
    } catch (error) {
      console.error("FTP upload failed:", error);
      return {
        success: false,
        usedSecure: false,
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      this.client.close();
    }
  }
  async testConnection() {
    try {
      const connectionResult = await this.connectWithFallback();
      this.client.close();
      return {
        success: true,
        usedSecure: connectionResult.usedSecure
      };
    } catch (error) {
      console.error("FTP connection test failed:", error);
      return {
        success: false,
        usedSecure: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
};

// src/site.ts
var import_obsidian10 = require("obsidian");

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value2, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value2));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/site.ts
var Site2 = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.languageContents = writable([]);
  }
  generateRandomId() {
    return Math.random().toString(36).substr(2, 9);
  }
  initializeContent(folder, file) {
    this.languageContents.update((contents) => {
      if (contents.length > 0) {
        return contents;
      }
      const initialContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode: "en",
        weight: 1
      };
      return [initialContent];
    });
  }
  addLanguageContent(folder, file) {
    let canAdd = false;
    let currentContents = [];
    this.languageContents.subscribe((contents) => {
      currentContents = contents;
    })();
    if (currentContents.length === 0) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.please_use_publish_first"), 5e3);
      return false;
    }
    const firstContent = currentContents[0];
    const isFirstFolder = !!firstContent.folder;
    const isNewFolder = !!folder;
    if (isFirstFolder !== isNewFolder) {
      const errorMessage = isFirstFolder ? this.plugin.i18n.t("messages.must_select_folder_type") : this.plugin.i18n.t("messages.must_select_file_type");
      new import_obsidian10.Notice(errorMessage, 5e3);
      return false;
    }
    this.languageContents.update((contents) => {
      const newContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode: "en",
        weight: contents.length + 1
      };
      canAdd = true;
      return [...contents, newContent];
    });
    if (canAdd) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.language_added_successfully"), 3e3);
    }
    return canAdd;
  }
  updateLanguageCode(contentId, newLanguageCode) {
    this.languageContents.update((contents) => {
      return contents.map((content) => content.id === contentId ? { ...content, languageCode: newLanguageCode } : content);
    });
  }
  removeLanguageContent(contentId) {
    this.languageContents.update((contents) => {
      const filteredContents = contents.filter((content) => content.id !== contentId);
      return filteredContents.map((content, index) => ({
        ...content,
        weight: index + 1
      }));
    });
  }
  clearAllContent() {
    this.languageContents.set([]);
    new import_obsidian10.Notice(this.plugin.i18n.t("messages.all_content_cleared"), 3e3);
  }
  hasContent() {
    let hasContent = false;
    this.languageContents.subscribe((contents) => {
      hasContent = contents.length > 0;
    })();
    return hasContent;
  }
  getCurrentContents() {
    let currentContents = [];
    this.languageContents.subscribe((contents) => {
      currentContents = contents;
    })();
    return currentContents;
  }
  getDefaultContentLanguage() {
    const contents = this.getCurrentContents();
    return contents.length > 0 ? contents[0].languageCode : "en";
  }
  isForSingleFile() {
    const contents = this.getCurrentContents();
    return contents.length > 0 && !!contents[0].file;
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  username: "",
  password: "",
  userToken: "",
  publishMethod: "netlify",
  netlifyAccessToken: "",
  netlifyProjectId: "",
  ftpServer: "",
  ftpUsername: "",
  ftpPassword: "",
  ftpRemoteDir: "",
  ftpIgnoreCert: true
};
var FRIDAY_ICON = "dice-5";
var API_URL_DEV = "http://127.0.0.1:1314";
var API_URL_PRO = "https://mdfriday.sunwei.xyz";
function GetBaseUrl() {
  return false ? API_URL_DEV : API_URL_PRO;
}
var FridayPlugin2 = class extends import_obsidian11.Plugin {
  constructor() {
    super(...arguments);
    this.ftp = null;
  }
  async onload() {
    this.pluginDir = `${this.manifest.dir}`;
    await this.loadSettings();
    await this.initFriday();
    this.initializeFTP();
    this.statusBar = this.addStatusBarItem();
    this.addSettingTab(new FridaySettingTab(this.app, this));
    this.registerView(FRIDAY_SERVER_VIEW_TYPE, (leaf) => new ServerView(leaf, this));
    this.app.workspace.onLayoutReady(() => this.initLeaf());
    this.addCommand({
      id: "export-current-note-with-css",
      name: this.i18n.t("menu.publish_to_web"),
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "md") {
          if (!checking) {
            this.openPublishPanel(null, file);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian11.TFolder) {
        menu.addItem((item) => {
          item.setTitle(this.i18n.t("menu.publish_to_web")).setIcon(FRIDAY_ICON).onClick(async () => {
            await this.openPublishPanel(file, null);
          });
        });
      } else if (file instanceof import_obsidian11.TFile && file.extension === "md") {
        menu.addItem((item) => {
          item.setTitle(this.i18n.t("menu.publish_to_web")).setIcon(FRIDAY_ICON).onClick(async () => {
            await this.openPublishPanel(null, file);
          });
        });
      }
    }));
  }
  async openPublishPanel(folder, file) {
    const rightSplit = this.app.workspace.rightSplit;
    if (!rightSplit) {
      return;
    }
    if (rightSplit.collapsed) {
      rightSplit.expand();
    }
    if (this.site.hasContent()) {
      const success = this.site.addLanguageContent(folder, file);
      if (!success) {
        return;
      }
    } else {
      this.site.initializeContent(folder, file);
    }
    const leaves = this.app.workspace.getLeavesOfType(FRIDAY_SERVER_VIEW_TYPE);
    if (leaves.length > 0) {
      await this.app.workspace.revealLeaf(leaves[0]);
    } else {
      const leaf = this.app.workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: FRIDAY_SERVER_VIEW_TYPE,
          active: true
        });
      }
    }
  }
  showThemeSelectionModal(selectedTheme, onSelect, isForSingleFile = false) {
    const modal = new ThemeSelectionModal(this.app, selectedTheme, onSelect, this, isForSingleFile);
    modal.open();
  }
  async initFriday() {
    this.apiUrl = false ? API_URL_DEV : API_URL_PRO;
    this.i18n = new I18nService(this);
    await this.i18n.init();
    this.user = new User(this);
    this.hugoverse = new Hugoverse(this);
    this.netlify = new NetlifyAPI(this);
    this.site = new Site2(this);
  }
  initLeaf() {
    if (this.app.workspace.getLeavesOfType(FRIDAY_SERVER_VIEW_TYPE).length > 0)
      return;
    this.app.workspace.getRightLeaf(false)?.setViewState({
      type: FRIDAY_SERVER_VIEW_TYPE,
      active: true
    }).then((r) => {
    });
  }
  async onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initializeFTP();
  }
  initializeFTP() {
    const { ftpServer, ftpUsername, ftpPassword, ftpRemoteDir, ftpIgnoreCert } = this.settings;
    if (ftpServer && ftpUsername && ftpPassword) {
      this.ftp = new FTPUploader({
        server: ftpServer,
        username: ftpUsername,
        password: ftpPassword,
        remoteDir: ftpRemoteDir || "/",
        ignoreCert: ftpIgnoreCert
      });
    } else {
      this.ftp = null;
    }
  }
  async testFTPConnection() {
    if (!this.ftp) {
      return {
        success: false,
        message: "FTP not configured"
      };
    }
    try {
      const result = await this.ftp.testConnection();
      if (result.success) {
        const secureInfo = result.usedSecure ? "FTPS" : "FTP (Plain)";
        return {
          success: true,
          message: `Connection successful using ${secureInfo}`
        };
      } else {
        return {
          success: false,
          message: result.error || "Connection failed"
        };
      }
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : String(error)
      };
    }
  }
  async status(text3) {
    this.statusBar.setText(text3);
  }
};
var FridaySettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const { username, password, userToken, publishMethod, netlifyAccessToken, netlifyProjectId, ftpServer, ftpUsername, ftpPassword, ftpRemoteDir, ftpIgnoreCert } = this.plugin.settings;
    containerEl.createEl("h2", { text: this.plugin.i18n.t("settings.publish_settings") });
    let netlifySettingsContainer;
    let ftpSettingsContainer;
    new import_obsidian11.Setting(containerEl).setName(this.plugin.i18n.t("settings.publish_method")).setDesc(this.plugin.i18n.t("settings.publish_method_desc")).addDropdown((dropdown) => {
      dropdown.addOption("netlify", this.plugin.i18n.t("settings.publish_method_netlify")).addOption("ftp", this.plugin.i18n.t("settings.publish_method_ftp")).setValue(publishMethod || "netlify").onChange(async (value2) => {
        this.plugin.settings.publishMethod = value2;
        await this.plugin.saveSettings();
        showPublishSettings(value2);
      });
    });
    netlifySettingsContainer = containerEl.createDiv("netlify-settings-container");
    ftpSettingsContainer = containerEl.createDiv("ftp-settings-container");
    const showPublishSettings = (method) => {
      if (method === "netlify") {
        netlifySettingsContainer.style.display = "block";
        ftpSettingsContainer.style.display = "none";
      } else {
        netlifySettingsContainer.style.display = "none";
        ftpSettingsContainer.style.display = "block";
      }
    };
    netlifySettingsContainer.createEl("h3", { text: this.plugin.i18n.t("settings.netlify_settings") });
    new import_obsidian11.Setting(netlifySettingsContainer).setName(this.plugin.i18n.t("settings.netlify_access_token")).setDesc(this.plugin.i18n.t("settings.netlify_access_token_desc")).addText((text3) => {
      text3.setPlaceholder(this.plugin.i18n.t("settings.netlify_access_token_placeholder")).setValue(netlifyAccessToken || "").onChange(async (value2) => {
        this.plugin.settings.netlifyAccessToken = value2;
        await this.plugin.saveSettings();
      });
      text3.inputEl.type = "password";
    });
    new import_obsidian11.Setting(netlifySettingsContainer).setName(this.plugin.i18n.t("settings.netlify_project_id")).setDesc(this.plugin.i18n.t("settings.netlify_project_id_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.netlify_project_id_placeholder")).setValue(netlifyProjectId || "").onChange(async (value2) => {
      this.plugin.settings.netlifyProjectId = value2;
      await this.plugin.saveSettings();
    }));
    ftpSettingsContainer.createEl("h3", { text: this.plugin.i18n.t("settings.ftp_settings") });
    let resetButtonState;
    new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_server")).setDesc(this.plugin.i18n.t("settings.ftp_server_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_server_placeholder")).setValue(ftpServer || "").onChange(async (value2) => {
      this.plugin.settings.ftpServer = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_username")).setDesc(this.plugin.i18n.t("settings.ftp_username_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_username_placeholder")).setValue(ftpUsername || "").onChange(async (value2) => {
      this.plugin.settings.ftpUsername = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_password")).setDesc(this.plugin.i18n.t("settings.ftp_password_desc")).addText((text3) => {
      text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_password_placeholder")).setValue(ftpPassword || "").onChange(async (value2) => {
        this.plugin.settings.ftpPassword = value2;
        await this.plugin.saveSettings();
        if (resetButtonState)
          resetButtonState();
      });
      text3.inputEl.type = "password";
    });
    new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_remote_dir")).setDesc(this.plugin.i18n.t("settings.ftp_remote_dir_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_remote_dir_placeholder")).setValue(ftpRemoteDir || "").onChange(async (value2) => {
      this.plugin.settings.ftpRemoteDir = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_ignore_cert")).setDesc(this.plugin.i18n.t("settings.ftp_ignore_cert_desc")).addToggle((toggle) => toggle.setValue(ftpIgnoreCert).onChange(async (value2) => {
      this.plugin.settings.ftpIgnoreCert = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    const testConnectionSetting = new import_obsidian11.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_test_connection")).setDesc(this.plugin.i18n.t("settings.ftp_test_connection_desc"));
    let testButton;
    let testResultEl = null;
    const isFTPConfigured = () => {
      return !!(this.plugin.settings.ftpServer?.trim() && this.plugin.settings.ftpUsername?.trim() && this.plugin.settings.ftpPassword?.trim());
    };
    const updateButtonState = (state, message) => {
      if (testResultEl) {
        testResultEl.remove();
        testResultEl = null;
      }
      switch (state) {
        case "idle":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection");
          testButton.disabled = !isFTPConfigured();
          testButton.removeClass("ftp-test-success", "ftp-test-error");
          break;
        case "testing":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_testing");
          testButton.disabled = true;
          testButton.removeClass("ftp-test-success", "ftp-test-error");
          break;
        case "success":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_success");
          testButton.disabled = false;
          testButton.removeClass("ftp-test-error");
          testButton.addClass("ftp-test-success");
          if (message) {
            testResultEl = ftpSettingsContainer.createEl("div", {
              text: `\u2705 ${message}`,
              cls: "ftp-test-result ftp-test-result-success"
            });
            testConnectionSetting.settingEl.insertAdjacentElement("afterend", testResultEl);
          }
          break;
        case "error":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_failed");
          testButton.disabled = false;
          testButton.removeClass("ftp-test-success");
          testButton.addClass("ftp-test-error");
          if (message) {
            testResultEl = ftpSettingsContainer.createEl("div", {
              text: `\u274C ${message}`,
              cls: "ftp-test-result ftp-test-result-error"
            });
            testConnectionSetting.settingEl.insertAdjacentElement("afterend", testResultEl);
          }
          break;
      }
    };
    resetButtonState = () => {
      updateButtonState("idle");
    };
    testConnectionSetting.addButton((button) => {
      testButton = button.buttonEl;
      updateButtonState("idle");
      button.onClick(async () => {
        updateButtonState("testing");
        try {
          this.plugin.initializeFTP();
          const result = await this.plugin.testFTPConnection();
          if (result.success) {
            updateButtonState("success", result.message);
          } else {
            updateButtonState("error", result.message);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          updateButtonState("error", errorMessage);
        }
      });
    });
    showPublishSettings(publishMethod || "netlify");
    containerEl.createEl("h2", { text: this.plugin.i18n.t("settings.mdfriday_account") });
    if (userToken) {
      containerEl.createEl("p", { text: this.plugin.i18n.t("settings.logged_in_as", { username }) });
      new import_obsidian11.Setting(containerEl).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.logout")).setCta().onClick(async () => {
        await this.plugin.user.logout();
        this.display();
      }));
    } else {
      containerEl.createEl("p", { text: this.plugin.i18n.t("settings.mdfriday_account_desc") });
      new import_obsidian11.Setting(containerEl).setName(this.plugin.i18n.t("settings.email")).setDesc(this.plugin.i18n.t("settings.email_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.email_placeholder")).setValue(username || "").onChange(async (value2) => {
        this.plugin.settings.username = value2;
        await this.plugin.saveSettings();
      }));
      new import_obsidian11.Setting(containerEl).setName(this.plugin.i18n.t("settings.password")).setDesc(this.plugin.i18n.t("settings.password_desc")).addText((text3) => {
        text3.setPlaceholder(this.plugin.i18n.t("settings.password_placeholder")).setValue(password || "").onChange(async (value2) => {
          this.plugin.settings.password = value2;
          await this.plugin.saveSettings();
        });
        text3.inputEl.type = "password";
      });
      new import_obsidian11.Setting(containerEl).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.register")).setCta().onClick(async () => {
        await this.plugin.user.register();
        this.display();
      })).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.login")).setCta().onClick(async () => {
        await this.plugin.user.login();
        this.display();
      }));
    }
  }
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */

/* nosourcemap */